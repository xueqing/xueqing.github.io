<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kiki</title>
    <link>https://xueqing.github.io/authors/kiki/</link>
      <atom:link href="https://xueqing.github.io/authors/kiki/index.xml" rel="self" type="application/rss+xml" />
    <description>kiki</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language><lastBuildDate>Sun, 10 Nov 2019 16:22:30 +0800</lastBuildDate>
    <image>
      <url>https://xueqing.github.io/img/icon-192.png</url>
      <title>kiki</title>
      <link>https://xueqing.github.io/authors/kiki/</link>
    </image>
    
    <item>
      <title>Redis vs Memcached</title>
      <link>https://xueqing.github.io/blog/database/redis_vs_memcached/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/redis_vs_memcached/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e6%a6%82%e8%a7%88&#34;&gt;1 概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e4%bb%80%e4%b9%88%e6%98%af-memcached&#34;&gt;2 什么是 Memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e4%bb%80%e4%b9%88%e6%98%af-redis&#34;&gt;3 什么是 Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-memcached-%e5%92%8c-redis-%e7%9a%84%e7%9b%b8%e4%bc%bc%e7%82%b9&#34;&gt;4 Memcached 和 Redis 的相似点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-memcached-%e5%92%8c-redis-%e7%9a%84%e4%b8%8d%e5%90%8c&#34;&gt;5 Memcached 和 Redis 的不同&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%e9%80%89%e6%8b%a9-memcached-%e8%bf%98%e6%98%af-redis&#34;&gt;6 选择 Memcached 还是 Redis&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-%e9%80%89%e6%8b%a9-memcached&#34;&gt;6.1 选择 Memcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62-%e9%80%89%e6%8b%a9-redis&#34;&gt;6.2 选择 Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63-%e6%80%bb%e7%bb%93&#34;&gt;6.3 总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%e5%8f%82%e8%80%83&#34;&gt;7 参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-概览&#34;&gt;1 概览&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;关系型数据库是常见的数据库类型，但是不适合存储大量的数据。因此，引入了 NoSQL。它表示非关系型或非 SQL。Memcached 和 Redis 归类为 NoSQL&lt;/li&gt;
&lt;li&gt;Memcached 和 Redis 最大的区别在于

&lt;ul&gt;
&lt;li&gt;Memcached 是开源的，高性能，分布式内存缓存系统，可通过最小化数据加载代价而加速 web 应用&lt;/li&gt;
&lt;li&gt;Redis 是开源的，key-value 存储，用于建设可扩展的 web 应用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-什么是-memcached&#34;&gt;2 什么是 Memcached&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Memcached 是开源的，高性能，分布式内存缓存系统。它是持久化数据存储&lt;/li&gt;
&lt;li&gt;Memcached 主要的优势在于它降低了数据库加载代价，因此对于大量数据库加载的网站是非常有效且快速的&lt;/li&gt;
&lt;li&gt;Memcached 有存储命令、检索命令、统计命令

&lt;ul&gt;
&lt;li&gt;存储命令&lt;/li&gt;
&lt;li&gt;set：为一个新的或已有的键设置新值&lt;/li&gt;
&lt;li&gt;add：为一个新键设置值&lt;/li&gt;
&lt;li&gt;replace：替换已有的键的值&lt;/li&gt;
&lt;li&gt;append：为已有键增加一些数据&lt;/li&gt;
&lt;li&gt;检索命令&lt;/li&gt;
&lt;li&gt;get：获取键中保存的值&lt;/li&gt;
&lt;li&gt;delete：删除已有键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-什么是-redis&#34;&gt;3 什么是 Redis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 是开源的，内存型数据结构存储，用作数据库、缓存和消息代理&lt;/li&gt;
&lt;li&gt;Redis 代表远程字典服务器(remote dictionary server)。以 key-value 格式存储数据&lt;/li&gt;
&lt;li&gt;用户在 Redis 命令行界面(command line interfacem, CLI)，使用命令和数据库通信

&lt;ul&gt;
&lt;li&gt;SET：写数据到 Redis 数据存储&lt;/li&gt;
&lt;li&gt;GET：从 Redis 数据存储读数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 简单易用。它归类为 NoSQL 数据库。和像 MySQL，Oracle 的关系型数据库不同，Redis 不使用表存储数据

&lt;ul&gt;
&lt;li&gt;Redis 不使用常规的 SQL 命令，例如 select、delete、create、update 等&lt;/li&gt;
&lt;li&gt;Redis 使用数据结构存储数据。主要的数据结构是 string，list，set，sorted set，hash，bitmap 等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 使用 C 语言编写，是开源的，跨平台的系统&lt;/li&gt;
&lt;li&gt;Redis 主要的优势在于它保存数据在内存中。这使得 Redis 非常快速。它也可以写数据到磁盘。Redis 可用作一个缓存系统或是全面的数据库&lt;/li&gt;
&lt;li&gt;Redis 另外一个优势是它可以和其他数据库一起使用。Redis 可以存储频繁访问的数据，而不访问主要的数据库，并且可以从主要的数据库获取其它的数据&lt;/li&gt;
&lt;li&gt;Redis 遵循 master-slave 架构。它提供性能、可扩展性且易用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-memcached-和-redis-的相似点&#34;&gt;4 Memcached 和 Redis 的相似点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;都归类为 NoSQL&lt;/li&gt;
&lt;li&gt;都以 key-value 格式存储数据：Redis 更准确的描述是作为数据结构存储&lt;/li&gt;
&lt;li&gt;都将存储数据到内存(毫秒级延迟)&lt;/li&gt;
&lt;li&gt;二者都是轻量级，和易失缓存一样快

&lt;ul&gt;
&lt;li&gt;Memcached 易失内存型的 key-value 存储&lt;/li&gt;
&lt;li&gt;Redis 不限于此，是一个数据结构服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;易用性、支持多种编程语言(Java/Python/PHP/C/C++/C#/JavaScript/NodeJS/Ruby/Go)&lt;/li&gt;
&lt;li&gt;支持数据分割：允许分布数据到多个节点，以便随着需求增长扩展数据处理能力&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-memcached-和-redis-的不同&#34;&gt;5 Memcached 和 Redis 的不同&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;不同点&lt;/th&gt;
&lt;th&gt;Memcached&lt;/th&gt;
&lt;th&gt;Redis&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;开源的，高性能，分布式内存缓存系统，可通过最小化数据加载代价而加速 web 应用&lt;/td&gt;
&lt;td&gt;开源的，key-value 存储，可作为数据库、缓存和消息代理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;易安装&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;高级数据结构&lt;/td&gt;
&lt;td&gt;N(字符串和整型)&lt;/td&gt;
&lt;td&gt;Y(string/list/set/sorted set/hash)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;多线程架构&lt;/td&gt;
&lt;td&gt;Y(充分利用多核)&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;快照&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y(时间快照存储数据到磁盘，用于归档或恢复)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;复制&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y(支持 master-slave 复制)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;事务&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;pub/sub&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Lua 脚本&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;地理空间支持&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;Y(可查找两个元素之间的距离，或者查找给定范围的所有元素)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;速度&lt;/td&gt;
&lt;td&gt;读写速度更快&lt;/td&gt;
&lt;td&gt;读写速度快，但是取决于开发的应用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;6-选择-memcached-还是-redis&#34;&gt;6 选择 Memcached 还是 Redis&lt;/h2&gt;

&lt;h3 id=&#34;6-1-选择-memcached&#34;&gt;6.1 选择 Memcached&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当缓存相当小的静态数据，比如 HTML 代码段：Memcached 内部的内存管理系统在最简单的应用场景下是更加高效，因为只占用相当小的内存资源用于元数据&lt;/li&gt;
&lt;li&gt;当数据大小动态变化，Memcached 的内存管理效率快速下降，有时内存会碎片化

&lt;ul&gt;
&lt;li&gt;同时，大数据集经常牵涉到序列化数据，需要更多空间存储&lt;/li&gt;
&lt;li&gt;如果使用Memcached，当重启时数据会丢失，而且重建缓存代价很好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Memcached 在伸缩性方面比 Redis 好： Memcached 是多线程，很方便增加计算资源；Redis 大多数是单线程，在不丢失数据的情况下只能通过集群水平增长

&lt;ul&gt;
&lt;li&gt;集群是有效的扩展方案，但是在设置和操作方面很复杂&lt;/li&gt;
&lt;li&gt;Memcached 不支持复制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Memcached 在处理高流量网站方面更好：可以一次读大量信息，而且响应时间快。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/database/memcached_redis_cluster.jpg&#34; alt=&#34;Memcached 和 Redis 的集群&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;6-2-选择-redis&#34;&gt;6.2 选择 Redis&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Redis 支持更多数据类型，所以作为缓存可以提供更更好的性能和效率&lt;/li&gt;
&lt;li&gt;数据回收(data eviction)：缓存使用数据回收机制，从内存删除旧数据为新数据分配空间

&lt;ul&gt;
&lt;li&gt;Memcached 使用 LRU(least recently used, 最近最少使用)算法，有时随机回收大小类似的数据&lt;/li&gt;
&lt;li&gt;Redis 支持细粒度控制回收，提供 6 种不同的回收策&lt;/li&gt;
&lt;li&gt;Redis 支持 lazy 和 active 的回收，即需要更多空间或主动地(proactively)&lt;/li&gt;
&lt;li&gt;Memcached 值支持 lazy 回收&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 作为数据结构的一些特性

&lt;ul&gt;
&lt;li&gt;丰富的数据类型和使用命令&lt;/li&gt;
&lt;li&gt;默认持久化到磁盘&lt;/li&gt;
&lt;li&gt;锁事务(WATCH/MULTI/EXEC)&lt;/li&gt;
&lt;li&gt;发布订阅(pub/sub)非常快&lt;/li&gt;
&lt;li&gt;值可达 512MB(Memcached 限制每个键 1MB)&lt;/li&gt;
&lt;li&gt;支持 Lua 脚本(2.6 开始)&lt;/li&gt;
&lt;li&gt;内嵌集群(3.0 开始)&lt;/li&gt;
&lt;li&gt;在各方面非常快&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 丰富的数据类型非常重要。它支持 Redis 提供共享队列(lists)，消息机制(pub/sub)，存储会话(hash)，高评分跟踪(sorted set)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-3-总结&#34;&gt;6.3 总结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Memcached 和 Redis 归类为 NoSQL。它们不使用结构化化查询语言(structed query language)来存储、检索和操作数据&lt;/li&gt;
&lt;li&gt;不同点在于 Memcached 是开源、高性能分布式内存缓存系统，Redis 是开源、key-value 存储用于构建可扩展 web 应用&lt;/li&gt;
&lt;li&gt;使用 Memcached 还是 Redis 取决于应用：需要高级数据结构时可使用 Redis；降低数据库加载代价，加速 web 应用可使用 Memcached&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-参考&#34;&gt;7 参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.differencebetween.com/difference-between-memcached-and-vs-redis/&#34; target=&#34;_blank&#34;&gt;Difference Between Memcached and Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.linkedin.com/pulse/memcached-vs-redis-which-one-pick-ranjeet-vimal/&#34; target=&#34;_blank&#34;&gt;Memcached vs Redis, Which One to Pick&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aws.amazon.com/elasticache/redis-vs-memcached/&#34; target=&#34;_blank&#34;&gt;Choosing between Redis and Memcached&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/blog/database/memcached/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/memcached/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%ae%e5%bd%95&#34;&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;1_intro.md&#34; target=&#34;_blank&#34;&gt;1 Memcached 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;2_store_command.md&#34; target=&#34;_blank&#34;&gt;2 Memcached 存储命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3_retrieval_command.md&#34; target=&#34;_blank&#34;&gt;3 Memcached 查找命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;4_statistics_command.md&#34; target=&#34;_blank&#34;&gt;4 Memcached 统计命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;5_examples.md&#34; target=&#34;_blank&#34;&gt;5 Memcached 实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/Memcached/Memcached-tutorial.html&#34; target=&#34;_blank&#34;&gt;Memcached 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redis.io/commands&#34; target=&#34;_blank&#34;&gt;Redis 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/blog/database/redis/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/redis/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%ae%e5%bd%95&#34;&gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;BSD 协议：可自由的使用，修改源代码，也可将修改后的代码作为开源或专有软件再发布&lt;/li&gt;
&lt;li&gt;守护进程(Daemon Process)：Linux 的后台服务进程。生存期较长，通常独立于控制终端且周期性地执行某种任务或等待处理某些发生的事件。脱离终端是为了避免进程被任何终端产生的信息打断，其执行过程中的信息也不显示在任何终端&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;1_intro.md&#34; target=&#34;_blank&#34;&gt;1 Redis 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;2_command.md&#34; target=&#34;_blank&#34;&gt;2 Redis 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;3_advanced.md&#34; target=&#34;_blank&#34;&gt;3 Redis 进阶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;4_vm.md&#34; target=&#34;_blank&#34;&gt;4 Redis VM 技术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/redis/redis-tutorial.html&#34; target=&#34;_blank&#34;&gt;Redis 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://redis.io/commands&#34; target=&#34;_blank&#34;&gt;Redis 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/blog/django_cms/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/django_cms/readme/</guid>
      <description>&lt;p&gt;参考&lt;a href=&#34;http://docs.django-cms.org/en/latest/index.html&#34; target=&#34;_blank&#34;&gt;官网&lt;/a&gt;学习。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/blog/git/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#git-%e5%ae%89%e8%a3%85&#34;&gt;git 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-%e9%85%8d%e7%bd%ae&#34;&gt;git 配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-%e5%b8%ae%e5%8a%a9&#34;&gt;git 帮助&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-%e5%9f%ba%e7%a1%80&#34;&gt;git 基础&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#git-%e4%bb%93%e5%ba%93%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95%e6%9a%82%e5%ad%98%e5%8c%ba%e5%9f%9f%e6%96%87%e4%bb%b6%e7%8a%b6%e6%80%81&#34;&gt;git 仓库、工作目录、暂存区域、文件状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%89%88%e6%9c%ac%e5%ba%93&#34;&gt;初始化版本库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b0%e5%bb%ba%e7%89%88%e6%9c%ac%e5%ba%93&#34;&gt;新建版本库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%8b%e9%9a%86%e7%89%88%e6%9c%ac%e5%ba%93&#34;&gt;克隆版本库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%89%88%e6%9c%ac%e5%ba%93%e7%9b%ae%e5%bd%95-git&#34;&gt;版本库目录 .git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#blob-%e5%af%b9%e8%b1%a1&#34;&gt;blob 对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tree-%e5%af%b9%e8%b1%a1&#34;&gt;tree 对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#commit-%e5%af%b9%e8%b1%a1&#34;&gt;commit 对象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e7%94%a8-git-%e5%91%bd%e4%bb%a4&#34;&gt;常用 git 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;git 服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83%e7%bd%91%e7%ab%99&#34;&gt;参考网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a5%bd%e7%8e%a9%e7%9a%84%e7%bd%91%e7%ab%99&#34;&gt;好玩的网站&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-安装&#34;&gt;git 安装&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://git-scm.com/download/linux&#34; target=&#34;_blank&#34;&gt;Linux&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# Fedora
sudo yum install git
# Debian
sudo apt-get install git
sudo apt-get install gitk git-gui
# 源码安装,[下载地址](http://git-scm.com/download)
sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev
export GIT_VER=2.0.0
wget https://www.kernel.org/pub/software/scm/git/git-$GIT_VER.tar.gz
tar -zxf git-$GIT_VER.tar.gz
pushd git-$GIT_VER
make prefix=/usr/local all
sudo make prefix=/usr/local install
popd
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Windows&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://git-scm.com/download/win&#34; target=&#34;_blank&#34;&gt;msysgit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Git 图形化操作程序, &lt;a href=&#34;https://tortoisegit.org/&#34; target=&#34;_blank&#34;&gt;TortoiseGit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://windows.github.com/&#34; target=&#34;_blank&#34;&gt;GitHub for Windows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mac&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安装 Xcode 后自动装上 Git&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sourceforge.net/projects/git-osx-installer/&#34; target=&#34;_blank&#34;&gt;使用图形化的Git 安装工具Git OS X&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-配置&#34;&gt;git 配置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参考&lt;a href=&#34;git_config.md&#34; target=&#34;_blank&#34;&gt;git_config&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-帮助&#34;&gt;git 帮助&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有三种命令可以找到 git 命令的使用手册

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git help &amp;lt;verb&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git &amp;lt;verb&amp;gt; --help&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;man git-&amp;lt;verb&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git help config&lt;/code&gt;            # 查看 config 命令的手册&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-基础&#34;&gt;git 基础&lt;/h2&gt;

&lt;h3 id=&#34;git-仓库-工作目录-暂存区域-文件状态&#34;&gt;git 仓库、工作目录、暂存区域、文件状态&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;git仓库：git 用来保存项目的元数据和对象数据库的地方&lt;/li&gt;
&lt;li&gt;工作目录：对项目的某个版本独立提取出来的内容.  是从 git 仓库的压缩数据库中提取出来的文件, 放在磁盘上使用或修改&lt;/li&gt;
&lt;li&gt;暂存区域(索引)：一个文件, 保存了下次将提交的文件列表信息, 一般在 Git 仓库目录中&lt;/li&gt;
&lt;li&gt;基本的 Git 工作流程如下：

&lt;ul&gt;
&lt;li&gt;在工作目录中修改文件&lt;/li&gt;
&lt;li&gt;暂存文件, 将文件的快照放入暂存区域&lt;/li&gt;
&lt;li&gt;提交更新, 找到暂存区域的文件, 将快照永久性存储到 git 仓库目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;文件状态：&lt;img src=&#34;gitfilestatus.png&#34; alt=&#34;git-文件的状态变化周期&#34; title=&#34;git-文件的状态变化周期&#34; /&gt;

&lt;ul&gt;
&lt;li&gt;已提交状态(commited)：git 目录中保存着的特定版本文件&lt;/li&gt;
&lt;li&gt;已暂存状态(staged)：作了修改并已放入暂存区域&lt;/li&gt;
&lt;li&gt;工作目录下的每一个文件都属于已跟踪(tracked)或未跟踪(untracked),已跟踪的文件状态可处于未修改(unmodified)、已修改(modified)或已放入暂存区(staged)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;初始化版本库&#34;&gt;初始化版本库&lt;/h3&gt;

&lt;h4 id=&#34;新建版本库&#34;&gt;新建版本库&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 确定版本库目录
mkdir dirname
pushd dirname
# 生成 .git 目录以及其下的版本历史记录文件, push 时易出现冲突
git init
# 创建一个裸仓库, 只保存git历史提交的版本信息, 不允许用户在上面进行各种 git 操作
git init --bare
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;克隆版本库&#34;&gt;克隆版本库&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;自动将其添加为远程仓库并默认以 “origin” 为简写&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 1 使用 ssh 协议克隆
# 1.1 默认本地仓库名字和远程仓库相同
git clone git@github.com:tensorflow/tensorflow.git
# 在当前目录下创建 tensorflow 目录, 并在这个目录下初始化一个 .git 文件夹,
# 从远程仓库拉取下所有数据放入 .git 文件夹, 然后从中读取最新版本的文件的拷贝
# 1.2 自定义本地仓库的名字克隆
git clone git@github.com:tensorflow/tensorflow.git MyTensorflow
# 2 使用 HTTPS 协议克隆
git clone https://github.com/tensorflow/tensorflow.git
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;版本库目录-git&#34;&gt;版本库目录 .git&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件(夹)名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;指向最新提交&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;config&lt;/td&gt;
&lt;td&gt;项目的配置信息, git config 命令会改动它&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;description&lt;/td&gt;
&lt;td&gt;项目的描述信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;hooks&lt;/td&gt;
&lt;td&gt;系统默认钩子脚本目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;索引文件，记录统计版本库的每个文件，如大小、创建时间和最后修改时间，对比当前统计信息和索引确定文件是否被修改&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;logs&lt;/td&gt;
&lt;td&gt;各个 refs 的历史信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;objects&lt;/td&gt;
&lt;td&gt;git 本地仓库的所有对象(commits, trees, blobs, tags)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;refs&lt;/td&gt;
&lt;td&gt;标识项目里的每个分支指向了哪个提交(commit)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;blob-对象&#34;&gt;blob 对象&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;git 基于“内容寻址”：文件不是按照文件名存储，而是按照包含内容的哈希值，存在一个叫“blob 对象”的文件中&lt;/li&gt;
&lt;li&gt;可以把文件内容的哈希值看做一个唯一 ID&lt;/li&gt;
&lt;li&gt;blob 对象存储文件内容，与文件名无关&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tree-对象&#34;&gt;tree 对象&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;tree 对象：一组包含文件类型、文件名和哈希值的数据&lt;/li&gt;
&lt;li&gt;tree 对象存储文件名&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;commit-对象&#34;&gt;commit 对象&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;commit 对象存储提交信息及其创建的日期和时间&lt;/li&gt;
&lt;li&gt;commit 对象是原子性的，即一个提交不会部分地记录变更&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;常用-git-命令&#34;&gt;常用 git 命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;添加文件参考&lt;a href=&#34;./git_add.md&#34;&gt;git_add&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;防止文件误添加

&lt;ul&gt;
&lt;li&gt;修改 .gitignore&lt;/li&gt;
&lt;li&gt;修改 .git/info/exclude&lt;/li&gt;
&lt;li&gt;格式规范参考&lt;a href=&#34;./git_ignore.md&#34;&gt;git_ignore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;提交更新参考&lt;a href=&#34;./git_commit.md&#34;&gt;git_commit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;跟踪状态参考&lt;a href=&#34;./git_status.md&#34;&gt;git_status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;提交日志参考&lt;a href=&#34;./git_log.md&#34;&gt;git_log&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;移除文件参考&lt;a href=&#34;./git_rm.md&#34;&gt;git_rm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;移动文件参考&lt;a href=&#34;./git_mv.md&#34;&gt;git_mv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;远程仓库参考&lt;a href=&#34;./git_remote.md&#34;&gt;git_remote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;推送数据参考&lt;a href=&#34;./git_push.md&#34;&gt;git_push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;标签参考&lt;a href=&#34;./git_tag.md&#34;&gt;git_tag&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;分支参考&lt;a href=&#34;./git_branch.md&#34;&gt;git_branch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;变基参考&lt;a href=&#34;./git_rebase.md&#34;&gt;git_rebase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;版本比较参考&lt;a href=&#34;./git_diff.md&#34;&gt;git_diff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;撤消操作

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git commit --amend&lt;/code&gt;  # 尝试重新提交&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset HEAD f1&lt;/code&gt;   # 取消暂存文件 f1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git checkout -- f1&lt;/code&gt;  # 撤消之前对文件 f1 所做的修改&lt;/li&gt;
&lt;li&gt;参考&lt;a href=&#34;./git_reset.md&#34;&gt;git_reset&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-服务器&#34;&gt;git 服务器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;协议

&lt;ul&gt;
&lt;li&gt;本地协议: 远程版本库就是硬盘内的另一个目录. 常见于团队每一个成员都对一个共享的文件系统(例如一个挂载的 NFS)拥有访问权, 或者比较少见的多人共用同一台电脑的情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone /opt/git/project.git&lt;/code&gt;      # Git 会尝试使用硬链接（hard link）或直接复制所需要的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone file:///opt/git/project.git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考网站&#34;&gt;参考网站&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www-cs-students.stanford.edu/~blynn//gitmagic/&#34; target=&#34;_blank&#34;&gt;Git Magic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/book/en/v2&#34; target=&#34;_blank&#34;&gt;git-scm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;好玩的网站&#34;&gt;好玩的网站&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.blog/&#34; target=&#34;_blank&#34;&gt;github blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/blog/go/basic/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/readme/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;go_install.md&#34; target=&#34;_blank&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_struct.md&#34; target=&#34;_blank&#34;&gt;结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_basic_syntax.md&#34; target=&#34;_blank&#34;&gt;基础语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_data_type.md&#34; target=&#34;_blank&#34;&gt;数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_variables.md&#34; target=&#34;_blank&#34;&gt;变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_constant.md&#34; target=&#34;_blank&#34;&gt;常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_operator.md&#34; target=&#34;_blank&#34;&gt;运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_decision_making.md&#34; target=&#34;_blank&#34;&gt;条件语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_loop.md&#34; target=&#34;_blank&#34;&gt;循环语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_function.md&#34; target=&#34;_blank&#34;&gt;函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_scope_rule.md&#34; target=&#34;_blank&#34;&gt;变量作用域&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_array.md&#34; target=&#34;_blank&#34;&gt;数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_pointer.md&#34; target=&#34;_blank&#34;&gt;指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_structure.md&#34; target=&#34;_blank&#34;&gt;结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_slice.md&#34; target=&#34;_blank&#34;&gt;切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_range.md&#34; target=&#34;_blank&#34;&gt;范围&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_map.md&#34; target=&#34;_blank&#34;&gt;散列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_recursive.md&#34; target=&#34;_blank&#34;&gt;递归函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_type_casting.md&#34; target=&#34;_blank&#34;&gt;类型转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_method.md&#34; target=&#34;_blank&#34;&gt;方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_interface.md&#34; target=&#34;_blank&#34;&gt;接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_error_handling.md&#34; target=&#34;_blank&#34;&gt;错误处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;补充笔记

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;go_exception.md&#34; target=&#34;_blank&#34;&gt;异常处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_package.md&#34; target=&#34;_blank&#34;&gt;包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_struct.md&#34; target=&#34;_blank&#34;&gt;结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_goroutine.md&#34; target=&#34;_blank&#34;&gt;goroutine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_channel.md&#34; target=&#34;_blank&#34;&gt;通道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_waitgroup.md&#34; target=&#34;_blank&#34;&gt;WaitGroup 和 worker pool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_mutex.md&#34; target=&#34;_blank&#34;&gt;锁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;go_module.md&#34; target=&#34;_blank&#34;&gt;模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/blog/go/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/readme/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;study/README.md&#34; target=&#34;_blank&#34;&gt;Go 基础学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./traps/README.md&#34;&gt;Go 开发遇到的坑&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/blog/go/traps/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/traps/readme/</guid>
      <description>&lt;p&gt;记录 go 开发遇到的坑&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;var_scope.md&#34; target=&#34;_blank&#34;&gt;不使用短变量声明 &lt;code&gt;:=&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;json_struct.md&#34; target=&#34;_blank&#34;&gt;json 解析成结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;mod_workspace.md&#34; target=&#34;_blank&#34;&gt;module 不要在 vscode 工作区打开工程&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;package_var.md&#34; target=&#34;_blank&#34;&gt;同一包不同源文件变量声明时不要带包名&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有时候新定义的变量或者函数不能跳转，需要重启 vscode，相关插件长时间运行可能崩溃&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;敏捷：一种用于增量创建软件的软件开发方法，使用 1-4 周的短期迭代以保证开发和一直改变的业务需求一致&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./1-primer.md&#34;&gt;1 入门&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.1-敏捷中的角色&#34;&gt;1.1 敏捷中的角色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.2-跨职能团队&#34;&gt;1.2 跨职能团队&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.3-敏捷团队如何计划工作&#34;&gt;1.3 敏捷团队如何计划工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.4-用户故事-user-story&#34;&gt;1.4 用户故事 user story&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.5-故事何时完成&#34;&gt;1.5 故事何时完成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./2-manifesto.md&#34;&gt;2 宣言&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./2-manifesto.md#2.1-软件开发价值观&#34;&gt;2.1 软件开发价值观&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./2-manifesto.md#2.2-敏捷宣言的-12-个原则&#34;&gt;2.2 敏捷宣言的 12 个原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./3-characteristics.md&#34;&gt;3 特点&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./3-characteristics.md#3.1-迭代/增量和准备进化&#34;&gt;3.1 迭代/增量和准备进化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./3-characteristics.md#3.2-面对面沟通&#34;&gt;3.2 面对面沟通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./3-characteristics.md#3.3-反馈回路&#34;&gt;3.3 反馈回路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./4-daily-standup.md&#34;&gt;4 每日站会&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.1-每日站会的概念&#34;&gt;4.1 每日站会的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.2-每日站会的重要性&#34;&gt;4.2 每日站会的重要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.3-每日站会的参与人&#34;&gt;4.3 每日站会的参与人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.4-物理分散的团队&#34;&gt;4.4 物理分散的团队&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./5-definition-of-done.md&#34;&gt;5 完成标准&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./5-definition-of-done.md#5.1-用户故事&#34;&gt;5.1 用户故事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./5-definition-of-done.md#5.2-迭代&#34;&gt;5.2 迭代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./5-definition-of-done.md#5.3-发布&#34;&gt;5.3 发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./6-release-planning.md&#34;&gt;6 发布计划&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.1-参与者&#34;&gt;6.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.2-计划的先决条件&#34;&gt;6.2 计划的先决条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.3-需要的材料&#34;&gt;6.3 需要的材料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.4-计划数据&#34;&gt;6.4 计划数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.5-输出&#34;&gt;6.5 输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.6-日程&#34;&gt;6.6 日程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./7-iteration-planning.md&#34;&gt;7 迭代计划&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.1-参与者&#34;&gt;7.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.2-计划的先决条件&#34;&gt;7.2 计划的先决条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.3-计划流程&#34;&gt;7.3 计划流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.4-速度计算&#34;&gt;7.4 速度计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.5-任务容量&#34;&gt;7.5 任务容量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.6-计划步骤&#34;&gt;7.6 计划步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./8-product-backlog.md&#34;&gt;8 产品需求列表&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./8-product-backlog.md#8.1-产品需求列表的重要性&#34;&gt;8.1 产品需求列表的重要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./8-product-backlog.md#8.2-产品需求列表的特点&#34;&gt;8.2 产品需求列表的特点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./9-useful-terms.md&#34;&gt;9 有用的术语&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;有用的书&#34;&gt;有用的书&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Scrum-Breathtakingly-Brief-Agile-Introduction/dp/193796504X/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Scrum: a Breathtakingly Brief and Agile Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Learning-Agile-Understanding-Scrum-Kanban/dp/1449331920/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Learning Agile: Understanding Scrum, XP, Lean, and Kanban&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Agile-Project-Management-Dummies-Layton/dp/1118026241/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Agile Project Management For Dummies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Agile-Project-Management-QuickStart-Guide/dp/1502393468/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Agile Project Management QuickStart Guide: A Simplified Beginners Guide To Agile Project Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Agile-Half-Assed-Creating-Anything-Scratch-ebook/dp/B00R0QHV3G/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Agile!: The Half-Assed Guide To Creating Anything You Want From Scratch. No Experts Required!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Understanding-Agile-Manifesto-Brief-Guide-ebook/dp/B00GR31ZDU/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Understanding the Agile Manifesto: A Brief &amp;amp; Bold Guide to Agile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/command/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/readme/</guid>
      <description>

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/cmd/go/&#34; target=&#34;_blank&#34;&gt;Go 命令官网&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;p&gt;Go 是一个用于管理 Go 源码的工具。&lt;/p&gt;

&lt;p&gt;用法：&lt;code&gt;go &amp;lt;command&amp;gt; [arguments]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令有:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;bug.md&#34; target=&#34;_blank&#34;&gt;bug&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;开启一个缺陷报告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;build.md&#34; target=&#34;_blank&#34;&gt;build&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;编译包及其依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;clean.md&#34; target=&#34;_blank&#34;&gt;clean&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;删除目标文件和缓存文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;doc.md&#34; target=&#34;_blank&#34;&gt;doc&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;查看包或者符号的文档&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;env.md&#34; target=&#34;_blank&#34;&gt;env&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;打印 Go 环境变量信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;fix.md&#34; target=&#34;_blank&#34;&gt;fix&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;更新包以使用新的 API&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;fmt.md&#34; target=&#34;_blank&#34;&gt;fmt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;gofmt(reformat) 包的源文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;generate.md&#34; target=&#34;_blank&#34;&gt;generate&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;通过处理源生成 Go 文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;get.md&#34; target=&#34;_blank&#34;&gt;get&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;为当前模块添加依赖并且安装依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;install.md&#34; target=&#34;_blank&#34;&gt;install&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;编译和安装包及其依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;list.md&#34; target=&#34;_blank&#34;&gt;list&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;列举包或模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;mod.md&#34; target=&#34;_blank&#34;&gt;mod&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;模块维护&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;run.md&#34; target=&#34;_blank&#34;&gt;run&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;编译和运行 Go 程序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;test_package.md&#34; target=&#34;_blank&#34;&gt;test&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;测试包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tool&lt;/td&gt;
&lt;td&gt;运行指定的 go 工具&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;打印 Go 版本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vet&lt;/td&gt;
&lt;td&gt;打印包中可能的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;go help &amp;lt;command&amp;gt;&lt;/code&gt; 查看命令的更多信息。&lt;/p&gt;

&lt;p&gt;其他的帮助话题：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;帮助&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;buildmode&lt;/td&gt;
&lt;td&gt;编译模式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;在 Go 和 C 直接调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cache&lt;/td&gt;
&lt;td&gt;编译和测试缓存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;environment&lt;/td&gt;
&lt;td&gt;环境变量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;filetype&lt;/td&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;go.mod&lt;/td&gt;
&lt;td&gt;go.mod 文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gopath&lt;/td&gt;
&lt;td&gt;GOPATH 环境变量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gopath-get&lt;/td&gt;
&lt;td&gt;传统 GOPATH 的 go get&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;goproxy&lt;/td&gt;
&lt;td&gt;模块 proxy 协议&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;importpath&lt;/td&gt;
&lt;td&gt;模块路径语法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;modules&lt;/td&gt;
&lt;td&gt;模块，模块版本等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;module-get&lt;/td&gt;
&lt;td&gt;明白模块的 go get&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;module-auth&lt;/td&gt;
&lt;td&gt;使用 go.sum 的模块认证&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;module-private&lt;/td&gt;
&lt;td&gt;对于非公共模块的模块配置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;packages&lt;/td&gt;
&lt;td&gt;包列表和模式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;testflag&lt;/td&gt;
&lt;td&gt;测试标识&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;testfunc&lt;/td&gt;
&lt;td&gt;测试函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;go help &amp;lt;topic&amp;gt;&lt;/code&gt; 查看话题的更多信息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85-go&#34;&gt;安装 Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%a6%e4%b9%a0-go&#34;&gt;学习 Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%87%e7%ab%a0&#34;&gt;文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9d%9e%e8%8b%b1%e6%96%87%e6%96%87%e7%ab%a0&#34;&gt;非英文文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;安装-go&#34;&gt;安装 Go&lt;/h2&gt;

&lt;h2 id=&#34;学习-go&#34;&gt;学习 Go&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;h2 id=&#34;文章&#34;&gt;文章&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;代码漫步：Go 程序的指导之旅。

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/codewalk/functions&#34; target=&#34;_blank&#34;&gt;Go 的一级函数&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/codewalk/markov&#34; target=&#34;_blank&#34;&gt;生成任意文本：一个 Markov 链算法&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/codewalk/sharemem&#34; target=&#34;_blank&#34;&gt;通过共享内存&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;articles/wiki.md&#34; target=&#34;_blank&#34;&gt;编写 Web 应用&lt;/a&gt;——构建一个简单的 web 应用。&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;工具

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;articles/go_command.md&#34; target=&#34;_blank&#34;&gt;关于 Go 命令&lt;/a&gt;——为什么我们编写它？它是什么？它不是什么？如何使用它？&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;gdb.md&#34; target=&#34;_blank&#34;&gt;使用 GDB 调试 Go 代码&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;articles/race_detector.md&#34; target=&#34;_blank&#34;&gt;数据竞争检测器&lt;/a&gt;——关于数据竞争检测器的手册&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;asm.md&#34; target=&#34;_blank&#34;&gt;快速入门 Go 的汇编器&lt;/a&gt;——介绍了 Go 使用的汇编器&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;更多

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 查看&lt;a href=&#34;../README.md&#34;&gt;维基&lt;/a&gt;的&lt;a href=&#34;../wiki/articles.md&#34;&gt;文章&lt;/a&gt;页面获取更多 Go 的文章&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;非英文文章&#34;&gt;非英文文章&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e5%87%86%e5%ba%93&#34;&gt;标准库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96%e5%8c%85&#34;&gt;其他包&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%90%e4%bb%93%e5%ba%93&#34;&gt;子仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%be%e5%8c%ba&#34;&gt;社区&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;标准库&#34;&gt;标准库&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;概述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;testing.md&#34; target=&#34;_blank&#34;&gt;testing&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;支持对 Go 包的自动测试&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;——&lt;a href=&#34;iotest.md&#34; target=&#34;_blank&#34;&gt;iotest&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了主要用于 testing 的 Reader 和 Writer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;——&lt;a href=&#34;quick.md&#34; target=&#34;_blank&#34;&gt;quick&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了帮助黑盒测试的工具函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;其他包&#34;&gt;其他包&lt;/h2&gt;

&lt;h3 id=&#34;子仓库&#34;&gt;子仓库&lt;/h3&gt;

&lt;h3 id=&#34;社区&#34;&gt;社区&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/readme/</guid>
      <description>&lt;p&gt;关于 &lt;a href=&#34;http://tour.golang.org/&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt; 的练习题&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e4%b9%8b%e5%ae%b6&#34;&gt;Go 之家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b4%a1%e7%8c%ae&#34;&gt;贡献&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e5%ae%b9%e5%88%97%e8%a1%a8&#34;&gt;内容列表&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e5%85%a5%e9%97%a8&#34;&gt;Go 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8-go-%e5%b7%a5%e4%bd%9c&#34;&gt;用 Go 工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%b4%e5%a4%9a%e5%85%b3%e4%ba%8e-go-%e7%9a%84%e5%ad%a6%e4%b9%a0&#34;&gt;更多关于 Go 的学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e7%a4%be%e5%8c%ba&#34;&gt;Go 社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-go-%e5%b7%a5%e5%85%b7%e9%93%be&#34;&gt;使用 go 工具链&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96%e7%9a%84-go-%e7%bc%96%e7%a8%8b%e7%bb%b4%e5%9f%ba&#34;&gt;其他的 Go 编程维基&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bd%91%e4%b8%8a%e7%94%a8-go-%e7%9a%84%e6%9c%8d%e5%8a%a1&#34;&gt;网上用 Go 的服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83%e7%9a%84-go-%e7%a8%8b%e5%ba%8f%e7%96%91%e9%9a%be%e8%a7%a3%e7%ad%94&#34;&gt;生产环境的 Go 程序疑难解答&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ba-go-%e9%a1%b9%e7%9b%ae%e5%81%9a%e8%b4%a1%e7%8c%ae&#34;&gt;为 Go 项目做贡献&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b3%e5%8f%b0%e7%89%b9%e5%ae%9a%e7%9a%84%e4%bf%a1%e6%81%af&#34;&gt;平台特定的信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%91%e5%b8%83%e7%89%b9%e5%ae%9a%e7%9a%84%e4%bf%a1%e6%81%af&#34;&gt;发布特定的信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki&#34; target=&#34;_blank&#34;&gt;Go 维基官网&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;原网页由 HunterQ 在 2019/4/12 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/Home/_history&#34; target=&#34;_blank&#34;&gt;第 99 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;go-之家&#34;&gt;Go 之家&lt;/h2&gt;

&lt;p&gt;欢迎来到 Go 维基，集中了关于 &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Go 编程语言&lt;/a&gt;的信息。&lt;a href=&#34;http://awesome-go.com/&#34; target=&#34;_blank&#34;&gt;Awesome Go&lt;/a&gt; 是另外一个给 Go 编程人员的丰富的资源，由 Go 社区管理。&lt;/p&gt;

&lt;h2 id=&#34;贡献&#34;&gt;贡献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这个维基可被拥有 Github 账号的 Go 社区的任意成员编辑。&lt;/li&gt;
&lt;li&gt;如果你想要新增一个页面，请首先在 &lt;a href=&#34;https://github.com/golang/go/issues&#34; target=&#34;_blank&#34;&gt;Go issue 跟踪页面&lt;/a&gt; 打开一个 issue，以前缀 “wiki” 开头来提议新增的内容。清楚地说明为什么这个内容不适用任何现有的页面。&lt;/li&gt;
&lt;li&gt;因为维基页面的重命名会破坏外部链接，请在重命名或删除任何维基页面之前打开一个 issue。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内容列表&#34;&gt;内容列表&lt;/h2&gt;

&lt;h3 id=&#34;go-入门&#34;&gt;Go 入门&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;gotour/README.md&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt;是入门最好的地方。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/effective_go.html&#34; target=&#34;_blank&#34;&gt;实效 Go 编程&lt;/a&gt;将会帮助学习如何编写惯用的 Go 代码。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/pkg/&#34; target=&#34;_blank&#34;&gt;Go 标准库文档&lt;/a&gt;使你熟悉标准库。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 使用 &lt;a href=&#34;http://play.golang.org/&#34; target=&#34;_blank&#34;&gt;Go Playground&lt;/a&gt; 用于在你的浏览器测试 Go 程序。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 仍然不确信？查看这份 &lt;a href=&#34;https://github.com/golang/go/wiki/GoUsers&#34; target=&#34;_blank&#34;&gt;Go 使用者&lt;/a&gt;清单以及他们的一些&lt;a href=&#34;https://github.com/golang/go/wiki/SuccessStories&#34; target=&#34;_blank&#34;&gt;成功案例&lt;/a&gt;。我们也收集了一份长长的原因清单，关于&lt;a href=&#34;https://github.com/golang/go/wiki/whygo&#34; target=&#34;_blank&#34;&gt;你为什么应该尝试 Go&lt;/a&gt;。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 了解更多已经&lt;a href=&#34;https://github.com/golang/go/wiki/FromXToGo&#34; target=&#34;_blank&#34;&gt;从其他语言转到 Go&lt;/a&gt; 的公司。
这里是一些帮助你入门的链接。&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用-go-工作&#34;&gt;用 Go 工作&lt;/h3&gt;

&lt;p&gt;准备好自己写一些 Go 代码了吗？这里是一些帮助你入门的链接。&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 安装和设置你的环境

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 由此开始：&lt;a href=&#34;https://golang.org/doc/install&#34; target=&#34;_blank&#34;&gt;官方安装文档&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 如果你更喜欢源码安装，&lt;a href=&#34;https://golang.org/doc/install/source&#34; target=&#34;_blank&#34;&gt;先阅读此文档&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/InstallFromSource&#34; target=&#34;_blank&#34;&gt;从源码安装&lt;/a&gt;——其他关于源码安装的建议&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Windows 用户？&lt;a href=&#34;https://github.com/abourget/getting-started-with-golang&#34; target=&#34;_blank&#34;&gt;为 Windows 安装和配置 Go、Git和 Atom&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Mac 用户？&lt;a href=&#34;https://howistart.org/posts/go/1&#34; target=&#34;_blank&#34;&gt;如何开始-Go&lt;/a&gt;——安装 Go 和编译你的以第一个 web 服务的分步指南&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 安装遇到问题？&lt;a href=&#34;https://github.com/golang/go/wiki/InstallTroubleShooting&#34; target=&#34;_blank&#34;&gt;安装疑难解答&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 确保你已经&lt;a href=&#34;https://golang.org/doc/install/source#gopath&#34; target=&#34;_blank&#34;&gt;正确设置了 $GOPATH 环境变量&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 如果需要其他关于&lt;a href=&#34;https://github.com/golang/go/wiki/GOPATH&#34; target=&#34;_blank&#34;&gt;使用 $GOPATH 的建议，浏览这里&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/MultipleGoRoots&#34; target=&#34;_blank&#34;&gt;多个 GOROOT&lt;/a&gt;——更多高级信息关于在安装多个 go 以及 &lt;code&gt;$GOROOT&lt;/code&gt; 变量的环境工作&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins&#34; target=&#34;_blank&#34;&gt;Go 集成开发环境和编辑器&lt;/a&gt;——一些关于如何使用你最喜欢的编辑器开发 Go 的信息&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/CodeTools&#34; target=&#34;_blank&#34;&gt;为开发 Go 代码的工具&lt;/a&gt;——格式化、语言分析、代码检查、代码重构、代码导航和可视化&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 查找 Go 库和包

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 由此开始：&lt;a href=&#34;https://github.com/golang/go/wiki/Projects&#34; target=&#34;_blank&#34;&gt;Go 开源工程&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 查找 Go 包：&lt;a href=&#34;http://godoc.org/&#34; target=&#34;_blank&#34;&gt;go 文档官网&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://anvaka.github.io/pm/#/galaxy/gosearch?l=1&#34; target=&#34;_blank&#34;&gt;Go 开源包图&lt;/a&gt;的可视化&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/PackageManagementTools&#34; target=&#34;_blank&#34;&gt;管理你的依赖&lt;/a&gt;——一个你可以用来管理第三方包 (vendoring) 的工具纵览&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 发布开源的 Go 包

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 准备好发布你的包了？&lt;a href=&#34;https://github.com/golang/go/wiki/PackagePublishing&#34; target=&#34;_blank&#34;&gt;由此开始&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/matttproud/gochecklist&#34; target=&#34;_blank&#34;&gt;Go 检查清单&lt;/a&gt;——发布一个项目的完全指南&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/GitHubCodeLayout&#34; target=&#34;_blank&#34;&gt;如何设计你的 Github 仓库&lt;/a&gt; 以便其他 Go 编程人员更容易使用 &lt;code&gt;go get&lt;/code&gt; 命令&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://johnsto.co.uk/blog/go-package-go&#34; target=&#34;_blank&#34;&gt;Go 包&lt;/a&gt;——一些使得 Go 包更易用的建议&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;更多关于-go-的学习&#34;&gt;更多关于 Go 的学习&lt;/h3&gt;

&lt;p&gt;当你对这门语言有一个概览之后，这里有一些资源供你使用学习更多关于 Go：&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Learn&#34; target=&#34;_blank&#34;&gt;学习 Go&lt;/a&gt;—— Go 入门到高级的资料集合

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://medium.com/@IndianGuru/best-practices-for-a-new-go-developer-8660384302fc&#34; target=&#34;_blank&#34;&gt;Go 新手开发人员的最佳实践&lt;/a&gt;——来自 Go 社区成员的见解&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/LearnServerProgramming&#34; target=&#34;_blank&#34;&gt;服务器编程&lt;/a&gt;——构建 web、移动端和 API 服务器&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/LearnConcurrency&#34; target=&#34;_blank&#34;&gt;并发&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/LearnErrorHandling&#34; target=&#34;_blank&#34;&gt;错误处理&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;learn_testing.md&#34; target=&#34;_blank&#34;&gt;测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Mobile&#34; target=&#34;_blank&#34;&gt;移动端&lt;/a&gt;——安卓和 iOS&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Books&#34; target=&#34;_blank&#34;&gt;书籍&lt;/a&gt;——一份已经出版的(电子书，论文)关于 Go 的的书籍清单&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Blogs&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;——关于 Go 的博客

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; [播客]——描写 Go 特色的播客和故事&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 视频、谈话和演示

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;http://gophervids.appspot.com/&#34; target=&#34;_blank&#34;&gt;GopherVids&lt;/a&gt; 是一个关于 Go 的视频的搜索目录&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/GoTalks&#34; target=&#34;_blank&#34;&gt;GoTalks&lt;/a&gt;——来自 Go 会议和聚会的谈话集合&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Screencasts&#34; target=&#34;_blank&#34;&gt;Screencasts&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Articles&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;——帮助你学习 Go 的文章集合&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Training&#34; target=&#34;_blank&#34;&gt;培训&lt;/a&gt;——免费的、商业的、在线的 Go 课堂培训&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Courses&#34; target=&#34;_blank&#34;&gt;大学课程&lt;/a&gt;——一个使用 Go 的 CS 编程和课程列表&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/NonEnglish&#34; target=&#34;_blank&#34;&gt;非英语人士的资源&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-社区&#34;&gt;Go 社区&lt;/h3&gt;

&lt;p&gt;有一些地方，你可以找到在线的 Gophers。要了解成为 Go 社区一名成员意味着什么，阅读 &lt;a href=&#34;https://medium.com/@dgryski/the-go-community-f0d00e3a19e&#34; target=&#34;_blank&#34;&gt;Damian Gryski 在 2015 年 GolankUK 会议上的主题演讲&lt;/a&gt;或者观看 &lt;a href=&#34;https://www.youtube.com/watch?v=0ht89TxZZnk&#34; target=&#34;_blank&#34;&gt;Andrew Gerrand 在 2015 年 GopherCon 上的闭幕演讲&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gophers 在线聚会场所：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://forum.golangbridge.org/&#34; target=&#34;_blank&#34;&gt;Go 论坛&lt;/a&gt;——Go 社区的万能讨论论坛&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gophers.slack.com/&#34; target=&#34;_blank&#34;&gt;Gophers Slack Channel&lt;/a&gt;——针对实时聊天(&lt;a href=&#34;http://blog.gopheracademy.com/gophers-slack-community/&#34; target=&#34;_blank&#34;&gt;要求成员&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golangnews.com/&#34; target=&#34;_blank&#34;&gt;Golang 新闻&lt;/a&gt;——关于 Go 编程的链接&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://reddit.com/r/golang&#34; target=&#34;_blank&#34;&gt;r/golang&lt;/a&gt;——sub-reddit&lt;/li&gt;
&lt;li&gt;在 Twitter 上，follow @golang 账户，并且&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-go-工具链&#34;&gt;使用 go 工具链&lt;/h3&gt;

&lt;h3 id=&#34;其他的-go-编程维基&#34;&gt;其他的 Go 编程维基&lt;/h3&gt;

&lt;h3 id=&#34;网上用-go-的服务&#34;&gt;网上用 Go 的服务&lt;/h3&gt;

&lt;h3 id=&#34;生产环境的-go-程序疑难解答&#34;&gt;生产环境的 Go 程序疑难解答&lt;/h3&gt;

&lt;h3 id=&#34;为-go-项目做贡献&#34;&gt;为 Go 项目做贡献&lt;/h3&gt;

&lt;h3 id=&#34;平台特定的信息&#34;&gt;平台特定的信息&lt;/h3&gt;

&lt;h3 id=&#34;发布特定的信息&#34;&gt;发布特定的信息&lt;/h3&gt;

&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>Markdown 规范</title>
      <link>https://xueqing.github.io/blog/markdown/markdown_%E8%A7%84%E8%8C%83/</link>
      <pubDate>Sun, 10 Nov 2019 16:22:30 +0800</pubDate>
      <guid>https://xueqing.github.io/blog/markdown/markdown_%E8%A7%84%E8%8C%83/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e8%be%91%e5%99%a8&#34;&gt;编辑器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9f%ba%e6%9c%ac%e6%8a%80%e5%b7%a7&#34;&gt;基本技巧&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e9%a2%98&#34;&gt;标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%a3%e7%a0%81&#34;&gt;代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b2%97%e6%96%9c%e4%bd%93&#34;&gt;粗斜体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8d%a2%e8%a1%8c&#34;&gt;换行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%93%be%e6%8e%a5&#34;&gt;链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%97%e8%a1%a8&#34;&gt;列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%99%ae%e9%80%9a%e6%97%a0%e5%ba%8f%e5%88%97%e8%a1%a8&#34;&gt;普通无序列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%99%ae%e9%80%9a%e6%9c%89%e5%ba%8f%e5%88%97%e8%a1%a8&#34;&gt;普通有序列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%97%e8%a1%a8%e5%b5%8c%e5%a5%97&#34;&gt;列表嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%a8%e6%a0%bc&#34;&gt;表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%95%e7%94%a8&#34;&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%99%ae%e9%80%9a%e5%bc%95%e7%94%a8&#34;&gt;普通引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%95%e7%94%a8%e5%b5%8c%e5%a5%97%e5%bc%95%e7%94%a8&#34;&gt;引用嵌套引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%95%e7%94%a8%e5%b5%8c%e5%a5%97%e5%88%97%e8%a1%a8&#34;&gt;引用嵌套列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%95%e7%94%a8%e5%b5%8c%e5%a5%97%e4%bb%a3%e7%a0%81%e5%9d%97&#34;&gt;引用嵌套代码块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9b%be%e7%89%87&#34;&gt;图片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%86%e9%9a%94%e7%ac%a6&#34;&gt;分隔符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%ab%98%e7%ba%a7%e6%8a%80%e5%b7%a7&#34;&gt;高级技巧&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%8c%e5%86%85-html-%e5%85%83%e7%b4%a0&#34;&gt;行内 HTML 元素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ac%a6%e5%8f%b7%e8%bd%ac%e4%b9%89&#34;&gt;符号转义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%ac%e5%bc%8f&#34;&gt;公式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%84%9a%e6%b3%a8&#34;&gt;脚注&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%87%e6%a1%a3%e8%a7%84%e8%8c%83&#34;&gt;文档规范&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编辑器&#34;&gt;编辑器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Mac

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://25.io/mou/&#34; target=&#34;_blank&#34;&gt;Mou&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Windows

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.markdownpad.com/&#34; target=&#34;_blank&#34;&gt;MarkdownPad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code52.org/MarkPadRT/&#34; target=&#34;_blank&#34;&gt;MarkPad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/retext-project/retext&#34; target=&#34;_blank&#34;&gt;ReText&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Vim+&lt;a href=&#34;http://xbeta.info/vimwiki.htm&#34; target=&#34;_blank&#34;&gt;Vimwiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在线编辑器

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://markable.in/&#34; target=&#34;_blank&#34;&gt;markable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dillinger.io/&#34; target=&#34;_blank&#34;&gt;dillinger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;浏览器插件

&lt;ul&gt;
&lt;li&gt;MaDe(chrome)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://maxiang.io/&#34; target=&#34;_blank&#34;&gt;马克飞象&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;高级应用

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sublimetext.com/2&#34; target=&#34;_blank&#34;&gt;Sublime Text 2&lt;/a&gt; + &lt;a href=&#34;http://ttscoff.github.io/MarkdownEditing/&#34; target=&#34;_blank&#34;&gt;MarkdownEditing&lt;/a&gt; / &lt;a href=&#34;https://lucifr.com/2012/07/12/markdownediting-for-sublime-text-2/&#34; target=&#34;_blank&#34;&gt;教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基本技巧&#34;&gt;基本技巧&lt;/h2&gt;

&lt;h3 id=&#34;标题&#34;&gt;标题&lt;/h3&gt;

&lt;p&gt;Markdown 支持两种标题的语法，类 &lt;a href=&#34;http://docutils.sourceforge.net/mirror/setext.html&#34; target=&#34;_blank&#34;&gt;Setext&lt;/a&gt; 和类 &lt;a href=&#34;http://www.aaronsw.com/2002/atx/&#34; target=&#34;_blank&#34;&gt;atx&lt;/a&gt; 形式&lt;br /&gt;
类 atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶(可以在行尾加上 #)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;# 一级标题 #
## 二级标题 ##
### 三级标题 ###
#### 四级标题 ####
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类 Setext 形式是用底线的形式，利用 = (最高阶标题)和 - (第二阶标题)(任何数量的 = 和 - 都可以有效果)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;一级标题
============
二级标题
------------
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;代码&#34;&gt;代码&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;行内代码：用反引号标记行内代码，如

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;function_name()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;包含反引号`的代码&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代码段，通常编辑器根据代码片段适配合适的高亮方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以用[三个`]包裹一段代码，并指定一种语言&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int test()
{
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可以使用 4 空格或是 1 个制表符缩进，再贴上代码，实现相同的的效果&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;int test()
{
  return 0;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果不需要代码高亮，可以用下面的语法禁用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-nohighlight&#34;&gt;int test()
{
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;粗斜体&#34;&gt;粗斜体&lt;/h3&gt;

&lt;p&gt;Markdown 使用星号和底线作为标记强调字词的符号&lt;br /&gt;
&lt;em&gt;斜体&lt;/em&gt;  &lt;em&gt;斜体&lt;/em&gt;&lt;br /&gt;
&lt;strong&gt;粗体&lt;/strong&gt;  &lt;strong&gt;粗体&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;粗斜体&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;粗斜体&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;换行&#34;&gt;换行&lt;/h3&gt;

&lt;p&gt;另起一行，只需要在当前结尾加2个空格&lt;br /&gt;
这样就会另起一行&lt;/p&gt;

&lt;p&gt;空出一行，即可新起一个段落&lt;/p&gt;

&lt;p&gt;行尾加斜线，&lt;br /&gt;
也可实现换行&lt;/p&gt;

&lt;h3 id=&#34;链接&#34;&gt;链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;行内式链接

&lt;ul&gt;
&lt;li&gt;文字链接：方括号(链接名称)+圆括号(链接地址) &lt;a href=&#34;http://链接地址&#34; target=&#34;_blank&#34;&gt;链接名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://translate.google.com/&#34; target=&#34;_blank&#34;&gt;google&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mail.google.com/mail/u/0/&#34; target=&#34;_blank&#34;&gt;gmail&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;自动链接：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，尖括号+(链接地址)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://translate.google.com/&#34; target=&#34;_blank&#34;&gt;https://translate.google.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mail.google.com/mail/u/0/&#34; target=&#34;_blank&#34;&gt;https://mail.google.com/mail/u/0/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参考式链接：在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记，然后在文件的任意处为标记变量赋值(网址)

&lt;ul&gt;
&lt;li&gt;隐式链接标记：可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字&lt;/li&gt;
&lt;li&gt;这个链接用 Google 作为网址变量 &lt;a href=&#34;http://www.google.com/&#34; title=&#34;Hi, Google&#34; target=&#34;_blank&#34;&gt;Google&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;这个链接用 yahoo 作为网址变量 &lt;a href=&#34;http://www.yahoo.com/&#34; title=&#34;Hi, Yahoo&#34; target=&#34;_blank&#34;&gt;Yahoo!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;链接标记的内容定义的形式为：&lt;/li&gt;
&lt;li&gt;方括号(前面可以选择性地加上至多三个空格来缩进)，里面输入链接文字&lt;/li&gt;
&lt;li&gt;接着一个冒号&lt;/li&gt;
&lt;li&gt;接着一个以上的空格或制表符&lt;/li&gt;
&lt;li&gt;接着链接的网址(链接网址也可以用尖括号包起来)&lt;/li&gt;
&lt;li&gt;选择性地接着 title 内容，可以用单引号、双引号或是括弧包着&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;列表&#34;&gt;列表&lt;/h3&gt;

&lt;h4 id=&#34;普通无序列表&#34;&gt;普通无序列表&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-md&#34;&gt;- 无序列表，文本前使用[减号+空格]
+ 无序列表，文本前使用[加号+空格]
* 无序列表，文本前使用[星号+空格]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;普通有序列表&#34;&gt;普通有序列表&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;列表前使用[数字+英文句点+空格]&lt;/li&gt;
&lt;li&gt;可以自动添加数字&lt;/li&gt;
&lt;li&gt;数字不对显示的时候回自动调整&lt;/li&gt;
&lt;li&gt;文档开始如果出现‘1986. blabla’要写成‘1986. blabla’&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;5) 列表前使用[数字+)+空格]
6) 可以自动添加数字
7) 数字不对显示的时候回自动调整
8) 文档开始如果出现‘1986. blabla’要写成‘1986. blabla’&lt;/p&gt;

&lt;h4 id=&#34;列表嵌套&#34;&gt;列表嵌套&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;列出所有元素：

&lt;ul&gt;
&lt;li&gt;无序列表元素 A

&lt;ol&gt;
&lt;li&gt;元素 A 的有序子列表&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;前面加 4 个空格或 1 个制表符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;列表里的多段换行：&lt;br /&gt;
前面必须加 4 个空格或 1 个制表符，&lt;br /&gt;
这样换行，整体的格式不会乱&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列表里引用：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;前面空一行&lt;br /&gt;
仍然需要在 &amp;gt; 前面加 4 个空格或 1 个制表符&lt;/p&gt;
&lt;/blockquote&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列表里代码段：&lt;/p&gt;

&lt;p&gt;前面 4 个空格或 1 个制表符，之后按三个`代码语法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;或者直接空 8 个空格或 2 个制表符，
引入代码块
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;表格&#34;&gt;表格&lt;/h3&gt;

&lt;p&gt;默认：左对齐(col1)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;col1&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;col2&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;col3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;col1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;col2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;col3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;col1,col1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;col2,col2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;col3,col3&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;col1,col1,col1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;col2,col2,col2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;col3,col3,col3&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;引用&#34;&gt;引用&lt;/h3&gt;

&lt;h4 id=&#34;普通引用&#34;&gt;普通引用&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;引用前使用[大于号+空格]&lt;br /&gt;
换行可以不加&lt;/p&gt;

&lt;p&gt;空行和新起一行需要加上&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;引用嵌套引用&#34;&gt;引用嵌套引用&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;最外层引用
&amp;gt; 多一个[大于号+空格]嵌套一层引用
&amp;gt; &amp;gt; 可以嵌套很多层&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;引用嵌套列表&#34;&gt;引用嵌套列表&lt;/h4&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;这是引用里嵌套的一个列表&lt;/li&gt;
&lt;li&gt;还可以有子列表

&lt;ul&gt;
&lt;li&gt;子列表需要从[减号、加号、星号]之后延后 4 个空格或 1 个制表符开始&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h4 id=&#34;引用嵌套代码块&#34;&gt;引用嵌套代码块&lt;/h4&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;同样的，在前面加 4 个空格或 1 个制表符形成代码块
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;或者使用三个`形成代码块
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;图片&#34;&gt;图片&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;跟链接的方法区别在于前面加了个感叹号。行内式的图片语法 感叹号+方括号(图片名称)+圆括号(图片链接地址/图片相对路径)：&lt;br /&gt;
&lt;img src=&#34;http://media.52poke.com/wiki/0/0d/025Pikachu.png&#34; alt=&#34;图片名称&#34; title=&#34;皮卡丘__1&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/markdown/natsume.jpg&#34; alt=&#34;penguin__2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/markdown/natsume.jpg&#34; alt=&#34;penguin__2&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;分隔符&#34;&gt;分隔符&lt;/h3&gt;

&lt;p&gt;在新起一行输入三个减号、星号、底线，即可实现分割线。当前后都有段落时，请空出一行。&lt;/p&gt;

&lt;p&gt;段落1&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;段落2&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;段落3&lt;/p&gt;

&lt;h2 id=&#34;高级技巧&#34;&gt;高级技巧&lt;/h2&gt;

&lt;h3 id=&#34;行内-html-元素&#34;&gt;行内 HTML 元素&lt;/h3&gt;

&lt;p&gt;目前只支持段内 HTML 元素效果，包括 kbd/b/i/em/sup/sub/br 等。现不建议使用 HTML 元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;键位显示： 使用 &lt;code&gt;&amp;lt;kbd&amp;gt;Ctrl&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Alt&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Del&amp;lt;/kbd&amp;gt;&lt;/code&gt; 重启电脑&lt;/li&gt;
&lt;li&gt;代码块：使用 pre/code 标签&lt;/li&gt;
&lt;li&gt;粗斜体：&lt;code&gt;&amp;lt;b&amp;gt;粗体&amp;lt;/b&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;符号转义&#34;&gt;符号转义&lt;/h3&gt;

&lt;p&gt;在符号前加反斜杠可以避免被转义。如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\_不想这里的文本变斜体\_  
\*\*不想这里的文本被加粗\*\*
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;

&lt;p&gt;\   反斜线&lt;br /&gt;
`   反引号&lt;br /&gt;
*   星号&lt;br /&gt;
_   底线&lt;br /&gt;
{}  花括号&lt;br /&gt;
[]  方括号&lt;br /&gt;
()  括弧&lt;br /&gt;
#   井字号&lt;br /&gt;
+   加号&lt;br /&gt;
-   减号&lt;br /&gt;
.   英文句点&lt;br /&gt;
!   惊叹号&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;公式&#34;&gt;公式&lt;/h3&gt;

&lt;p&gt;当需要在编辑器中插入数学公式时，可以使用两个美元符包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：&lt;/p&gt;

&lt;p&gt;$$ x = {-b \pm \sqrt{b^2-4ac} \over 2a}. $$&lt;/p&gt;

&lt;p&gt;$$ x \href{why-equal.html}{=} y^2 + 1 $$&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;脚注&#34;&gt;脚注&lt;/h3&gt;

&lt;p&gt;Markdown 官网&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:markdown&#34;&gt;&lt;a href=&#34;#fn:markdown&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&#34;文档规范&#34;&gt;文档规范&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;标题用#，右边的#可不加&lt;/li&gt;
&lt;li&gt;行内代码

&lt;ul&gt;
&lt;li&gt;三个反引号&lt;/li&gt;
&lt;li&gt;制表符&lt;/li&gt;
&lt;li&gt;code 标签&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码段

&lt;ul&gt;
&lt;li&gt;三个反引号&lt;/li&gt;
&lt;li&gt;制表符&lt;/li&gt;
&lt;li&gt;pre/code 标签&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:markdown&#34;&gt;&lt;a href=&#34;https://daringfireball.net/projects/markdown/&#34; target=&#34;_blank&#34;&gt;https://daringfireball.net/projects/markdown/&lt;/a&gt;
 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:markdown&#34;&gt;&lt;sup&gt;^&lt;/sup&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>1 Memcached 简介</title>
      <link>https://xueqing.github.io/blog/database/memcached/1_intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/memcached/1_intro/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e5%89%8d%e8%a8%80&#34;&gt;1.1 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%e7%89%b9%e7%82%b9&#34;&gt;1.2 特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%e6%94%af%e6%8c%81%e7%9a%84%e8%af%ad%e8%a8%80&#34;&gt;1.3 支持的语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-memcached-%e7%94%a8%e6%88%b7&#34;&gt;1.4 Memcached 用户&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-1-前言&#34;&gt;1.1 前言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Memcached 是一个自由开源、高性能、分布式内存对象缓存系统&lt;/li&gt;
&lt;li&gt;基于内存的 key-value 存储，用于存储小块的任意数据(字符串、对象)。这些数据可以是数据库调用、API 调用或页面渲染的结果&lt;/li&gt;
&lt;li&gt;设计简洁：便于快速开发，减轻开发难度，解决了大数据量缓存的问题。API 兼容大部分流行的开发语言&lt;/li&gt;
&lt;li&gt;本质上是一个简洁的 key-value 存储系统&lt;/li&gt;
&lt;li&gt;一般的使用目的：通过缓存数据库查询结果，减少数据库访问次数，以提高动态 web 应用的速度，提高可扩展性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-特点&#34;&gt;1.2 特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;协议简单&lt;/li&gt;
&lt;li&gt;基于 libevent 的事件处理

&lt;ul&gt;
&lt;li&gt;libevent 是一个基于事件触发的网络库&lt;/li&gt;
&lt;li&gt;libevent API 提供一种机制：当一个文件描述符的特定时间发生(可读、可写、出错)，或一个定时时间发生，libevent 自动执行用户指定的回调函数，来处理事件&lt;/li&gt;
&lt;li&gt;libevent 也支持信号或常规超时的回调&lt;/li&gt;
&lt;li&gt;libevent 用于取代网络服务器中的事件循环检查框架&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;内置内存存储方式&lt;/li&gt;
&lt;li&gt;分布式不互相通信&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-3-支持的语言&#34;&gt;1.3 支持的语言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;许多语言实现了连接 Memcached 的客户端，以 Perl、PHP 为主&lt;/li&gt;
&lt;li&gt;其他语言包括：Python/Ruby/C#/C/C++/Lua&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-4-memcached-用户&#34;&gt;1.4 Memcached 用户&lt;/h2&gt;

&lt;p&gt;LiveJournal/Wikipedia/Flickr/Bebo/Twitter/Typepad/Yellowbot/Youtube/WordPress.com/Craigslist/Mixi&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1 Redis 简介</title>
      <link>https://xueqing.github.io/blog/database/redis/1_intro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/redis/1_intro/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-key-value-%e7%bc%93%e5%ad%98%e4%ba%a7%e5%93%81%e7%89%b9%e7%82%b9&#34;&gt;1.1 key-value 缓存产品特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-redis-%e4%bc%98%e7%82%b9&#34;&gt;1.2 Redis 优点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-redis-%e9%85%8d%e7%bd%ae&#34;&gt;1.3 Redis 配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-redis-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;1.4 Redis 数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-redis-%e6%95%b0%e6%8d%ae%e5%ba%93&#34;&gt;1.5 Redis 数据库&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-1-key-value-缓存产品特点&#34;&gt;1.1 key-value 缓存产品特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;支持数据持久化：可将内存数据保存到磁盘，重启的时候再次加载使用&lt;/li&gt;
&lt;li&gt;支持简单的 key-value 类型，也支持 list/set/zset/hash 数据的存储&lt;/li&gt;
&lt;li&gt;支持数据备份：master-slave 模式的数据备份&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-redis-优点&#34;&gt;1.2 Redis 优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;性能极高：读写速度快&lt;/li&gt;
&lt;li&gt;数据类型丰富：支持 string/list/hash/set/zset(sorted set)&lt;/li&gt;
&lt;li&gt;原子性：单个操作是原子性的。多个操作支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来&lt;/li&gt;
&lt;li&gt;特性丰富：支持 publish/subscribe，通知，key 过期等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-3-redis-配置&#34;&gt;1.3 Redis 配置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;配置文件位于安装目录，文件名 &lt;code&gt;redis.conf&lt;/code&gt;(Windows 下是 &lt;code&gt;redis.windows.conf&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;查看配置项 &lt;code&gt;CONFIG GET CONFIG_STRING_NAME&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CONFIG_STRING_NAME&lt;/code&gt; 为 &lt;code&gt;*&lt;/code&gt; 表示获取所有配置项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设置配置项 &lt;code&gt;CONFIG GET CONFIG_STRING_NAME NEW_CONFIG_VALUE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-4-redis-数据类型&#34;&gt;1.4 Redis 数据类型&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;简介&lt;/th&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;key-value&lt;/td&gt;
&lt;td&gt;二进制安全，即 string 可包含任何数据(jpg 对象或序列化的对象等)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;SET key val&lt;/code&gt;/&lt;code&gt;GET key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;hash&lt;/td&gt;
&lt;td&gt;key-value 对集合，即编程中的 Map&lt;/td&gt;
&lt;td&gt;适合存储对象，可像数据库只修改某一属性值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HMSET hash_name key1 val1 [key2 val2...]&lt;/code&gt;/&lt;code&gt;HGET hash_name key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;存储/读取/修改用户属性&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;list&lt;/td&gt;
&lt;td&gt;string 列表(双向链表)，按插入顺序排序，下标从 0 开始&lt;/td&gt;
&lt;td&gt;增删快，可操作某一段元素&lt;/td&gt;
&lt;td&gt;&lt;code&gt;lpush list_key value&lt;/code&gt;/&lt;code&gt;lrange list_key start_index end_index&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;消息队列；最新消息排行等(如朋友圈时间线)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;set&lt;/td&gt;
&lt;td&gt;string 无序集合，不允许 member 重复，hash 表实现&lt;/td&gt;
&lt;td&gt;增删查的复杂度都是 O(1)；为集合提供交并差运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;sadd set_key member&lt;/code&gt;：添加 member 到 set_key 对应的集合，成功返回 1，已存在返回 0，set_key 对应集合不存在返回错误；&lt;code&gt;smembers set_key&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;共同好友；利用唯一性，统计访问网站的所有独立 IP；根据 tag 求交集，大于某阈值可推荐好友&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;zset&lt;/td&gt;
&lt;td&gt;string 集合，member 唯一，score 可重复。score是 double 类型，根据 score 为 member 从小到大排序&lt;/td&gt;
&lt;td&gt;数据插入时已排序&lt;/td&gt;
&lt;td&gt;&lt;code&gt;zadd zset_key score member&lt;/code&gt;/&lt;code&gt;ZEANGEBYSCORE zset_key score1 score2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;排行榜；带权重的消息队列&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;1-5-redis-数据库&#34;&gt;1.5 Redis 数据库&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个 Redis 示例提供了多个字典用于存储数据。客户端可指定存储的字典。每个字典可理解成一个独立的数据库。每个数据库数据隔离不共享&lt;/li&gt;
&lt;li&gt;Redis 不支持自定义数据名字，每个数据库以编号(0 开始)命名。默认支持 16 个数据库，可通过配置文件修改&lt;/li&gt;
&lt;li&gt;客户端连接 Redis 之后，默认选择 0 号数据库，可使用 &lt;code&gt;SELECT db_no&lt;/code&gt; 更换数据库&lt;/li&gt;
&lt;li&gt;局限性

&lt;ul&gt;
&lt;li&gt;开发者需要自己记录每个数据库存储的数据&lt;/li&gt;
&lt;li&gt;不支持为每个数据库单独设置密码。所以所有数据库的权限是绑定的&lt;/li&gt;
&lt;li&gt;多个数据库不是完全隔离，如 &lt;code&gt;FLUSHALL&lt;/code&gt; 可清除一个 Redis 示例所有数据库的数据。所以不建议多个应用程序使用一个 Redis 实例的不同数据库存储数据。且 Redis 是轻量级的，一个空的实例占用内存很小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1 入门</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/1-primer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/1-primer/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e6%95%8f%e6%8d%b7%e4%b8%ad%e7%9a%84%e8%a7%92%e8%89%b2&#34;&gt;1.1 敏捷中的角色&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-scrum-master-%e6%b5%81%e7%a8%8b%e7%ae%a1%e7%90%86%e5%91%98&#34;&gt;1.1.1 Scrum Master 流程管理员&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#112-product-owner-%e4%ba%a7%e5%93%81%e8%b4%9f%e8%b4%a3%e4%ba%ba&#34;&gt;1.1.2 Product Owner 产品负责人&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%e8%b7%a8%e8%81%8c%e8%83%bd%e5%9b%a2%e9%98%9f&#34;&gt;1.2 跨职能团队&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%e6%95%8f%e6%8d%b7%e5%9b%a2%e9%98%9f%e5%a6%82%e4%bd%95%e8%ae%a1%e5%88%92%e5%b7%a5%e4%bd%9c&#34;&gt;1.3 敏捷团队如何计划工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b-user-story&#34;&gt;1.4 用户故事 user story&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#141-%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b%e5%92%8c%e4%bb%bb%e5%8a%a1%e7%9a%84%e5%85%b3%e7%b3%bb&#34;&gt;1.4.1 用户故事和任务的关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-%e6%95%85%e4%ba%8b%e4%bd%95%e6%97%b6%e5%ae%8c%e6%88%90&#34;&gt;1.5 故事何时完成&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#151-%e9%aa%8c%e6%94%b6%e6%a0%87%e5%87%86acceptance-criteria&#34;&gt;1.5.1 验收标准(acceptance criteria)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#152-%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e9%9c%80%e6%b1%82&#34;&gt;1.5.2 如何定义需求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-1-敏捷中的角色&#34;&gt;1.1 敏捷中的角色&lt;/h2&gt;

&lt;h3 id=&#34;1-1-1-scrum-master-流程管理员&#34;&gt;1.1.1 Scrum Master 流程管理员&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;流程管理员是团队领导，帮助团队成员实现敏捷计划。责任包括

&lt;ul&gt;
&lt;li&gt;保证所有角色和机能之间的紧密合作&lt;/li&gt;
&lt;li&gt;移除阻碍&lt;/li&gt;
&lt;li&gt;保护团队免受打扰&lt;/li&gt;
&lt;li&gt;和组织一起跟踪公司的进度和流程&lt;/li&gt;
&lt;li&gt;保证敏捷的检查与调整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-1-2-product-owner-产品负责人&#34;&gt;1.1.2 Product Owner 产品负责人&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从业务角度推动产品。责任包括

&lt;ul&gt;
&lt;li&gt;定义需求，评估需求的优先级&lt;/li&gt;
&lt;li&gt;确定发布的实际和内容&lt;/li&gt;
&lt;li&gt;在迭代计划和发布计划会议中承担积极的角色&lt;/li&gt;
&lt;li&gt;确保团队致力于最有价值的需求&lt;/li&gt;
&lt;li&gt;接受满足完成标准和定义好的验收标准(acceptance criteria)用户故事(user story)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-跨职能团队&#34;&gt;1.2 跨职能团队&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个敏捷团队应当是一个自满足的团队，成员是 5-9 人，平均经验是 6-10 年&lt;/li&gt;
&lt;li&gt;典型的敏捷团队包括 3-4 位开发者，1 位测试，1 位技术领导， 1 位产品负责人和 1 位流程管理员

&lt;ul&gt;
&lt;li&gt;产品负责人和流程管理员作为团队接口，其他成员是技术接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-3-敏捷团队如何计划工作&#34;&gt;1.3 敏捷团队如何计划工作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;迭代实现用户故事，每个迭代周期是 10-15 天&lt;/li&gt;
&lt;li&gt;point 点：定义一个团队可以提交完成。一般是 8 个小时。每个故事用点评估&lt;/li&gt;
&lt;li&gt;capacity 能力：定义一个人可以提交完成。用小时评估&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-4-用户故事-user-story&#34;&gt;1.4 用户故事 user story&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个用户故事是一个需求，定义用户所需作为功能

&lt;ul&gt;
&lt;li&gt;在发布计划中，使用相对范围的点数粗略的评估一个用户故事&lt;/li&gt;
&lt;li&gt;在迭代计划中，将用户故事分解成任务(task)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-4-1-用户故事和任务的关系&#34;&gt;1.4.1 用户故事和任务的关系&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用户故事描述要完成什么，定义了用户所需；任务描述如何完成它，定义了要实现的功能&lt;/li&gt;
&lt;li&gt;故事是通过任务实现，每个故事是任务的一个集合&lt;/li&gt;
&lt;li&gt;当把用户固执放在当前迭代计划时，用户故事被分解成任务&lt;/li&gt;
&lt;li&gt;任务用小时评估，一般是 2-12 个小时&lt;/li&gt;
&lt;li&gt;故事通过验收测试进行验证&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-5-故事何时完成&#34;&gt;1.5 故事何时完成&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;团队定义完成的含义。标准可能是

&lt;ul&gt;
&lt;li&gt;所有的任务(开发和测试)被完成&lt;/li&gt;
&lt;li&gt;所有的验收测试在运行并通过&lt;/li&gt;
&lt;li&gt;没有开放的缺陷(defect)&lt;/li&gt;
&lt;li&gt;产品负责人已经接受了故事&lt;/li&gt;
&lt;li&gt;可交付给终端用户&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-5-1-验收标准-acceptance-criteria&#34;&gt;1.5.1  验收标准(acceptance criteria)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;标准定义一个特性需要的功能、行为和性能，以便产品负责人可以接受&lt;/li&gt;
&lt;li&gt;它定义了要完成什么以便开发者知道一个用户故事何时完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-5-2-如何定义需求&#34;&gt;1.5.2 如何定义需求&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;需求可以定义为

&lt;ul&gt;
&lt;li&gt;一个用户故事&lt;/li&gt;
&lt;li&gt;包含验收标准&lt;/li&gt;
&lt;li&gt;包含完成这个故事的任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1 安装</title>
      <link>https://xueqing.github.io/blog/django_cms/tutorial/1_install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/django_cms/tutorial/1_install/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e7%8e%af%e5%a2%83%e8%a6%81%e6%b1%82&#34;&gt;1.1 环境要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%e9%85%8d%e7%bd%ae-python-%e7%8e%af%e5%a2%83&#34;&gt;1.2 配置 Python 环境&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121-%e9%85%8d%e7%bd%ae-python&#34;&gt;1.2.1 配置 Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#122-%e9%85%8d%e7%bd%ae-pip&#34;&gt;1.2.2 配置 pip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#123-%e9%85%8d%e7%bd%ae-python3-venv&#34;&gt;1.2.3 配置 python3-venv&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%e5%88%9b%e5%bb%ba%e5%92%8c%e6%bf%80%e6%b4%bb%e8%99%9a%e6%8b%9f%e7%8e%af%e5%a2%83&#34;&gt;1.2 创建和激活虚拟环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%e4%bd%bf%e7%94%a8-django-cms-installer&#34;&gt;1.3 使用 django CMS installer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%e5%90%af%e5%8a%a8-runserver&#34;&gt;1.4 启动 runserver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-1-环境要求&#34;&gt;1.1 环境要求&lt;/h2&gt;

&lt;p&gt;django CMS 要求 Django &amp;gt;=1.11，Python 2.7/&amp;gt;=3.3。下面使用 Python3。&lt;/p&gt;

&lt;h2 id=&#34;1-2-配置-python-环境&#34;&gt;1.2 配置 Python 环境&lt;/h2&gt;

&lt;h3 id=&#34;1-2-1-配置-python&#34;&gt;1.2.1 配置 Python&lt;/h3&gt;

&lt;p&gt;本地环境是 ubuntu 16.04。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看本地的 Python 版本
python
# python      python2     python2.7   python3     python3.5   python3.5m  python3m
# 配置 python2.7 和 python3
sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 100
# update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 2
# 配置使用 python3，选择 2，即 /usr/bin/python3
sudo update-alternatives --config python
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-2-配置-pip&#34;&gt;1.2.2 配置 pip&lt;/h3&gt;

&lt;p&gt;pip 是 Python 包管理工具。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install python-pip python3-pip
# 可能会有 warning: not replacing /usr/bin/pip with a link 错误， ll /usr/bin/pip* 查看可知道 /usr/bin/pip 不是一个软链接，可以删除 /usr/bin/pip，再重新执行 --install 命令
sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip2 100
sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 2
# 配置使用 pip3，选择 2，即 /usr/bin/pip3
sudo update-alternatives --config pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-3-配置-python3-venv&#34;&gt;1.2.3 配置 python3-venv&lt;/h3&gt;

&lt;p&gt;在 Debian/Ubuntu系统，需要使用 &lt;code&gt;apt-get install python3-venv&lt;/code&gt; 命令安装 python3-venv 包。&lt;/p&gt;

&lt;h2 id=&#34;1-2-创建和激活虚拟环境&#34;&gt;1.2 创建和激活虚拟环境&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建虚拟环境，遇到 The virtual environment was not created successfully because ensurepip is not availabl ... 错误，参考上述教程安装 python3-venv
python -m venv env
# 激活虚拟环境
source env/bin/activate
# 升级虚拟环境的 pip
pip install --upgrade pip
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;1-3-使用-django-cms-installer&#34;&gt;1.3 使用 django CMS installer&lt;/h2&gt;

&lt;p&gt;django CMS installer 是一个帮助设置一个新项目的脚本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 安装 django CMS installer，安装之后可使用 djangocms 命令
(env) kiki@ubuntu:~$ pip install djangocms-installer
# 新建目录并切换到该目录
(env) kiki@ubuntu:~$ mkdir mydjango &amp;amp;&amp;amp; cd mydjango
# 新建一个 django 项目
(env) kiki@ubuntu:~/mydjango$ djangocms -f -p . mysite
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于 &lt;code&gt;djangocms -f -p . mysite&lt;/code&gt; 命令：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;djangocms&lt;/code&gt; 表示运行 django CMS installer&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f&lt;/code&gt; 表示安装 django Filer，是用于 django 的一个文件管理应用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p .&lt;/code&gt; 表示使用当前目录作为新项目目录的父目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mysite&lt;/code&gt; 指定新项目目录的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;installer 会创建一个管理员用户，用户名/密码 是 &lt;code&gt;admin&lt;/code&gt;/&lt;code&gt;admin&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;1-4-启动-runserver&#34;&gt;1.4 启动 runserver&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;(env) kiki@ubuntu:~/mydjango$ python manage.py runserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在浏览器打开 &lt;code&gt;http://localhost:8000/&lt;/code&gt; 或 &lt;code&gt;http://127.0.0.1:8000/&lt;/code&gt;，可以看到登录页面，然后可以新建页面。&lt;/p&gt;

&lt;p&gt;当需要登录时，在 URL 后面添加 &lt;code&gt;?edit&lt;/code&gt;，会启动工具栏，可以输入用户名和密码重新登录并管理网站。&lt;/p&gt;

&lt;p&gt;当前的 Django 版本是 1.11.25，django CMS 版本是 3.6.0。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2 Redis 命令</title>
      <link>https://xueqing.github.io/blog/database/redis/2_command/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/redis/2_command/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e5%91%bd%e4%bb%a4&#34;&gt;2.1 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%e9%94%ae%e5%91%bd%e4%bb%a4&#34;&gt;2.2 键命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%91%bd%e4%bb%a4&#34;&gt;2.3 字符串命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%e5%93%88%e5%b8%8c%e5%91%bd%e4%bb%a4&#34;&gt;2.4 哈希命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25-%e5%88%97%e8%a1%a8%e5%91%bd%e4%bb%a4&#34;&gt;2.5 列表命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26-%e9%9b%86%e5%90%88%e5%91%bd%e4%bb%a4&#34;&gt;2.6 集合命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27-%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88%e5%91%bd%e4%bb%a4&#34;&gt;2.7 有序集合命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28-redis-hyperloglog-%e5%91%bd%e4%bb%a4&#34;&gt;2.8 Redis HyperLogLog 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29-redis-%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%e5%91%bd%e4%bb%a4&#34;&gt;2.9 Redis 发布订阅命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#210-redis-%e4%ba%8b%e5%8a%a1%e5%91%bd%e4%bb%a4&#34;&gt;2.10 Redis 事务命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#211-redis-%e8%84%9a%e6%9c%ac%e5%91%bd%e4%bb%a4&#34;&gt;2.11 Redis 脚本命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#212-redis-%e8%bf%9e%e6%8e%a5%e5%91%bd%e4%bb%a4&#34;&gt;2.12 Redis 连接命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#213-redis-%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%91%bd%e4%bb%a4&#34;&gt;2.13 Redis 服务器命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-1-命令&#34;&gt;2.1 命令&lt;/h2&gt;

&lt;p&gt;通过 Redis 客户端再 Redis 服务上执行 Redis 命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 启动客户端，连接本地 redis 服务
redis-cli
# 检查 redis 服务是否启动
PING
# 连接远程 redis 服务
redis-cli -h host -p port -a password
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;避免中文乱码 &lt;code&gt;redis-cli --raw&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-键命令&#34;&gt;2.2 键命令&lt;/h2&gt;

&lt;p&gt;用于管理 redis 的 key：&lt;code&gt;COMMAND key_name&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DEL key&lt;/td&gt;
&lt;td&gt;key 存在时删除 key&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DUMP key&lt;/td&gt;
&lt;td&gt;序列化 key，返回被序列化的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EXISTS key&lt;/td&gt;
&lt;td&gt;检查 key 是否存在&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EXPIRE key seconds&lt;/td&gt;
&lt;td&gt;为给定 key 设置过期时间，以秒计&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EXPIREAT key timestamp&lt;/td&gt;
&lt;td&gt;EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PEXPIRE key milliseconds&lt;/td&gt;
&lt;td&gt;设置 key 的过期时间以毫秒计&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PEXPIREAT key milliseconds-timestamp&lt;/td&gt;
&lt;td&gt;设置 key 过期时间的时间戳(unix timestamp) 以毫秒计&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;KEYS pattern&lt;/td&gt;
&lt;td&gt;查找所有符合给定模式(pattern)的 key&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MOVE key db&lt;/td&gt;
&lt;td&gt;将当前数据库的 key 移动到给定的数据库 db 当中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PERSIST key&lt;/td&gt;
&lt;td&gt;移除 key 的过期时间，key 将持久保持&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PTTL key&lt;/td&gt;
&lt;td&gt;以毫秒为单位返回 key 的剩余的过期时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TTL key&lt;/td&gt;
&lt;td&gt;以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RANDOMKEY&lt;/td&gt;
&lt;td&gt;从当前数据库中随机返回一个 key&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RENAME key newkey&lt;/td&gt;
&lt;td&gt;修改 key 的名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RENAMENX key newkey&lt;/td&gt;
&lt;td&gt;仅当 newkey 不存在时，将 key 改名为 newkey&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TYPE key&lt;/td&gt;
&lt;td&gt;返回 key 所储存的值的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-3-字符串命令&#34;&gt;2.3 字符串命令&lt;/h2&gt;

&lt;p&gt;用于管理字符串值：&lt;code&gt;COMMAND key_name&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SET key value&lt;/td&gt;
&lt;td&gt;设置 key 的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GET key&lt;/td&gt;
&lt;td&gt;获取 key 的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GETRANGE key start end&lt;/td&gt;
&lt;td&gt;返回 key 中字符串值的子字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GETSET key value&lt;/td&gt;
&lt;td&gt;将 key 的值设为 value ，并返回 key 的旧值(old value)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;GETBIT key offset&lt;/td&gt;
&lt;td&gt;对 key 所储存的字符串值，获取指定偏移量上的位(bit)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MGET key1 [key2..]&lt;/td&gt;
&lt;td&gt;获取所有(一个或多个)给定 key 的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SETBIT key offset value&lt;/td&gt;
&lt;td&gt;对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SETEX key seconds value&lt;/td&gt;
&lt;td&gt;将值 value 关联到 key ，并将 key 的过期时间设为 seconds (秒)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SETNX key value&lt;/td&gt;
&lt;td&gt;只有在 key 不存在时设置 key 的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SETRANGE key offset value&lt;/td&gt;
&lt;td&gt;用 value 覆写给定 key 所储存的字符串值，从偏移量 offset 开始&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;STRLEN key&lt;/td&gt;
&lt;td&gt;返回 key 所储存的字符串值的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MSET key value [key value &amp;hellip;]&lt;/td&gt;
&lt;td&gt;同时设置一个或多个 key-value 对&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MSETNX key value [key value &amp;hellip;]&lt;/td&gt;
&lt;td&gt;同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PSETEX key milliseconds value&lt;/td&gt;
&lt;td&gt;和 SETEX 命令相似，以毫秒为单位设置 key 的生存时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;INCR key&lt;/td&gt;
&lt;td&gt;将 key 中储存的数字值增一&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;INCRBY key increment&lt;/td&gt;
&lt;td&gt;将 key 所储存的值加上给定的增量值(increment)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;INCRBYFLOAT key increment&lt;/td&gt;
&lt;td&gt;将 key 所储存的值加上给定的浮点增量值(increment)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DECR key&lt;/td&gt;
&lt;td&gt;将 key 中储存的数字值减 1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DECRBY key decrement&lt;/td&gt;
&lt;td&gt;key 所储存的值减去给定的减量值(decrement)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;APPEND key value&lt;/td&gt;
&lt;td&gt;如果 key 已经存在并且是一个字符串， 将 value 追加到该 key 原来值的末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-4-哈希命令&#34;&gt;2.4 哈希命令&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HDEL key field1 [field2]&lt;/td&gt;
&lt;td&gt;删除一个或多个哈希表字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HEXISTS key field&lt;/td&gt;
&lt;td&gt;查看哈希表 key 中，指定的字段是否存在&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HGET key field&lt;/td&gt;
&lt;td&gt;获取存储在哈希表中指定字段的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HGETALL key&lt;/td&gt;
&lt;td&gt;获取在哈希表中指定 key 的所有字段和值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HINCRBY key field increment&lt;/td&gt;
&lt;td&gt;为哈希表 key 中的指定字段的整数值加上增量 increment&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HINCRBYFLOAT key field increment&lt;/td&gt;
&lt;td&gt;为哈希表 key 中的指定字段的浮点数值加上增量 increment&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HKEYS key&lt;/td&gt;
&lt;td&gt;获取所有哈希表中的字段&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HLEN key&lt;/td&gt;
&lt;td&gt;获取哈希表中字段的数量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HMGET key field1 [field2]&lt;/td&gt;
&lt;td&gt;获取所有给定字段的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HMSET key field1 value1 [field2 value2 ]&lt;/td&gt;
&lt;td&gt;同时将多个 field-value (域-值)对设置到哈希表 key 中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HSET key field value&lt;/td&gt;
&lt;td&gt;将哈希表 key 中的字段 field 的值设为 value&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HSETNX key field value&lt;/td&gt;
&lt;td&gt;只有在字段 field 不存在时，设置哈希表字段的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HVALS key&lt;/td&gt;
&lt;td&gt;获取哈希表中所有值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;HSCAN key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;迭代哈希表中的键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-5-列表命令&#34;&gt;2.5 列表命令&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BLPOP key1 [key2 ] timeout&lt;/td&gt;
&lt;td&gt;移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BRPOP key1 [key2 ] timeout&lt;/td&gt;
&lt;td&gt;移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BRPOPLPUSH source destination timeout&lt;/td&gt;
&lt;td&gt;从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LINDEX key index&lt;/td&gt;
&lt;td&gt;通过索引获取列表中的元&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LINSERT key BEFORE&lt;/td&gt;
&lt;td&gt;AFTER pivot value&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LLEN key&lt;/td&gt;
&lt;td&gt;获取列表长&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LPOP key&lt;/td&gt;
&lt;td&gt;移出并获取列表的第一个元&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LPUSH key value1 [value2]&lt;/td&gt;
&lt;td&gt;将一个或多个值插入到列表头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LPUSHX key value&lt;/td&gt;
&lt;td&gt;将一个值插入到已存在的列表头&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LRANGE key start stop&lt;/td&gt;
&lt;td&gt;获取列表指定范围内的元&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LREM key count value&lt;/td&gt;
&lt;td&gt;移除列表元&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LSET key index value&lt;/td&gt;
&lt;td&gt;通过索引设置列表元素的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LTRIM key start stop&lt;/td&gt;
&lt;td&gt;对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RPOP key&lt;/td&gt;
&lt;td&gt;移除列表的最后一个元素，返回值为移除的元素&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RPOPLPUSH source destination&lt;/td&gt;
&lt;td&gt;移除列表的最后一个元素，并将该元素添加到另一个列表并返&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RPUSH key value1 [value2]&lt;/td&gt;
&lt;td&gt;在列表中添加一个或多个&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RPUSHX key value&lt;/td&gt;
&lt;td&gt;为已存在的列表添加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-6-集合命令&#34;&gt;2.6 集合命令&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SADD key member1 [member2]&lt;/td&gt;
&lt;td&gt;向集合添加一个或多个成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SCARD key&lt;/td&gt;
&lt;td&gt;获取集合的成员数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SDIFF key1 [key2]&lt;/td&gt;
&lt;td&gt;返回给定所有集合的差集&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SDIFFSTORE destination key1 [key2]&lt;/td&gt;
&lt;td&gt;返回给定所有集合的差集并存储在 destination 中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SINTER key1 [key2]&lt;/td&gt;
&lt;td&gt;返回给定所有集合的交集&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SINTERSTORE destination key1 [key2]&lt;/td&gt;
&lt;td&gt;返回给定所有集合的交集并存储在 destination 中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SISMEMBER key member&lt;/td&gt;
&lt;td&gt;判断 member 元素是否是集合 key 的成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SMEMBERS key&lt;/td&gt;
&lt;td&gt;返回集合中的所有成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SMOVE source destination member&lt;/td&gt;
&lt;td&gt;将 member 元素从 source 集合移动到 destination 集合&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SPOP key&lt;/td&gt;
&lt;td&gt;移除并返回集合中的一个随机元素&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SRANDMEMBER key [count]&lt;/td&gt;
&lt;td&gt;返回集合中一个或多个随机数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SREM key member1 [member2]&lt;/td&gt;
&lt;td&gt;移除集合中一个或多个成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SUNION key1 [key2]&lt;/td&gt;
&lt;td&gt;返回所有给定集合的并集&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SUNIONSTORE destination key1 [key2]&lt;/td&gt;
&lt;td&gt;所有给定集合的并集存储在 destination 集合中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SSCAN key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;迭代集合中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-7-有序集合命令&#34;&gt;2.7 有序集合命令&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ZADD key score1 member1 [score2 member2]&lt;/td&gt;
&lt;td&gt;向有序集合添加一个或多个成员，或者更新已存在成员的分数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZCARD key&lt;/td&gt;
&lt;td&gt;获取有序集合的成员数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZCOUNT key min max&lt;/td&gt;
&lt;td&gt;计算在有序集合中指定区间分数的成员数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZINCRBY key increment member&lt;/td&gt;
&lt;td&gt;有序集合中对指定成员的分数加上增量 increment&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZINTERSTORE destination numkeys key [key &amp;hellip;]&lt;/td&gt;
&lt;td&gt;计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZLEXCOUNT key min max&lt;/td&gt;
&lt;td&gt;在有序集合中计算指定字典区间内成员数量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZRANGE key start stop [WITHSCORES]&lt;/td&gt;
&lt;td&gt;通过索引区间返回有序集合成指定区间内的成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZRANGEBYLEX key min max [LIMIT offset count]&lt;/td&gt;
&lt;td&gt;通过字典区间返回有序集合的成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]&lt;/td&gt;
&lt;td&gt;通过分数返回有序集合指定区间内的成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZRANK key member&lt;/td&gt;
&lt;td&gt;返回有序集合中指定成员的索引&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZREM key member [member &amp;hellip;]&lt;/td&gt;
&lt;td&gt;移除有序集合中的一个或多个成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZREMRANGEBYLEX key min max&lt;/td&gt;
&lt;td&gt;移除有序集合中给定的字典区间的所有成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZREMRANGEBYRANK key start stop&lt;/td&gt;
&lt;td&gt;移除有序集合中给定的排名区间的所有成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZREMRANGEBYSCORE key min max&lt;/td&gt;
&lt;td&gt;移除有序集合中给定的分数区间的所有成员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZREVRANGE key start stop [WITHSCORES]&lt;/td&gt;
&lt;td&gt;返回有序集中指定区间内的成员，通过索引，分数从高到底&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZREVRANGEBYSCORE key max min [WITHSCORES]&lt;/td&gt;
&lt;td&gt;返回有序集中指定分数区间内的成员，分数从高到低排序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZREVRANK key member&lt;/td&gt;
&lt;td&gt;返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZSCORE key member&lt;/td&gt;
&lt;td&gt;返回有序集中，成员的分数值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZUNIONSTORE destination numkeys key [key &amp;hellip;]&lt;/td&gt;
&lt;td&gt;计算给定的一个或多个有序集的并集，并存储在新的 key 中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ZSCAN key cursor [MATCH pattern] [COUNT count]&lt;/td&gt;
&lt;td&gt;迭代有序集合中的元素(包括元素成员和元素分值)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
&lt;p&gt;集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)其实不太准确&lt;/p&gt;

&lt;p&gt;在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;添加和删除都需要修改skiplist，所以复杂度为O(log(n))。但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1)。
其他的range操作复杂度一般为O(log(n))。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;2-8-redis-hyperloglog-命令&#34;&gt;2.8 Redis HyperLogLog 命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 2.8.9 版本添加 HyperLogLog 结构，用于做基数统计&lt;/li&gt;
&lt;li&gt;优点：输入元素的数量或提交非常大时，计算基数所需空间小且固定&lt;/li&gt;
&lt;li&gt;原因：HyperLogLog 只根据输入元素计算基数，不会存储元素本身。所以也不能返回输入的各个元素&lt;/li&gt;
&lt;li&gt;基数估计：在误差可接受范围内，快速计算基数&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PFADD key element [element &amp;hellip;]&lt;/td&gt;
&lt;td&gt;添加指定元素到 HyperLogLog 中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PFCOUNT key [key &amp;hellip;]&lt;/td&gt;
&lt;td&gt;返回给定 HyperLogLog 的基数估算值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PFMERGE destkey sourcekey [sourcekey &amp;hellip;]&lt;/td&gt;
&lt;td&gt;将多个 HyperLogLog 合并为一个 HyperLogLog&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-9-redis-发布订阅命令&#34;&gt;2.9 Redis 发布订阅命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者发送消息，订阅者接收消息

&lt;ul&gt;
&lt;li&gt;Redis 客户端可以订阅任意数量的频道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;PSUBSCRIBE pattern [pattern &amp;hellip;]&lt;/td&gt;
&lt;td&gt;订阅一个或多个符合给定模式的频道&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PUBSUB subcommand [argument [argument &amp;hellip;]]&lt;/td&gt;
&lt;td&gt;查看订阅与发布系统状态&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PUBLISH channel message&lt;/td&gt;
&lt;td&gt;将信息发送到指定的频道&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PUNSUBSCRIBE [pattern [pattern &amp;hellip;]]&lt;/td&gt;
&lt;td&gt;退订所有给定模式的频道&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SUBSCRIBE channel [channel &amp;hellip;]&lt;/td&gt;
&lt;td&gt;订阅给定的一个或多个频道的信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNSUBSCRIBE [channel [channel &amp;hellip;]]&lt;/td&gt;
&lt;td&gt;退订给定的频道&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-10-redis-事务命令&#34;&gt;2.10 Redis 事务命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 事务可一次执行多个命令，且保证

&lt;ul&gt;
&lt;li&gt;批量操作在发送 EXEC 命令前被放入缓存队列&lt;/li&gt;
&lt;li&gt;收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余命令仍旧执行&lt;/li&gt;
&lt;li&gt;事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一个事务从开始到执行有三个阶段：开始事务、命令入列、执行事务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：单个 Redis 命令的执行是原子性的。但 Redis 未在事务上增加维护原子性的机制，所以 Redis 事务的执行不是原子性的

&lt;ul&gt;
&lt;li&gt;事务可理解为一个打包的批量执行脚本，但批量指令不是原子化的，中间指令的失败不会回滚前面已做指令，也不会停止执行后续指令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事务的原子性是指：事务要么完整的被执行，要么完全不执行&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DISCARD&lt;/td&gt;
&lt;td&gt;取消事务，放弃执行事务块内的所有命令&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EXEC&lt;/td&gt;
&lt;td&gt;执行所有事务块内的命令&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MULTI&lt;/td&gt;
&lt;td&gt;标记一个事务块的开始&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;UNWATCH&lt;/td&gt;
&lt;td&gt;取消 WATCH 命令对所有 key 的监视&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;WATCH key [key &amp;hellip;]&lt;/td&gt;
&lt;td&gt;监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-11-redis-脚本命令&#34;&gt;2.11 Redis 脚本命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 脚本使用 Lua 解释器执行脚本。Redis 2.6 内嵌支持 Lua 环境&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;EVAL script numkeys key [key &amp;hellip;] arg [arg &amp;hellip;]&lt;/td&gt;
&lt;td&gt;执行 Lua 脚本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;EVALSHA sha1 numkeys key [key &amp;hellip;] arg [arg &amp;hellip;]&lt;/td&gt;
&lt;td&gt;执行 Lua 脚本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SCRIPT EXISTS script [script &amp;hellip;]&lt;/td&gt;
&lt;td&gt;查看指定的脚本是否已经被保存在缓存当中&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SCRIPT FLUSH&lt;/td&gt;
&lt;td&gt;从脚本缓存中移除所有脚本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SCRIPT KILL&lt;/td&gt;
&lt;td&gt;杀死当前正在运行的 Lua 脚本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SCRIPT LOAD script&lt;/td&gt;
&lt;td&gt;将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-12-redis-连接命令&#34;&gt;2.12 Redis 连接命令&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;AUTH password&lt;/td&gt;
&lt;td&gt;验证密码是否正确&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ECHO message&lt;/td&gt;
&lt;td&gt;打印字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;PING&lt;/td&gt;
&lt;td&gt;查看服务是否运行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;QUIT&lt;/td&gt;
&lt;td&gt;关闭当前连接&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SELECT index&lt;/td&gt;
&lt;td&gt;切换到指定的数据库&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;2-13-redis-服务器命令&#34;&gt;2.13 Redis 服务器命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;INFO&lt;/code&gt; 命令获取 Redis 服务器的统计信息&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BGREWRITEAOF&lt;/td&gt;
&lt;td&gt;异步执行一个 AOF(AppendOnly File) 文件重写操作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BGSAVE&lt;/td&gt;
&lt;td&gt;在后台异步保存当前数据库的数据到磁盘&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT KILL [ip:port] [ID client-id]&lt;/td&gt;
&lt;td&gt;关闭客户端连接&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT LIST&lt;/td&gt;
&lt;td&gt;获取连接到服务器的客户端连接列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT GETNAME&lt;/td&gt;
&lt;td&gt;获取连接的名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT PAUSE timeout&lt;/td&gt;
&lt;td&gt;在指定时间内终止运行来自客户端的命令&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT SETNAME connection-name&lt;/td&gt;
&lt;td&gt;设置当前连接的名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLUSTER SLOTS&lt;/td&gt;
&lt;td&gt;获取集群节点的映射数组&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;COMMAND&lt;/td&gt;
&lt;td&gt;获取 Redis 命令详情数组&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;COMMAND COUNT&lt;/td&gt;
&lt;td&gt;获取 Redis 命令总数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;COMMAND GETKEYS&lt;/td&gt;
&lt;td&gt;获取给定命令的所有键&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;TIME&lt;/td&gt;
&lt;td&gt;返回当前服务器时间&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;COMMAND INFO command-name [command-name &amp;hellip;]&lt;/td&gt;
&lt;td&gt;获取指定 Redis 命令描述的数组&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CONFIG GET parameter&lt;/td&gt;
&lt;td&gt;获取指定配置参数的值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CONFIG REWRITE&lt;/td&gt;
&lt;td&gt;对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CONFIG SET parameter value&lt;/td&gt;
&lt;td&gt;修改 redis 配置参数，无需重启&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CONFIG RESETSTAT&lt;/td&gt;
&lt;td&gt;重置 INFO 命令中的某些统计数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DBSIZE&lt;/td&gt;
&lt;td&gt;返回当前数据库的 key 的数量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DEBUG OBJECT key&lt;/td&gt;
&lt;td&gt;获取 key 的调试信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DEBUG SEGFAULT&lt;/td&gt;
&lt;td&gt;让 Redis 服务崩溃&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FLUSHALL&lt;/td&gt;
&lt;td&gt;删除所有数据库的所有key&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;FLUSHDB&lt;/td&gt;
&lt;td&gt;删除当前数据库的所有key&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;INFO [section]&lt;/td&gt;
&lt;td&gt;获取 Redis 服务器的各种信息和统计数值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;LASTSAVE&lt;/td&gt;
&lt;td&gt;返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;MONITOR&lt;/td&gt;
&lt;td&gt;实时打印出 Redis 服务器接收到的命令，调试用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ROLE&lt;/td&gt;
&lt;td&gt;返回主从实例所属的角色&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SAVE&lt;/td&gt;
&lt;td&gt;同步保存数据到硬盘&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SHUTDOWN [NOSAVE] [SAVE]&lt;/td&gt;
&lt;td&gt;异步保存数据到硬盘，并关闭服务器&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SLAVEOF host port&lt;/td&gt;
&lt;td&gt;将当前服务器转变为指定服务器的从属服务器(slave server)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SLOWLOG subcommand [argument]&lt;/td&gt;
&lt;td&gt;管理 redis 的慢日志&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SYNC&lt;/td&gt;
&lt;td&gt;用于复制功能(replication)的内部命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>2 宣言</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/2-manifesto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/2-manifesto/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e4%bb%b7%e5%80%bc%e8%a7%82&#34;&gt;2.1 软件开发价值观&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%e6%95%8f%e6%8d%b7%e5%ae%a3%e8%a8%80%e7%9a%84-12-%e4%b8%aa%e5%8e%9f%e5%88%99&#34;&gt;2.2 敏捷宣言的 12 个原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-1-软件开发价值观&#34;&gt;2.1 软件开发价值观&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;个体和互动：高于流程和工具&lt;/li&gt;
&lt;li&gt;可工作的软件：高于详尽的文档&lt;/li&gt;
&lt;li&gt;客户合作：高于合同谈判&lt;/li&gt;
&lt;li&gt;响应变化：高于遵循计划&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-敏捷宣言的-12-个原则&#34;&gt;2.2 敏捷宣言的 12 个原则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;满足客户需求：最重要的是通过尽早和不断交付有价值的软件满足客户需求&lt;/li&gt;
&lt;li&gt;欢迎变化：软件开发过程中变化不可避免。应该欢迎需求的变化，即使在开发后期。敏捷过程应保持客户的竞争优势&lt;/li&gt;
&lt;li&gt;交付可工作软件：经常交付可以工作的软件，从几周到几个月，时间尺度越短越好&lt;/li&gt;
&lt;li&gt;合作：业务人员和开发者在整个项目过程中必须在一起工作&lt;/li&gt;
&lt;li&gt;动力：应该围绕斗志高昂的人进行软件开发。给开发者提供环境，相信他们一边使他们感觉对完成工作负责&lt;/li&gt;
&lt;li&gt;面对面对话：面对面对话是在开发小组中最有效率也最有效果的信息传达方式&lt;/li&gt;
&lt;li&gt;按照可工作的软件度量进度：可工作的软件是关键，它应当是进度的主要度量标准&lt;/li&gt;
&lt;li&gt;维持不变的节奏：敏捷过程提倡可持续开发。业务、开发人员和用户应能维持项目不变的节奏&lt;/li&gt;
&lt;li&gt;监察：定期关注技术的完美型和好的设计来提高敏捷性&lt;/li&gt;
&lt;li&gt;简单性：保持事情简单，使用简单的术语来度量未完成的工作&lt;/li&gt;
&lt;li&gt;自我组织的团队：一个敏捷团队应该是自我组织的，不应严重依赖其他团队，因为最好的架构、需求和设计源自自我组织的团队&lt;/li&gt;
&lt;li&gt;定期评审工作：每隔一段时间评审工作，以便团队可以离开如何变得更有效率，并相应地调整自己的行为&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2 模板和占位符</title>
      <link>https://xueqing.github.io/blog/django_cms/tutorial/2_template_palceholder/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/django_cms/tutorial/2_template_palceholder/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e6%a8%a1%e6%9d%bf&#34;&gt;2.1 模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%e5%8d%a0%e4%bd%8d%e7%ac%a6&#34;&gt;2.2 占位符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%e9%9d%99%e6%80%81%e5%8d%a0%e4%bd%8d%e7%ac%a6&#34;&gt;2.3 静态占位符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%e6%b8%b2%e6%9f%93%e8%8f%9c%e5%8d%95&#34;&gt;2.4 渲染菜单&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-1-模板&#34;&gt;2.1 模板&lt;/h2&gt;

&lt;p&gt;可以使用 HTML 模板来定制网站外观、定义占位符标记要管理的内容，以及使用特殊标签生成菜单等。&lt;/p&gt;

&lt;p&gt;可以使用不同的格式或内置组件定义多个模板，然后根据需要为每个页面选择模板。一个页面的模板总是可被其他页面使用。&lt;/p&gt;

&lt;p&gt;网站模板位于 &lt;code&gt;mysite/templates&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;默认的，网站页面使用 &lt;code&gt;fullwidth.html&lt;/code&gt; 模板，即列举在项目 &lt;code&gt;settings.py&lt;/code&gt; 的 &lt;code&gt;CMS_TEMPLATES&lt;/code&gt; 元组的第一个。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html(settings.py)&#34;&gt;CMS_TEMPLATES = (
    ## Customize this
    (&#39;fullwidth.html&#39;, &#39;Fullwidth&#39;),
    (&#39;sidebar_left.html&#39;, &#39;Sidebar Left&#39;),
    (&#39;sidebar_right.html&#39;, &#39;Sidebar Right&#39;)
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-2-占位符&#34;&gt;2.2 占位符&lt;/h2&gt;

&lt;p&gt;占位符定义 HTML 模板的一部分，然后在渲染网页的时候使用数据库的内容填充它。通过使用 django CMS 的前端的编辑机制(使用 Django 的模板标签)编辑网页内容。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fullwidth.html&lt;/code&gt; 包含一个占位符 &lt;code&gt;{% placeholder &amp;quot;content&amp;quot; %}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;fullwidth.html&lt;/code&gt; 还有一个占位符 &lt;code&gt;{% load cms_tags %}&lt;/code&gt;。&lt;code&gt;cms_tags&lt;/code&gt; 是需要的模板标签库。&lt;/p&gt;

&lt;p&gt;可以参考 &lt;a href=&#34;https://docs.djangoproject.com/en/dev/topics/templates/&#34; target=&#34;_blank&#34;&gt;Django 文档&lt;/a&gt; 查看更多关于 Django 的模板标签。&lt;/p&gt;

&lt;p&gt;给 &lt;code&gt;fullwidth.html&lt;/code&gt; 的 &lt;code&gt;{% block content %}&lt;/code&gt; 部分增加一些占位符。比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% block content %}
  {% placeholder &amp;quot;feature&amp;quot; %}
  {% placeholder &amp;quot;content&amp;quot; %}
  {% placeholder &amp;quot;splashbox&amp;quot; %}
{% endblock content %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果切换到结构模式，看以看到新的可用的占位符：&lt;code&gt;Feature&lt;/code&gt; 和 &lt;code&gt;Splashbox&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;2-3-静态占位符&#34;&gt;2.3 静态占位符&lt;/h2&gt;

&lt;p&gt;静态占位符可以在网站的多个位置展示相同的内容。静态占位符大多数行为类似普通占位符，但是当创建一个静态占位符并增加内容，它会在全局保存。即使从一个模板删除这个静态占位符，也可以之后重用。&lt;/p&gt;

&lt;p&gt;比如，增加一个 footer 到所有的页面。因为我们想要 footer 出现在每个页面，应该增加到基础模板(&lt;code&gt;mysite/templates/base.html&lt;/code&gt;)。放置在 HTML &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 元素的末尾：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;        &amp;lt;footer&amp;gt;
            {% static_placeholder &#39;footer&#39; %}
        &amp;lt;/footer&amp;gt;

        {% render_block &amp;quot;js&amp;quot; %}
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存模板文件，返回到浏览器。刷新任一页面，在结构模式可以看到新的静态占位符。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：为了减少界面的凌乱，静态占位符的插件默认会被隐藏。可点击展开。&lt;/p&gt;

&lt;p&gt;如果按照正常方式增加内容到新的占位符，你会看到它出现在网站的其他页面。&lt;/p&gt;

&lt;h2 id=&#34;2-4-渲染菜单&#34;&gt;2.4 渲染菜单&lt;/h2&gt;

&lt;p&gt;使用 &lt;a href=&#34;http://docs.django-cms.org/en/latest/reference/navigation.html&#34; target=&#34;_blank&#34;&gt;show_menu&lt;/a&gt; 渲染模板中的菜单。&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;show_menu&lt;/code&gt; 的模板必须首先加载 CMS 的 &lt;code&gt;menu_tags&lt;/code&gt; 库：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% load menu_tags %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在 &lt;code&gt;mysite/templates/base.html&lt;/code&gt; 使用的菜单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;ul class=&amp;quot;nav&amp;quot;&amp;gt;
    {% show_menu 0 100 100 100 %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个选项控制展示在菜单树的网站层级。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3 Redis 进阶</title>
      <link>https://xueqing.github.io/blog/database/redis/3_advanced/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/redis/3_advanced/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-redis-%e6%95%b0%e6%8d%ae%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d&#34;&gt;3.1 Redis 数据备份与恢复&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-redis-%e5%ae%89%e5%85%a8&#34;&gt;3.2 Redis 安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-redis-%e6%80%a7%e8%83%bd%e6%b5%8b%e8%af%95&#34;&gt;3.3 Redis 性能测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34-redis-%e5%ae%a2%e6%88%b7%e7%ab%af%e5%91%bd%e4%bb%a4&#34;&gt;3.4 Redis 客户端命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#35-redis-%e7%ae%a1%e9%81%93%e6%8a%80%e6%9c%af&#34;&gt;3.5 Redis 管道技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#36-redis-%e5%88%86%e5%8c%ba&#34;&gt;3.6 Redis 分区&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-redis-数据备份与恢复&#34;&gt;3.1 Redis 数据备份与恢复&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SAVE&lt;/td&gt;
&lt;td&gt;创建当前数据库的备份，在 Redis 安装目录创建 dump.rdb 文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CONFIG GET dir&lt;/td&gt;
&lt;td&gt;获取 Redis 安装目录。将备份文件 dump.rdb 移动到安装目录并启动服务即可&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;BGSAVE&lt;/td&gt;
&lt;td&gt;在后台执行命令，创建 Redis 备份文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-2-redis-安全&#34;&gt;3.2 Redis 安全&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过配置文件设置密码，使得客户端连接到 Redis 服务需要密码验证&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CONFIG get requirepass&lt;/td&gt;
&lt;td&gt;查看是否设置了密码验证。默认 requirepass 参数为空，即无需密码&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CONFIG set requirepass password&lt;/td&gt;
&lt;td&gt;设置密码。之后客户端连接 Redis 服务需要密码验证&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;AUTH password&lt;/td&gt;
&lt;td&gt;输入密码验证&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-3-redis-性能测试&#34;&gt;3.3 Redis 性能测试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过同时执行多个命令实现性能测试&lt;/li&gt;
&lt;li&gt;基本命令 &lt;code&gt;redis-benchmark [option] [option value]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;在 Redis 安装目录下执行&lt;/li&gt;
&lt;li&gt;不是 Redis 客户端的内部命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;可选参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;默认值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-h&lt;/td&gt;
&lt;td&gt;指定服务器主机名&lt;/td&gt;
&lt;td&gt;127.0.0.1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-p&lt;/td&gt;
&lt;td&gt;指定服务器端口&lt;/td&gt;
&lt;td&gt;6379&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;指定服务器 socket&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;指定并发连接数&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;指定请求数&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;以字节的形式指定 SET/GET 值的数据大小&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-k&lt;/td&gt;
&lt;td&gt;1=keep alive 0=reconnect&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;SET/GET/INCR 使用随机 key, SADD 使用随机值&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-P&lt;/td&gt;
&lt;td&gt;通过管道传输 numreq 请求&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-q&lt;/td&gt;
&lt;td&gt;强制退出 redis。仅显示 query/sec 值&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;csv&lt;/td&gt;
&lt;td&gt;以 CSV 格式输出&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;生成循环，永久执行测试&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;仅运行以逗号分隔的测试命令列表&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-I&lt;/td&gt;
&lt;td&gt;Idle 模式。仅打开 N 个 idle 连接并等待&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-4-redis-客户端命令&#34;&gt;3.4 Redis 客户端命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 通过监听一个 TCP 端口或 Unix socket 方式接收来自客户端的连接。建立一个连接后，Redis 内部会进行

&lt;ul&gt;
&lt;li&gt;客户端 socket 被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型&lt;/li&gt;
&lt;li&gt;为该 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法&lt;/li&gt;
&lt;li&gt;创建一个可读的文件事件用于监听该客户端 socket 的数据发送&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最大连接数： Redis 2.4 中，最大连接数被硬编码到代码内部。2.6 之后可配置

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CONFIG get maxclients&lt;/code&gt; 查看最大连接数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CONFIG set maxclients 1000&lt;/code&gt; 修改最大连接数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-server --maxclients 10000&lt;/code&gt; 在服务启动时设置最大连接数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CLIENT LIST&lt;/td&gt;
&lt;td&gt;返回连接到 Redis 服务的客户端列表&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT SETNAME&lt;/td&gt;
&lt;td&gt;设置当前连接的名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT GETNAME&lt;/td&gt;
&lt;td&gt;获取通过 CLIENT SETNAME 命令设置的服务名称&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT PAUSE&lt;/td&gt;
&lt;td&gt;挂起客户端连接，指定挂起的时间以毫秒计&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CLIENT KILL&lt;/td&gt;
&lt;td&gt;关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-5-redis-管道技术&#34;&gt;3.5 Redis 管道技术&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 是一种基于客户端-服务端模型以及请求/响应协议的 TCP 服务。一般步骤

&lt;ul&gt;
&lt;li&gt;客户端向服务端发送一个查询请求，并监听 socket 返回。通常以阻塞模式，等待服务端响应&lt;/li&gt;
&lt;li&gt;服务端处理命令，将结果返回给客户端&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Redis 管道技术可在服务端未响应时，客户端可继续向服务端发送请求，并最终一次性读取所有服务端的响应&lt;/li&gt;
&lt;li&gt;管道技术提高了 Redis 服务的性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-6-redis-分区&#34;&gt;3.6 Redis 分区&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;分区是分割数据到多个 Redis 实例的处理过程。每个实例只保存 key 的一个子集&lt;/li&gt;
&lt;li&gt;优势

&lt;ul&gt;
&lt;li&gt;通过利用多台计算机内存的和值，使得可以构造更大的数据库&lt;/li&gt;
&lt;li&gt;通过多核和多台计算机，支持扩展计算能力；通过多台计算机和网络适配器，支持扩展网络带宽&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不足

&lt;ul&gt;
&lt;li&gt;通常不支持涉及多个 key 的操作。如，当两个 set 映射到不同的 Redis 实例上时，不能对两个 set 做交集操作&lt;/li&gt;
&lt;li&gt;不能使用涉及多个 key 的 Redis 事务&lt;/li&gt;
&lt;li&gt;数据处理复杂。如，需要处理多个 rdb/aof 文件，并且从多个实例和主机备份持久化文件&lt;/li&gt;
&lt;li&gt;增删容量复杂。Redis 集群大多支持在运行时增删节点的透明数据平衡能力。类似于客户端分区、代理等其他系统则不支持此特性。可参考 presharding 技术&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分区类型

&lt;ul&gt;
&lt;li&gt;范围分区：映射一定范围的对象到特定的 Redis 实例&lt;/li&gt;
&lt;li&gt;不足：要有一个区间范围到实例的映射表，要管理表和各种对象的映射表&lt;/li&gt;
&lt;li&gt;哈希分区：对任何 key 都适用。操作方法&lt;/li&gt;
&lt;li&gt;用一个 hash 函数将 key 转换为一个数字&lt;/li&gt;
&lt;li&gt;对整数取模(按照 Redis 实例数目)，从而映射到其中一个 Redis 实例&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>3 特点</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/3-characteristics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/3-characteristics/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%e8%bf%ad%e4%bb%a3%e5%a2%9e%e9%87%8f%e5%92%8c%e5%87%86%e5%a4%87%e8%bf%9b%e5%8c%96&#34;&gt;3.1 迭代/增量和准备进化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%e9%9d%a2%e5%af%b9%e9%9d%a2%e6%b2%9f%e9%80%9a&#34;&gt;3.2 面对面沟通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%e5%8f%8d%e9%a6%88%e5%9b%9e%e8%b7%af&#34;&gt;3.3 反馈回路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-迭代-增量和准备进化&#34;&gt;3.1 迭代/增量和准备进化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;大多数敏捷开发方法将一个问题分解成小任务。对于所有的需求没有直接长期的计划。通常，迭代是短时间的规划，例如一到四周。&lt;/li&gt;
&lt;li&gt;每个迭代都有一个跨职能的团队，工作内容包含软件开发的所有功能，包括规划、需求分析、设计、编码、单元测试和验收测试&lt;/li&gt;
&lt;li&gt;迭代结束的产物是一个可工作的产品，并在迭代结束后向利益相关者展示&lt;/li&gt;
&lt;li&gt;演示之后，采纳评审意见，并根据需求计划包含进可工作的软件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-面对面沟通&#34;&gt;3.2 面对面沟通&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个敏捷团队应该有一个客户代表(类似Scrum 中的产品负责人)。这个代表被授权代表利益相关者，且能够回答开发者在迭代中的问题&lt;/li&gt;
&lt;li&gt;通常会在办公室的显著位置放一个消息辐射体(实体显示器)，以便路人可以看到敏捷团队的进度。消息辐射体展示了最新的项目状态总结&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-反馈回路&#34;&gt;3.3 反馈回路&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每日站会是所有敏捷开发的一个共同文化，也称为日常 Scrum。它是一个简短的会议，每个团队成员相互报告自己已经完成的、接下来要做的以及面对的所有问题状态&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>3 集成应用</title>
      <link>https://xueqing.github.io/blog/django_cms/tutorial/3_integrate_app/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/django_cms/tutorial/3_integrate_app/</guid>
      <description></description>
    </item>
    
    <item>
      <title>4 Redis VM 技术</title>
      <link>https://xueqing.github.io/blog/database/redis/4_vm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/database/redis/4_vm/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%e5%89%8d%e8%a8%80&#34;&gt;4.1 前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%e7%ae%80%e5%8d%95%e8%a7%a3%e9%87%8a-vm&#34;&gt;4.2 简单解释 VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8-vm-%e6%98%af%e4%b8%aa%e5%a5%bd%e4%b8%bb%e6%84%8f&#34;&gt;4.3 何时使用 VM 是个好主意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44-vm-%e9%85%8d%e7%bd%ae&#34;&gt;4.4 VM 配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45-%e8%ae%be%e7%bd%ae-vm-max-memory&#34;&gt;4.5 设置 vm-max-memory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#46-%e9%85%8d%e7%bd%ae-swap-%e6%96%87%e4%bb%b6&#34;&gt;4.6 配置 swap 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#47-%e7%ba%bf%e7%a8%8b%e5%bc%8f-vm-vs-%e9%98%bb%e5%a1%9e%e5%bc%8f-vm&#34;&gt;4.7 线程式 VM vs 阻塞式 VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#48-%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e4%ba%9b%e4%ba%8b&#34;&gt;4.8 需要知道的一些事&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#481-swap-%e6%96%87%e4%bb%b6%e7%9a%84%e5%a5%bd%e4%bd%8d%e7%bd%ae&#34;&gt;4.8.1 swap 文件的好位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#482-%e7%9b%91%e8%a7%86-vm&#34;&gt;4.8.2 监视 VM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#483-%e5%bc%80%e5%90%af-vm-%e7%9a%84-redisrdb-%e6%96%87%e4%bb%b6-%e5%92%8c-%e5%8f%aa%e8%83%bd%e8%bf%bd%e5%8a%a0%e7%9a%84%e6%96%87%e4%bb%b6%e5%93%aa%e4%b8%aa%e5%a5%bd&#34;&gt;4.8.3 开启 VM 的 Redis：.rdb 文件 和 只能追加的文件哪个好&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#484-%e5%b0%bd%e5%8f%af%e8%83%bd%e5%b0%91%e7%9a%84%e4%bd%bf%e7%94%a8%e5%86%85%e5%ad%98&#34;&gt;4.8.4 尽可能少的使用内存&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#49-vm-%e7%a8%b3%e5%ae%9a%e6%80%a7&#34;&gt;4.9 VM 稳定性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#410-%e5%8f%82%e8%80%83&#34;&gt;4.10 参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#411-%e5%85%b6%e4%bb%96%e5%86%85%e5%ae%b9&#34;&gt;4.11 其他内容&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4111-redis-%e5%af%b9%e8%b1%a1%e5%92%8c-vm-pointer&#34;&gt;4.11.1 Redis 对象和 VM pointer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4112-%e4%ba%a4%e6%8d%a2%e8%bf%87%e7%a8%8b&#34;&gt;4.11.2 交换过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-1-前言&#34;&gt;4.1 前言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重要提示&lt;/strong&gt;：Redis VM(virtual memory) 现在已经弃用。2.4 是最新支持 VM 的版本(但警告不鼓励使用 VM)。我们发现使用 VM 有一些劣势和问题。在将来的 Redis，我们希望简单提供最好的内存数据库(但像往常一样持久化到磁盘)，至少现在不用考虑支持大于 RAM 大小的数据库。我们将来致力于提供脚本化、集群和更好的持久化&lt;/li&gt;
&lt;li&gt;Redis VM 特性第一次出现在稳定的 Redis 2.0 发布版本。然而，VM 在 &lt;a href=&#34;http://github.com/antirez/redis&#34; target=&#34;_blank&#34;&gt;git&lt;/a&gt; 的不稳定分支上仍然可以获取，且稳定可测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-简单解释-vm&#34;&gt;4.2 简单解释 VM&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 遵循 key-value 模型。键和一些值关联。通常，Redis 将键和相关的值保存在内存。有时这不是最好的选项，所以在设计上必须把键放在内存(为了保证快速查找)，但是可以把较少使用的值交换到磁盘&lt;/li&gt;
&lt;li&gt;在实际中，这意味着如果你在内存有 100 000 个键的数据集，但是只有 10% 的键经常使用，支持 VM 的 Redis 会尝试将较少使用的键关联的值转移到磁盘。当客户端的命令请求这些值时，这些值从 swap 文件加载到主存&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-何时使用-vm-是个好主意&#34;&gt;4.3 何时使用 VM 是个好主意&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在使用 VM 之前，你应该问自己你是否真的需要它。Redis 是磁盘备份，内存型数据库。正确使用 Redis 几乎总是有足够的 RAM 保存所有数据到内存。仍然有一些场景是不可能实现的

&lt;ul&gt;
&lt;li&gt;数据访问非常不均匀。只有小部分的键(比如网站上相关的活跃用户)被大量访问。同时每个键有大量的数据在内存中&lt;/li&gt;
&lt;li&gt;不管数据访问模式和大量的值，只是没有足够的内存存放所有的数据。这种配置下，Redis 可当作磁盘型数据库，而键保存在内存，因此键查找很快，但是访问实际的值需要访问磁盘(较慢)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;需要记住一个重要的概念&lt;code&gt;Redis 不能交换键&lt;/code&gt;，因此如果内存问题的事实是键太多而对应的值很小，VM 不是解决方案&lt;/li&gt;
&lt;li&gt;然而，如果因为值很大(比如大量的字符串、列表、集合或者有太多元素的哈希)而占用大量内存，VM 是一个好主意&lt;/li&gt;
&lt;li&gt;有时候，可以通过哈希将相关的数据组合在一个键中，从而将“键很多，值很小”的问题转换成“键很少，值很大”的问题。比如，不要为对象的每个属性设置一个键，而是每个对象一个键，用哈希表示不同的属性&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-4-vm-配置&#34;&gt;4.4 VM 配置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;配置 VM 不难，但是需要根据需求仔细设置最好的参数&lt;/li&gt;
&lt;li&gt;通过编辑 redis.conf 开启和配置 VM：&lt;code&gt;vm-enabled yes&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他一些配置选项可以改变 VM 行为。规则就是不想使用默认配置运行 Redis，因为每个问题和数据集需要一些微调以达到最好的优势&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-5-设置-vm-max-memory&#34;&gt;4.5 设置 vm-max-memory&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vm-max-memory&lt;/code&gt; 指定 Redis 在交换值到磁盘之前可以自由使用的内存大小&lt;/li&gt;
&lt;li&gt;基本上，如果没有达到这个内存限制，Redis 不会交换对象，所有对象在内存中。一旦达到这个限制，Redis 会交换足够的对象以使内存降到限制以下&lt;/li&gt;
&lt;li&gt;交换的对象主要是“年纪最大”(即未被使用的实际最长)，但是一个对象的“可交换性”与它在内存中大小的对数是成比例的。因此，虽然偏向更旧的对象，当“年纪”相同时首先交换更大的对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;警告&lt;/strong&gt;：因为不能交换键，在键使用空间大于内存时，Redis 不会考虑 &lt;code&gt;vm-max-memory&lt;/code&gt; 设置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm-max-memory&lt;/code&gt; 最好的值是足够的 RAM 来保持数据工作集。在实际中，只要给 Redis 尽可能多的空间，交换过程更好&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-6-配置-swap-文件&#34;&gt;4.6 配置 swap 文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Redis 使用交换文件将数据从内存转移到磁盘。交换文件和数据持久性无关，而且当一个 Redis 示例终止时可以被删除。但是，Redis 运行时，不应移动、删除或改变交换文件&lt;/li&gt;
&lt;li&gt;因为在随机访问方式中经常使用 Redis 交换文件，把交换文件放在 SSD(solid state disk)会达到更好的性能&lt;/li&gt;
&lt;li&gt;交换文件被分成页。一个值可以被交换到一个或多个页，但是一个页不能保存超过一个值&lt;/li&gt;
&lt;li&gt;没有直接方式告诉 Redis 应该使用多大的交换文件。而是配置两个不同的值，二者相乘得到使用的字节数。可通过 redis.conf 配置两个参数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vm-pages&lt;/code&gt;：交换文件的页数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm-page-size&lt;/code&gt;：页的大小，以字节为单位&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;比如页大小是 32 bytes，总页数是 10 000 000，交换文件可以保存 320 MB 的数据&lt;/li&gt;
&lt;li&gt;因为一个页不能保存超过一个值(但是一个值可以保存在多个页)，必须仔细设置这些参数。通常，最好的注意是设置页大小以便大部分值可以使用较少的页交换&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-7-线程式-vm-vs-阻塞式-vm&#34;&gt;4.7 线程式 VM vs 阻塞式 VM&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;另一个很重要的配置参数是 &lt;code&gt;vm-max-threads&lt;/code&gt;。默认值是 4&lt;/li&gt;
&lt;li&gt;表示为了执行交换文件的 I/O 操作所用的线程数量最大值。一个好的值只要和系统的核数匹配即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0&lt;/code&gt; 会开启阻塞式 VM。当配置成阻塞式 VM 时，Redis 会以同步阻塞方式执行 I/O

&lt;ul&gt;
&lt;li&gt;客户端访问交换出去的值，从磁盘读时会阻塞其他客户端，因此客户端经历的延迟会变大，尤其当磁盘慢或者忙，或者磁盘有大的交换的值&lt;/li&gt;
&lt;li&gt;阻塞式 VM 的性能总的来说较好，因为没有同步、线程创建、恢复等待值的阻塞客户端的时间损失。因此，如果愿意接受较高的延迟，阻塞式 VM 是个好的选择。尤其是交换很少发生，且大部分访问的数据都在内存时&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;相反，如果有大量的交换操作，且有许多核想要利用，而且通常不希望处理交换值的客户端阻塞其他客户端几毫秒(交换值很大的时候时间更长)，最好使用线程式 VM&lt;/li&gt;
&lt;li&gt;鼓励使用不同的配置对数据集做实验。。。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-8-需要知道的一些事&#34;&gt;4.8 需要知道的一些事&lt;/h2&gt;

&lt;h3 id=&#34;4-8-1-swap-文件的好位置&#34;&gt;4.8.1 swap 文件的好位置&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在很多配置中，交换文件可以很大，达到 40GB 甚至更大。不是所有类型的文件系统可以较好的处理大文件，尤其是 Mac OS X 文件系统在处理大文件方面比较差&lt;/li&gt;
&lt;li&gt;建议使用 Linux ext3 文件系统，或者其他较好支持稀疏文件(sparse files)的文件系统。什么是稀疏文件呢？

&lt;ul&gt;
&lt;li&gt;稀疏文件大部分内容是空白的。高级的文件系统如 ext2，ext3，ext4，ReiserFS，Reiser4 等可以更有效地编码这些文件，并且在需要的时候为文件分配更多的空间，即文件更多的实际块被使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;交换文件显然是非常稀疏的，尤其是当服务运行时间较短，或者相比交换出去的数据更大时。一个不支持稀疏文件的文件系统创建一个大文件时，有时会阻塞 Redis 流程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-8-2-监视-vm&#34;&gt;4.8.2 监视 VM&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当有一个开启 VM 的 Redis 系统允许时，可能对它如何工作感兴趣：总共交换了多少对象，每秒交换和加载的对象数目等&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有一个工具方便检查 VM 如何允许，是 &lt;a href=&#34;http://github.com/antirez/redis-tools&#34; target=&#34;_blank&#34;&gt;Redis 工具&lt;/a&gt;的一部分。这个工具叫做 &lt;code&gt;redis-stat&lt;/code&gt;，使用方式很直接：&lt;code&gt;./redis-stat vmstat&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./redis-stat vmstat
--------------- objects --------------- ------ pages ------ ----- memory -----
load-in  swap-out  swapped   delta      used     delta      used     delta
138837   1078936   800402    +800402    807620   +807620    209.50M  +209.50M
4277     38011     829802    +29400     837441   +29821     206.47M  -3.03M
3347     39508     862619    +32817     870340   +32899     202.96M  -3.51M
4445     36943     890646    +28027     897925   +27585     199.92M  -3.04M
10391    16902     886783    -3863      894104   -3821      200.22M  +309.56K
8888     19507     888371    +1588      895678   +1574      200.05M  -171.81K
8377     20082     891664    +3293      899850   +4172      200.10M  +53.55K
9671     20210     892586    +922       899917   +67        199.82M  -285.30K
10861    16723     887638    -4948      895003   -4914      200.13M  +312.35K
9541     21945     890618    +2980      898004   +3001      199.94M  -197.11K
9689     17257     888345    -2273      896405   -1599      200.27M  +337.77K
10087    18784     886771    -1574      894577   -1828      200.36M  +91.60K
9330     19350     887411    +640       894817   +240       200.17M  -189.72K
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上述输出的 redis 服务开启了 VM，大约有 1 百万键，且有大量的同步加载使用 &lt;code&gt;redis-load&lt;/code&gt; 工具&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以从输出中看到，每秒都发生一些 load-in 和 swap-out 操作。注意第一行表示服务启动后实际的值，后续的行和前面的不一样&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果分配足够的内存来保存数据工作集，可能应该看到更少的交换发送，因为 redis-stat 是一个很有价值的工具来理解是否需要去商店购买 RAM&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-8-3-开启-vm-的-redis-rdb-文件-和-只能追加的文件哪个好&#34;&gt;4.8.3 开启 VM 的 Redis：.rdb 文件 和 只能追加的文件哪个好&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当开启 VM 时，保存和加载数据库是相当慢的操作。如果服务配置成使用最小的内存(即 &lt;code&gt;vm-max-memory&lt;/code&gt; 设置成 0)，在开启 VM 后，在 2 秒内加载的数据库通常需要 13 秒时间加载&lt;/li&gt;
&lt;li&gt;因此，你可能想要切换配置使用只能追加的文件(Append Only File)来持久化，以便于你可以一直执行 &lt;code&gt;BGREWRITEAOF&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要注意当一个 &lt;code&gt;BGSAVE&lt;/code&gt; 或 &lt;code&gt;BGREWRITEAOF&lt;/code&gt; 在处理时，Redis 不会在磁盘上交换新的值。当有一个子进程访问 VM 时 VM 是只读的。因此如果一个工作的子进程有大量的写操作时，内存使用会增长

&lt;ul&gt;
&lt;li&gt;子进程在读 VM 时，主进程不能进行值交换操作。因为通常读完一次值，“年龄”变小，可能从 VM 取出，而交换新的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-8-4-尽可能少的使用内存&#34;&gt;4.8.4 尽可能少的使用内存&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将 Redis 设置成磁盘型数据库，而只保存键在内存的一个有趣的设置是设置 &lt;code&gt;vm-max-memory&lt;/code&gt; 为 0。如果不介意更多延迟和较差的性能，但是想要非常大的值使用更少的内存，这个是好的设置&lt;/li&gt;
&lt;li&gt;这种设置情况，应该首先尝试设置 VM 是阻塞式的(&lt;code&gt;vm-max-threads&lt;/code&gt; 为 0)，因为大业务量会导致很多交换操作，且和简单的阻塞式实现相比，线程会消耗大量的资源&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-9-vm-稳定性&#34;&gt;4.9 VM 稳定性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;VM 仍然是实验性代码，但是在过去的几周，在开发环境下用各种方式测试了 VM，甚至在一些生产环境。在测试阶段没有注意到 bug。但是在一些未控制的环境，且出于某些原因无法复现这些设置，会出现更加模糊的 bug&lt;/li&gt;
&lt;li&gt;在这个阶段，鼓励在开发环境尝试 VM，甚至是生产环境下，当数据库不是关键型任务，比如大量持久化数据可以小时而不会有任何问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-10-参考&#34;&gt;4.10 参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://redis.io/topics/virtual-memory&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-11-其他内容&#34;&gt;4.11 其他内容&lt;/h2&gt;

&lt;h3 id=&#34;4-11-1-redis-对象和-vm-pointer&#34;&gt;4.11.1 Redis 对象和 VM pointer&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;键值都是 Redis 的对象，但是当值被移到 VM 时，会变成 VM pointer。主要记录值在磁盘的信息，如记录对象在交换文件第几页、共使用几页等内容&lt;/li&gt;
&lt;li&gt;Redis 对象和 VM pointer 都有一个字段 storage，用于判断值的位置

&lt;ul&gt;
&lt;li&gt;redis_vm_memory：在内存&lt;/li&gt;
&lt;li&gt;redis_vm_swapped：在磁盘&lt;/li&gt;
&lt;li&gt;redis_vm_loading：在磁盘，但目前正有进程将其加载到内存&lt;/li&gt;
&lt;li&gt;redis_vm_swapping：在内存，但目前正有进程将其写入磁盘&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-11-2-交换过程&#34;&gt;4.11.2 交换过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;将对象交换到交换文件

&lt;ul&gt;
&lt;li&gt;计算保存此对象需要占用多少页&lt;/li&gt;
&lt;li&gt;在交换文件中寻找一段连续空间保存此对象&lt;/li&gt;
&lt;li&gt;把对象写入交换文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将对象从交换文件取出到内存

&lt;ul&gt;
&lt;li&gt;VM pointer 记录了对象在文件的起始页和占用页数，直接加载到内存即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;阻塞式 VM 在内存使用超过设定的 &lt;code&gt;vm-max-memory&lt;/code&gt; 时，会循环找到候选对象进行交换直到内存使用下降到设定值以下&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>4 每日站会</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/4-daily-standup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/4-daily-standup/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%e6%af%8f%e6%97%a5%e7%ab%99%e4%bc%9a%e7%9a%84%e6%a6%82%e5%bf%b5&#34;&gt;4.1 每日站会的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%e6%af%8f%e6%97%a5%e7%ab%99%e4%bc%9a%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7&#34;&gt;4.2 每日站会的重要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%e6%af%8f%e6%97%a5%e7%ab%99%e4%bc%9a%e7%9a%84%e5%8f%82%e4%b8%8e%e4%ba%ba&#34;&gt;4.3 每日站会的参与人&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#44-%e7%89%a9%e7%90%86%e5%88%86%e6%95%a3%e7%9a%84%e5%9b%a2%e9%98%9f&#34;&gt;4.4 物理分散的团队&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每日站会，顾名思义，是敏捷团队所有成员媒体的状态会议。它不仅为定期的更新提供论坛，也将团队成员的问题作为关注点以便可以被快速处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每日站会是一个必须的实践，不管一个敏捷团队建立的办公室位置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-1-每日站会的概念&#34;&gt;4.1 每日站会的概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每日站会是所有成员间的一个每日状态会议，大概举行 15 分钟&lt;/li&gt;
&lt;li&gt;每个成员必须回答三个重要的问题

&lt;ul&gt;
&lt;li&gt;昨天做了什么&lt;/li&gt;
&lt;li&gt;今天要做什么&lt;/li&gt;
&lt;li&gt;正面临的问题或阻碍&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每日站会用于更新状态，而不是讨论。讨论的成员应当安排其他时间&lt;/li&gt;
&lt;li&gt;参与者应当站着而不是坐着以便快速结束&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-每日站会的重要性&#34;&gt;4.2 每日站会的重要性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每日站会在敏捷中的益处

&lt;ul&gt;
&lt;li&gt;团队可以评估每日进度，查看每个迭代计划是否可以交付&lt;/li&gt;
&lt;li&gt;每个团队成员通知自己每天的完成量&lt;/li&gt;
&lt;li&gt;为团队的所有延期和障碍提供可视化性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-每日站会的参与人&#34;&gt;4.3 每日站会的参与人&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;流程管理员、产品负责人和交付团队应当参与每日站会&lt;/li&gt;
&lt;li&gt;利益相关者和客户鼓励出席会议，并可以作为观察者，但是不应该参与站会&lt;/li&gt;
&lt;li&gt;流程管理员应该记录每个团队成员的疑问和面临的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-4-物理分散的团队&#34;&gt;4.4 物理分散的团队&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;站会可以有多种方式，以便敏捷团队的成员分布在不同的时区

&lt;ul&gt;
&lt;li&gt;轮流选择一名成员，可以出席不同时区的站会&lt;/li&gt;
&lt;li&gt;每个团队有单独的站会，在一个工具(如 Rally，SharePoint，Wikis等)更新站会的状态&lt;/li&gt;
&lt;li&gt;准备多种沟通工具(如电话会议、视频会议、即时通讯工具或其他第三方认可的知识共享工具)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>5 完成标准</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/5-definition-of-done/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/5-definition-of-done/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b&#34;&gt;5.1 用户故事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-%e8%bf%ad%e4%bb%a3&#34;&gt;5.2 迭代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-%e5%8f%91%e5%b8%83&#34;&gt;5.3 发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-1-用户故事&#34;&gt;5.1 用户故事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个用户故事是由用户几句日常语言表叔的需求，应该在一个迭代中完成&lt;/li&gt;
&lt;li&gt;用户故事完成时

&lt;ul&gt;
&lt;li&gt;检查了所有相关代码&lt;/li&gt;
&lt;li&gt;通过所有单元测试 case&lt;/li&gt;
&lt;li&gt;通过所有验收测试 case&lt;/li&gt;
&lt;li&gt;写了帮助文档&lt;/li&gt;
&lt;li&gt;产品负责人已经验收了这个故事&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-2-迭代&#34;&gt;5.2 迭代&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个迭代发布一个产品，来验收解决的用户故事或故障&lt;/li&gt;
&lt;li&gt;迭代在迭代计划会议中定义，通过一个迭代演示和评审会议完成&lt;/li&gt;
&lt;li&gt;一个迭代也叫一个冲刺(sprint)&lt;/li&gt;
&lt;li&gt;一个迭代完成时

&lt;ul&gt;
&lt;li&gt;产品需求列表已完成&lt;/li&gt;
&lt;li&gt;测试了性能&lt;/li&gt;
&lt;li&gt;用户故事被验收或移动到下次迭代&lt;/li&gt;
&lt;li&gt;故障被解决或推迟到下次迭代&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-3-发布&#34;&gt;5.3 发布&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个发布是一个主要的里程碑，代表内部或外部工作的交付，是产品或系统的测试版本&lt;/li&gt;
&lt;li&gt;一个发布完成时

&lt;ul&gt;
&lt;li&gt;测试了系统压力&lt;/li&gt;
&lt;li&gt;调整了性能&lt;/li&gt;
&lt;li&gt;执行了安全验证&lt;/li&gt;
&lt;li&gt;测试了灾难恢复计划&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>6 发布计划</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/6-release-planning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/6-release-planning/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-%e5%8f%82%e4%b8%8e%e8%80%85&#34;&gt;6.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62-%e8%ae%a1%e5%88%92%e7%9a%84%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34;&gt;6.2 计划的先决条件-&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63-%e9%9c%80%e8%a6%81%e7%9a%84%e6%9d%90%e6%96%99&#34;&gt;6.3 需要的材料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#64-%e8%ae%a1%e5%88%92%e6%95%b0%e6%8d%ae&#34;&gt;6.4 计划数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#65-%e8%be%93%e5%87%ba&#34;&gt;6.5 输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#66-%e6%97%a5%e7%a8%8b&#34;&gt;6.6 日程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发布计划的目的是创建一个计划，来增量交付产品。每 2~3 个月做一次。&lt;/p&gt;

&lt;h2 id=&#34;6-1-参与者&#34;&gt;6.1 参与者&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;流程管理员：敏捷交付团队的引导者&lt;/li&gt;
&lt;li&gt;产品负责人：代表产品需求列表的一般观点&lt;/li&gt;
&lt;li&gt;敏捷团队：提出技术可行性和任何依赖的观点&lt;/li&gt;
&lt;li&gt;利益相关者：当发布会议作出决定时，利益相关者比如客户、程序管理者、主体专家提出建议&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-2-计划的先决条件&#34;&gt;6.2 计划的先决条件-&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;排好序的产品需求列表：由产品负责人管理。一般考虑 5~10 个特性，由产品负责人考虑可被纳入一个发布&lt;/li&gt;
&lt;li&gt;团队能力的输入、已知的速度或任何关于技术的挑战&lt;/li&gt;
&lt;li&gt;高等级的愿景&lt;/li&gt;
&lt;li&gt;市场和业务目标&lt;/li&gt;
&lt;li&gt;确认新产品的需求列表项是否需要&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-3-需要的材料&#34;&gt;6.3 需要的材料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;贴出的日常，目的&lt;/li&gt;
&lt;li&gt;挂图，白板，记号笔&lt;/li&gt;
&lt;li&gt;投影仪，用于共享计划会议中所需数据或工具的电脑&lt;/li&gt;
&lt;li&gt;计划数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-4-计划数据&#34;&gt;6.4 计划数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上次迭代或发布计划的结果&lt;/li&gt;
&lt;li&gt;不同的利益相关者对于产品、市场条件和截止日期的反馈&lt;/li&gt;
&lt;li&gt;上次发布或迭代的行动计划&lt;/li&gt;
&lt;li&gt;需要考虑的特性或故障&lt;/li&gt;
&lt;li&gt;上次发布或预估的速度&lt;/li&gt;
&lt;li&gt;组织和个人的日程表&lt;/li&gt;
&lt;li&gt;其他团队和主体专家管理依赖性的输入&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-5-输出&#34;&gt;6.5 输出&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;发布计划&lt;/li&gt;
&lt;li&gt;承诺&lt;/li&gt;
&lt;li&gt;要监察的问题、关注点、依赖性和假设&lt;/li&gt;
&lt;li&gt;改进未来发布计划的建议&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-6-日程&#34;&gt;6.6 日程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;开场仪式：欢迎消息，评审目的和提成，组织工具，介绍业务赞助者&lt;/li&gt;
&lt;li&gt;产品愿景，蓝图：展示产品的大图&lt;/li&gt;
&lt;li&gt;评审之前的发布：太累可能影响这次计划的条目&lt;/li&gt;
&lt;li&gt;发布名字或主题：检查蓝图主题的当前状态，做出所需的调整&lt;/li&gt;
&lt;li&gt;速度：代表当前发布和之前发布的速度&lt;/li&gt;
&lt;li&gt;发布安排：评审发布中关键的里程碑和决定&lt;/li&gt;
&lt;li&gt;问题和关注点：检查并记录所有的关注点或问题&lt;/li&gt;
&lt;li&gt;评审和更新完成标准：评审完成标准，基于上次迭代或发布之后的技术、技巧或团队成员的改变做出合适的改变&lt;/li&gt;
&lt;li&gt;需要考虑的故事和条目：展示来自产品需求列表需要考虑的用户故事和特点，用于当前发布的安排&lt;/li&gt;
&lt;li&gt;确定分级值：如果速度未知，计划发布计划中药使用的分级值&lt;/li&gt;
&lt;li&gt;粗粒度划分故事：交付团队考虑之后确定故事的合适大小，且当故事比较大时，将故事划分成多个迭代。产品负责人和主体专家澄清疑问，详细制作验收标准，并做出合适的故事划分。流程管理者促进合作&lt;/li&gt;
&lt;li&gt;将故事映射到迭代：交付团队和产品负责人基于大小和速度将故事或故障移到迭代。流程管理者促进合作&lt;/li&gt;
&lt;li&gt;新的关注点或问题：基于之前的计划检查新问题，记录相同的问题&lt;/li&gt;
&lt;li&gt;依赖性和假设：价差发布计划中的任何依赖性或假设&lt;/li&gt;
&lt;li&gt;承诺：流程管理者好找计划。交付团队和产品负责人视其为最好的计划，并承诺开展下个级别的计划，即迭代计划&lt;/li&gt;
&lt;li&gt;沟通和后勤计划：为发布评审或更新沟通和后勤计划&lt;/li&gt;
&lt;li&gt;停车场：所有条目应该被解决或作为行动条目&lt;/li&gt;
&lt;li&gt;分发行动条目和行动计划：分发负责人的行动条目，处理行动计划&lt;/li&gt;
&lt;li&gt;回顾：征求参与者的反馈使会议成功&lt;/li&gt;
&lt;li&gt;结束：庆祝成功&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>7 迭代计划</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/7-iteration-planning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/7-iteration-planning/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-%e5%8f%82%e4%b8%8e%e8%80%85&#34;&gt;7.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-%e8%ae%a1%e5%88%92%e7%9a%84%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34;&gt;7.2 计划的先决条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-%e8%ae%a1%e5%88%92%e6%b5%81%e7%a8%8b&#34;&gt;7.3 计划流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74-%e9%80%9f%e5%ba%a6%e8%ae%a1%e7%ae%97&#34;&gt;7.4 速度计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#75-%e4%bb%bb%e5%8a%a1%e5%ae%b9%e9%87%8f&#34;&gt;7.5 任务容量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#76-%e8%ae%a1%e5%88%92%e6%ad%a5%e9%aa%a4&#34;&gt;7.6 计划步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;迭代计划的目的是为了完成优先级高的产品需求列表项。承诺是基于迭代时间和团队速度的时间盒&lt;/p&gt;

&lt;h2 id=&#34;7-1-参与者&#34;&gt;7.1 参与者&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;流程管理者：敏捷交付团队的引导者&lt;/li&gt;
&lt;li&gt;产品负责人：处理产品需求列表及其验收标准的详细的看法&lt;/li&gt;
&lt;li&gt;敏捷团队：敏捷交付定义他们的任务，并设置完成承诺所需的努力评估&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-2-计划的先决条件&#34;&gt;7.2 计划的先决条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;产品需求列表项有大小，且指定了相关的故事点&lt;/li&gt;
&lt;li&gt;产品负责人条目集合排好序&lt;/li&gt;
&lt;li&gt;每个条目有清晰描述的验收标准&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-3-计划流程&#34;&gt;7.3 计划流程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;确定一个迭代包含的故事&lt;/li&gt;
&lt;li&gt;划分这些故事成任务，并分配每个任务给对应的负责人&lt;/li&gt;
&lt;li&gt;每个任务按小时评估&lt;/li&gt;
&lt;li&gt;这些评估帮助团队成员检查每个成员对于这此迭代的任务时&lt;/li&gt;
&lt;li&gt;根据团队成员的速度分配任务，以便他们不会负担过重&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-4-速度计算&#34;&gt;7.4 速度计算&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;敏捷团队基于过去的迭代计算速度&lt;/li&gt;
&lt;li&gt;速度是迭代中所需的平均数字单位以便完成用户故事

&lt;ul&gt;
&lt;li&gt;比如，一个团队在过去的三个迭代中分别用12，14，10个故事点，这个团队下次迭代的速度是 12&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;计划的速度高速团队可以在当前迭代完成多少用户故事。如果团队快速完成分配的任务，那么可以加入更多的用户故事。否则，可在下次迭代移除一些故事&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-5-任务容量&#34;&gt;7.5 任务容量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个团队的容量从下面三个因素考量

&lt;ul&gt;
&lt;li&gt;每天理想的工作小时&lt;/li&gt;
&lt;li&gt;这次迭代中成员可用的天数&lt;/li&gt;
&lt;li&gt;一个成员在此团队中不可用的时间百分比&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;假设一个团队 5 个成员，承诺为一个项目满时工作(每天 8 小时)，且没有人在迭代中离开，那么一个两周迭代的任务容量是 5*8*10=400 小时&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-6-计划步骤&#34;&gt;7.6 计划步骤&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;产品负责人描述产品需求列表排序最高的条目&lt;/li&gt;
&lt;li&gt;团队描述完成条目需要的任务&lt;/li&gt;
&lt;li&gt;团队成员负责任务&lt;/li&gt;
&lt;li&gt;团队成员估计完成每个任务的时间&lt;/li&gt;
&lt;li&gt;在迭代中重复上述步骤&lt;/li&gt;
&lt;li&gt;如果有人任务过多，将任务分给其他团队成员&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>8 产品需求列表</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/8-product-backlog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/8-product-backlog/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81-%e4%ba%a7%e5%93%81%e9%9c%80%e6%b1%82%e5%88%97%e8%a1%a8%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7&#34;&gt;8.1 产品需求列表的重要性&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#82-%e4%ba%a7%e5%93%81%e9%9c%80%e6%b1%82%e5%88%97%e8%a1%a8%e7%9a%84%e7%89%b9%e7%82%b9&#34;&gt;8.2 产品需求列表的特点&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个产品需求列表是将要做的条目的列表。条目具有特性描述，被排好序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在理想的场景中，条目应划分成用户故事&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-1-产品需求列表的重要性&#34;&gt;8.1 产品需求列表的重要性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;准备好产品需求列表，以便可以评估每个特性&lt;/li&gt;
&lt;li&gt;帮助计划产品蓝图&lt;/li&gt;
&lt;li&gt;帮助对特性重排序，以便产品具有更多价值&lt;/li&gt;
&lt;li&gt;帮助确定需要优先处理的事情。团队对条目排序并建立值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-2-产品需求列表的特点&#34;&gt;8.2 产品需求列表的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个产品应该有一个产品需求列表，具有很多大的特性&lt;/li&gt;
&lt;li&gt;多个团队可以为一个产品需求列表工作&lt;/li&gt;
&lt;li&gt;特性排序基于业务价值、技术值、风险管理或策略调整排序&lt;/li&gt;
&lt;li&gt;在发布计划中将优先级高的条目分解成小的故事，以便可以在未来的迭代中完成它们&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>9 有用的术语</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/9-useful-terms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/9-useful-terms/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;验收标准 Acceptance Criteria：由产品负责人或客户设置的条件，为了验收一个特性时有效的且和他们的需求一致&lt;/li&gt;
&lt;li&gt;列表修整 Backlog Grooming：一个持续的过程，是产品管理者或客户通过从敏捷团队获取反馈管理产品需求列表。包含条目项的排序、分解条目项成更小的条目、规划未来的迭代、创建新的故事、更小验收标准和消息描述验收标准&lt;/li&gt;
&lt;li&gt;容量 Capacity：一个迭代中团队可以完成的工作&lt;/li&gt;
&lt;li&gt;特性 Feature：对于产品的一个改进，或对利益相关者价值的兼容，在一个发布中开发&lt;/li&gt;
&lt;li&gt;迭代 Iteration：基于主题的工作项可在一个时间盒完成，并在产品的一个迭代中验收。迭代工作由迭代计划定义，结果是一个 demo 和评审会议。也叫做 Sprint&lt;/li&gt;
&lt;li&gt;增量 Increment：一个增量是逐渐开发的产品变化的状态。通常展示为里程碑或固定的迭代数&lt;/li&gt;
&lt;li&gt;产品负责人 Product Owner：敏捷交付团队的一名成员，负责收集和排序产品需求列表中的业务需求。一个产品负责人沟通一个发布或迭代中要做的工作。产品负责人设置成活，并负责保护团队在一个迭代中需求不被改变&lt;/li&gt;
&lt;li&gt;产品需求列表 Product Backlog：功能性和非功能性的产品需求的集合&lt;/li&gt;
&lt;li&gt;产品需求列表项 Product Backlog Items：可以是用户故事、故障、特性，由敏捷团队开发&lt;/li&gt;
&lt;li&gt;点 Points：一个通用单位，用以设置用户故事、特性或其他条目的相对大小&lt;/li&gt;
&lt;li&gt;发布 Release：在一个时间箱中，完成工作以支持一个软件的可测试的增量交付。在一个 Scrum 中，一个发布由多个迭代组成&lt;/li&gt;
&lt;li&gt;需求 Requirement：软件产品的规格说明，用于满足规定的合同或功能。用户故事和条目项是需求类型&lt;/li&gt;
&lt;li&gt;故事点 Story Points：敏捷团队用于评估用户故事和特性的相对大小的单位&lt;/li&gt;
&lt;li&gt;冲刺 Sprint：同迭代&lt;/li&gt;
&lt;li&gt;时间箱 Timebox：一个固定的持续时间，在这期间开发出一个可交付产品。通常，伴随固定的开始和结束时间，资源的数目也是固定的&lt;/li&gt;
&lt;li&gt;任务 Task：在迭代中，对于一个用户故事有共享的工作的单位。用户故事被分解成多个任务，且每个任务被分给团队成员作为任务负责人。团队成员可为每个任务负责，更新评估，记录已完成和要做的工作日志&lt;/li&gt;
&lt;li&gt;用户故事 User Story：一个列举的验收标准用于实现用户的一些需求。通常从一个终端用户的角度写&lt;/li&gt;
&lt;li&gt;速度 Velocity：度量迭代或时间箱的验收工作。通常是迭代中验收的故事点的总和&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>auto_ptr, unique_ptr, shared_ptr and weak_ptr</title>
      <link>https://xueqing.github.io/blog/cplusplus/smart_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/smart_ptr/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#autoptr&#34;&gt;auto_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#uniqueptr&#34;&gt;unique_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sharedptr&#34;&gt;shared_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weakptr&#34;&gt;weak_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reference&#34;&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;auto-ptr&#34;&gt;auto_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++11 已经弃用。&lt;code&gt;unique_ptr&lt;/code&gt;是新的具有相似功能的智能指针，但是安全性更高。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;是管理对象的指针，通过&lt;code&gt;new&lt;/code&gt;的操作创建，当&lt;code&gt;auto_ptr&lt;/code&gt;销毁的时候会删除该对象。&lt;/li&gt;
&lt;li&gt;一个用&lt;code&gt;auto_ptr&lt;/code&gt;存储了一个指针指向一个被分配的对象，确保当代码运行到指针的范围之外时，指针指向的对象会自动销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;基于独有的所有权模型(exclusive ownership model)，也就是说，两个相同类型的指针不能同时指向同一个资源。复制或者赋值给指针会改变所有权，即源指针会把所有权移交给目的指针。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码可以看出复制指针的时候所有权的转移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// C++ program to illustrate the use of auto_ptr
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

class A
{
public:
    void show() { cout &amp;lt;&amp;lt; &amp;quot;A::show()&amp;quot; &amp;lt;&amp;lt; endl; }
};

int main()
{
    // p1 is an auto_ptr of type A
    auto_ptr&amp;lt;A&amp;gt; p1(new A);
    p1-&amp;gt;show();

    // returns the memory address of p1
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;

    // copy constructor called, this makes p1 empty.
    auto_ptr &amp;lt;A&amp;gt; p2(p1);
    p2-&amp;gt;show();

    // p1 is empty now
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;

    // p1 gets copied in p2
    cout&amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输出结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;A::show()
0x1b42c20
A::show()
0           // NULL
0x1b42c20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;auto_ptr&lt;/code&gt;的拷贝构造函数和赋值运算符实际上不会拷贝存储的指针，而是转移指针，从而使得源指针为空。&lt;code&gt;auto_ptr&lt;/code&gt;实现了严格的所有权管理，使得同一时刻只有一个&lt;code&gt;auto_ptr&lt;/code&gt;对象可以拥有该指针。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;丢弃&lt;code&gt;auto_ptr&lt;/code&gt;的原因：&lt;code&gt;auto_ptr&lt;/code&gt;的赋值运算转移所有权，并且重置右值的&lt;code&gt;auto_ptr&lt;/code&gt;为空指针。因此，&lt;code&gt;auto_ptr&lt;/code&gt;不能用于 STL 容器。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unique-ptr&#34;&gt;unique_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;是 C++11 开发用于替换&lt;code&gt;std::auto_ptr&lt;/code&gt;的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;具有更好的安全性(没有“虚假”的拷贝赋值)，增加了特性(删除器)，支持数组。它是一个保存原始指针的容器。&lt;code&gt;unique_ptr&lt;/code&gt;显式地避免持有的指针拷贝赋值，它只允许指针有一个持有者。所以对于一个资源，至多只有一个&lt;code&gt;unique_ptr&lt;/code&gt;指向，当&lt;code&gt;unique_ptr&lt;/code&gt;销毁时，资源会自动释放。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对&lt;code&gt;unique_ptr&lt;/code&gt;拷贝赋值会导致编译错误。比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unique_ptr&amp;lt;A&amp;gt; ptr1 (new A);
unique_ptr&amp;lt;A&amp;gt; ptr2 = ptr1; // Error: can&#39;t copy unique_ptr
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以使用&lt;code&gt;std::move()&lt;/code&gt;语法转移持有指针的所有权给另外一个&lt;code&gt;unique_ptr&lt;/code&gt;。&lt;code&gt;unique_ptr&amp;lt;A&amp;gt; ptr2 = move(ptr1);&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码阐述了&lt;code&gt;unique_ptr&lt;/code&gt;的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

class A
{
public:
    void show() { cout &amp;lt;&amp;lt; &amp;quot;A::show()&amp;quot; &amp;lt;&amp;lt; endl; }
};

int main()
{
    unique_ptr&amp;lt;A&amp;gt; p1(new A);
    p1-&amp;gt;show();

    // returns the memory address of p1
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;

    // transfers ownership to p2
    unique_ptr&amp;lt;A&amp;gt; p2 = move(p1);
    p2-&amp;gt;show();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    // transfers ownership to p3
    unique_ptr&amp;lt;A&amp;gt; p3 = move (p2);
    p3-&amp;gt;show();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p3.get() &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;A::show()
0x1c4ac20
A::show()
0          // NULL
0x1c4ac20
A::show()
0          // NULL
0          // NULL
0x1c4ac20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码返回一个资源，如果我们不显式的接收返回值，资源会被清理。反之，我们会得到对该资源的唯一所有权。因此，可以认为&lt;code&gt;unique_ptr&lt;/code&gt;比&lt;code&gt;auto_ptr&lt;/code&gt;更安全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unique_ptr&amp;lt;A&amp;gt; fun()
{
    unique_ptr&amp;lt;A&amp;gt; ptr(new A);
    // do something
    return ptr;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shared-ptr&#34;&gt;shared_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt;是一个保存原始指针的容器。它是引用计数所有权模型(&lt;code&gt;reference counting ownership model&lt;/code&gt;)。&lt;code&gt;shared_ptr&lt;/code&gt;维护了持有指针的引用计数以及所有对&lt;code&gt;shared_ptr&lt;/code&gt;的拷贝。因此，当一个新的指针指向资源的时候计数增加，当指针析构的时候计数减少。&lt;/li&gt;
&lt;li&gt;引用计数(&lt;code&gt;reference counting&lt;/code&gt;)：是一种存储对于一个资源(比如对象，内存块，磁盘空间或者其他资源)的引用、指针或者句柄的数目的技术。&lt;/li&gt;
&lt;li&gt;当代码执行到指向资源的所有&lt;code&gt;shared_ptr&lt;/code&gt;的范围之外，资源才会销毁释放。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码阐述了&lt;code&gt;shared_ptr&lt;/code&gt;的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;memory&amp;gt;
using namespace std;  
class A
{
public:
    void show() { cout &amp;lt;&amp;lt; &amp;quot;A::show()&amp;quot; &amp;lt;&amp;lt; endl; }
};

int main()
{
    shared_ptr&amp;lt;A&amp;gt; p1(new A);
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    p1-&amp;gt;show();
    shared_ptr&amp;lt;A&amp;gt; p2(p1);
    p2-&amp;gt;show();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    // Returns the number of shared_ptr objects referring to the same managed object.
    cout &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.use_count() &amp;lt;&amp;lt; endl;

    // Relinquishes ownership of p1 on the object and pointer becomes NULL
    p1.reset();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.use_count() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;0x1c41c20
A::show()
A::show()
0x1c41c20
0x1c41c20
2
2
0          // NULL
1
0x1c41c20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;weak-ptr&#34;&gt;weak_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;weak_ptr&lt;/code&gt;是&lt;code&gt;shared_ptr&lt;/code&gt;的拷贝。它可以访问被一个或多个&lt;code&gt;shared_ptr&lt;/code&gt;实例持有的对象，但是不参与引用计数。&lt;code&gt;weak_ptr&lt;/code&gt;的存在或销毁对&lt;code&gt;shared_ptr&lt;/code&gt;及其拷贝没有影响。&lt;code&gt;weak_ptr&lt;/code&gt;对于打破&lt;code&gt;shared_ptr&lt;/code&gt;实例之间的循环引用必不可少。&lt;/li&gt;
&lt;li&gt;相互依赖(&lt;code&gt;Cyclic Dependency&lt;/code&gt;,&lt;code&gt;shared_ptr&lt;/code&gt;存在的问题)：考虑一个场景，类 A 和类 B，二者都有指针指向另外一个类。因此，如果有两个&lt;code&gt;shared_ptr&lt;/code&gt;的指针&lt;code&gt;ptr_A&lt;/code&gt;和&lt;code&gt;ptr_B&lt;/code&gt;分别指向 A 和 B的某个对象，总是&lt;code&gt;ptr_A&lt;/code&gt;持有 B 的对象而且&lt;code&gt;ptr_B&lt;/code&gt;持有 A 的对象。A 和 B 的对象引用计数一直不会变成 0，A 和 B 的对象都不会被删除。&lt;/li&gt;
&lt;li&gt;现在把&lt;code&gt;ptr_A&lt;/code&gt;换成&lt;code&gt;weak_ptr&lt;/code&gt;，&lt;code&gt;ptr_A&lt;/code&gt;可以访问 B 的对象但是不会持有该对象。B 对象的引用计数就是 0，可以先释放，之后 A 对象的引用计数变成 0 就可以释放内存。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ptr_A&lt;/code&gt;之前需要检查 B 对象的有效性，因为 B 对象可能销毁。&lt;/li&gt;
&lt;li&gt;什么时候需要用&lt;code&gt;weak_ptr&lt;/code&gt;？当希望从不同的地方访问对象，且不关心这些引用的删除。但是尝试间接引用该对象的时候需要注意检查对象的有效性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reference&#34;&gt;reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/auto_ptr-unique_ptr-shared_ptr-weak_ptr-2/&#34; target=&#34;_blank&#34;&gt;auto_ptr, unique_ptr, shared_ptr and weak_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/3451099/stdauto-ptr-to-stdunique-ptr&#34; target=&#34;_blank&#34;&gt;std::auto_ptr to std::unique_ptr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; new</title>
      <link>https://xueqing.github.io/blog/cplusplus/cplusplus_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/cplusplus_new/</guid>
      <description>

&lt;h2 id=&#34;关于-new-int-和-new-int&#34;&gt;关于 new int() 和 new int[]&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    #define LEN 100
    int *arr1 = new int(LEN);
    int *arr2 = new int[LEN];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第一行的代码&lt;code&gt;arr1&lt;/code&gt;指向内存中&lt;code&gt;int = 100&lt;/code&gt;的一个数的地址&lt;/li&gt;
&lt;li&gt;第二行的代码&lt;code&gt;arr2&lt;/code&gt;指向长度为 100 的数组的内存块&lt;/li&gt;
&lt;li&gt;圆括号是对象赋值的意思；方括号是声明数组大小的意思&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; string 转换大小写</title>
      <link>https://xueqing.github.io/blog/cplusplus/cplusplus_string_case_convert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/cplusplus_string_case_convert/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;

void CString::StringToUpper(std::string &amp;amp;str)
{
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
}

void CString::StringToLower(std::string &amp;amp;str)
{
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;提示出错&lt;code&gt;error: no matching function for call to ‘transform(__gnu_cxx::__normal_iterator&amp;lt;char*, std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;, __gnu_cxx::__normal_iterator&amp;lt;char*, std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;, __gnu_cxx::__normal_iterator&amp;lt;char*, std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;, &amp;lt;unknown type&amp;gt;)’&lt;/code&gt;的解决方法：既有 C 版本的&lt;code&gt;toupper/tolower&lt;/code&gt;函数，又有 STL 模板函数&lt;code&gt;toupper/tolower&lt;/code&gt;，二者存在冲突，在&lt;code&gt;toupper/tolower&lt;/code&gt;前加上&lt;code&gt;::&lt;/code&gt;表示强制指定 C 版本的&lt;/li&gt;
&lt;li&gt;::toloweer/::toupper 只用于单字节字符的替换，不适用于多字节编码（如 UTF-8）？&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可使用 boost 库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;boost/algorithm/string.hpp&amp;gt;
using namespace boost;
// use to_lower/to_upper function
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 未定义的行为</title>
      <link>https://xueqing.github.io/blog/cplusplus/undefined_behavior/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/undefined_behavior/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;UB(Undefined behavior):程序的行为没有限制。常见的未定义行为例子包括：数组访问内存越界，有符号数溢出，间接访问空指针，在一个表达式中无顺序多次修改标量，用不同类型的指针访问对象&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/language/ub&#34; target=&#34;_blank&#34;&gt;UB and optimization&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正确的 C++ 程序是没有未定义行为的，所以当编译器优化了含有 UB 的代码，程序会出现不可预料的结果&lt;/li&gt;
&lt;li&gt;有符号数溢出，下面是 C++ 代码和对应可能生成的机器语言&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没有溢出时返回 1，溢出时是 UB，编译器可能优化，每次都返回 1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;int foo(int x)
{
return x+1 &amp;gt; x; // either true or UB due to signed overflow
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;foo(int):
movl    $1, %eax
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;访问越界，下面是 C++ 代码和对应可能生成的机器语言&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;访问下标在 0-3 时，如果存在元素 v 返回true，否则会访问越界，编译器可能优化，每次都返回 true，也不会访问越界&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;int table[4] = {};
bool exists_in_table(int v)
{
// return true in one of the first 4 iterations or UB due to out-of-bounds access
for (int i = 0; i &amp;lt;= 4; i++)
{
    if (table[i] == v) return true;
}
return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;exists_in_table(int):
movl    $1, %eax
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;未初始化的标量，下面是 C++ 代码和对应可能生成的机器语言&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当 x 非 0 时，a 会被赋值 42，否则 a 未初始化，编译器可能优化，每次都将 a 赋值42，然后返回&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;std::size_t f(int x)
{
std::size_t a;
if(x) // either x nonzero or UB
    a = 42;
return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;f(int):
mov     eax, 42
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;间接访问空指针，下面是 C++ 代码和对应可能生成的机器语言&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数&lt;code&gt;foo&lt;/code&gt;：当 p 是空指针时，x 的赋值是间接访问空指针。否则返回 0。编译器可能优化，每次返回 0 而不会访问到空指针&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xorl %eax,%eax&lt;/code&gt;按位异或，相当于清 0，将寄存器&lt;code&gt;%eax&lt;/code&gt;设置为 0。也可以使用&lt;code&gt;movl $0,%eax&lt;/code&gt;，但是前者需要 2 个字节，后者需要 5 个字节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数&lt;code&gt;bar&lt;/code&gt;：直接访问空指针指向的值是 UB，编译器可能优化，每次直接执行下一行代码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;retq&lt;/code&gt;等同于&lt;code&gt;addq $8,%rsp; jmpq -8(%rsp)&lt;/code&gt;，&lt;code&gt;retq&lt;/code&gt;将&lt;code&gt;%esp&lt;/code&gt;指向的返回地址弹出，存入寄存器&lt;code&gt;%eip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;寄存器&lt;code&gt;%eip&lt;/code&gt;是程序计数器，存储了 CPU 要读取指令的地址，即 CPU 将要执行的指令的地址。每次 CPU执行完相应的汇编指令后，&lt;code&gt;%eip&lt;/code&gt;的值就会增加&lt;/li&gt;
&lt;li&gt;寄存器&lt;code&gt;%esp&lt;/code&gt;是栈指针指向栈顶元素。栈向低地址方向增长，可以通过增加栈指针来释放空间&lt;/li&gt;
&lt;li&gt;函数调用时会先将返回地址入栈，即程序中紧跟在调用函数后面的那条指令的地址，所以栈顶指针&lt;code&gt;%esp&lt;/code&gt;指向的就是调用函数后面的那条指令的地址，&lt;code&gt;retq&lt;/code&gt;会将该地址存入&lt;code&gt;%eip&lt;/code&gt;，CPU 就会继续往后执行&lt;/li&gt;
&lt;li&gt;在 64-bit 时，&lt;code&gt;ret&lt;/code&gt;会从栈中弹出四字节的地址保存到寄存器&lt;code&gt;%eip&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 32-bit 时，&lt;code&gt;ret&lt;/code&gt;会从栈中弹出两字节的地址保存到寄存器&lt;code&gt;%eip&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;int foo(int* p)
{
int x = *p;
if(!p) return x; // Either UB above or this branch is never taken
else return 0;
}
int bar()
{
int* p = nullptr;
return *p;        // Unconditional UB
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;foo(int*):
xorl    %eax, %eax
ret
bar():
retq
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Chrome 导入和导出密码</title>
      <link>https://xueqing.github.io/blog/chrome/ex_import_pwd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/chrome/ex_import_pwd/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#chrome-%E5%AF%BC%E5%85%A5%E5%92%8C%E5%AF%BC%E5%87%BA%E5%AF%86%E7%A0%81&#34;&gt;Chrome 导入和导出密码&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E7%94%A8%E5%8A%9F%E8%83%BD&#34;&gt;启用功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%BC%E5%87%BA%E5%AF%86%E7%A0%81&#34;&gt;导出密码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%BC%E5%85%A5%E5%AF%86%E7%A0%81&#34;&gt;导入密码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%87%8D%E7%BD%AE%E5%8A%9F%E8%83%BD&#34;&gt;重置功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%86%E7%A0%81%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6&#34;&gt;密码管理软件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;启用功能&#34;&gt;启用功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;进入地址栏，输入&lt;code&gt;chrome://flags/#PasswordImport&lt;/code&gt;，启用功能并重启浏览器生效&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;导出密码&#34;&gt;导出密码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;打开 Chrome，进入 [settings] — [passwords]，可看到已保存的密码列表&lt;/li&gt;
&lt;li&gt;右键点击 [Saved Passwords] 右面的图标，下拉菜单选择 [Export passwords&amp;hellip;]，选择保存的文件夹，确定&lt;/li&gt;
&lt;li&gt;为保障安全，在进行密码导出时先输入当前 Windows 用户的密码以完成身价验证，验证成功后 Chrome 才会将密码导出成以逗号分隔的 Excel 文件(CSV)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;导入密码&#34;&gt;导入密码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;打开 Chrome，进入 [settings] — [passwords]，可看到已保存的密码列表&lt;/li&gt;
&lt;li&gt;右键点击 [Saved Passwords] 右面的图标，下拉菜单选择 [Import]，选择导入的文件，确定&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重置功能&#34;&gt;重置功能&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;进入地址栏，输入&lt;code&gt;chrome://flags/#PasswordImport&lt;/code&gt;，重置功能并重启浏览器生效&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;密码管理软件&#34;&gt;密码管理软件&lt;/h2&gt;

&lt;p&gt;Lastpass、1Password（推荐）、Keepass&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Chrome 插件</title>
      <link>https://xueqing.github.io/blog/chrome/extensions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/chrome/extensions/</guid>
      <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;插件&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Infinity&lt;/td&gt;
&lt;td&gt;新标签页，还有邮件提醒、天气预报、笔记、TODO、壁纸、历史记录等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;QRImagefromURL&lt;/td&gt;
&lt;td&gt;把 Chrome 当前的网址，生成标准二维码格式图片，扫描二维码会得到网址，就可以使用扫描软件自带的浏览器进行阅读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;DotVPN&lt;/td&gt;
&lt;td&gt;免费的 VPN 代理插件，相比 ProxySwitchySharp 代理插件，DotVPN 具有很强大的数据保护功能，可以保障用户在使用 VPN 代理时的数据传输安全&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;小云插件&lt;/td&gt;
&lt;td&gt;优酷、土豆、爱奇艺、乐视网、搜狐视频、酷六、腾讯视频、等视频去广告插件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;谷歌卫星地图&lt;/td&gt;
&lt;td&gt;每天打开标签页都是随机的卫星地图，点击右下角的地球标志可切换位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;VideoHunter+&lt;/td&gt;
&lt;td&gt;可帮助用户找到正在播放视频的真实网络地址，用户可根据这个地址直接下载视频到本地计算机&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;如意淘插件&lt;/td&gt;
&lt;td&gt;查看某商品在各大商城的价格对比，以及该商品的在该商场的价格走势&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;购物党自动比价工具&lt;/td&gt;
&lt;td&gt;查看某商品在各大商城的价格对比，以及该商品的在该商场的价格走势&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Code Review 代码审查</title>
      <link>https://xueqing.github.io/blog/coolshell/code_review/codereview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/coolshell/code_review/codereview/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e4%ba%8e-cr&#34;&gt;关于 CR&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%ae%e7%9a%84&#34;&gt;目的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%89%8d%e6%8f%90&#34;&gt;前提&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9c%80%e8%a6%81%e5%81%9a%e4%bb%80%e4%b9%88&#34;&gt;需要做什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%ad%a5%e9%aa%a4&#34;&gt;步骤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e5%87%86&#34;&gt;标准&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%89%a7%e8%a1%8c&#34;&gt;执行&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%ba%8b%e5%89%8d%e5%87%86%e5%a4%87%e9%98%b6%e6%ae%b5&#34;&gt;事前准备阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%9e%e6%96%bd%e9%98%b6%e6%ae%b5&#34;&gt;实施阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%ba%8b%e5%90%8e%e8%b7%9f%e8%b8%aa&#34;&gt;事后跟踪&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9&#34;&gt;注意事项&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bb%8f%e5%b8%b8%e8%bf%9b%e8%a1%8c-cr&#34;&gt;经常进行 CR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cr-%e4%b8%8d%e8%a6%81%e5%a4%aa%e6%ad%a3%e5%bc%8f%e8%80%8c%e4%b8%94%e8%a6%81%e7%9f%ad&#34;&gt;CR 不要太正式，而且要短&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b0%bd%e5%8f%af%e8%83%bd%e7%9a%84%e8%ae%a9%e4%b8%8d%e5%90%8c%e7%9a%84%e4%ba%ba-reivew-%e4%bd%a0%e7%9a%84%e4%bb%a3%e7%a0%81&#34;&gt;尽可能的让不同的人 Reivew 你的代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bf%9d%e6%8c%81%e7%a7%af%e6%9e%81%e7%9a%84%e6%ad%a3%e9%9d%a2%e7%9a%84%e6%80%81%e5%ba%a6&#34;&gt;保持积极的正面的态度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%a6%e4%bc%9a%e4%ba%ab%e5%8f%97-cr&#34;&gt;学会享受 CR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%93%8d%e4%bd%9c&#34;&gt;操作&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%87%aa%e6%88%91%e5%ae%a1%e6%9f%a5&#34;&gt;自我审查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%80%e5%8f%91%e4%ba%92%e5%ae%a1&#34;&gt;开发互审&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8a%e7%ba%a7%e5%ae%a1%e6%9f%a5&#34;&gt;上级审查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%b2%e7%aa%81%e8%a7%a3%e5%86%b3&#34;&gt;冲突解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%99%84%e5%bd%95-%e5%ae%a1%e6%a0%b8%e8%ae%b0%e5%bd%95&#34;&gt;附录 审核记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%99%84%e5%bd%95-%e5%ae%a1%e6%a0%b8%e7%bb%93%e6%9e%9c&#34;&gt;附录 审核结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关于-cr&#34;&gt;关于 CR&lt;/h2&gt;

&lt;p&gt;代码审查(Code Review, CR)是项目进展到编码阶段非常重要的品质保证活动&lt;/p&gt;

&lt;h3 id=&#34;目的&#34;&gt;目的&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;CR 是一种用来确认方案设计和代码实现的质量保证机制，通过这个机制我们可以对代码、测试过程和注释进行检查&lt;/li&gt;
&lt;li&gt;CR 主要用来在软件工程过程中改进代码质量，通过 CR 可以达到如下目的

&lt;ul&gt;
&lt;li&gt;在项目早期发现代码中的 BUG&lt;/li&gt;
&lt;li&gt;帮助初级开发人员学习高级开发人员的经验，达到知识共享&lt;/li&gt;
&lt;li&gt;避免开发人员犯一些很常见，很普通的错误&lt;/li&gt;
&lt;li&gt;保证项目组人员的良好沟通&lt;/li&gt;
&lt;li&gt;项目或产品的代码更容易维护&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;前提&#34;&gt;前提&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;进入 CR 需要检查的条件如下

&lt;ul&gt;
&lt;li&gt;CR 人员是否理解了 CR 的概念和 CR 将做什么&lt;/li&gt;
&lt;li&gt;如果做 CR 的人员不能理解 CR 对项目成败和代码质量的重要程度，他们的做法可能就会是应付了事&lt;/li&gt;
&lt;li&gt;代码是否已经正确的 build，build 使得代码已经不存在基本语法错误&lt;/li&gt;
&lt;li&gt;我们总不希望高级开发人员或是主管将时间浪费在检查连编译都通不过的代码上吧&lt;/li&gt;
&lt;li&gt;代码执行时功能是否正确&lt;/li&gt;
&lt;li&gt;CR 人员不负责检查代码的功能是否正确，需要复查的代码必须由开发人员或质量人员负责该代码的功能的正确性&lt;/li&gt;
&lt;li&gt;Review 人员是否理解代码&lt;/li&gt;
&lt;li&gt;做复查的人员需要对该代码有一个基本的了解，其功能是什么，是哪一方面的代码，涉及到数据库或是通讯，这样才能采取针对性的检查&lt;/li&gt;
&lt;li&gt;开发人员是否对代码做了单元测试&lt;/li&gt;
&lt;li&gt;这一点也是为了保证 CR 前一些语法和功能问题已经得到解决，CR 人员可以将精力集中在代码的质量上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;需要做什么&#34;&gt;需要做什么&lt;/h3&gt;

&lt;p&gt;CR 主要检查代码中是否存在以下方面问题：
代码的一致性、编码风格、代码的安全问题、代码冗余、是否正确设计以满足需求(性能、功能）等等
以下内容参考了《&lt;a href=&#34;https://archive.org/details/softwarequalitya4909wall&#34; target=&#34;_blank&#34;&gt;Software Quality Assurance: Documentation and Reviews&lt;/a&gt;》一文中的代码检查部分&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;完整性检查(Completeness)

&lt;ul&gt;
&lt;li&gt;代码是否完全实现了设计文档中提出的功能需求&lt;/li&gt;
&lt;li&gt;代码是否已按照设计文档进行了集成和 Debug&lt;/li&gt;
&lt;li&gt;代码是否已创建了需要的数据库，包括正确的初始化数据&lt;/li&gt;
&lt;li&gt;代码中是否存在任何没有定义或没有引用到的变量、常数或数据类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一致性检查(Consistency)

&lt;ul&gt;
&lt;li&gt;代码的逻辑是否符合设计文档&lt;/li&gt;
&lt;li&gt;代码中使用的格式、符号、结构等风格是否保持一致&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正确性检查(Correctness)

&lt;ul&gt;
&lt;li&gt;代码是否符合制定的标准&lt;/li&gt;
&lt;li&gt;所有的变量都被正确定义和使用&lt;/li&gt;
&lt;li&gt;所有的注释都是准确的&lt;/li&gt;
&lt;li&gt;所有的程序调用都使用了正确的参数个数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可修改性检查(Modifiability)

&lt;ul&gt;
&lt;li&gt;代码涉及到的常量是否易于修改(如使用配置、定义为类常量、使用专门的常量类等)&lt;/li&gt;
&lt;li&gt;代码中是否包含了交叉说明或数据字典，以描述程序是如何对变量和常量进行访问的&lt;/li&gt;
&lt;li&gt;代码是否只有一个出口和一个入口(严重的异常处理除外)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可预测性检查(Predictability)

&lt;ul&gt;
&lt;li&gt;代码所用的开发语言是否具有定义良好的语法和语义&lt;/li&gt;
&lt;li&gt;是否代码避免了依赖于开发语言缺省提供的功能&lt;/li&gt;
&lt;li&gt;代码是否无意中陷入了死循环&lt;/li&gt;
&lt;li&gt;代码是否是否避免了无穷递归&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;健壮性检查(Robustness)

&lt;ul&gt;
&lt;li&gt;代码是否采取措施避免运行时错误(如数组边界溢出、被零除、值越界、堆栈溢出等)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;结构性检查(Structuredness)

&lt;ul&gt;
&lt;li&gt;程序的每个功能是否都作为一个可辩识的代码块存在&lt;/li&gt;
&lt;li&gt;循环是否只有一个入口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可追溯性检查(Traceability)

&lt;ul&gt;
&lt;li&gt;代码是否对每个程序进行了唯一标识&lt;/li&gt;
&lt;li&gt;是否有一个交叉引用的框架可以用来在代码和开发文档之间相互对应&lt;/li&gt;
&lt;li&gt;代码是否包括一个修订历史记录，记录中对代码的修改和原因都有记录&lt;/li&gt;
&lt;li&gt;是否所有的安全功能都有标识&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可理解性检查(Understandability)

&lt;ul&gt;
&lt;li&gt;注释是否足够清晰的描述每个子程序&lt;/li&gt;
&lt;li&gt;是否使用到不明确或不必要的复杂代码，它们是否被清楚的注释&lt;/li&gt;
&lt;li&gt;使用一些统一的格式化技巧(如缩进、空白等）用来增强代码的清晰度&lt;/li&gt;
&lt;li&gt;是否在定义命名规则时采用了便于记忆，反映类型等方法&lt;/li&gt;
&lt;li&gt;每个变量都定义了合法的取值范围&lt;/li&gt;
&lt;li&gt;代码中的算法是否符合开发文档中描述的数学模型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可验证性检查(Verifiability)

&lt;ul&gt;
&lt;li&gt;代码中的实现技术是否便于测试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;步骤&#34;&gt;步骤&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;代码编写者和代码审核者坐在一起，由代码编写者按照设计文档中的用例依次讲解自己负责的代码和相关逻辑

&lt;ul&gt;
&lt;li&gt;可采用从前端到后台的方式，例如从 Web 层到 DAO 层&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码审核者在此过程中可以随时提出自己的疑问，同时积极发现隐藏的 bug

&lt;ul&gt;
&lt;li&gt;对这些 bug 记录在案&lt;/li&gt;
&lt;li&gt;代码编写者修改后再次提交审核&lt;/li&gt;
&lt;li&gt;代码审核者对 bug 记录进行回验&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码讲解完毕后，代码审核者给自己安排几个小时再对代码审核一遍

&lt;ul&gt;
&lt;li&gt;代码需要一行一行静下心看。同时代码又要全面的看，以确保代码整体上设计优良&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码审核者根据审核的结果编写“审核报告”

&lt;ul&gt;
&lt;li&gt;“审核报告”中记录发现的问题及修改建议&lt;/li&gt;
&lt;li&gt;将“审核记录”和“审核结果”提交至 git&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码编写者从 git 拉取，根据“审核报告”给出的修改意见，修改好代码，有不清楚的地方可积极向代码审核者提出&lt;/li&gt;
&lt;li&gt;代码编写者 bug fix 完毕之后提交代码审核者再次进行审核

&lt;ul&gt;
&lt;li&gt;通过审核则更新审核结果并提交至 git&lt;/li&gt;
&lt;li&gt;审核通过的代码不能再进行修改，需要修改必须重新进行审核流程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码审核者把 CR 中发现的有价值的问题更新到&amp;rdquo;代码审核规范&amp;rdquo;的文档中，对于特别值得提醒的问题可群发 email 给所有技术人员&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;提示：CR 必备的文档&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;“代码审核规范”文档：记录代码应该遵循的标准&lt;/li&gt;
&lt;li&gt;代码审核者根据这些标准来 CR 代码，同时在 CR 过程中不断完善该文档&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;标准&#34;&gt;标准&lt;/h3&gt;

&lt;p&gt;代码审核的基础是 设计文档规范、代码规范、日志规范、测试代码规范。针对新增的业务场景和设计尚未有规范时应先确立规范后进行代码审核流程&lt;/p&gt;

&lt;h2 id=&#34;执行&#34;&gt;执行&lt;/h2&gt;

&lt;p&gt;一个标准的 CR 活动应该分为三个阶段&lt;/p&gt;

&lt;h3 id=&#34;事前准备阶段&#34;&gt;事前准备阶段&lt;/h3&gt;

&lt;p&gt;在一次 CR 前，对以下内容进行充分准备&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CR 的对象

&lt;ul&gt;
&lt;li&gt;在准备 CR 代码对象时，我们要注意代码的数量，如果代码量比较大，要对代码进行必要的分解，确定其中的关键代码，对关键代码进行 CR，可以达到举一反三的目的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CR 的内容

&lt;ul&gt;
&lt;li&gt;我们对代码的审查内容很多，如代码的编写是否规范（注释的书写格式、命名规范等）、技术处理规范（异常处理、日志处理、代码组织结构等）、业务实现等&lt;/li&gt;
&lt;li&gt;我们不能希望通过一次 CR 活动，完成所有这些内容的审查，因此我们必须设定本次 CR 活动内容界限，确定审查重点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;评审规范和标准

&lt;ul&gt;
&lt;li&gt;在 CR 前设计确定评审规范和标准是必要，通过规范和标准我们在审查过程中可以有据可依，有理可循，而且还可以做到标准统一&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选择 CR 活动的参与者

&lt;ul&gt;
&lt;li&gt;在 CR 开始前，必须把本次 CR 活动的对象、审查内容以及审查的规范和标准通报给所有的参与者&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选择 CR 活动的实施方式

&lt;ul&gt;
&lt;li&gt;CR 活动有很多形式可供我们选择，我们可以根据实际情况选择桌面式 CR、演示讲解式 CR、一对一的座位 CR 等等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;实施阶段&#34;&gt;实施阶段&lt;/h3&gt;

&lt;p&gt;充分的事前准备，只是做好 CR 活动的前提，在 CR 实施过程中，我们要做好以下工作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;准确记录

&lt;ul&gt;
&lt;li&gt;对于 CR 过程发现的问题，我们必须清晰准确的记录，可以使用问题点记录单，明确记录的项目和内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;讲解与提问

&lt;ul&gt;
&lt;li&gt;CR 过程中，要采用代码作者讲解和审查者提问方式。审查者不能只在发现问题时提问，同时也要根据本次审查的内容要求代码作者对某个特定问题的讲解&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逐项审查

&lt;ul&gt;
&lt;li&gt;对事前确定的审查内容，要逐项审查，不能因为时间不足等因素一扫而过&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注意气氛

&lt;ul&gt;
&lt;li&gt;实施审查时，要营造一个讨论问题、解决问题的氛围，不能把审查会搞成批判会，这样会影响相关人员的积极性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;事后跟踪&#34;&gt;事后跟踪&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;确认发现的问题

&lt;ul&gt;
&lt;li&gt;CR 结束后，对发现的问题，首先需要确定以下内容&lt;/li&gt;
&lt;li&gt;问题点的难易程度以及影响的范围&lt;/li&gt;
&lt;li&gt;解决问题的责任者和问题点修正结果的确认者&lt;/li&gt;
&lt;li&gt;解决问题点的时限&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;修正问题责任者

&lt;ul&gt;
&lt;li&gt;对于修正问题责任者，在问题点的修正过程中，要三方面内容的记录&lt;/li&gt;
&lt;li&gt;问题点的原因&lt;/li&gt;
&lt;li&gt;解决问题点的对策&lt;/li&gt;
&lt;li&gt;修正的内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;修正结果确认者

&lt;ul&gt;
&lt;li&gt;做为修正结果的确认者，必须按照事前约定的时限及时的对修正结果进行全面的确认&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;注意事项&#34;&gt;注意事项&lt;/h2&gt;

&lt;h3 id=&#34;经常进行-cr&#34;&gt;经常进行 CR&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;要 Review 的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多

&lt;ul&gt;
&lt;li&gt;建议每一个功能，每一个用例完成之后就进行审核&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西&lt;/li&gt;
&lt;li&gt;越接近软件发布的最终期限，代码也就不能改得太多

&lt;ul&gt;
&lt;li&gt;先 review 设计实现思路&lt;/li&gt;
&lt;li&gt;review 设计模式&lt;/li&gt;
&lt;li&gt;review 成形的骨干代码&lt;/li&gt;
&lt;li&gt;review完成的代码&lt;/li&gt;
&lt;li&gt;如果程序复杂的话，需要拆成几个单元或模块分别 review&lt;/li&gt;
&lt;li&gt;每次 review 的代码再 1000 行以内，时间不超过 1.5 小时&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cr-不要太正式-而且要短&#34;&gt;CR 不要太正式，而且要短&lt;/h3&gt;

&lt;p&gt;忘了那个代码评审的 Checklist 吧，走到你的同事座位跟前，像请师父一样请他坐到你的电脑面前，然后，花 5 分钟给他讲讲你的代码，给他另外一个 5 分钟让他给你的代码提提意见，这比什么都好。而如果你用了一个 Checklist，让这个事情表现得很正式的话，下面两件事中必有一件事会发生：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;只有在 Checklist 上存在的东西才会被 Review&lt;/li&gt;
&lt;li&gt;CR 变成了一种礼节性的东西，你的同事会装做很关心你的代码，但其实他心里想着尽快地离开你&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有不正式的 CR 才会让你和评审者放轻松，人只有放松了，才会表现得很真实，很真诚。记住R eview 只不过是一种形式，而只有在相互信任中通过相互的讨论得到了有意义和有建设性的建议和意见，那才是最实在的。不然，作者和评审者的关系就会变成小偷和警察的关系。&lt;/p&gt;

&lt;h3 id=&#34;尽可能的让不同的人-reivew-你的代码&#34;&gt;尽可能的让不同的人 Reivew 你的代码&lt;/h3&gt;

&lt;p&gt;如果可能的话，不要总是只找一个人来 Review 你的代码，不同的人有不同的思考方式，有不同的见解，所以，不同的人可以全面的从各个方面评论你的代码。
但不要太多了，人多嘴杂反而适得其反，基本上来说，不要超过3个人，这是因为，这是一个可以围在一起讨论的最大人员尺寸。&lt;/p&gt;

&lt;p&gt;下面是几个优点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;从不同的方向（实现、需求、用户使用、算法、性能效率、易读性、扩展性）评审代码总是好的&lt;/li&gt;
&lt;li&gt;会有更多的人帮你在日后维护你的代码&lt;/li&gt;
&lt;li&gt;这也是一个增加团队凝聚力的方法&lt;/li&gt;
&lt;li&gt;不要超过 3 个人，减少讨论的代价&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;保持积极的正面的态度&#34;&gt;保持积极的正面的态度&lt;/h3&gt;

&lt;p&gt;程序员最大的问题就是“自负”，尤其当我们 Reivew 别人的代码的时候，我已经见过无数的场面，程序员在 CR 的时候，开始抨击别人的代码，质疑别人的能力。太可笑了，我分析了一下，这类的程序员其实并没有什么本事，因为他们指责对方的目的是想告诉大家自己有多么的牛，靠这种手段来表现自己的程序员，其实是就是传说中所说的“半瓶水”。&lt;/p&gt;

&lt;p&gt;所以，无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！&lt;/p&gt;

&lt;h3 id=&#34;学会享受-cr&#34;&gt;学会享受 CR&lt;/h3&gt;

&lt;p&gt;这可能是最重要的一个提示了，如果你到了一个人人都喜欢 CR 的团队，那么你会进入到一个生机勃勃的地方，在那里，每个人都能写出质量非常好的代码，在那里，你不需要经理的管理，团队会自适应一切变化，他们相互学习，相互帮助，不仅仅是写出好的代码，而且团队和其中的每个人都会自动进化，最关键的是，这个是一个团队&lt;/p&gt;

&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;

&lt;h3 id=&#34;自我审查&#34;&gt;自我审查&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;提交代码前自我审查，添加对代码的说明

&lt;ul&gt;
&lt;li&gt;所有团队成员先进行自我审查，除了检查代码的正确性以外，还可以完成&lt;/li&gt;
&lt;li&gt;对代码添加注释，说明本次修改背后的原因，方便其他人进行审查&lt;/li&gt;
&lt;li&gt;修正编码风格，尤其是一些关键数据和方法的命名，提高代码的可读性&lt;/li&gt;
&lt;li&gt;从全局审视设计，是否完整的考虑了所有情景&lt;/li&gt;
&lt;li&gt;提交自己的单元测试报告&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;开发互审&#34;&gt;开发互审&lt;/h3&gt;

&lt;p&gt;任意两名开发人员（建议不要固定配对，避免思维定式）进行交叉代码审查&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;代码编写者：

&lt;ul&gt;
&lt;li&gt;准备所开发的代码相关的全部资料列表：需求、设计文档、代码工程、类、方法、配置文件、数据库修改等全部资料的版本号等详细信息&lt;/li&gt;
&lt;li&gt;向代码审查者全面介绍代码的目标和设计实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码审查者

&lt;ul&gt;
&lt;li&gt;根据需求文档、设计文档、开发规范进行代码审查（业务、日志、测试）&lt;/li&gt;
&lt;li&gt;将审查结果提交至 git&lt;/li&gt;
&lt;li&gt;代码编写者对问题进行修改并由代码审查者复审，复审结果提交至 git 保留&lt;/li&gt;
&lt;li&gt;代码审查者对审查的代码负责&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;上级审查&#34;&gt;上级审查&lt;/h3&gt;

&lt;p&gt;开发互审完成后，由上级进行上级审查，流程与开发互审相同，对于三次复审仍未通过的代码需要代码编写者进行组内检讨问题原因，并书面列出改进计划&lt;/p&gt;

&lt;h3 id=&#34;冲突解决&#34;&gt;冲突解决&lt;/h3&gt;

&lt;p&gt;当开发互审对于检查内容出现争议时由上级进行协调解决或逐级向上协调解决&lt;/p&gt;

&lt;h2 id=&#34;附录-审核记录&#34;&gt;附录 审核记录&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;审核记录如同修改记录一样，直接记录入代码头部，代码审核者修改审核记录后提交代码至 git 参考即可&lt;/li&gt;
&lt;li&gt;之后的审核可以基于两次审核间的变更利用对比工具进行增量审核&lt;/li&gt;

&lt;li&gt;&lt;p&gt;示例如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
* 名称：xxxxx类
* 创建者：xx
* 创建时间：2018-12-07
* 创建描述：实现xxxxxx
* 修改者：xxx
* 修改时间：2018-12-08
* 修改描述：添加xxx，修改xxx
* 审核者：xxx
* 审核时间：2018-12-08
* 审核描述：审核通过
* 审核者：xxx
* 审核时间：2018-12-09
* 审核描述：审核不通过，xxxxxxxxxxxxx
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;附录-审核结果&#34;&gt;附录 审核结果&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;审核结果建议以表格的形式描述，每个问题分别列出&lt;/li&gt;
&lt;li&gt;可通过标注行号来具体执行位置，给出合理的修改意见并说明标准&lt;/li&gt;

&lt;li&gt;&lt;p&gt;审核结果写入 commit message 中，以软表格的形式描述&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;docs(代码审核)：审核通过
docs(代码审核)：审核失败
1 日志不符合规范
问题：没有使用 log4j2，日志不规范
建议：建议使用 log4j2，包括包引用和代码修改
行号：53 行
2 命名不符合规范
问题：log 命名不符合规范
建议：修改为 logger
行号： 53 行
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>code_review 预研</title>
      <link>https://xueqing.github.io/blog/coolshell/code_review/code_review/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/coolshell/code_review/code_review/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://coolshell.cn/articles/1302.html&#34; target=&#34;_blank&#34;&gt;code_review 中的几个提示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coolshell.cn/articles/11432.html&#34; target=&#34;_blank&#34;&gt;从 code_review 谈如何做技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://coolshell.cn/articles/1218.html&#34; target=&#34;_blank&#34;&gt;简单实用的 code_review 工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.reviewboard.org/&#34; target=&#34;_blank&#34;&gt;Review board&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;追踪待决代码的改动，并可以让 Code-Review 更为容易和简练&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://codestriker.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;Codestriker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://groogle.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;Groogle&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;各式各样语言的语法高亮&lt;/li&gt;
&lt;li&gt;支持整个版本树的比较&lt;/li&gt;
&lt;li&gt;支持当个文件不同版本的 diff 功能，并有一个图形的版本树&lt;/li&gt;
&lt;li&gt;邮件通知所有的 Reivew 的人当前的状态&lt;/li&gt;
&lt;li&gt;认证机制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://code.google.com/p/rietveld/&#34; target=&#34;_blank&#34;&gt;Rietveld&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://jcodereview.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;JCR&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;主要面对的是大型的项目，或是非常正式的代码评审&lt;/li&gt;
&lt;li&gt;主要想协助：&lt;/li&gt;
&lt;li&gt;审查者：所有的代码更改会被高亮，以及大多数语言的语法高亮。Code extracts 可以显示代码评审意见。如果你正在 Review Java 的代码，你可以点击代码中的类名来查看相关的类的声明&lt;/li&gt;
&lt;li&gt;项目所有者。可以轻松创建并配置需要 Review 的项目，并不需要集成任何的软件配置管理系统（SCM）&lt;/li&gt;
&lt;li&gt;流程信仰者。所有的评语都会被记录在数据库中，并且会有状态报告，以及各种各样的统计&lt;/li&gt;
&lt;li&gt;架构师和开发者。这个系统也可以让我们查看属于单个文件的评语，这样有利于我们重构代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://code.google.com/archive/p/jupiter-eclipse-plugin&#34; target=&#34;_blank&#34;&gt;Jupiter&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;是一个 Eclipse IDE 的插件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;风格检查工具：PC-Lint&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43;, 3rd</title>
      <link>https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%e8%ae%a9%e8%87%aa%e5%b7%b1%e4%b9%a0%e6%83%af-c&#34;&gt;1.让自己习惯 C++&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#01%e8%a7%86-c-%e4%b8%ba%e4%b8%80%e4%b8%aa%e8%af%ad%e8%a8%80%e8%81%94%e9%82%a6&#34;&gt;01.视 C++ 为一个语言联邦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#02%e5%b8%b8%e9%87%8f%e6%9e%9a%e4%b8%be%e5%92%8c%e5%86%85%e8%81%94%e4%bc%98%e4%ba%8e%e5%ae%8f%e5%ae%9a%e4%b9%89&#34;&gt;02.常量，枚举和内联优于宏定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#03%e5%b0%bd%e5%8f%af%e8%83%bd%e4%bd%bf%e7%94%a8%e5%b8%b8%e9%87%8f&#34;&gt;03.尽可能使用常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#04%e7%a1%ae%e5%ae%9a%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%bd%bf%e7%94%a8%e5%89%8d%e5%b7%b2%e5%85%88%e8%a2%ab%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;04.确定对象被使用前已先被初始化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%e6%9e%84%e9%80%a0%e6%9e%90%e6%9e%84%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97&#34;&gt;2.构造/析构/赋值运算&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#05%e4%ba%86%e8%a7%a3-c-%e9%bb%98%e9%bb%98%e7%bc%96%e5%86%99%e5%b9%b6%e8%b0%83%e7%94%a8%e5%93%aa%e4%ba%9b%e5%87%bd%e6%95%b0&#34;&gt;05.了解 C++ 默默编写并调用哪些函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#06%e6%98%8e%e7%a1%ae%e6%8b%92%e7%bb%9d%e4%b8%8d%e6%83%b3%e7%94%a8%e7%9a%84%e7%bc%96%e8%af%91%e5%99%a8%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e7%9a%84%e5%87%bd%e6%95%b0&#34;&gt;06.明确拒绝不想用的编译器自动生成的函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#07%e5%a3%b0%e6%98%8e%e5%a4%9a%e6%80%81%e5%9f%ba%e7%b1%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%ba%e8%99%9a%e5%87%bd%e6%95%b0&#34;&gt;07.声明多态基类析构函数为虚函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#08%e5%88%ab%e8%ae%a9%e5%bc%82%e5%b8%b8%e9%80%83%e7%a6%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0&#34;&gt;08.别让异常逃离析构函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#09%e7%bb%9d%e4%b8%8d%e5%9c%a8%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e8%b0%83%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0&#34;&gt;09.绝不在构造和析构过程中调用虚函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10%e4%bd%bf-operator-%e8%bf%94%e5%9b%9e%e4%b8%80%e4%b8%aa-this-%e7%9a%84%e5%bc%95%e7%94%a8&#34;&gt;10.使 operator= 返回一个 *this 的引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11%e5%9c%a8-operator-%e4%b8%ad%e5%a4%84%e7%90%86%e8%87%aa%e6%88%91%e8%b5%8b%e5%80%bc&#34;&gt;11.在 operator= 中处理“自我赋值”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12%e5%a4%8d%e5%88%b6%e5%af%b9%e8%b1%a1%e7%9a%84%e6%89%80%e6%9c%89%e9%83%a8%e5%88%86&#34;&gt;12.复制对象的所有部分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86&#34;&gt;3.资源管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#13%e4%bb%a5%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86%e8%b5%84%e6%ba%90&#34;&gt;13.以对象管理资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e5%b0%8f%e5%bf%83%e5%a4%8d%e5%88%b6%e8%a1%8c%e4%b8%ba&#34;&gt;14.在资源管理类中小心复制行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e6%8f%90%e4%be%9b%e5%af%b9%e5%8e%9f%e5%a7%8b%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%bf%e9%97%ae&#34;&gt;15.在资源管理类中提供对原始资源的访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16%e5%9c%a8%e5%af%b9%e5%ba%94%e7%9a%84-new-%e5%92%8c-delete-%e9%87%87%e7%94%a8%e7%9b%b8%e5%90%8c%e5%bd%a2%e5%bc%8f&#34;&gt;16.在对应的 new 和 delete 采用相同形式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#17-%e4%bb%a5%e7%8b%ac%e7%ab%8b%e8%af%ad%e5%8f%a5%e5%b0%86-newed-%e5%af%b9%e8%b1%a1%e4%bf%9d%e5%ad%98%e5%88%b0%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88&#34;&gt;17. 以独立语句将 newed 对象保存到智能指针&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%a3%b0%e6%98%8e&#34;&gt;4.设计与声明&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#18%e8%ae%a9%e6%8e%a5%e5%8f%a3%e6%98%93%e8%a2%ab%e6%ad%a3%e5%b8%b8%e4%bd%bf%e7%94%a8%e4%b8%8d%e6%98%93%e8%a2%ab%e8%af%af%e7%94%a8&#34;&gt;18.让接口易被正常使用，不易被误用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#19%e6%8a%8a%e7%b1%bb%e8%ae%be%e8%ae%a1%e7%9c%8b%e4%bd%9c%e7%b1%bb%e5%9e%8b%e8%ae%be%e8%ae%a1&#34;&gt;19.把类设计看作类型设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#20%e5%b8%b8%e9%87%8f%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92%e4%bc%98%e4%ba%8e%e5%80%bc%e4%bc%a0%e9%80%92&#34;&gt;20.常量引用传递优于值传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#21%e5%bf%85%e9%a1%bb%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e6%97%b6%e4%b8%8d%e8%a6%81%e8%bf%94%e5%9b%9e%e5%bc%95%e7%94%a8&#34;&gt;21.必须返回对象时，不要返回引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22%e5%a3%b0%e6%98%8e%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98%e4%b8%ba%e7%a7%81%e6%9c%89%e7%9a%84&#34;&gt;22.声明数据成员为私有的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e4%bc%98%e4%ba%8e%e9%9d%9e%e6%88%90%e5%91%98%e9%9d%9e%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0&#34;&gt;23.成员函数优于非成员、非友元函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24%e5%bd%93%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e9%9c%80%e5%ba%94%e7%94%a8%e5%88%b0%e6%89%80%e6%9c%89%e5%8f%82%e6%95%b0%e5%a3%b0%e6%98%8e%e4%b8%ba%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;24.当类型转换需应用到所有参数，声明为非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25%e8%80%83%e8%99%91%e6%94%af%e6%8c%81%e4%b8%8d%e6%8a%9b%e5%bc%82%e5%b8%b8%e7%9a%84-swap-%e5%87%bd%e6%95%b0&#34;&gt;25.考虑支持不抛异常的 swap 函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%e5%ae%9e%e7%8e%b0&#34;&gt;5.实现&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#26%e5%b0%bd%e5%8f%af%e8%83%bd%e6%8e%a8%e8%bf%9f%e5%8f%98%e9%87%8f%e5%ae%9a%e4%b9%89&#34;&gt;26.尽可能推迟变量定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27%e6%9c%80%e5%b0%8f%e5%8c%96-cast-%e6%93%8d%e4%bd%9c&#34;&gt;27.最小化 cast 操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28%e9%81%bf%e5%85%8d%e8%bf%94%e5%9b%9e%e6%8c%87%e5%90%91%e5%af%b9%e8%b1%a1%e5%86%85%e9%83%a8%e7%9a%84%e5%8f%a5%e6%9f%84&#34;&gt;28.避免返回指向对象内部的句柄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29%e5%8a%aa%e5%8a%9b%e5%86%99%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8%e7%9a%84%e4%bb%a3%e7%a0%81&#34;&gt;29.努力写异常安全的代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#30%e4%ba%86%e8%a7%a3%e5%86%85%e8%81%94%e7%9a%84%e7%bb%86%e8%8a%82&#34;&gt;30.了解内联的细节&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#31%e6%9c%80%e5%b0%8f%e5%8c%96%e6%96%87%e4%bb%b6%e7%bc%96%e8%af%91%e4%be%9d%e8%b5%96&#34;&gt;31.最小化文件编译依赖&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%e7%bb%a7%e6%89%bf%e4%b8%8e%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1&#34;&gt;6.继承与面向对象设计&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#32%e7%a1%ae%e4%bf%9d%e5%85%ac%e6%9c%89%e7%bb%a7%e6%89%bf%e6%98%af%22is-a%22%e5%85%b3%e7%b3%bb&#34;&gt;32.确保公有继承是&amp;rdquo;is-a&amp;rdquo;关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33%e9%81%bf%e5%85%8d%e9%9a%90%e8%97%8f%e7%bb%a7%e6%89%bf%e7%9a%84%e5%90%8d%e5%ad%97&#34;&gt;33.避免隐藏继承的名字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34%e5%8c%ba%e5%88%86%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf%e5%92%8c%e5%ae%9e%e7%8e%b0%e7%bb%a7%e6%89%bf&#34;&gt;34.区分接口继承和实现继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#35%e8%80%83%e8%99%91%e8%99%9a%e5%87%bd%e6%95%b0%e7%9a%84%e6%9b%bf%e4%bb%a3&#34;&gt;35.考虑虚函数的替代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#36%e7%bb%9d%e4%b8%8d%e9%87%8d%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e7%9a%84%e9%9d%9e%e8%99%9a%e5%87%bd%e6%95%b0&#34;&gt;36.绝不重定义继承的非虚函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#37%e7%bb%9d%e4%b8%8d%e9%87%8d%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0%e7%bb%a7%e6%89%bf%e7%9a%84%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0%e5%80%bc&#34;&gt;37.绝不重定义函数继承的默认参数值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#38%e9%80%9a%e8%bf%87%e7%bb%84%e5%90%88%e5%af%b9%22has-a%22%e6%88%96%22is-implemented-in-terms-of%22%e5%bb%ba%e6%a8%a1&#34;&gt;38.通过组合对&amp;rdquo;has-a&amp;rdquo;或&amp;rdquo;is-implemented-in-terms-of&amp;rdquo;建模&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#39%e6%85%8e%e9%87%8d%e4%bd%bf%e7%94%a8%e7%a7%81%e6%9c%89%e7%bb%a7%e6%89%bf&#34;&gt;39.慎重使用私有继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#40%e6%85%8e%e9%87%8d%e4%bd%bf%e7%94%a8%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf&#34;&gt;40.慎重使用多重继承&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%e6%a8%a1%e6%9d%bf%e4%b8%8e%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b&#34;&gt;7.模板与泛型编程&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41%e7%90%86%e8%a7%a3%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%bc%96%e8%af%91%e6%9c%9f%e5%a4%9a%e6%80%81&#34;&gt;41.理解隐式接口和编译期多态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42%e7%90%86%e8%a7%a3-typename-%e7%9a%84%e5%8f%8c%e9%87%8d%e5%ae%9a%e4%b9%89&#34;&gt;42.理解 typename 的双重定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43%e4%ba%86%e8%a7%a3%e5%a6%82%e4%bd%95%e8%ae%bf%e9%97%ae%e6%a8%a1%e6%9d%bf%e5%8c%96%e5%9f%ba%e7%b1%bb%e5%86%85%e7%9a%84%e5%90%8d%e7%a7%b0&#34;&gt;43.了解如何访问模板化基类内的名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44%e6%8a%8a%e5%8f%82%e6%95%b0%e6%97%a0%e5%85%b3%e7%9a%84%e4%bb%a3%e7%a0%81%e5%88%86%e7%a6%bb%e5%87%ba%e6%a8%a1%e6%9d%bf&#34;&gt;44.把参数无关的代码分离出模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45%e4%bd%bf%e7%94%a8%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e6%9d%a5%e6%8e%a5%e5%8f%97%e6%89%80%e6%9c%89%e5%85%bc%e5%ae%b9%e7%b1%bb%e5%9e%8b&#34;&gt;45.使用成员函数模板来接受“所有兼容类型”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#46%e9%9c%80%e8%a6%81%e7%b1%bb%e5%9e%8b%e8%bd%ac%e5%8c%96%e6%97%b6%e5%9c%a8%e6%a8%a1%e6%9d%bf%e5%86%85%e5%ae%9a%e4%b9%89%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;46.需要类型转化时在模板内定义非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#47%e4%bd%bf%e7%94%a8-traits-class-%e8%a1%a8%e7%8e%b0%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af&#34;&gt;47.使用 traits class 表现类型信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#48-%e8%ae%a4%e8%af%86%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b&#34;&gt;48. 认识模板元编程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%e5%ae%9a%e5%88%b6-new-%e5%92%8c-delete&#34;&gt;8.定制 new 和 delete&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#49%e7%90%86%e8%a7%a3-new-handler-%e7%9a%84%e8%a1%8c%e4%b8%ba&#34;&gt;49.理解 new-handler 的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#50%e7%90%86%e8%a7%a3%e4%bd%95%e6%97%b6%e6%9b%bf%e6%8d%a2-new-%e5%92%8c-delete-%e6%9c%89%e6%84%8f%e4%b9%89&#34;&gt;50.理解何时替换 new 和 delete 有意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#51%e5%86%99-new-%e5%92%8c-delete-%e6%97%b6%e9%81%b5%e5%be%aa%e6%83%af%e4%be%8b&#34;&gt;51.写 new 和 delete 时遵循惯例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52%e5%86%99%e4%ba%86-placement-new-%e4%b9%9f%e8%a6%81%e5%86%99-placement-delete&#34;&gt;52.写了 placement new 也要写 placement delete&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%e6%9d%82%e9%a1%b9%e8%ae%a8%e8%ae%ba&#34;&gt;9.杂项讨论&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#53%e6%b3%a8%e6%84%8f%e7%bc%96%e8%af%91%e5%99%a8%e8%ad%a6%e5%91%8a&#34;&gt;53.注意编译器警告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54%e7%86%9f%e6%82%89%e5%8c%85%e6%8b%ac-tr1-%e5%9c%a8%e5%86%85%e7%9a%84%e6%a0%87%e5%87%86%e5%ba%93&#34;&gt;54.熟悉包括 TR1 在内的标准库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#55%e7%86%9f%e6%82%89-boost&#34;&gt;55.熟悉 Boost&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-让自己习惯-c&#34;&gt;1.让自己习惯 C++&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Accustoming yourself to C++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;01-视-c-为一个语言联邦&#34;&gt;01.视 C++ 为一个语言联邦&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;View C++ as a federation of languages&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;面向对象的 C++：类、封装、继承、多态&lt;/li&gt;
&lt;li&gt;模板 C++：泛型编程&lt;/li&gt;
&lt;li&gt;STL：模板库&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;02-常量-枚举和内联优于宏定义&#34;&gt;02.常量，枚举和内联优于宏定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer consts, enums, inlines to #defines&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;对于单纯常量，以 const 对象或枚举&lt;/li&gt;
&lt;li&gt;对于形似函数的宏，用内联函数替换

&lt;ul&gt;
&lt;li&gt;常量、枚举和内联更具封装性，可以限定作用域&lt;/li&gt;
&lt;li&gt;枚举比常量约束更多，不能为该常量创建指针或引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;03-尽可能使用常量&#34;&gt;03.尽可能使用常量&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use const whenever possible&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;指定语义约束，即“不该被改动”的对象

&lt;ul&gt;
&lt;li&gt;可帮助编译器侦测错误用法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;const 在 * 左边，表示被指物是常量

&lt;ul&gt;
&lt;li&gt;也可将 const 放在类型之前&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;const widget *pw&lt;/code&gt;等同于&lt;code&gt;widget const *pw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针所指东西不可被改动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;const 在 * 右边，表示指针自身是常量

&lt;ul&gt;
&lt;li&gt;指针不得指向不同的东西，但所指东西的值可以改动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;const 在 * 两侧，表示被指物和指针自身都是常量&lt;/li&gt;
&lt;li&gt;const 成员函数

&lt;ul&gt;
&lt;li&gt;可作用于 const 对象，不可更改对象内任何非静态成员变量&lt;/li&gt;
&lt;li&gt;成员变量前加&lt;code&gt;mutable&lt;/code&gt;，也可在 const 成员函数内部修改该成员变量&lt;/li&gt;
&lt;li&gt;当 const 和 non-const 成员函数有着实质等价的实现时，另 non-const 版本调用 const 版本避免代码重复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;04-确定对象被使用前已先被初始化&#34;&gt;04.确定对象被使用前已先被初始化&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Make sure that objects are initialized before they&amp;rsquo;re used&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;对于内置类型手动初始化&lt;/li&gt;
&lt;li&gt;对于类，在构造函数中初始化成员变量

&lt;ul&gt;
&lt;li&gt;赋值不等于初始化&lt;/li&gt;
&lt;li&gt;使用成员初始化列表列替换赋值动作，前者效率更高，后者先设初值再赋值&lt;/li&gt;
&lt;li&gt;可使用无参数构造函数来初始化&lt;/li&gt;
&lt;li&gt;对于多个构造函数，可添加私有成员函数，接收初始化参数，在函数内部使用赋值操作给成员变量“初始化”&lt;/li&gt;
&lt;li&gt;初始化顺序&lt;/li&gt;
&lt;li&gt;先基类再衍生类&lt;/li&gt;
&lt;li&gt;类内部，按照声明的顺序初始化，与成员初始化列表列操作顺序无关&lt;/li&gt;
&lt;li&gt;最好按照声明顺序初始化&lt;/li&gt;
&lt;li&gt;不同编译单元内的 non-local static 对象的初始化顺序未定义

&lt;ul&gt;
&lt;li&gt;static 对象包括全局对象、定义于命名空间作用域内的对象、类内、函数内，以及在文件作用域内被声明为 static 的对象&lt;/li&gt;
&lt;li&gt;函数内的 static 对象称为 local-static 对象，其他的则是 non-local static 对象&lt;/li&gt;
&lt;li&gt;程序结束时 static 对象会被自动销毁，即在 main 函数结束时调用他们的析构函数&lt;/li&gt;
&lt;li&gt;编译单元是产出单一目标文件的源码&lt;/li&gt;
&lt;li&gt;将每个 non-local static 对象移到自己的专属函数内，改函数返回对该对象的引用，保证该函数被调用期间，首次遇到该对象的定义时被初始化，即以函数调用替换直接访问 non-local static 对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-构造-析构-赋值运算&#34;&gt;2.构造/析构/赋值运算&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Contructors, destructors, and assignments operators&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;05-了解-c-默默编写并调用哪些函数&#34;&gt;05.了解 C++ 默默编写并调用哪些函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Know what functions C++ silently writes and calls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;编译器自动为类创建默认构造函数、拷贝构造函数、拷贝赋值操作和析构函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;06-明确拒绝不想用的编译器自动生成的函数&#34;&gt;06.明确拒绝不想用的编译器自动生成的函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Explicitly disallow the use of complier-generated functions you do not want&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果不想用编译器自动生成的函数，可将相应的成员函数声明为 private 并且不予实现&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以继承 Uncopyable 这样的基类，但是可能会多重继承&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Uncopyable {
protected: // allow constructor and destructor for derived object
Uncopyable() {}
~Uncopyable() {}
private:
Uncopyable(const Uncopyable&amp;amp;); //avoid copying
Uncopyable&amp;amp; operator=(const Uncopyable&amp;amp;);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;07-声明多态基类析构函数为虚函数&#34;&gt;07.声明多态基类析构函数为虚函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Declare destructors virtual in polymorphic base classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;包含虚函数的类需要额外的信息来实现虚函数：vptr(virtual table pointer)指向一个由函数指针构成的数组，称为 vtbl(virtual table)，每个有虚函数的类都有一个相应的 vtbl&lt;/li&gt;
&lt;li&gt;析构顺序：先父类再子类，构造函数的调用顺序相反&lt;/li&gt;
&lt;li&gt;带有多态性质的基类应声明一个虚析构函数&lt;/li&gt;
&lt;li&gt;如果一个类带有任何虚函数，就声明一个虚析构函数&lt;/li&gt;
&lt;li&gt;类的设计目的不是作为基类使用，或者不是为了多态性，不应该声明虚析构函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;08-别让异常逃离析构函数&#34;&gt;08.别让异常逃离析构函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prevent exceptions from leaving destructors&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果析构函数内可能抛出异常，应该在析构函数内捕获异常，然后不传播或结束程序&lt;/li&gt;
&lt;li&gt;如果需要客户自定义异常的反应，类应该提供接口执行该操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;09-绝不在构造和析构过程中调用虚函数&#34;&gt;09.绝不在构造和析构过程中调用虚函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Never call virtual functions during construction or destruction&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;在构造和析构中不要调用虚函数没因为这类调用不会下降到衍生类，即调用的仍然是基类的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;10-使-operator-返回一个-this-的引用&#34;&gt;10.使 operator= 返回一个 *this 的引用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Having assignment operators return a reference to *this&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;赋值相关运算(包括 operator=/+=、-=、*=)操作符返回一个 *this 的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-在-operator-中处理-自我赋值&#34;&gt;11.在 operator= 中处理“自我赋值”&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Handle assignment to self in operator=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;确保对象自我赋值时，operator= 行为良好，包括比较源对象和目标对象的地址、精心周到的语句顺序(先复制源对象，再执行删除)，以及icopy-and-swap&lt;/li&gt;
&lt;li&gt;确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，行为仍然正确&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;12-复制对象的所有部分&#34;&gt;12.复制对象的所有部分&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Copy all parts of an object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;拷贝构造函数和拷贝赋值操作符都是 copying 函数&lt;/li&gt;
&lt;li&gt;copying 函数应该确保复制“对象内的所有成员变量”和“所有基类成分”&lt;/li&gt;
&lt;li&gt;不要尝试以某个 copying 函数实现另一个 copying 函数，应该将相同的东西抽象成一个函数，二者都调用这个函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-资源管理&#34;&gt;3.资源管理&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Resource management&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;13-以对象管理资源&#34;&gt;13.以对象管理资源&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use objects to manage resources&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;为防止内存泄漏，建议使用 RAII(Resource Acquisition Is Initialization，资源取得时机就是初始化时机) 对象，它们在构造函数中获得资源并在析构函数中释放资源&lt;/li&gt;
&lt;li&gt;常用的 RAII 类是 shared_ptr 和 auto_ptr。前者的拷贝行为比较直观，后者的复制动作会转移资源的所有权：shared_ptr 有引用计数，但是无法打破环装引用&lt;/li&gt;
&lt;li&gt;参考&lt;a href=&#34;./smart_ptr.md&#34;&gt;智能指针&lt;/a&gt;一文&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-在资源管理类中小心复制行为&#34;&gt;14.在资源管理类中小心复制行为&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Think carefully about copying behavior in resource-managing classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;复制 RAII 对象必须一并复制它锁管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为&lt;/li&gt;
&lt;li&gt;一般情况下，RAII 类的 copying 行为是：阻止 copying、实行引用计数法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;15-在资源管理类中提供对原始资源的访问&#34;&gt;15.在资源管理类中提供对原始资源的访问&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Provide access to raw resources in resource-managing classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;APIs 往往要求访问原始资源，所以每一个 RAII 类应该提供一个接口可以获得其管理的资源&lt;/li&gt;
&lt;li&gt;对原始资源的访问可以是显示转换或隐式转换：一般显示转换比较安全，隐式转换对客户比较方便&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;16-在对应的-new-和-delete-采用相同形式&#34;&gt;16.在对应的 new 和 delete 采用相同形式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use the same form in corresponding uses of new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;调用 new 时使用&lt;code&gt;[]&lt;/code&gt;，那么对应调用 delete 时也调用&lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 new 时没有使用&lt;code&gt;[]&lt;/code&gt;，那么也不该在调用 delete 时使用&lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;17-以独立语句将-newed-对象保存到智能指针&#34;&gt;17. 以独立语句将 newed 对象保存到智能指针&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Store newed onjects in smart pointers in standalone statements&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;以独立语句将 newed 对象保存在智能指针内。否则，抛出异常的时候，可能会导致内存泄漏&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-设计与声明&#34;&gt;4.设计与声明&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Designs and declarations&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;18-让接口易被正常使用-不易被误用&#34;&gt;18.让接口易被正常使用，不易被误用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Make interfaces easy to use correctly and hard to use incorrectly&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容&lt;/li&gt;
&lt;li&gt;“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任&lt;/li&gt;
&lt;li&gt;shared_ptr 支持自定义删除器，可以防止 DLL 问题，可被用来自动解除互斥锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;19-把类设计看作类型设计&#34;&gt;19.把类设计看作类型设计&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Treat class design as type design&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;在设计一个类之前，考虑以下问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新类型的对象如何被创建和销毁&lt;/li&gt;
&lt;li&gt;对象的初始化和对象的赋值该有什么样的差别：区分构造函数和赋值操作符的行为&lt;/li&gt;
&lt;li&gt;新类型的对象如果以值传递，意味着什么：取决于拷贝构造函数&lt;/li&gt;
&lt;li&gt;什么是新类型的“合法值”：确定需要做的错误检查工作&lt;/li&gt;
&lt;li&gt;新类型需要配合某个继承图系吗：受继承类的约束，如果允许被继承，析构函数是否为虚函数&lt;/li&gt;
&lt;li&gt;新类型需要什么样的转换：显示类型转换和隐式类型转换&lt;/li&gt;
&lt;li&gt;什么样的操作符和函数对此新类型是合理的：确定需要声明的函数，哪些是成员函数，哪些不是成员函数&lt;/li&gt;
&lt;li&gt;谁该调用新类型的成员：确定成员的属性(public/protected/private)，也确定类之间的关系(所属，友元)&lt;/li&gt;
&lt;li&gt;什么是新类型的未声明接口&lt;/li&gt;
&lt;li&gt;新类型有多一般化：是否需要定义一个模板类&lt;/li&gt;
&lt;li&gt;真的需要一个新类型吗：是否可以为已有类添加非成员函数或模板来实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;20-常量引用传递优于值传递&#34;&gt;20.常量引用传递优于值传递&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer pass-by-reference-to-const to pass-by-value&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;值传递效率低，而且可能造成对象切割(slicing)：值传递一个衍生类对象时，如果函数声明的是基类，那么调用的是基类的拷贝构造函数&lt;/li&gt;
&lt;li&gt;C++ 编译器底层使用指针实现，不同情形使用不同的方式

&lt;ul&gt;
&lt;li&gt;内置类型(如 int)采用值传递&lt;/li&gt;
&lt;li&gt;STL 的迭代器和函数对象使用值传递&lt;/li&gt;
&lt;li&gt;其他的采用常量引用传递&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;21-必须返回对象时-不要返回引用&#34;&gt;21.必须返回对象时，不要返回引用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t try to return a reference when you must return an object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;绝不要返回指针或引用指向一个 local stack 对象&lt;/li&gt;
&lt;li&gt;绝不要返回引用指向一个 heap-allocated 对象&lt;/li&gt;
&lt;li&gt;绝不要返回指针或引用指向一个 local static 对象而有可能同时需要多个这样的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;22-声明数据成员为私有的&#34;&gt;22.声明数据成员为私有的&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Declare data memebers private&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;语法一致性：public 接口内的所有东西都是函数&lt;/li&gt;
&lt;li&gt;可细微划分访问控制、允诺约束条件获得保证&lt;/li&gt;
&lt;li&gt;protected 并不比 public 更具封装性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;23-成员函数优于非成员-非友元函数&#34;&gt;23.成员函数优于非成员、非友元函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer non-member non-friend functions to member function&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;将所有功能函数放在多个头文件内但隶属同一命名空间，使用者可以轻松扩展这一组功能函数

&lt;ul&gt;
&lt;li&gt;在命名空间添加非成员非友元函数，以便为使用者提供方便的接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;优先考虑非成员、非友元函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;24-当类型转换需应用到所有参数-声明为非成员函数&#34;&gt;24.当类型转换需应用到所有参数，声明为非成员函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Declare non-member functions when type conversions should apply to all parameters&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果需要为某个函数的所有参数(包括被 this 指针所指的隐喻参数)进行类型转换，那么这个函数必须是非成员函数

&lt;ul&gt;
&lt;li&gt;编译器可对每一个实参执行隐式类型转换&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;25-考虑支持不抛异常的-swap-函数&#34;&gt;25.考虑支持不抛异常的 swap 函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Consider support for a non-throwing swap&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果 std::swap 缺省实现对自定义的类或类模板的效率不足，试着做

&lt;ul&gt;
&lt;li&gt;提供一个 public swap 成员函数，在函数内高效地置换两个对象值&lt;/li&gt;
&lt;li&gt;在类或模板所在的命名空间提供一个非成员的 swap 函数，在函数内调用上述 swap 函数&lt;/li&gt;
&lt;li&gt;如果正在编写一个类或类模板，让该类特化 std::swap，另其调用上述的 swap 函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果调用 swap，确定包含&lt;code&gt;using std::swap&lt;/code&gt;，然后不加任何 namespace 修饰符，直接调用 swap，编译器就会查找适当的 swap 函数并调用&lt;/li&gt;
&lt;li&gt;警告：成员函数 swap 不可抛出异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-实现&#34;&gt;5.实现&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Implementations&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;26-尽可能推迟变量定义&#34;&gt;26.尽可能推迟变量定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Postpone variable definitions as long as possible&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;尽可能延后变量定义式的出现，最好是延后到可以用有意义的参数进行始化&lt;/li&gt;
&lt;li&gt;对于循环，如果构造和析构的代码大于赋值操作，则将定义放在循环外&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;27-最小化-cast-操作&#34;&gt;27.最小化 cast 操作&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Minimize casting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;C 风格的转换操作，将 expression 转换为 T：&lt;code&gt;(T)expression&lt;/code&gt;和&lt;code&gt;T(expression)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C++ 另外提供 4 种转换操作

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;用来移除对象的常量性，唯一可以实现这个目的的 C++ 风格的转换操作符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;用于执行“安全向下转换”，用于确定某对象是否归属继承体系中的某个类型，可能耗费重大运行成本，唯一一个 C 风格无法实现的转换操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;意图执行低级转换，实际动作和结果可能取决于编译器，即不可移植&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;用于强迫隐式转换，例如 non-const 转换为 const，或者 int 转 double 等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;倾向使用 C++ 风格的转换操作，不要使用 C 风格的转换

&lt;ul&gt;
&lt;li&gt;易被辨识，因而得以简化查找类型被破坏的过程&lt;/li&gt;
&lt;li&gt;各转换工作有各自的局限，便于编译器诊断错误的运用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果可以，尽量避免转换操作，特别是在注重效率的代码中避免 dynamic_cast，如果有需要，尝试改成无需转换的设计

&lt;ul&gt;
&lt;li&gt;使用类型安全容器，确定是哪种衍生类或基类&lt;/li&gt;
&lt;li&gt;将虚函数放在父类，然后添加空实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果必须转换，试着用函数封装，可以调用函数，而无需将转换操作引入代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;28-避免返回指向对象内部的句柄&#34;&gt;28.避免返回指向对象内部的句柄&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid returning &amp;ldquo;handles&amp;rdquo; to object internals&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;避免返回 handles(包括引用、指针、迭代器)指向对象内部。一遍增加封装性，帮助 const 成员函数的行为像个 const，并将发生 dangling handles 的可能性降至最低&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;29-努力写异常安全的代码&#34;&gt;29.努力写异常安全的代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Strive for exception-safe code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;异常安全函数即使发生议程也不会内存泄漏或破坏任何数据结构。这样的函数分为三种可能的保证：基本型、强烈型、不抛异常型&lt;/li&gt;
&lt;li&gt;“强烈保证”往往以 copy-and-swap 实现，但“强烈保证”并非对所有函数都可实现或具备现实意义&lt;/li&gt;
&lt;li&gt;函数提供的“异常安全保证”通常最高只等于其调用的各个函数的“异常安全保证”中的最弱者&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;30-了解内联的细节&#34;&gt;30.了解内联的细节&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand the ins and outs of inlining&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;将大多数内联限制在小型、被频繁调用的函数。可使日后的调试过程和二进制升级更容易，也可最小化潜在的代码膨胀问题，最大化提升程序的速度

&lt;ul&gt;
&lt;li&gt;内联函数无法随着程序库的升级而升级：内联函数修改，用到该函数的程序必须重新编译&lt;/li&gt;
&lt;li&gt;大部分调试器不支持内联函数调试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;隐式内联：函数定义在类定义内&lt;/li&gt;
&lt;li&gt;显式内联：添加关键字 inline

&lt;ul&gt;
&lt;li&gt;没有要求每个函数都是内联，就避免声明一个模板是内联&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大多数编译拒绝复杂的函数内联：比如虚函数，带有循环或递归的函数。此时会有警告信息&lt;/li&gt;
&lt;li&gt;编译器通常不对“通过函数指针进行的调用”执行内联&lt;/li&gt;
&lt;li&gt;不要只因为函数模板出现在头文件，就将其声明为内联&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;31-最小化文件编译依赖&#34;&gt;31.最小化文件编译依赖&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Minimize compilation dependencies between files&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;pimply idiom(pointer to implementation)：将一个类分为两个，一个提供接口，一个负责实现接口，前者在类内包含一个后者的 shared_ptr，做到“接口与实现分离”&lt;/li&gt;
&lt;li&gt;使用接口类、衍生类和工厂模式进行实现&lt;/li&gt;
&lt;li&gt;分离的关键在于“声明的依存性”替换“定义的依存性”：让头文件尽可能自我满足，万一做不到，则使用前置声明&lt;/li&gt;
&lt;li&gt;设计策略

&lt;ul&gt;
&lt;li&gt;尽量使用对象引用或对象指针，而不是对象：可以在头文件中使用前置声明&lt;/li&gt;
&lt;li&gt;尽量使用 class 声明式而不是 class 定义式&lt;/li&gt;
&lt;li&gt;为声明式和定义式提供不同的头文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;程序头文件应该以“完全且仅有声明式”的形式存在&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-继承与面向对象设计&#34;&gt;6.继承与面向对象设计&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Inheritance and object-oriented design&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;32-确保公有继承是-is-a-关系&#34;&gt;32.确保公有继承是&amp;rdquo;is-a&amp;rdquo;关系&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Make sure public inheritance models &amp;ldquo;is-a&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;public 继承意味着 is-a。适用于基类的每一件事情一定适用于衍生类，每一个衍生类对象也都是一个基类对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;33-避免隐藏继承的名字&#34;&gt;33.避免隐藏继承的名字&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid hiding inherited names&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;衍生类内的名称会隐藏基类内的名称

&lt;ul&gt;
&lt;li&gt;如果继承基类并加上重载函数，又希望重新定义或覆盖其中一部分，必须为那些原本会被隐藏的名称引入一个 using 声明式，否则继承的名称会被隐藏&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为了让隐藏的名称仍然可见，可使用 using 声明式或 forwarding 函数

&lt;ul&gt;
&lt;li&gt;内置的 forwarding 函数的另一个用途是为那些不支持 using 声明式的编译器而用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;34-区分接口继承和实现继承&#34;&gt;34.区分接口继承和实现继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Differentiate between inheritance of interface and inhertance of implementation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;接口继承和实现继承不同。在 public 继承时，衍生类会继承基类的接口，即成员函数&lt;/li&gt;
&lt;li&gt;声明纯虚函数的目的是让衍生类只继承函数接口&lt;/li&gt;
&lt;li&gt;声明非纯虚函数的目的是让衍生类继承该函数的接口和缺省实现&lt;/li&gt;
&lt;li&gt;声明非虚函数的目的是让衍生类继承函数的接口和一份强制性实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;35-考虑虚函数的替代&#34;&gt;35.考虑虚函数的替代&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Condider alternatives to virtual functions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;虚函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式

&lt;ul&gt;
&lt;li&gt;使用 non-virtual interface(NVI)手法，是 Template Method 设计模式的一种特殊形式。以 public non-virtual 成员函数包裹较低访问性的虚函数&lt;/li&gt;
&lt;li&gt;将虚函数替换为“函数指针成员变量”。是 Strategy 设计模式的一种分解表现形式&lt;/li&gt;
&lt;li&gt;以 function 成员变量替换虚函数，因而允许使用任何可调用实体(callable entities)搭配一个兼容与需求的签名式。这也是 Strategy 设计模式的某种形式&lt;/li&gt;
&lt;li&gt;将继承体系内的虚函数替换为另一继承体系的虚函数。这是 Strategy 设计模式的传统实现手法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将功能从成员函数移到类外部，缺点是非成员函数无法访问类的 non-public 成员&lt;/li&gt;
&lt;li&gt;function 对象的行为就像一般函数指针。这样的对象可接纳“与给定的目标签名式兼容”的所有可调用实体&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;36-绝不重定义继承的非虚函数&#34;&gt;36.绝不重定义继承的非虚函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Never redefine an inherited non-virtual function&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;非虚函数是静态绑定的，虚函数是动态绑定的&lt;/li&gt;
&lt;li&gt;任何情况下都不该重新定义一个继承而来的非虚函数，否则调用的函数取决于对象最开始的声明类型，跟实际所指类型无关&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;37-绝不重定义函数继承的默认参数值&#34;&gt;37.绝不重定义函数继承的默认参数值&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Never redefine a function&amp;rsquo;s inherited default parameter value&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;虚函数是动态绑定，但是缺省参数是静态绑定

&lt;ul&gt;
&lt;li&gt;调用虚函数时，默认参数可能是基类的默认参数，而不是实际指向的父类的默认参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;静态类型是声明的类型，动态类型是“目前所指对象的类型”

&lt;ul&gt;
&lt;li&gt;动态类型可以表现出一个对象将会有什么行为&lt;/li&gt;
&lt;li&gt;动态类型可在程序执行过程中改变&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以使用 NVI 手法：另基类内的一个 public 非虚函数调用 private 虚函数，后者可被衍生类重新定义。让非虚函数知道缺省参数，虚函数负责真正的工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;38-通过组合对-has-a-或-is-implemented-in-terms-of-建模&#34;&gt;38.通过组合对&amp;rdquo;has-a&amp;rdquo;或&amp;rdquo;is-implemented-in-terms-of&amp;rdquo;建模&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Model &amp;ldquo;has-a&amp;rdquo; or &amp;ldquo;is-implemented-in-terms-of&amp;rdquo; through composition&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;复合是类型间的一种关系，当某种类型的对象内包含其他类型的对象，就是复合关系&lt;/li&gt;
&lt;li&gt;在应用域，复合意味着 has-a(有一个)。在实现域，复合以为着 is-implemented-in-terms-of(根据某物实现出)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;39-慎重使用私有继承&#34;&gt;39.慎重使用私有继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use private inheritance judiciously&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;private 继承意味着 is-implemented-in-terms-of。通常比复合的级别低，但是当衍生类需要访问基类的 protected 成员，或需要重新定义继承而来的虚函数时，private 继承是合理的

&lt;ul&gt;
&lt;li&gt;private 继承时，编译器不会自动将一个衍生类对象转换为一个基类对象&lt;/li&gt;
&lt;li&gt;由 private 继承而来的所有成员，在衍生类中都是 private 属性&lt;/li&gt;
&lt;li&gt;private 继承是一种实现技术，意味着只有实现部分被继承，接口部分应忽略&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;与复合相比，private 继承可以使得空白基类最优化(EBO, empty base optimization)。对致力于“对象尺寸最小化”的程序库开发者比较重要&lt;/li&gt;
&lt;li&gt;尽可能使用复合，必要时采用 private 继承

&lt;ul&gt;
&lt;li&gt;当想要访问一个类的 protected 成员，或需要重新定义该类的一个或多个虚函数&lt;/li&gt;
&lt;li&gt;当空间更加重要，衍生类的基类可以不包含任何 non-static 成员变量&lt;/li&gt;
&lt;li&gt;“独立(非附属)”对象的大小一定不为零，不适用于单一继承(多重继承不可以)衍生类对象的基类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;40-慎重使用多重继承&#34;&gt;40.慎重使用多重继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use multiple inheritance judiciously&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;多重继承是继承一个以上的基类，但这些基类并不常在继承体系中又有基类

&lt;ul&gt;
&lt;li&gt;虚继承：防止多重继承时，基类之间又有基类，从而上层的基类的成员变量被父类复制&lt;/li&gt;
&lt;li&gt;虚继承的类产生的对象体积更大，访问虚基类的成员变量速度慢，增加初始化(及赋值)的复杂度&lt;/li&gt;
&lt;li&gt;如果虚基类不带任何数据，是具有使用价值的情况&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多重继承比单一继承复杂，可能导致新的歧义性，以及对虚继承的需要&lt;/li&gt;
&lt;li&gt;多重继承的用途：涉及“public 继承某个接口类”和“private 继承某个协助实现的类”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-模板与泛型编程&#34;&gt;7.模板与泛型编程&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Templates and generic programming&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;41-理解隐式接口和编译期多态&#34;&gt;41.理解隐式接口和编译期多态&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand implicit interfaces and compile-time polymorphism&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;类和模板都支持接口和多态&lt;/li&gt;
&lt;li&gt;对类而言接口是显式的，以函数签名为中心。多态则是通过虚函数发生于运行期&lt;/li&gt;
&lt;li&gt;对模板参数而言，接口是隐式的，基于有效表达式。多态则是通过模板具体化和函数重载解析，发生于编译期&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;42-理解-typename-的双重定义&#34;&gt;42.理解 typename 的双重定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand the two meanings of typename&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;声明模板类型参数的两种方式：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template&amp;lt;class T&amp;gt; class widget;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt; class widget;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从属名称：模板内的名称依赖于某个模板参数

&lt;ul&gt;
&lt;li&gt;非从属名称：模板内不依赖模板参数的名称&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;嵌套从属名称：从属名称在类内呈嵌套状&lt;/li&gt;
&lt;li&gt;嵌套从属类型名称：嵌套从属名称且指向某类型

&lt;ul&gt;
&lt;li&gt;想在模板中指定一个嵌套从属类型名称，就必须在紧邻它的前一个位置加上关键字 typename&lt;/li&gt;
&lt;li&gt;typename 不可出现在基类列表类的嵌套从属类型名称前，也不可在成员初始化列表中作为基类的修饰符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;43-了解如何访问模板化基类内的名称&#34;&gt;43.了解如何访问模板化基类内的名称&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Know how to access names in templatized base classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;当基类从模板中被具体化时，它假设对基类的内容一无所知，即衍生类基类继承一个基类模板，不能再衍生类的实现中直接调用基类的成员(变量和函数)

&lt;ul&gt;
&lt;li&gt;可在衍生类模板内添加&lt;code&gt;this-&amp;gt;&lt;/code&gt;指向基类模板的成员(变量和函数)&lt;/li&gt;
&lt;li&gt;使用 using 声明式，假设已经存在这个成员(变量和函数)&lt;/li&gt;
&lt;li&gt;明确指出被调用的函数位于基类内，使用&lt;code&gt;基类::&lt;/code&gt;，如果是一个虚函数，会关闭虚函数的动态绑定行为&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;44-把参数无关的代码分离出模板&#34;&gt;44.把参数无关的代码分离出模板&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Factor parameter-independent code out of templates&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;模板生成多个类和多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生依赖关系&lt;/li&gt;
&lt;li&gt;因非类型模板参数造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数&lt;/li&gt;
&lt;li&gt;因类型参数造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表示的具体类型实现共享代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;45-使用成员函数模板来接受-所有兼容类型&#34;&gt;45.使用成员函数模板来接受“所有兼容类型”&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use member function templates to accept &amp;ldquo;all compatible types&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;具有基类-衍生类关系的两个类型分别具体化某个模板，生成的两个结构并不带有基类-衍生类关系&lt;/li&gt;
&lt;li&gt;使用成员函数模板生成“可接受所有兼容类型”的函数&lt;/li&gt;
&lt;li&gt;如果声明成员模板用于“泛化拷贝构造”或“泛化赋值操作”，必须声明正常的拷贝构造函数和拷贝赋值操作符

&lt;ul&gt;
&lt;li&gt;声明泛化拷贝构造函数和拷贝赋值操作符，不会阻止编译器生成默认的拷贝构造函数和拷贝赋值操作符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;46-需要类型转化时在模板内定义非成员函数&#34;&gt;46.需要类型转化时在模板内定义非成员函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Define non-member functions inside templates when type conversions are desired&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;模板实参推导过程中不会考虑隐式类型转换函数&lt;/li&gt;
&lt;li&gt;写类模板时，当它提供的“与此模板相关的”函数支持“所有参数的隐式类型转换”时，将那些函数定义为类模板内部的友元函数

&lt;ul&gt;
&lt;li&gt;在类内部声明非成员函数作为友元函数，成为内联函数&lt;/li&gt;
&lt;li&gt;为了将内联声明的影响最小化，在类外定义一个辅助函数模板，在友元函数内只调用辅助函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;47-使用-traits-class-表现类型信息&#34;&gt;47.使用 traits class 表现类型信息&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use traits classes for information about types&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;STL 有 5 种迭代器

&lt;ul&gt;
&lt;li&gt;input 迭代器：只能向前移动，一次异步，只可读取(不能修改)所指的东西，且只能读取一次。模仿了指向输入文件的读指针。如 C++ 的 istream_iterator&lt;/li&gt;
&lt;li&gt;output 迭代器：只能向前移动，一次一步，只可修改所指的东西，且只能修改一次。模仿了指向输出文件的写指针。如 C++ 的 ostream_iterator&lt;/li&gt;
&lt;li&gt;input 和 output 迭代器都只适合“单步操作算法(one-pass algorithms)”&lt;/li&gt;
&lt;li&gt;forward 迭代器：既能完成上述两种迭代器的工作，且可以读或写所指对象一次以上。使得可以实施“多步操作算法(multi-pass algorithms)”。如单向链表的迭代器&lt;/li&gt;
&lt;li&gt;bidirectional 迭代器：既能完成 forward 迭代器的工作，还支持向后移动。STL 的 list/set/multiset/map/multimap 迭代器就属于这一分类&lt;/li&gt;
&lt;li&gt;random access 迭代器：可以执行“迭代器运算”，即可以在常量时间内向前或向后跳跃任意距离。如 array/vector/deque/string 提供的都是随机访问迭代器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如何设计一个 traits 类

&lt;ul&gt;
&lt;li&gt;确认若干希望将来可取得的类型相关信息。例如迭代器希望取得分类(category)&lt;/li&gt;
&lt;li&gt;为该信息选择一个名词。如迭代器是 iterator_category&lt;/li&gt;
&lt;li&gt;提供一个模板和一组特化版本，其中包含希望支持的类型相关信息&lt;/li&gt;
&lt;li&gt;traits 类的名称常以&amp;rdquo;traits&amp;rdquo;结束&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如何使用一个 traits 类

&lt;ul&gt;
&lt;li&gt;建立一组重载函数(类似劳工)或函数模板，彼此间的差异只在于各自的 traits 参数。令每个函数实现与其接受的 traits 信息相对应&lt;/li&gt;
&lt;li&gt;建立一个控制函数(类似工头)或函数模板，调用上述的函数并传递 traits 类所提供的信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;traits 类使得“类型相关信息”在编译期可用。它们以模板和一组“模板特化”完成实现&lt;/li&gt;
&lt;li&gt;整合重载技术后，traits 类可在编译期对类型执行 if&amp;hellip;else 测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;48-认识模板元编程&#34;&gt;48. 认识模板元编程&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Be aware of template metaprogramming&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;模板元编程(TMP, template metaprogramming)是编写基于模板的 C++ 程序并在编译期执行的过程

&lt;ul&gt;
&lt;li&gt;即以 C++ 写成、在 C++ 编译期内执行的程序&lt;/li&gt;
&lt;li&gt;TMP 程序结束执行，输出的 C++ 源码可以像往常一样编译&lt;/li&gt;
&lt;li&gt;优点：&lt;/li&gt;
&lt;li&gt;让某些事情更容易&lt;/li&gt;
&lt;li&gt;可将工作从运行期转移到编译期。使得原本在运行期才可以侦测的错误在编译期被找到&lt;/li&gt;
&lt;li&gt;TMP 的 C++ 程序在每一方面可能更加高效：较小的可执行文件、较短的运行期、较少的内存需求&lt;/li&gt;
&lt;li&gt;缺点：导致编译时间变长&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TMP 主要是函数式语言，可以达到的目的

&lt;ul&gt;
&lt;li&gt;确保度量单位正确：在编译期确保程序所有度量单位的组合是正确的&lt;/li&gt;
&lt;li&gt;优化矩阵运算：使用 expression template，可能会消除中间计算生成的临时对象并合并循环&lt;/li&gt;
&lt;li&gt;可生成用户自定义设计模式的实现品。设计模式如 Strategy/Observer/Visitor 等都可以多种方式实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;问题：

&lt;ul&gt;
&lt;li&gt;语法不直观&lt;/li&gt;
&lt;li&gt;支持工具不充分，如没有调试器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-定制-new-和-delete&#34;&gt;8.定制 new 和 delete&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Customizing new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;只适合分配单一对象；&lt;code&gt;new []&lt;/code&gt;和&lt;code&gt;delete []&lt;/code&gt;用来分配数组&lt;/li&gt;
&lt;li&gt;STL 容器所使用的 heap 内存是由容器所拥有的分配器对象(allocator objects)管理，而不是 new 和 delete 管理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;49-理解-new-handler-的行为&#34;&gt;49.理解 new-handler 的行为&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand the behavior of the new-handler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;当 new 操作抛出异常以反映一个未获满足的内存需求之前，会先调研一个客户指定的错误处理函数，即 new-handler

&lt;ul&gt;
&lt;li&gt;可以用是&lt;code&gt;set_new_handler&lt;/code&gt;设置该函数&lt;/li&gt;
&lt;li&gt;参数是个指针，指向 new 无法分配足够内存时该调用的函数&lt;/li&gt;
&lt;li&gt;返回值是个指针，指向&lt;code&gt;set_new_handler&lt;/code&gt;被调用之前正在执行的 new_handler 函数&lt;/li&gt;
&lt;li&gt;new_handler 是个 typedef，定义一个指针指向函数，函数没有参数也没有返回值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设计良好的 new-handler 函数

&lt;ul&gt;
&lt;li&gt;让更多内存可被使用：程序一开始执行就分配一大块内存，而后第一次调用 new-handler，将该内存释放给程序使用&lt;/li&gt;
&lt;li&gt;设置另一个 new-handler：如果已知哪个 new-handler 可以获得更多可用内存，调用时设置该 new-handler 替换自己。比如令 new-handler 修改“会影响 new-handler 行为”的静态数据、命名空间数据或全局数据&lt;/li&gt;
&lt;li&gt;取消设置 new-handler：即将 null 指针传给&lt;code&gt;set_new_handler&lt;/code&gt;，内存分配不成功时就会抛异常&lt;/li&gt;
&lt;li&gt;抛出 bad_alloc 或派生自 bad_alloc 的异常：该异常不会被 new 操作捕获，但会传播给请求内存的代码&lt;/li&gt;
&lt;li&gt;不返回：通常调用 abort 或 exit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nothrow new&lt;/code&gt;是一个有局限性的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;50-理解何时替换-new-和-delete-有意义&#34;&gt;50.理解何时替换 new 和 delete 有意义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand when it makes sense to replace new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;三个替换编译器提供的 new 和 delete 理由：

&lt;ul&gt;
&lt;li&gt;检测运用上的错误：自定义 new 操作，可超额分配内存，以额外空间放置特定的 byte patterns(即签名，signature)。对应的 delete 操作可以检查上述签名是否原封不动，若否表示在分配区的某个声生命时间点发生了 overrun(写入点在分配区块尾端之后) 或 underrun(写入点在分配区块起点之前)。此时 delete 可以日志记录该时间和发生错误的指针&lt;/li&gt;
&lt;li&gt;强化效能：编译器的 new 和 delete 无法解决碎片问题，导致程序可能无法申请大区块内存。通常来说这种自定制的性能更好&lt;/li&gt;
&lt;li&gt;收集使用上的统计数据：先收集软件如何使用动态内存，包括分配区块的大小分布、寿命分布、分配和释放的次序(FIFO/LIFO/随机)、任何时刻内存分配上限&lt;/li&gt;
&lt;li&gt;增加分配和释放的速度：当定制型分配器专门针对某特定类型的对象设计时，往往比泛用型分配器更快&lt;/li&gt;
&lt;li&gt;降低缺省内存管理器带来的空间额外开销：泛用型内存管理器往往使用更多内存&lt;/li&gt;
&lt;li&gt;弥补缺省分配器中的非最佳对齐：缺省的分配器一般是 4 字节对齐，但是对于 x86 最好是 8 字节对齐&lt;/li&gt;
&lt;li&gt;将相关对象成簇集中：将往往被一起使用某个数据结构放在一起创建，可以减少 page fault 的错误&lt;/li&gt;
&lt;li&gt;获得非传统的行为：比如添加数据初始化工作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;51-写-new-和-delete-时遵循惯例&#34;&gt;51.写 new 和 delete 时遵循惯例&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Adhere to convention when writing new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;new 操作

&lt;ul&gt;
&lt;li&gt;应该包含一个无穷循环，并在其中尝试分配内存&lt;/li&gt;
&lt;li&gt;如果无法满足需求，调用 new-handler&lt;/li&gt;
&lt;li&gt;也应该可以处理 0 字节申请&lt;/li&gt;
&lt;li&gt;类的自定义版本还应该处理“比正确大小更大的(错误)申请”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;delete 操作

&lt;ul&gt;
&lt;li&gt;收到 null 指针不做任何事&lt;/li&gt;
&lt;li&gt;类的自定义版本还应该处理“比正确大小更大的(错误)申请”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;52-写了-placement-new-也要写-placement-delete&#34;&gt;52.写了 placement new 也要写 placement delete&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Write placement delete if you write placement new&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果自己实现一个 placement operator new，也要写出对应的 placement operator delete。否则会发生隐蔽时断时续的内存泄漏&lt;/li&gt;
&lt;li&gt;当声明 placement new 和 placement delete，确定不要无意识地遮掩它们的正常版本&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-杂项讨论&#34;&gt;9.杂项讨论&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Miscellany&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;53-注意编译器警告&#34;&gt;53.注意编译器警告&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Pay attention to compiler warnings&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;严肃对待编译器发出的警告信息。努力在编译器的最高(最严苛)警告级别下争取“无任何警告”&lt;/li&gt;
&lt;li&gt;不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度不相同。一旦移植到另一个编译器上，原本依赖的警告信息有可能消失&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;54-熟悉包括-tr1-在内的标准库&#34;&gt;54.熟悉包括 TR1 在内的标准库&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Familiarize yourself with the standard library, including TR1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;55-熟悉-boost&#34;&gt;55.熟悉 Boost&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Familiarize yourself with Boost&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Equivalent Binary Trees</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/equivalent_binary_trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/equivalent_binary_trees/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Equivalent Binary Trees
1. Implement the Walk function.

2. Test the Walk function.

The function tree.New(k) constructs a randomly-structured (but always sorted) binary tree holding the values k, 2k, 3k, ..., 10k.

Create a new channel ch and kick off the walker:

go Walk(tree.New(1), ch)
Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10.

3. Implement the Same function using Walk to determine whether t1 and t2 store the same values.

4. Test the Same function.

Same(tree.New(1), tree.New(1)) should return true, and Same(tree.New(1), tree.New(2)) should return false.

The documentation for Tree can be found here.
*/

package main

import (
  &amp;quot;fmt&amp;quot;

  &amp;quot;golang.org/x/tour/tree&amp;quot;
)

// Walk walks the tree t sending all values
// from the tree to the channel ch.
func Walk(t *tree.Tree, ch chan int) {
  if t.Left != nil {
    Walk(t.Left, ch)
  }
  ch &amp;lt;- t.Value
  if (t.Right) != nil {
    Walk(t.Right, ch)
  }
}

// Same determines whether the trees
// t1 and t2 contain the same values.
func Same(t1, t2 *tree.Tree) bool {
  ch1 := make(chan int)
  ch2 := make(chan int)
  go Walk(t1, ch1)
  go Walk(t2, ch2)
  for i := 1; i &amp;lt;= 10; i++ {
    v1, v2 := &amp;lt;-ch1, &amp;lt;-ch2
    fmt.Println(&amp;quot;Walk two tree: &amp;quot;, v1, v2)
    if v1 != v2 {
      return false
    }
  }
  return true
}

func main() {
  ch := make(chan int)
  go Walk(tree.New(1), ch)
  for i := 1; i &amp;lt;= 10; i++ {
    v := &amp;lt;-ch
    fmt.Println(&amp;quot;Walk tree: &amp;quot;, v)
    if i != v {
      fmt.Println(&amp;quot;Test Walk failure&amp;quot;)
      return
    }
  }
  fmt.Println(&amp;quot;Test Walk success&amp;quot;)

  if Same(tree.New(1), tree.New(1)) &amp;amp;&amp;amp; !Same(tree.New(1), tree.New(2)) {
    fmt.Println(&amp;quot;Test Same success&amp;quot;)
  } else {
    fmt.Println(&amp;quot;Test Same failure&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Errors</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/errors/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Errors
Copy your Sqrt function from the earlier exercise and modify it to return an error value.

Sqrt should return a non-nil error value when given a negative number, as it doesn&#39;t support complex numbers.

Create a new type

type ErrNegativeSqrt float64
and make it an error by giving it a

func (e ErrNegativeSqrt) Error() string
method such that ErrNegativeSqrt(-2).Error() returns &amp;quot;cannot Sqrt negative number: -2&amp;quot;.

Note: A call to fmt.Sprint(e) inside the Error method will send the program into an infinite loop. You can avoid this by converting e first: fmt.Sprint(float64(e)). Why?

Change your Sqrt function to return an ErrNegativeSqrt value when given a negative number.
*/

package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;math&amp;quot;
)

type errNegativeSqrt float64

func (e errNegativeSqrt) Error() string {
  // 因为e变量是一个通过实现Error()的接口函数成为了error类型，那么在fmt.Sprint(e)时就会调用e.Error()来输出错误的字符串信息
  return fmt.Sprint(&amp;quot;cannot Sqrt negative number: &amp;quot;, float64(e))
}

func mySqrt(x float64) (float64, error) {
  if x &amp;lt; 0 {
    return -1, errNegativeSqrt(x)
  }
  z := x / 2
  tmp := 0.0
  for math.Abs(z-tmp) &amp;gt;= 0.000000000001 {
    tmp = z
    z -= (z*z - x) / (2 * z)
  }
  return z, nil
}

func main() {
  fmt.Println(mySqrt(2))
  fmt.Println(mySqrt(-2))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Event playlist 构造</title>
      <link>https://xueqing.github.io/translation/hls/event_playlist_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/event_playlist_construction/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/event_playlist_construction&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;示例&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#extm3u&#34;&gt;EXTM3U&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-version&#34;&gt;EXT-X-VERSION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#extinf&#34;&gt;EXTINF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%b4%e6%96%b0-playlist-%e6%96%87%e4%bb%b6&#34;&gt;更新 playlist 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;通过 EXT-X-PLAYLIST-TYPE 标记的值设为 EVENT 指定一个 event playlist。它起初没有 EXT-X-ENDLIST 标签，表示当新的媒体文件可访问时将会被加到 playlist。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的代码是一个第一个出现在会话中的 event playlist 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:EVENT
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.00,
fileSequence0.ts
#EXTINF:10.0,
fileSequence1.ts
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.0,
fileSequence4.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;event playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/h3&gt;

&lt;p&gt;提供了适用于整个 playlist 文件的易变信息。这个标记可能包含一个 EVENT 或 VOD 值。如果标记存在且值为 EVENT，服务器一定不能修改或删除 playlist 文件的任意部分(但是它可以追加行到 playlist 文件)。如果标记存在且值为 VOD，playlist 文件一定不能改变。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/h3&gt;

&lt;p&gt;指定最大的媒体文件时长。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-version&#34;&gt;EXT-X-VERSION&lt;/h3&gt;

&lt;p&gt;表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/h3&gt;

&lt;p&gt;表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。&lt;/p&gt;

&lt;h3 id=&#34;extinf&#34;&gt;EXTINF&lt;/h3&gt;

&lt;p&gt;一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。&lt;/p&gt;

&lt;h2 id=&#34;更新-playlist-文件&#34;&gt;更新 playlist 文件&lt;/h2&gt;

&lt;p&gt;当使用 EVENT 标记时，你不能从 playlist 中删除任何东西；你只可能追加新的片段到文件直到这个事件终止，那是会追加一个 EXT-X-ENDLIST 标签。下面的示例展示了使用新的媒体 URL 更新且该事件已经终止的同一 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:EVENT
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
fileSequence0.ts
#EXTINF:10.0,
fileSequence1.ts
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.0,
fileSequence4.ts

// List of files between 4 and 120 go here.

#EXTINF:10.0,
fileSequence120.ts
#EXTINF:10.0,
fileSequence121.ts
#EXT-X-ENDLIST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大概你想要支持用户跳转到事件内的任何一点时，比如一个音乐会或者运动事件，通常使用 event playlist。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>FFMPEG/FFPLAY 源码剖析</title>
      <link>https://xueqing.github.io/blog/ffmepg/ffmpeg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ffmepg/ffmpeg/</guid>
      <description>

&lt;h2 id=&#34;播放器一般原理&#34;&gt;播放器一般原理&lt;/h2&gt;

&lt;p&gt;Windows DirectShow&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;媒体文件基本模块：读文件、解复用、视频解码、音频解码、颜色空间转换、视频显示、音频播放&lt;/li&gt;
&lt;li&gt;模块：过滤器 filter。

&lt;ul&gt;
&lt;li&gt;输入输出：pin，管脚。input pin 和 output pin&lt;/li&gt;
&lt;li&gt;source filter 和 sink filter&lt;/li&gt;
&lt;li&gt;filter 组成 graph。媒体文件的数据流在 graph 中流动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;source filter：&lt;/li&gt;
&lt;li&gt;demux filter：&lt;/li&gt;
&lt;li&gt;decoder filter：&lt;/li&gt;
&lt;li&gt;color space converter filter：&lt;/li&gt;
&lt;li&gt;render filter：&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Fibonacci closure</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/fibonacci_closure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/fibonacci_closure/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Fibonacci closure
Let&#39;s have some fun with functions.

Implement a fibonacci function that returns a function (a closure) that returns successive fibonacci numbers (0, 1, 1, 2, 3, 5, ...).
*/

package main

import &amp;quot;fmt&amp;quot;

func fibonacci() func() int {
  before, val := 0, 1
  return func() int {
    ret := before
    before, val = val, before + val
    return ret
  }
}

func main() {
  f := fibonacci()
  for i := 0; i &amp;lt; 10; i++ {
    fmt.Println(f())
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>fmt 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/fmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/fmt/</guid>
      <description>

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;fmt&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;fmt 包用类似于 C 的 printf 和 scanf 的函数实现了格式化的 I/O。格式 “verbs” 衍生自 C 但是更简单。&lt;/p&gt;

&lt;h3 id=&#34;打印&#34;&gt;打印&lt;/h3&gt;

&lt;p&gt;verbs 包括：&lt;/p&gt;

&lt;p&gt;通用的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;%v  默认格式的值
    当打印结构体时，增加标识 (%+v) 会增加域名。
%#v 值的一个 Go 语法显示
%T  值类型的一个 Go 语法显示
%%  一个字面百分比符号；不消费任何值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;布尔型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;%t  单词是 true 还是 false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;%b  base 2
%c  the character represented by the corresponding Unicode code point
%d  base 10
%o  base 8
%O  base 8 with 0o prefix
%q  a single-quoted character literal safely escaped with Go syntax.
%x  base 16, with lower-case letters for a-f
%X  base 16, with upper-case letters for A-F
%U  Unicode format: U+1234; same as &amp;quot;U+%04X&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/fmt/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/fmt/#pkg-examples&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git add 添加文件</title>
      <link>https://xueqing.github.io/blog/git/git_add/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_add/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;git add: 添加内容到下一次提交中. 当使用 git commit 时, git 将依据暂存区域的内容来进行文件的提交&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以用它开始跟踪新文件, 或者把已跟踪的文件放到暂存区, 还能用于合并时把有冲突的文件标记为已解决状态等&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 把 path 添加到索引库, path 可以是文件或目录
git add path
# 添加所有文件
git add .
# 添加指定文件
git add file1 file2
# 不处理未跟踪(untracked)的文件
git add -u [&amp;lt;path&amp;gt;]
# 添加所有
git add -A [&amp;lt;path&amp;gt;]
# 查看所有修改过或已删除文件但是未提交的文件
git add -i [&amp;lt;path&amp;gt;]
# 交互式添加修改内容到本次提交
git add -i
# 交互式选择当前的修改添加到本次提交，只需输入 y/n
git add -p
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;提交空文件&#34;&gt;提交空文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;方法 1：在空文件夹创建一个空文件 &lt;code&gt;.gitkeep&lt;/code&gt;，提交该文件&lt;/li&gt;

&lt;li&gt;&lt;p&gt;方法 2：在空文件夹创建一个空文件 &lt;code&gt;.gitignore&lt;/code&gt;，文件内容如下。提交文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;# 忽视目录所有内容
*
# 不忽视 .gitignore 文件
!.gitignore
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git bisect 查找错误提交</title>
      <link>https://xueqing.github.io/blog/git/git_bisect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_bisect/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;已知 HEAD 节点是错误的，正确版本是 xxxxx 对应的提交，使用&lt;code&gt;git bisect&lt;/code&gt;查找错误的提交&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git bisect start
git bisect bad HEAD
git bisect good xxxxx
# git 从中间的历史记录检出一个中间状态，在此状态上测试功能
# 1 如果此状态错误
git bisect bad
# 2 如果此状态正确
git bisect good
# 迭代多次之后可以找到导致错误的提交
# 返回到原始状态
git bisect reset
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git blame</title>
      <link>https://xueqing.github.io/blog/git/git_blame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_blame/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git blame&lt;/code&gt;可标注出指定文件的每一行内容的最后修改者和最后修改时间&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线下完成，即读本地磁盘完成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git blame bug.c
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git bundle</title>
      <link>https://xueqing.github.io/blog/git/git_bundle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_bundle/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打包整个仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 发送者使用仓库创建一个文件包
git bundle create somefile HEAD
# 接收者使用 somefile 文件获取提交
git pull somefile
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打包部分提交：假设 xxxx 是发送者和接收者共享的最近提交&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 发送者打包增加的变更
git bundle create somefile HEAD ^xxxx
# 使用标签记录最近一次打包的节点
git tag -f lastbundle HEAD
# 一段时间后创建新文件包
git bundle create newbundle HEAD ^lastbundle
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git cherry-pick 选择某次提交</title>
      <link>https://xueqing.github.io/blog/git/git_-cherry-pick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_-cherry-pick/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 选择某次提交应用到当前分支
git cherry-pick &amp;lt;commit-id&amp;gt;
# 选择某次提交应用到当前分支，并保留原提交者信息
git cherry-pick -x &amp;lt;commit-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;批量操作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 应用 start-commit-id （不包含） 到 end-commit-id （包含）之间的提交到当前分支
git cherry-pick &amp;lt;start-commit-id&amp;gt;..&amp;lt;end-commit-id&amp;gt;
# 应用 start-commit-id （包含） 到 end-commit-id （包含）之间的提交到当前分支
git cherry-pick &amp;lt;start-commit-id&amp;gt;^..&amp;lt;end-commit-id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git clean 清理工作目录</title>
      <link>https://xueqing.github.io/blog/git/git_clean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_clean/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clean&lt;/code&gt; 从工作目录移除未被跟踪的文件，直接删除，不能从回收站找到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 移除未跟踪的目录&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-f&lt;/code&gt; 强制移除文件或目录，如果 &lt;code&gt;clean.requireForce&lt;/code&gt; 设置为 true，&lt;code&gt;git clean&lt;/code&gt; 只有添加 &lt;code&gt;-f&lt;/code&gt;&lt;code&gt;-n&lt;/code&gt;&lt;code&gt;-i&lt;/code&gt; 才会清理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 移除工作目录中所有未追踪的文件以及空的目录
git clean -f -d
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-n&lt;/code&gt; “演示”查看将会清除的内容，不会移除任何文件或目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 可以打印“将要移除什么”，并未真正移除，相当于“演示”
git clean -d -n
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-x&lt;/code&gt; 不使用 &lt;code&gt;.gitignore&lt;/code&gt; 或者 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 指定的忽略规则，仍然使用 &lt;code&gt;-e&lt;/code&gt; 选项指定的忽略规则&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以移除所有的未跟踪文件，包括构建目录，可以用来创建一个干净的工作目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 移除未跟踪的文件和目录
git clean -d -x
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-X&lt;/code&gt; 只移除忽略的文件，可以用于保留手动创建的文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git commit 提交更新</title>
      <link>https://xueqing.github.io/blog/git/git_commit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_commit/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将提交信息与命令放在同一行
git commit -m &amp;quot;add README&amp;quot;
# 自动把所有已经跟踪过的文件暂存起来一并提交, 跳过 git add 步骤
git commit -a -m &amp;quot;add README&amp;quot;
# 在日志信息之后添加提交者的信息，--signoff
git commit -s
# git commit &amp;lt;file&amp;gt;...
git commit -p
git commit –allow-empty
# 改变上一次提交
git commit --amend
# 把本地的修改包含在上一次提交
git commit --amend -a
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git config 配置</title>
      <link>https://xueqing.github.io/blog/git/git_config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_config/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE&#34;&gt;配置&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF&#34;&gt;修改配置信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF&#34;&gt;查看配置信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;修改配置信息&#34;&gt;修改配置信息&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;/etc/gitconfig：包含系统上每一个用户及他们仓库的通用配置, 使用&lt;code&gt;--system&lt;/code&gt;会从此文件读写配置变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 输出中文文件名显示问题
git config --system core.quotepath false
# 开启颜色显示
git config --system color.ui true
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;~/.gitconfig 或 ~/.config/git/config：只针对当前用户.  使用&lt;code&gt;--global&lt;/code&gt;让 git 读写此文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 配置全局用户名
git config --global user.name kiki
# 配置全局 email
git config --global user.email kiki@bmi.com
# 配置默认文本编辑器(默认 vim)
git config --global core.editor emacs
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为 git 命令设置别名，参考&lt;a href=&#34;./git_alias.md&#34;&gt;git_alias&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rep-dir/.git/config：当前使用仓库的 Git 目录中的 config 文件, 只针对该仓库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 配置某个项目用户名
git config user.name xueqing
# 配置某个项目 email
git config user.email haijuanchen.sun@gmail.com
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每一个级别覆盖上一级别的配置, 所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;查看配置信息&#34;&gt;查看配置信息&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 列出所有 git 当时能找到的配置
git config --list
git config -l
# git config &amp;lt;key&amp;gt; 检查 Git 的某一项配置
# 查看用户名
git config user.name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git diff 版本比较</title>
      <link>https://xueqing.github.io/blog/git/git_diff/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_diff/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#diff-%e6%8f%92%e4%bb%b6&#34;&gt;diff 插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-diff&#34;&gt;git diff&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;diff-插件&#34;&gt;diff 插件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用 &lt;code&gt;git difftool&lt;/code&gt; 命令来用 Araxis , emerge 或 vimdiff 等软件通过图形化的方式或其它格式输出方式输出 diff 分析结果&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 命令查看系统支持哪些 git diff 插件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-diff&#34;&gt;git diff&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 工作目录中当前文件和暂存区域快照之间的差异, 即修改之后还没有暂存起来的变化内容
git diff
# HEAD 和暂存区比较, 即已暂存的将要添加到下次提交里的内容, --staged
git diff --cached
# HEAD 和工作区比较
git diff HEAD
# HEAD 和 HEAD 的父版本比较
git diff HEAD HEAD^
# HEAD 父父版本和 HEAD 的父版本比较
git diff HEAD~2 HEAD^
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git grep</title>
      <link>https://xueqing.github.io/blog/git/git_grep/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_grep/</guid>
      <description></description>
    </item>
    
    <item>
      <title>git log</title>
      <link>https://xueqing.github.io/blog/git/git_log/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_log/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%af%ad%e6%b3%95&#34;&gt;语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4&#34;&gt;常用命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%95%e7%94%a8%e6%97%a5%e5%bf%97-reflog&#34;&gt;引用日志 reflog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;git log [&amp;lt;options&amp;gt;] [&amp;lt;revision range&amp;gt;] [[--] &amp;lt;path&amp;gt;…​]&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;options&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-L &amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;:&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查看指定文件的开始行到结束行的提交历史&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-L :&amp;lt;funcname&amp;gt;:&amp;lt;file&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查看指定文件的函数的提交历史&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;git log &amp;ndash;pretty              # 使用其他格式显示历史提交信息. 可用 oneline/short/full/fuller/format&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 按行显示每次提交
git log --pretty=oneline
# 定制要显示的记录格式
git log --pretty=format
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;stat                # 显示每次更新的文件修改统计信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;graph               # 显示 ASCII 图形表示的分支合并历史&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log -p                    # 按补丁格式显示每个更新之间的差异&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 比较本地 master 分支和 origin/master 分支的差别
git log -p master..origin/master
# 显示最近两次提交的差别
git log -p -2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;decorate            # 查看各个分支当前所指的对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 输出提交历史、各个分支的指向以及项目的分支分叉情况
git log --oneline --decorate --graph --all
# 显示简短且唯一的 SHA-1 值
git log --abbrev-commit
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log -(n)                  # 仅显示最近的 n 条提交&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;since, &amp;ndash;after      # 仅显示指定时间之后的提交&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;until, &amp;ndash;before     # 仅显示指定时间之前的提交&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;author              # 仅显示指定作者相关的提交&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;committer           # 仅显示指定提交者相关的提交&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log &amp;ndash;grep                # 仅显示含指定关键字的提交&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log -S                    # 仅显示添加或移除了某个关键字的提交&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;git log -g                    # 查看类似于 git log 输出格式的引用日志信息&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;引用日志-reflog&#34;&gt;引用日志 reflog&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;工作时,  git 会在后台保存一个引用日志(reflog), 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史&lt;/li&gt;
&lt;li&gt;每当 HEAD 指向的位置发生了变化, git 就会将这个信息存储到引用日志&lt;/li&gt;

&lt;li&gt;&lt;p&gt;引用日志只存在于本地仓库, 一个记录你在你自己的仓库里做过什么的日志&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看引用日志
git reflog
# 使用`@{n}`引用 reflog 中输出的提交记录
git show HEAD@{5}
# 查看 master 分支在昨天的时候指向了哪个提交
git show master@{yesterday}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;祖先引用是另一种指明一个提交的方式. 如果在引用的尾部加上一个&lt;code&gt;^&lt;/code&gt;,  git 会将其解析为该引用的上一个提交&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看上一个提交, 也就是 “HEAD 的父提交”
git show HEAD^
# d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并(merge)的提交
git show d921970^2
# HEAD^^^, 也是第一父提交的第一父提交的第一父提交
git show HEAD~3
# HEAD^^^, 也是第一父提交的第一父提交的第一父提交的第二父提交
git show HEAD~3^2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.git-scm.com/docs/git-log&#34; target=&#34;_blank&#34;&gt;git log&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git move 移动文件</title>
      <link>https://xueqing.github.io/blog/git/git_mv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_mv/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# git rm + git add
git mv file_from file_to
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git patch 补丁</title>
      <link>https://xueqing.github.io/blog/git/git_patch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_patch/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%99%ae%e9%80%9a%e8%a1%a5%e4%b8%81&#34;&gt;普通补丁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%ad%a3%e5%bc%8f%e8%a1%a5%e4%b8%81-git-format-patch&#34;&gt;正式补丁 git format-patch&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e6%95%b0&#34;&gt;参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8%e4%ba%8e%e9%82%ae%e4%bb%b6%e5%8f%91%e9%80%81&#34;&gt;用于邮件发送&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%b4%e6%8e%a5%e7%94%a8%e4%ba%8e-git-am&#34;&gt;直接用于 git am&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;普通补丁&#34;&gt;普通补丁&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 发送者生成一个补丁
git diff xxx &amp;gt; my.patch
# 接收者在其他地方使用这个补丁
git apply &amp;lt; my.patch
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;正式补丁-git-format-patch&#34;&gt;正式补丁 git format-patch&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git format-patch&lt;/code&gt;生成补丁用于 email 发送，格式是类似 UNIX mailbox&lt;/li&gt;
&lt;li&gt;命令的输出用于 email 发送或者&lt;code&gt;git am&lt;/code&gt;直接使用&lt;/li&gt;
&lt;li&gt;是更正式的设置，记录作者名字或签名&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;参数&#34;&gt;参数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--root&lt;/code&gt;从提交历史开始的所有提交&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-M&lt;/code&gt;检测重命名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-B&lt;/code&gt;分割完整的重写信息为删除和创建对，即把提交当做删除旧文件，创建新文件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-M -B&lt;/code&gt;可将一个完全重写的文件当做重命名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;--stdout&lt;/code&gt;将所有提交以 mbox 格式打印到标准输出，而不是为每个提交创建一个文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不使用时，在当前文件夹为每次提交生成一个单独的文件，并打印文件的名字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 为某一时刻生成补丁
git format-patch xxxx
# 为某一个提交范围生成补丁
git format-patch xxxx..HEAD^^
# 提取在当前分支但是不在 origin 分支的提交
git format-patch origin
# 提取工程开始到 &amp;lt;commit&amp;gt; 的所有的提交
git format-patch --root &amp;lt;commit&amp;gt;
# 等同于
git format-patch -M -B origin
# 提取当前分支最上面的 3 次提交，生成补丁
git format-patch -3
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用于邮件发送&#34;&gt;用于邮件发送&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 发送者可使用 git-send-email 发送 git format-patch 的结果给接收者
# 接收者保存邮件到文件 email.txt，然后应用补丁创建一个提交，会自动包含作者的信息
git am &amp;lt; email.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;直接用于-git-am&#34;&gt;直接用于 git am&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;git am&lt;/code&gt; 将 mailbox 的邮件信息分割成提交日志信息、作者信息和补丁，应用它们至当前分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 提取 R1 和 R2 之间的提交，使用 git am 来 cherry-pick 提交应用到当前分支
git format-patch -k --stdout R1..R2 | git am -3 -k
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/git-format-patch&#34; target=&#34;_blank&#34;&gt;git format-patch doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/gitrevisions&#34; target=&#34;_blank&#34;&gt;gitrevisions doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/git-am&#34; target=&#34;_blank&#34;&gt;git am doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/git-send-email&#34; target=&#34;_blank&#34;&gt;git send-email doc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/git-apply&#34; target=&#34;_blank&#34;&gt;git apply doc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git push 推送数据</title>
      <link>https://xueqing.github.io/blog/git/git_push/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_push/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将本地的 master 分支推送至 origin 服务器的 dev 分支
git push origin master:dev
git push url master
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git rebase 变基</title>
      <link>https://xueqing.github.io/blog/git/git_rebase/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_rebase/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%98%e5%9f%ba&#34;&gt;变基&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-rebase&#34;&gt;git rebase&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#git-rebase--i&#34;&gt;git rebase -i&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;变基&#34;&gt;变基&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;变基和三方合并整合的最终结果指向的快照始终是一样的, 只是提交历史不同&lt;/li&gt;
&lt;li&gt;变基是将一系列提交按照原有次序依次应用到另一分支上, 而三方合并是把最终结果合在一起&lt;/li&gt;
&lt;li&gt;变基使得提交历史更加简洁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：不要对在你的仓库外有副本的分支执行变基&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-rebase&#34;&gt;git rebase&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将当前分支变基到 base_branch
git rebase base_branch
# 将 topic_branch 变基到 base_branch
# 等同于 git checkout topic_branch &amp;amp;&amp;amp; git rebase base_branch
git rebase base_branch topic_branch
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;git-rebase-i&#34;&gt;git rebase -i&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;交互式变基的命令&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;pick/p：使用提交&lt;/li&gt;
&lt;li&gt;reword/r：使用提交，但是修改日志信息&lt;/li&gt;
&lt;li&gt;edit/e：标记一个提交需要修改&lt;/li&gt;
&lt;li&gt;squash/s：将当前提交与前一个提交合并&lt;/li&gt;
&lt;li&gt;fixup/f：将当前提交与前一个提交合并，并丢弃日志信息&lt;/li&gt;
&lt;li&gt;exec/x：使用 shell 运行剩下的命令行&lt;/li&gt;

&lt;li&gt;&lt;p&gt;drop/d：删除提交&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 放弃修改
git rebase --abort
# 重写从初次提交到达 commit 的所有历史
git rebase -i --root &amp;lt;commit&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/git-rebase&#34; target=&#34;_blank&#34;&gt;git rebase&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git remote 远程仓库</title>
      <link>https://xueqing.github.io/blog/git/git_remote/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_remote/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看指定的每一个远程服务器的简写
git remote
# 查看需要读写远程仓库使用的 git 保存的简写与其对应的 URL
git remote -v
# 查看某一个远程仓库信息
git remote show [remote-name]
# 添加一个新的远程 git 仓库, 同时指定一个简写
git remote add &amp;lt;shortname&amp;gt; &amp;lt;url&amp;gt;
# 移除一个远程仓库
git remote rm lvlin
# 修改一个远程仓库的简写名, 这同样也会修改远程分支名字
git remote rename temp lvlin
# 列出远端分支
git remote -r
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git revert</title>
      <link>https://xueqing.github.io/blog/git/git_revert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_revert/</guid>
      <description></description>
    </item>
    
    <item>
      <title>git rm 移除文件</title>
      <link>https://xueqing.github.io/blog/git/git_rm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_rm/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 从工作目录中删除指定的文件并存入暂存区
git rm file1
# 删除之前修改过并且已经放到暂存区域的文件, --forced, 用于防止误删还没有添加到快照的数据
git rm -f file1
# 从 git 仓库中删除文件, 即从暂存区域移除, 但仍然保留在当前工作目录
git rm --cached file1
# 可以使用 glob 模式
# 删除 log/ 目录下扩展名为 .log 的所有文件
git rm log/\*.log
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git status 跟踪状态</title>
      <link>https://xueqing.github.io/blog/git/git_status/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_status/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看哪些文件处于什么状态
git status
# 得到一种更为紧凑的格式输出, --short
git status -s
git status --ignored
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git submodule</title>
      <link>https://xueqing.github.io/blog/git/git_submodule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_submodule/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#git-submodule&#34;&gt;git submodule&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&#34;&gt;应用场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%97%AE%E9%A2%98&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4&#34;&gt;高级命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;git&lt;/code&gt;将&lt;code&gt;submodule&lt;/code&gt;有关的信息保存在两个地方：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.gitmodules&lt;/code&gt;在仓库中，有版本控制，修改之后会同步到其他仓库，使用&lt;code&gt;submodule&lt;/code&gt;相关命令的时候会自动更新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.git/config&lt;/code&gt;在本地，需要手动更新，或者执行&lt;code&gt;git submodule sync&lt;/code&gt;将新的配置从&lt;code&gt;.gitmodules&lt;/code&gt;拷贝到&lt;code&gt;.git/config&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git submodule sync&lt;/code&gt;会将&lt;code&gt;submodule&lt;/code&gt;远程的 url 配置设置到&lt;code&gt;.gitmodules&lt;/code&gt;，并且只会影响&lt;code&gt;.git/config&lt;/code&gt;已经有 url 的条目&lt;/li&gt;
&lt;li&gt;指定&lt;code&gt;--recursive&lt;/code&gt;，将会递归更新注册的&lt;code&gt;submodule&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;场景1：添加一个&lt;code&gt;submodule&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git submodule add repo_url local_path&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此命令做三件事：克隆工程到本地；创建/修改&lt;code&gt;.gitmodules&lt;/code&gt;标记&lt;code&gt;submodule&lt;/code&gt;的具体信息；更新&lt;code&gt;.git/config&lt;/code&gt;文件，增加&lt;code&gt;submodule&lt;/code&gt;的地址&lt;/li&gt;
&lt;li&gt;可用&lt;code&gt;git submodule add -b branch_name repo_url local_path&lt;/code&gt;指定&lt;code&gt;submodule&lt;/code&gt;跟踪的分支&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;场景 2：删除一个&lt;code&gt;submodule&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git submodule deinit -f -- path_to_submodule&lt;/code&gt;(路径最后不要加斜线)&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;.git/modules&lt;/code&gt;下面的文件夹&lt;/li&gt;
&lt;li&gt;从 git 版本控制中删除缓存的子模块对应文件夹&lt;/li&gt;
&lt;li&gt;本地仍保留文件&lt;code&gt;git rm --cached path_to_submodule&lt;/code&gt;(路径最后不要加斜线)&lt;/li&gt;
&lt;li&gt;本地不保留文件&lt;code&gt;git rm -f path_to_submodule&lt;/code&gt;(路径最后不要加斜线)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;场景 3：更新&lt;code&gt;submodule&lt;/code&gt;的&lt;code&gt;url&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;删除&lt;code&gt;.git/config&lt;/code&gt;相关代码&lt;/li&gt;
&lt;li&gt;删除工程目录下的&lt;code&gt;.gitmodules&lt;/code&gt;相关代码&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;git submodule sync --recursive&lt;/code&gt;更新到本地的配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;场景 4：克隆一个有&lt;code&gt;submodule&lt;/code&gt;的项目

&lt;ul&gt;
&lt;li&gt;分步克隆&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone repo_url&lt;/code&gt;，&lt;code&gt;submodule&lt;/code&gt;的代码不会和父项目一起克隆出来&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git submodule update --init [--recursive]&lt;/code&gt;可以检出&lt;code&gt;submodule&lt;/code&gt;的代码，&lt;code&gt;recursive&lt;/code&gt;适用于嵌套&lt;code&gt;submodule&lt;/code&gt;的项目&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git submodule update --init [--recursive] subname&lt;/code&gt;可以检出指定子模块&lt;code&gt;subname&lt;/code&gt;的代码，&lt;code&gt;recursive&lt;/code&gt;适用于嵌套&lt;code&gt;submodule&lt;/code&gt;的项目&lt;/li&gt;
&lt;li&gt;一步克隆&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone repo_url --recursive&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;场景 5：更新&lt;code&gt;submodule&lt;/code&gt;，与远程仓库同步&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;更改对应的&lt;code&gt;submodule&lt;/code&gt;提交到远程仓库&lt;/li&gt;
&lt;li&gt;在父工程中，进入该&lt;code&gt;submodule&lt;/code&gt;，执行&lt;code&gt;git pull&lt;/code&gt;，可以用&lt;code&gt;git status&lt;/code&gt;查看&lt;code&gt;submodule&lt;/code&gt;是否有改到&lt;/li&gt;
&lt;li&gt;如果有改到，需要执行&lt;code&gt;git add&lt;/code&gt;提交该&lt;code&gt;submodule&lt;/code&gt;的更新&lt;/li&gt;
&lt;li&gt;也可在父工程中执行&lt;code&gt;git submodule update --remote&lt;/code&gt;更新所有子模块到最新版本，再执行&lt;code&gt;git add&lt;/code&gt;提交所有子模块的更新&lt;/li&gt;
&lt;li&gt;注意：在含有子模块的工程中，每次执行&lt;code&gt;git pull&lt;/code&gt;之后需要执行&lt;code&gt;git submodule update --remote&lt;/code&gt;更新子模块&lt;/li&gt;

&lt;li&gt;&lt;p&gt;技巧：可以通过修改&lt;code&gt;~/.gitconfig&lt;/code&gt;设置每次&lt;code&gt;git pull&lt;/code&gt;之后执行&lt;code&gt;git submodule update --remote&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;[alias]
psu = !git pull &amp;amp;&amp;amp; git submodule update
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;问题 1：&lt;code&gt;git submodule add&lt;/code&gt;时报错&lt;code&gt;A git directory for xxx is found locally with remote(s): origin&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;删除&lt;code&gt;.git/config&lt;/code&gt;相关代码&lt;/li&gt;
&lt;li&gt;删除工程目录下的&lt;code&gt;.gitmodules&lt;/code&gt;相关代码&lt;/li&gt;
&lt;li&gt;删除缓存的子模块&lt;code&gt;git rm --cached path_to_submodule&lt;/code&gt;`(路径最后不要加斜线)&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;git submodule sync --recursive&lt;/code&gt;更新到本地的配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;问题 2：&lt;code&gt;git submodule add&lt;/code&gt;时报错&lt;code&gt;Pathspec xxx is in submodule&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;删除缓存的子模块&lt;code&gt;git rm --cached path_to_submodule&lt;/code&gt;(路径最后不要加斜线)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;高级命令&#34;&gt;高级命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;查看差异输出，使得子模块的差异输出更加具体&lt;code&gt;git diff --cached --submodule&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改子模块跟踪分支

&lt;ul&gt;
&lt;li&gt;只修改本地：修改&lt;code&gt;.git/config&lt;/code&gt;文件中对应子模块的设置&lt;/li&gt;
&lt;li&gt;修改仓库：&lt;/li&gt;
&lt;li&gt;修改&lt;code&gt;.gitmodule&lt;/code&gt;的命令&lt;code&gt;git config -f .gitmodules submodule.Utility.branch dev&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Utility&lt;/code&gt;是子模块的名字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dev&lt;/code&gt;是&lt;code&gt;Utility&lt;/code&gt;的分支&lt;/li&gt;
&lt;li&gt;不用&lt;code&gt;-f .gitmodules&lt;/code&gt;只会应用到本地&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;同步到本地配置&lt;code&gt;git submodule sync&lt;/code&gt;????&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在主项目查看子模块的更改摘要：配置选项&lt;code&gt;status.submodulesummary&lt;/code&gt;，使用命令&lt;code&gt;git config status.submodulesummary 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;子模块遍历

&lt;ul&gt;
&lt;li&gt;遍历子模块保存工作进度&lt;code&gt;git submodule foreach &#39;git stash save&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遍历子模块新建工作分支&lt;code&gt;git submodule foreach &#39;git checkout -b featureA&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在主项目查看所有子模块的修改内容&lt;code&gt;git diff; git submodule foreach &#39;git diff&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除所有子模块本地的修改&lt;code&gt;git submodule foreach --recursive &#39;git checkout .&#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在主项目修改子模块

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git submodule update&lt;/code&gt;更新子模块的文件时，会将子仓库留在一个&lt;code&gt;游离的HEAD&lt;/code&gt;状态，本地没有工作分支跟踪改到&lt;/li&gt;
&lt;li&gt;首先进入子模块检出一个分支，修改之后提交到本地&lt;/li&gt;
&lt;li&gt;拉取远程仓库的子模块提交并合并到本地&lt;code&gt;git submodule update --remote --rebase/merge&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;发布子模块的改到

&lt;ul&gt;
&lt;li&gt;在主项目推送代码到远程仓库前检查本地有没有未推送的子模块修改&lt;code&gt;git push --recursive-submodules=check&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果提交的子模块改到未推送，会导致主项目的推送失败，可以根据提示进入子模块然后推送到远程仓库&lt;/li&gt;
&lt;li&gt;或者使用&lt;code&gt;git push --recursive-submodules=on-demand&lt;/code&gt;，&lt;code&gt;git&lt;/code&gt;会尝试推送子模块修改到远程仓库，只有子模块都推送成功，主项目才可以推送&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git tag 标签</title>
      <link>https://xueqing.github.io/blog/git/git_tag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_tag/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;标签不能像分支一样来回移动. 分为轻量标签（lightweight）与附注标签（annotated）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;轻量标签：很像一个不会改变的分支, 只是一个特定提交的引用. 本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息&lt;/li&gt;

&lt;li&gt;&lt;p&gt;附注标签：存储在 git 数据库中的一个完整对象.  是可以被校验的；包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 列出已有的标签
git tag
# 列出 1.8.5 系列的标签
git tag -l &#39;v1.8.5*&#39;
# 创建一个附注标签
git tag -a v1.4 -m &#39;v1.4&#39;
# 查看标签信息与对应的提交信息
git show v1.4
# 创建一个轻量标签
git tag v1.4-lw
# 不会看到额外的标签信息.  只会显示出提交信息
git show v1.4-lw
# 在 commit-id 提交上打标签
git tag -a v1.2 &amp;lt;commit-id&amp;gt;
# 把所有不在远程仓库服务器上的标签全部推送到远程仓库服务器
git push origin --tags
# 把 [tagname] 标签推送到远程仓库服务器
git push origin [tagname]
# 在标签 v2.0.0 上创建分支 v2
git checkout -b v2 v2.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>git 分支</title>
      <link>https://xueqing.github.io/blog/git/git_branch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_branch/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#head&#34;&gt;HEAD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-branch&#34;&gt;git branch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-checkout&#34;&gt;git checkout&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%90%88%e5%b9%b6%e5%88%86%e6%94%af&#34;&gt;合并分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8b%89%e5%8f%96%e5%88%86%e6%94%af&#34;&gt;拉取分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%a0%e9%99%a4%e8%bf%9c%e7%a8%8b%e4%bb%93%e5%ba%93%e5%88%86%e6%94%af&#34;&gt;删除远程仓库分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%86%e6%94%af%e5%bc%95%e7%94%a8&#34;&gt;分支引用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;head&#34;&gt;HEAD&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HEAD：一个指针, 指向当前所在的本地分支

&lt;ul&gt;
&lt;li&gt;HEAD 分支随着提交操作自动向前移动&lt;/li&gt;
&lt;li&gt;检出时 HEAD 随之移动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-branch&#34;&gt;git branch&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看当前所有分支列表, 星号表示 HEAD 指向的分支
git branch
# 创建新分支 dev
git branch dev
# 以7次前的提交创建新的 master 分支
git branch master HEAD~7
# 在 commit-id 创建分支 dev
git branch dev [commit-id]
# 删除 dev 分支
git branch -d dev
# 强制删除 dev 分支
git branch -D dev
# 查看每个分支的最后一次提交
git branch -v
# 查看哪些分支已经合并到当前分支
git branch --merged
# 查看所有包含未合并工作的分支
git branch --no-merged
# 设置已有的本地分支正在跟踪的上游分支,--set-upstream-to
git branch -u origin/dev
# 重命名 master 分支为 fix
git branch -m master fix
# 列举所有本地分支并显示具体信息
git branch -vv
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;git-checkout&#34;&gt;git checkout&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 切换至 dev 分支
git checkout dev
# 创建并切换至分支 dev，等同于 git branch + git checkout
git checkout -b dev
# 在 commit-id 创建并切换至分支 dev
git checkout -b dev [commit-id]
# 从远程 dev 分支创建本地分支 deve, 本地 deve 分支会自动从 origin/dev 分支拉取
git checkout -b deve origin/dev
# 以7次前的提交创建并切换到新的 master 分支
git checkout HEAD~7 -b master
# 从远程 dev 分支创建本地分支 dev, 本地 dev 分支会自动从 origin/dev 分支拉取
git checkout --track origin/dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;合并分支&#34;&gt;合并分支&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 合并 dev 分支至当前分支
# 当设置好跟踪分支后, 可以通过 @{upstream} 或 @{u} 快捷方式来引用它
# 所以在 master 分支且它正在跟踪 origin/master 时, 可以使用 git merge @{u} 来取代 git merge origin/master
git merge dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;拉取分支&#34;&gt;拉取分支&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 抓取所有的远程仓库
git fetch --all
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;删除远程仓库分支&#34;&gt;删除远程仓库分支&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 删除远程 dev 分支, git v1.7.0
git push origin --delete dev
# git v1.5.0
git push origin :dev
# git v2.8.0
git push origin -d dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分支引用&#34;&gt;分支引用&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看某个分支指向的SHA-1
git rev-parse branch_name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>git 别名管理</title>
      <link>https://xueqing.github.io/blog/git/git_alias/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_alias/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用&lt;code&gt;git config&lt;/code&gt;为命令设置别名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;输入 git cpick commit-id 就可以引用某次提交
git config --global alias.cpick cherry-pick
git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;git config&lt;/code&gt;新建命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 输入 git unstage fileA 就可以取消文件暂存
git config --global alias.unstage &#39;reset HEAD --&#39;
# 输入 git last 可以查看最后一次提交
git config --global alias.last &#39;log -1 HEAD&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;git config&lt;/code&gt;可以执行外部命令，在命令前加&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 输入 git visual 等同于执行 gitk
git config --global alias.visual &#39;!gitk&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>github 账户管理</title>
      <link>https://xueqing.github.io/blog/git/account_ssh/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/account_ssh/</guid>
      <description>

&lt;h2 id=&#34;添加-ssh-ke-到-github-账户&#34;&gt;添加 SSH ke 到 github 账户&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;检查 .ssh 文件夹是否有密钥 &lt;code&gt;ls ~/.ssh/&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;没有的话生成密钥 &lt;code&gt;ssh-keygen -t rsa -C &amp;quot;your_email@example.com&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加 SSH key 到 ssh-agent&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 后台启动 ssh-agent
eval $(ssh-agent -s)
# 添加 key
ssh-add ~/.ssh/id_rsa
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 github 的个人设置中添加一个 ssh-key&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可在某个 repository 中单独管理访问的 ssh-key&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;测试连接-github-网站&#34;&gt;测试连接 github 网站&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 尝试 ssh 到 github
ssh -T git@github.com
# 看到更详细的信息
ssh -vT git@github.com
# 看到 warning 之后输入 yes 尝试继续连接，如果看到 Hi username 说明连接成功
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;验证捆绑到-github-账户的-public-key&#34;&gt;验证捆绑到 github 账户的 public key&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 启动 ssh-agent 服务
ssh-agent -s
# 查看 public key 的 fingerprint
ssh-add -l
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>gitlab 踩坑</title>
      <link>https://xueqing.github.io/blog/gitlab/gitlab/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/gitlab/gitlab/</guid>
      <description>

&lt;h2 id=&#34;cache&#34;&gt;cache&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用 gitlab 的 CI/CD 时，将项目的 runner 设置为 group-runner&lt;/li&gt;
&lt;li&gt;若同一个 pipeline 中的 stage 之间共享的 cache 依赖于同一个 runner，所以要保证同一个 pipeline 使用的是一个 runner&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以定义基类的 job，指定某个 tag  的 runner，其他需要共享 cache 的 job 继承此 job。例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;.job:
tags:
- vdms1

build-job:
extends: .job

package-job:
extends: .job
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;含有子模块的工程在克隆源码时遇到下面的问题&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Checking out 7f97aadf as master...
Skipping Git submodules setup
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方案&lt;a href=&#34;https://docs.gitlab.com/ee/ci/git_submodules.html#using-git-submodules-in-your-ci-jobs&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 确定子模块的 URL 使用相对路径&lt;/li&gt;
&lt;li&gt;2 gitlab-runner 版本是 v1.10+ 的，设置&lt;code&gt;GIT_SUBMODULE_STRATEGY&lt;/code&gt;为&lt;code&gt;normal&lt;/code&gt;或&lt;code&gt;recursive&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3 gitlab-runner 版本较低的，在&lt;code&gt;before-script&lt;/code&gt;中使用&lt;code&gt;git submodule sync/update&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;before_script:
- git submodule sync --recursive
- git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go bug</title>
      <link>https://xueqing.github.io/translation/go-doc/command/bug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/bug/</guid>
      <description>&lt;p&gt;用法：&lt;code&gt;go bug&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令打开默认浏览器，并开启一个新的缺陷报告。报告包含有用的系统信息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go build</title>
      <link>https://xueqing.github.io/translation/go-doc/command/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/build/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%ba%90%e7%a0%81%e6%96%87%e4%bb%b6&#34;&gt;源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa-go-%e6%ba%90%e7%a0%81%e6%96%87%e4%bb%b6&#34;&gt;编译多个 Go 源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-build-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go build 的参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%9d%e8%b5%96%e5%8c%85&#34;&gt;依赖包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%84%e5%bb%ba%e6%a0%87%e7%ad%be&#34;&gt;构建标签&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build [-o output] [-i] [build flags] [packages]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令用于编译我们指定的源码文件或代码包以及它们的依赖包&lt;/li&gt;
&lt;li&gt;如果在执行 &lt;code&gt;go build&lt;/code&gt; 命令时不后跟任何代码包，那么命令将试图编译当前目录所对应的代码包&lt;/li&gt;
&lt;li&gt;编译码包 &lt;code&gt;cnet/ctcp&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH/src/cnet/ctcp&lt;/code&gt; 执行 &lt;code&gt;go build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH/src/cnet/&lt;/code&gt; 执行 &lt;code&gt;go build ctcp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在任意目录下执行 &lt;code&gt;go build cnet/ctcp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 会忽略目录下以 “_” 或 “.” 开头的 go 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt; 强制将生成的可执行文件或目标文件写到指定的输出文件或文件夹。如果指定的输出是存在的文件夹，生成的可执行文件会写到文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 安装依赖包&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;源码文件&#34;&gt;源码文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go 语言的源码文件有三大类，即：命令源码文件、库源码文件和测试源码文件

&lt;ul&gt;
&lt;li&gt;命令源码文件：总是作为可执行的程序的入口&lt;/li&gt;
&lt;li&gt;库源码文件：一般用于集中放置各种待被使用的程序实体（全局常量、全局变量、接口、结构体、函数等等）&lt;/li&gt;
&lt;li&gt;测试源码文件：主要用于对前两种源码文件中的程序实体的功能和性能进行测试。另外也可以用于展现命令源码文件和库源码文件中程序的使用方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果是库源码文件，执行 &lt;code&gt;go build&lt;/code&gt; 之后，不会产生任何文件。如果需要在 &lt;code&gt;$GOPATH/pkg&lt;/code&gt; 下生成相应的文件，那就得执行 &lt;code&gt;go install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是命令源码文件(main 包)，执行 &lt;code&gt;go build&lt;/code&gt; 之后，它就会调用链接器在当前目录下生成一个可执行文件，可执行程序的名字取自包的导入路径的最后一段。如果需要在 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 下生成相应的文件，需要执行 &lt;code&gt;go install&lt;/code&gt;，或者使用 &lt;code&gt;go build -o 可执行文件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编译多个-go-源码文件&#34;&gt;编译多个 Go 源码文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 默认会编译当前目录下的所有 go 文件

&lt;ul&gt;
&lt;li&gt;构建所有需要的包及其依赖，然后丢弃除了可执行程序之外的所有编译的代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以同时编译多个 Go 源码文件，在 &lt;code&gt;go build&lt;/code&gt; 后跟要编译的文件名，用空格分隔

&lt;ul&gt;
&lt;li&gt;限制：作为参数的多个 Go 源码文件必须在同一个目录中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查性的编译，而不会输出任何结果文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令既不能编译包含多个命令源码文件的代码包，也不能同时编译多个命令源码文件。因为，如果把多个命令源码文件作为一个整体看待，那么每个文件中的 main 函数就属于重名函数，在编译时会抛出重复定义错误&lt;/li&gt;
&lt;li&gt;如果编译的多个属于 main 包的源码文件中没有 main 函数的声明，那么就会使编译器立即报出“未定义 main 函数声明”的错误并中止编译&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结：&lt;/strong&gt;同时编译多个 main 包的源码文件时，要保证其中有且仅有一个 main 函数声明，否则编译是无法成功的&lt;/li&gt;
&lt;li&gt;如果有多个声明为属于 main 包的源码文件，且其中只有一个文件声明了 main 函数的话，那么是可以使用 &lt;code&gt;go build&lt;/code&gt; 命令同时编译它们的。在这种情况下，不包含 main 函数声明的那几个源码文件会被视为库源码文件。如此编译之后的可执行文件的名称来自指定的编译目标中最左边的那个源码文件的主文件名相同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-build-的参数&#34;&gt;go build 的参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;下面的编译标志被 &lt;code&gt;build/clean/get/install/list/run/test&lt;/code&gt; 共享&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;强行重新构建包，即使它们已经是最新的了，但是对标准包不适用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;打印将要执行的命令，但是不执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-p n&lt;/td&gt;
&lt;td&gt;指定执行命令的并行程序数量。默认等于可用的 CPU 逻辑数。在 darwin/arm (iPhone 和 iPad) 平台，默认是1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-race&lt;/td&gt;
&lt;td&gt;开启竞态条件检测。仅在 linux/amd64、freebsd/amd64、darwin/amd64和windows/amd64 平台支持&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;打印被编译的包名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-work&lt;/td&gt;
&lt;td&gt;打印临时工作目录名称，且如果存在不会在执行命令后删除。默认结束命令时会删除该目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;打印命令。注意它与 &lt;code&gt;-n&lt;/code&gt; 标记的区别&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;其他参数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-mod&lt;/code&gt; 控制对 &lt;code&gt;go.mod&lt;/code&gt; 的更新和使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mod=readonly&lt;/code&gt; 不能隐式自动更新 &lt;code&gt;go.mod&lt;/code&gt;。当需要修改 &lt;code&gt;go.mod&lt;/code&gt; 时会失败。用于检查 &lt;code&gt;go.mod&lt;/code&gt; 不需要任何更新，比如在持续集成和测试系统

&lt;ul&gt;
&lt;li&gt;这个参数对 &lt;code&gt;go get&lt;/code&gt; 不生效，即命令仍然可以更新 &lt;code&gt;go.mod&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mod=vendor&lt;/code&gt;: 使用模块的顶层的 &lt;code&gt;vendor&lt;/code&gt; 目录来编译以满足依赖(不使用通常的网络源码和本地缓存)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;依赖包&#34;&gt;依赖包&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令在执行时，编译程序会先查找目标代码包的所有依赖包，以及这些依赖包的依赖包，直至找到最深层的依赖包为止。在此过程中，如果发现有循环依赖的情况，编译程序就会输出错误信息并立即退出。此过程完成之后，所有的依赖关系也就形成了一棵含有重复元素的依赖树。对于依赖树中的一个节点（代码包）来说，它的直接分支节点（前者的依赖包），是按照代码包导入路径的字典序从左到右排列的。最左边的分支节点会最先被编译。编译程序会依此设定每个代码包的编译优先级&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go build&lt;/code&gt; 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：&lt;code&gt;依赖代码包 -&amp;gt; 当前代码包 -&amp;gt; 触发代码包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在执行 &lt;code&gt;go build&lt;/code&gt; 命令时加入标记 &lt;code&gt;-p 1&lt;/code&gt;，那么就可以保证代码包编译顺序严格按照预先设定好的优先级进行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;构建标签&#34;&gt;构建标签&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;构建标签：&lt;code&gt;go build&lt;/code&gt; 只会在构建指定规格的目标文件的时候才进行编译，叫做构建标签的特殊注释，提供更细力度的控制。&lt;/li&gt;
&lt;li&gt;注释需要加在包的声明之前，这是文档注释。如 &lt;code&gt;// +build linux darwin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;// +build ignore&lt;/code&gt; 指出任何时候都不要编译这个文件&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go clean</title>
      <link>https://xueqing.github.io/translation/go-doc/command/clean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/clean/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-clean-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go clean 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go clean&lt;/code&gt; 命令会删除掉执行其它命令时产生的一些文件和目录，包括

&lt;ul&gt;
&lt;li&gt;有一些目录和文件是在编译 Go 或 C 源码文件时留在相应目录中的&lt;/li&gt;
&lt;li&gt;目录 &lt;code&gt;_obj/&lt;/code&gt;：旧的 object 目录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;目录 &lt;code&gt;_test/&lt;/code&gt;：旧的 test 目录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;_testmain.go&lt;/code&gt;：旧的 gotest 文件，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;test.out&lt;/code&gt;：旧的 test 记录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;build.out&lt;/code&gt;：旧的 test 记录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;a.out&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;DIR(.exe)&lt;/code&gt;： 由 &lt;code&gt;go build&lt;/code&gt; 在当前代码包下生成的与包名同名或者与 Go 源码文件同名的可执行文件(Windows 带有 &lt;code&gt;.exe&lt;/code&gt; 后缀)&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;DIR.test(.exe)&lt;/code&gt;： 由 &lt;code&gt;go test -c&lt;/code&gt; 在当前代码包下生成(Windows 带有 &lt;code&gt;.test.exe&lt;/code&gt; 后缀)&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;MAINFILE(.exe)&lt;/code&gt;： 由 &lt;code&gt;go build MAINFILE.go&lt;/code&gt; 产生&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;*.so&lt;/code&gt;：由 SWIG 遗留&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go clean&lt;/code&gt; 命令时带有标记 &lt;code&gt;-i&lt;/code&gt;，则会同时删除安装当前代码包时所产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区的 pkg 目录的相应目录下的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区的 bin 目录下的可执行文件。这些目录和文件是在执行 &lt;code&gt;go build&lt;/code&gt; 命令时生成在临时目录中的。临时目录的名称以 go-build 为前缀&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go clean&lt;/code&gt; 命令时带有标记 &lt;code&gt;-r&lt;/code&gt;，则还包括当前代码包的所有依赖包的上述目录和文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-clean-的参数&#34;&gt;go clean 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;清除关联的安装的包和可运行文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;打印执行命令期间所用到的其它命令，但是并不真正执行它们&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;循环的清除在 import 中引入的包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;打印执行命令期间所用到的其它命令。注意它与 &lt;code&gt;-n&lt;/code&gt; 标记的区别&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go doc</title>
      <link>https://xueqing.github.io/translation/go-doc/command/doc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/doc/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e8%af%ad%e8%a8%80%e7%a8%8b%e5%ba%8f%e5%ae%9e%e4%bd%93&#34;&gt;Go 语言程序实体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-doc-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go doc 的参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#godoc&#34;&gt;godoc&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4%e8%a1%8c%e6%a8%a1%e5%bc%8f&#34;&gt;命令行模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#web-%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%bc%8f&#34;&gt;Web 服务器模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 命令可以打印附于 Go 语言程序实体上的文档。可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 可以接受一个参数，指定包/包成员/方法：&lt;code&gt;go doc http.Request&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 命令根据参数查找代码包或程序实体的顺序：Go 语言根目录（GOROOT 环境变量指定的目录）-&amp;gt; 工作区目录（GOPATH 环境变量包含的目录）。在内部遵循字典序&lt;/li&gt;
&lt;li&gt;如果某个工作区目录中的代码包与标准库中的包重名了，那么它是无法被打印出来的。&lt;code&gt;go doc&lt;/code&gt; 命令只会打印出第一个匹配的代码包或程序实体的文档&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 也可以接受两个参数：&lt;code&gt;go doc net/http Request&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这是一种更加精细的指定代码包或程序实体的方式&lt;/li&gt;
&lt;li&gt;第一个参数的代码包名称必须是完整的导入路径&lt;/li&gt;
&lt;li&gt;在给定两个参数时，&lt;code&gt;go doc&lt;/code&gt; 会打印出所有匹配的文档，而不是像给定一个参数时那样只打印出第一个匹配的文档。这对于查找只有大小写不同的多个方法（如 New、new）的文档来说非常有用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-语言程序实体&#34;&gt;Go 语言程序实体&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go 语言的程序实体，是指变量、常量、函数、结构体以及接口&lt;/li&gt;
&lt;li&gt;程序实体的标识符即是代表它们的名称。标识符又分非限定标识符和限定标识符

&lt;ul&gt;
&lt;li&gt;限定标识符一般用于表示某个代码包中的程序实体或者某个结构体类型中的方法或字段&lt;/li&gt;
&lt;li&gt;如：标准库代码包 io 中的名为 EOF 的变量用限定标识符表示即 io.EOF&lt;/li&gt;
&lt;li&gt;如：如果有一个 sync.WaitGroup 类型的变量 wg 并且想调用它的 Add 方法，那么可以这样写 wg.Add()。其中，wg.Add 就是一个限定标识符，而后面的 () 则代表了调用操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-doc-的参数&#34;&gt;go doc 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;区分参数中字母的大小写。默认情况下，命令是大小写不敏感的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-cmd&lt;/td&gt;
&lt;td&gt;打印出 main 包中的可导出的程序实体（其名称的首字母大写）的文档。默认情况下，这部分文档是不会被打印出来的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;打印出不可导出的程序实体（其名称的首字母小写）的文档。默认情况下，这部分文档是不会被打印出来的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;godoc&#34;&gt;godoc&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 Go1.2 版本之前还支持 &lt;code&gt;go doc&lt;/code&gt; 命令，但是之后全部移到了 &lt;code&gt;godoc&lt;/code&gt; 这个命令下，需要这样安装 &lt;code&gt;go get golang.org/x/tools/cmd/godoc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 Go1.5 版本中，&lt;code&gt;go doc&lt;/code&gt; 是一个内置的标准命令&lt;/li&gt;
&lt;li&gt;命令有两种模式可供选择&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命令行模式&#34;&gt;命令行模式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不加入 &lt;code&gt;-http&lt;/code&gt; 标记：以命令行模式运行。在打印纯文本格式的文档到标准输出后，命令执行就结束了。如 &lt;code&gt;godoc fmt Printf&lt;/code&gt;，&lt;code&gt;godoc fmt Printf Println&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加 &lt;code&gt;-src&lt;/code&gt; 标记：不但可以在文档中查看可导出的程序实体的声明，还可以看到源码。如 &lt;code&gt;godoc -src fmt Printf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;godoc&lt;/code&gt; 命令只能把代码包和程序实体的标识符拆成两个参数。也就是说，&lt;code&gt;godoc&lt;/code&gt; 命令不支持前文所述的 &lt;code&gt;go doc&lt;/code&gt; 命令的单参数用法&lt;/li&gt;
&lt;li&gt;在实际的环境中，可能会遇到一个命令源码文件所产生的可执行文件与代码包重名的情况。比如，标准命令 go 和官方代码包 go。们要明确的告诉 &lt;code&gt;godoc&lt;/code&gt; 命令要查看可执行文件 go 的文档，需要在名称前加入 &lt;code&gt;cmd/&lt;/code&gt; 前缀 &lt;code&gt;godoc cmd/go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看 HTML 格式的文档，就需要加入标记 &lt;code&gt;-html&lt;/code&gt;，可以在其中找到一些相应源码的链接地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;web-服务器模式&#34;&gt;Web 服务器模式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;加上 &lt;code&gt;-http&lt;/code&gt; 标记：以 Web 服务器模式运行。以 Web 页面的形式提供 Go 语言文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;godoc -http=:6060&lt;/code&gt; 标记 &lt;code&gt;-http&lt;/code&gt; 的值 &lt;code&gt;:6060&lt;/code&gt; 表示启动的 Web 服务器使用本机的 6060 端口。之后，可通过在浏览器中输入 &lt;code&gt;http://localhost:6060&lt;/code&gt; 查看以网页方式展现的 Go 文档&lt;/li&gt;
&lt;li&gt;这使得在不方便访问 Go 语言官方站点的情况下也可以查看 Go 语言文档。并且通过本机的 Go 文档 Web 服务，还可以查看所有本机工作区下的代码的文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;godoc -http=:9090 -index&lt;/code&gt; 使用 &lt;code&gt;-index&lt;/code&gt; 标记开启搜索索引。这个索引会在服务器启动时创建并维护。如果不加入此标记，那么无论在 Web 页面还是命令行终端中都无法进行查询操作&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go env</title>
      <link>https://xueqing.github.io/translation/go-doc/command/env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/env/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-env-%e5%91%bd%e4%bb%a4%e5%8f%af%e6%89%93%e5%8d%b0%e5%87%ba%e7%9a%84-go-%e8%af%ad%e8%a8%80%e9%80%9a%e7%94%a8%e7%8e%af%e5%a2%83%e4%bf%a1%e6%81%af&#34;&gt;go env 命令可打印出的 Go 语言通用环境信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-env-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go env 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go env&lt;/code&gt; 用于打印 Go 语言的环境信息：&lt;code&gt;go env GOARCH&lt;/code&gt; 或 &lt;code&gt;go env GOARCH GOCHAR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go env -w&lt;/code&gt; 重写 Go 语言的环境信息：&lt;code&gt;go env -w GOPRIVATE=&amp;quot;*.bmi&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-env-命令可打印出的-go-语言通用环境信息&#34;&gt;go env 命令可打印出的 Go 语言通用环境信息&lt;/h2&gt;

&lt;p&gt;| 名称 | 描述 |
| CGO_ENABLED | 指明 cgo 工具是否可用的标识 |
| GOARCH | 程序构建环境的目标计算架构 |
| GOBIN | 存放可执行文件的目录的绝对路径 |
| GOCHAR | 程序构建环境的目标计算架构的单字符标识 |
| GOEXE | 可执行文件的后缀 |
| GOHOSTARCH | 程序运行环境的目标计算架构 |
| GOOS | 程序构建环境的目标操作系统 |
| GOHOSTOS | 程序运行环境的目标操作系统 |
| GOPATH | 工作区目录的绝对路径 |
| GORACE | 用于数据竞争检测的相关选项 |
| GOROOT | Go 语言的安装目录的绝对路径 |
| GOTOOLDIR | Go 工具目录的绝对路径 |&lt;/p&gt;

&lt;h2 id=&#34;go-env-的参数&#34;&gt;go env 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go fmt</title>
      <link>https://xueqing.github.io/translation/go-doc/command/fmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/fmt/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gofmt-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;gofmt 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;go 代码有标准的风格。&lt;code&gt;go fmt file_name.go&lt;/code&gt; 命令可以格式化写好的代码文件&lt;/li&gt;
&lt;li&gt;开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了 &lt;code&gt;go fmt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;go fmt&lt;/code&gt; 命令，其实是调用了 &lt;code&gt;gofmt&lt;/code&gt;，而且需要参数 &lt;code&gt;-w&lt;/code&gt;，否则格式化结果不会写入文件。&lt;code&gt;gofmt -w -l src&lt;/code&gt; 可以格式化整个项目&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gofmt-的参数&#34;&gt;gofmt 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;显示需要格式化的文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;添加形如 “a[b:len(a)] -&amp;gt; a[b:]” 的重写规则，方便做批量替换&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;简化文件中的代码&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;显示格式化前后的 diff 而不是写入文件，默认是 false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-cpuprofile&lt;/td&gt;
&lt;td&gt;支持调试模式，写入相应的 cpufile 到指定的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go generate</title>
      <link>https://xueqing.github.io/translation/go-doc/command/generate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/generate/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go generate&lt;/code&gt; 用于在编译前自动化生成某类代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go generate&lt;/code&gt; 通过分析源码中特殊的注释，然后执行相应的命令。注意

&lt;ul&gt;
&lt;li&gt;此特殊注释必须在 &lt;code&gt;.go&lt;/code&gt; 源码文件&lt;/li&gt;
&lt;li&gt;每个源码文件可包含多个 generate 注释&lt;/li&gt;
&lt;li&gt;显示运行 &lt;code&gt;go generate&lt;/code&gt; 命令时，才会执行特殊注释后面的命令&lt;/li&gt;
&lt;li&gt;命令串执行时，如果出错则终止后面的执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//go:generate go tool yacc -o gopher.go -p parser gopher.y&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//go:generate&lt;/code&gt; 没有空格，这是一个固定的格式，在扫描源码文件的时候是根据这个来判断的&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;yacc&lt;/code&gt; 来生成代码：&lt;code&gt;-o&lt;/code&gt; 指定输出文件名，&lt;code&gt;-p&lt;/code&gt; 指定 package 名称&lt;/li&gt;
&lt;li&gt;这是一个单独的命令。如果想让 &lt;code&gt;go generate&lt;/code&gt; 来触发这个命令，那么就可以在当然目录的任意一个 xxx.go 文件里面的任意位置增加此注释&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go get</title>
      <link>https://xueqing.github.io/translation/go-doc/command/get/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/get/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-get-%e5%91%bd%e4%bb%a4%e6%94%af%e6%8c%81%e7%9a%84-vcs&#34;&gt;go get 命令支持的 VCS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-get-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go get 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 命令用来动态获取远程代码包，从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装&lt;/li&gt;
&lt;li&gt;在内部实际上分成了两步操作：第一步是下载源码包第一个工作区的 src 目录下，第二步是执行 &lt;code&gt;go install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下

&lt;ul&gt;
&lt;li&gt;BitBucket (Mercurial Git)&lt;/li&gt;
&lt;li&gt;GitHub (Git)&lt;/li&gt;
&lt;li&gt;Google Code Project Hosting (Git, Mercurial, Subversion)&lt;/li&gt;
&lt;li&gt;Launchpad (Bazaar)&lt;/li&gt;
&lt;li&gt;这些网站的项目包路径有一个共同标准：远程包路径格式是 &lt;code&gt;网站域名/作者或机构/项目名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如 &lt;code&gt;go get github.com/hyper-carrot/go_lib/logging&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 支持自定义域名的功能，具体参见 &lt;code&gt;go help remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;除非要求强行更新代码包，否则 &lt;code&gt;go get&lt;/code&gt; 命令不会进行重复下载&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-get-命令支持的-vcs&#34;&gt;go get 命令支持的 VCS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;代码版本控制系统（Version Control System，VCS）&lt;/li&gt;
&lt;li&gt;这几个版本控制系统都有一个共同点，那就是会在检出的项目目录中存放一个元数据目录，名称为 “.” 前缀加其主命令名&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;主命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mercurial&lt;/td&gt;
&lt;td&gt;hg&lt;/td&gt;
&lt;td&gt;Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Git&lt;/td&gt;
&lt;td&gt;git&lt;/td&gt;
&lt;td&gt;Git 最开始是 Linux Torvalds 为了帮助管理 Linux 内核开发而开发的一个开源的分布式版本控制软件。但现在已被广泛使用。它是被用来进行有效、高速的各种规模项目的版本管理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Subversion&lt;/td&gt;
&lt;td&gt;svn&lt;/td&gt;
&lt;td&gt;Subversion 是一个版本控制系统，也是第一个将分支概念和功能纳入到版本控制模型的系统。但相对于 Git 和 Mercurial 而言，它只算是传统版本控制系统的一员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Bazaar&lt;/td&gt;
&lt;td&gt;bzr&lt;/td&gt;
&lt;td&gt;Bazaar 是一个开源的分布式版本控制系统。但相比而言，用它来作为 VCS 的项目并不多&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于不知名的网站，需要指出导入路径使用哪种版本控制协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;位置由诸如 googlesource.com 或 github.com 之类通用服务托管，包可以在其导入路径中使用自定义域名。其 HTML 网页下包含元数据重定向 go 工具到实际托管地址的服务仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-get-的参数&#34;&gt;go get 的参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 命令可以接受所有可用于 &lt;code&gt;go build&lt;/code&gt; 命令和 &lt;code&gt;go install&lt;/code&gt; 命令的参数。这是因为 &lt;code&gt;go get&lt;/code&gt; 命令的内部步骤中完全包含了编译和安装这两个动作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 命令还有一些特有的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;只下载不安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;只有在包含 -u 参数时才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-fix&lt;/td&gt;
&lt;td&gt;在获取源码之后先运行 fix，而后再进行编译和安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-insecure&lt;/td&gt;
&lt;td&gt;允许使用非安全的 scheme（如HTTP）去下载指定的代码包。如果代码仓库（如公司内部的Gitlab）没有 HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;下载并安装指定的代码包中的测试源码文件中依赖的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;强制使用网络更新已有代码包及其依赖包。默认情况该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;显示执行的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go install</title>
      <link>https://xueqing.github.io/translation/go-doc/command/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/install/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85%e4%bb%a3%e7%a0%81%e5%8c%85&#34;&gt;安装代码包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85%e5%91%bd%e4%bb%a4%e6%ba%90%e7%a0%81%e6%96%87%e4%bb%b6&#34;&gt;安装命令源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-install-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go install 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 用于编译并安装指定的代码包及它们的依赖包&lt;/li&gt;
&lt;li&gt;这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或 &lt;code&gt;.a&lt;/code&gt; 包)，第二步会把编译好的结果移到指定目录(&lt;code&gt;$GOPATH/bin&lt;/code&gt; 或 &lt;code&gt;$GOPATH/pkg&lt;/code&gt;)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令只比 &lt;code&gt;go build&lt;/code&gt; 命令多做了一件事，即安装编译后的结果文件到指定目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令可以接受所有可用于 &lt;code&gt;go build&lt;/code&gt; 命令的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装代码包&#34;&gt;安装代码包&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令会把编译后的可执行文件保存在源码文件所在工作区的 bin 目录下，包保存在 pkg 目录&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;go install&lt;/code&gt; 命令后跟的代码包中仅包含库源码文件，那么 &lt;code&gt;go install&lt;/code&gt; 命令会把编译后的结果文件保存在源码文件所在工作区的 pkg 目录下。结果文件是对应的代码包归档文件（也叫静态链接库文件，名称以 .a 结尾）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令对仅包含库源码文件的代码包进行编译时，不会在当前工作区的 src 以及 pkg 目录下产生任何结果文件。结果文件会出于编译目的被生成在临时目录，但并不会使当前工作区目录产生任何变化。只会留下可执行文件。&lt;code&gt;go build -i&lt;/code&gt; 可将包安装在独立于构建目标的地方&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令时不后跟任何代码包参数，那么命令将试图编译当前目录所对应的代码包&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装命令源码文件&#34;&gt;安装命令源码文件&lt;/h2&gt;

&lt;h2 id=&#34;go-install-的参数&#34;&gt;go install 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;只下载不安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;只有在包含 -u 参数时才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-fix&lt;/td&gt;
&lt;td&gt;在获取源码之后先运行 fix，而后再进行编译和安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-insecure&lt;/td&gt;
&lt;td&gt;允许使用非安全的 scheme（如HTTP）去下载指定的代码包。如果代码仓库（如公司内部的Gitlab）没有 HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;下载并安装指定的代码包中的测试源码文件中依赖的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;强制使用网络更新已有代码包及其依赖包。默认情况该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;显示执行的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go list</title>
      <link>https://xueqing.github.io/translation/go-doc/command/list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/list/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8%e6%b3%95&#34;&gt;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#f&#34;&gt;-f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#m&#34;&gt;-m&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;列举命名包，每行一个。不带参数时判断一个包是否存在工作空间，存在则输出包的导入路径&lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;go list [-f format] [-json] [-m] [list flags] [build flags] [packages]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;常用的参数是 &lt;code&gt;-f&lt;/code&gt; 和 &lt;code&gt;-json&lt;/code&gt;，用于控制输出格式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list cnet hash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt; 通配符用于匹配包的导入路径中的任意子串

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go list ...&lt;/code&gt; 枚举工作空间的所有包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list ch3/...&lt;/code&gt; 指定子树中的所有包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list ...xml..&lt;/code&gt; 指定具体主题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list&lt;/code&gt; 获取每个包的完整元数据，提供各种用于对用户或其他工具可访问的格式&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;以容错模式加载和分析指定的代码包，这样讲不会打印错误信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-json&lt;/td&gt;
&lt;td&gt;把代码包的结构实体用 JSON 样式打印，所有值为对应类型的空值的字段会被忽略&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-compiled&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-deps&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-export&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-find&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-test&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;列举模块而不是包。使用 -f 指定的是模块模板&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;f&#34;&gt;-f&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用包模板语法指定可选格式。默认输出等价于 &lt;code&gt;-f &#39;{{ImportPath}}&#39;&lt;/code&gt;。&lt;code&gt;-f&lt;/code&gt; 的值需要满足 &lt;code&gt;text/template&lt;/code&gt; 中定义的语法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{.S}}&lt;/code&gt; 代表根结构体的 &lt;code&gt;S&lt;/code&gt; 字段的值。&lt;code&gt;go list&lt;/code&gt; 对应的跟结构体就是指定的代码包所对应的的结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -f {{.GoFiles}} cnet/ctcp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -e -f {{.Error.Err}} cnet&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -e -f &#39;The package {{.ImportPath}} is {{if .Incomplete}}incomplete!{{else}}complete.{{end}}&#39; cnet&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Package struct {
  Dir           string   // directory containing package sources
  ImportPath    string   // import path of package in dir
  ImportComment string   // path in import comment on package statement
  Name          string   // package name
  Doc           string   // package documentation string
  Target        string   // install path
  Shlib         string   // the shared library that contains this package (only set when -linkshared)
  Goroot        bool     // is this package in the Go root?
  Standard      bool     // is this package part of the standard Go library?
  Stale         bool     // would &#39;go install&#39; do anything for this package?
  StaleReason   string   // explanation for Stale==true
  Root          string   // Go root or Go path dir containing this package
  ConflictDir   string   // this directory shadows Dir in $GOPATH
  BinaryOnly    bool     // binary-only package (no longer supported)
  ForTest       string   // package is only for use in named test
  Export        string   // file containing export data (when using -export)
  Module        *Module  // info about package&#39;s containing module, if any (can be nil)
  Match         []string // command-line patterns matching this package
  DepOnly       bool     // package is only a dependency, not explicitly listed

  // Source files
  GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
  CgoFiles        []string // .go source files that import &amp;quot;C&amp;quot;
  CompiledGoFiles []string // .go files presented to compiler (when using -compiled)
  IgnoredGoFiles  []string // .go source files ignored due to build constraints
  CFiles          []string // .c source files
  CXXFiles        []string // .cc, .cxx and .cpp source files
  MFiles          []string // .m source files
  HFiles          []string // .h, .hh, .hpp and .hxx source files
  FFiles          []string // .f, .F, .for and .f90 Fortran source files
  SFiles          []string // .s source files
  SwigFiles       []string // .swig files
  SwigCXXFiles    []string // .swigcxx files
  SysoFiles       []string // .syso object files to add to archive
  TestGoFiles     []string // _test.go files in package
  XTestGoFiles    []string // _test.go files outside package

  // Cgo directives
  CgoCFLAGS    []string // cgo: flags for C compiler
  CgoCPPFLAGS  []string // cgo: flags for C preprocessor
  CgoCXXFLAGS  []string // cgo: flags for C++ compiler
  CgoFFLAGS    []string // cgo: flags for Fortran compiler
  CgoLDFLAGS   []string // cgo: flags for linker
  CgoPkgConfig []string // cgo: pkg-config names

  // Dependency information
  Imports      []string          // import paths used by this package
  ImportMap    map[string]string // map from source import to ImportPath (identity entries omitted)
  Deps         []string          // all (recursively) imported dependencies
  TestImports  []string          // imports from TestGoFiles
  XTestImports []string          // imports from XTestGoFiles

  // Error information
  Incomplete bool            // this package or a dependency has an error
  Error      *PackageError   // error loading package
  DepsErrors []*PackageError // errors loading dependencies
}

type PackageError struct {
  ImportStack   []string // shortest path from package named on command line to this one
  Pos           string   // position of error (if present, file:line:col)
  Err           string   // the error itself
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板函数 &lt;code&gt;join&lt;/code&gt; 调用 &lt;code&gt;strings.Join&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go list -f &#39;{{join .Deps &amp;quot; &amp;quot;}}&#39; strconv&lt;/code&gt; 输出 strconv 包的依赖过渡关系记录，空格分隔&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -f &#39;{{.ImportPath}} -&amp;gt; {{join .Imports &amp;quot; &amp;quot;}}&#39; compress/...&lt;/code&gt; 输出标准库的 compress 子树中每个包的直接导入记录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板函数 &lt;code&gt;context&lt;/code&gt; 返回构建上下文，定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Context struct {
  GOARCH        string   // target architecture
  GOOS          string   // target operating system
  GOROOT        string   // Go root
  GOPATH        string   // Go path
  CgoEnabled    bool     // whether cgo can be used
  UseAllFiles   bool     // use files regardless of +build lines, file names
  Compiler      string   // compiler to assume when computing target paths
  BuildTags     []string // build constraints to match in +build lines
  ReleaseTags   []string // releases the current release is compatible with
  InstallSuffix string   // suffix to use in the name of the install dir
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;m&#34;&gt;-m&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;默认输出模块路径、版本信息，如果有替换，输出替换信息

&lt;ul&gt;
&lt;li&gt;如果有替换，即 &lt;code&gt;Replace&lt;/code&gt; 不为 nil 时，下面的 &lt;code&gt;Dir&lt;/code&gt; 设置的是 &lt;code&gt;Replace.Dir&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;主模块是包含当前目录的模块。活动模块是主模块及其依赖模块。默认显示主模块

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt; 指定所有活动模块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;和 &lt;code&gt;-f&lt;/code&gt; 一起使用，指定模块模板&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结构体 Module 有一个 String 方法，用于格式化输出行，因此默认输出等价于 &lt;code&gt;-f {{.String}}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Module struct {
  Path      string       // module path
  Version   string       // module version
  Versions  []string     // available module versions (with -versions)
  Replace   *Module      // replaced by this module
  Time      *time.Time   // time version was created
  Update    *Module      // available update, if any (with -u)
  Main      bool         // is this the main module?
  Indirect  bool         // is this module only an indirect dependency of main module?
  Dir       string       // directory holding files for this module, if any
  GoMod     string       // path to go.mod file for this module, if any
  GoVersion string       // go version used in module
  Error     *ModuleError // error loading module
}

type ModuleError struct {
  Err string // the error itself
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-u&lt;/code&gt; 增加了关于可以升级的信息：&lt;code&gt;go list -m -u -json all&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-version&lt;/code&gt; 设置 &lt;code&gt;Module.Version&lt;/code&gt; 域为模块已知的版本&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板函数 &lt;code&gt;module&lt;/code&gt; 接收一个字符串参数(必须是一个模块路径或查询)，返回指定的模块对应的 Module 结构体&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go mod</title>
      <link>https://xueqing.github.io/translation/go-doc/command/mod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/mod/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8%e6%b3%95&#34;&gt;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#download&#34;&gt;download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#edit&#34;&gt;edit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#graph&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#init&#34;&gt;init&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tidy&#34;&gt;tidy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vendor&#34;&gt;vendor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#verify&#34;&gt;verify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why&#34;&gt;why&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用于操作模块。&lt;strong&gt;注意：所有的 go 命令支持模块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用法：&lt;code&gt;go mod &amp;lt;command&amp;gt; [arguments]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;download&lt;/td&gt;
&lt;td&gt;下载模块到本地缓存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;edit&lt;/td&gt;
&lt;td&gt;使用工具或脚本更新 go.mod&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;graph&lt;/td&gt;
&lt;td&gt;打印模块需求图&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;init&lt;/td&gt;
&lt;td&gt;在当前目录初始化一个新模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tidy&lt;/td&gt;
&lt;td&gt;添加缺失模块，删除无用模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vendor&lt;/td&gt;
&lt;td&gt;创建依赖的 vendor 拷贝&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;verify&lt;/td&gt;
&lt;td&gt;验证依赖拥有预期的内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;why&lt;/td&gt;
&lt;td&gt;解释为什么需要一个包或者模块&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;download&#34;&gt;download&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;go mod download [-json] [modules]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不带模块参数时，默认下载主模块的所有依赖&lt;/li&gt;
&lt;li&gt;其他 go 命令会自动下载所需模块，&lt;code&gt;go mod download&lt;/code&gt; 主要用于预先填充本地缓存或用户计算 Go 模块代理&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认将错误发生给标准错误。&lt;code&gt;-json&lt;/code&gt; 会打印 JSON 对象到标准输出，描述每个下载的模块(或失败)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Module struct {
  Path     string // module path
  Version  string // module version
  Error    string // error loading module
  Info     string // absolute path to cached .info file
  GoMod    string // absolute path to cached .mod file
  Zip      string // absolute path to cached .zip file
  Dir      string // absolute path to cached source root directory
  Sum      string // checksum for path, version (as in go.sum)
  GoModSum string // checksum for go.mod (as in go.sum)
  Latest   bool   // would @latest resolve to this version?
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;edit&#34;&gt;edit&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod edit [edit flags] [go.mod]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命令只会读写主模块 &lt;code&gt;go.mod&lt;/code&gt; 文件，可在编辑参数指定另外需要编辑的文件&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑标识包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-fmt&lt;/code&gt;: 只格式化文件。其他参数默认会格式化。只有在没有其他编辑参数时需要指定 &lt;code&gt;-fmt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-module&lt;/code&gt;: 修改模块路径(&lt;code&gt;module&lt;/code&gt; 行)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-require=path@version&lt;/code&gt;/&lt;code&gt;-droprequire=path&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-exclude=path@version&lt;/code&gt;/&lt;code&gt;-dropexclude=path@version&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-replace=old[@v]=new[@v]&lt;/code&gt;/&lt;code&gt;-dropreplace=old[@v]&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-go=version&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-print&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-json&lt;/code&gt;: 以 JSON 格式打印最终的 &lt;code&gt;go.mod&lt;/code&gt; 而不是写到 &lt;code&gt;go.mod&lt;/code&gt;。JSON 输出符合下面的 Go 类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命令只会描述 &lt;code&gt;go.mod&lt;/code&gt; 文件，间接引用的模块不会包含。需要查看编译所需的所有模块使用 &lt;code&gt;go list -m -json all&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Module struct {
Path string
Version string
}

type GoMod struct {
Module  Module
Go      string
Require []Require
Exclude []Module
Replace []Replace
}

type Require struct {
Path string
Version string
Indirect bool
}

type Replace struct {
Old Module
New Module
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工具可以通过解析 &lt;code&gt;go mod edit -json&lt;/code&gt; 的输出获取 &lt;code&gt;go.mod&lt;/code&gt; 数据结构，然后通过 &lt;code&gt;go mod edit&lt;/code&gt; 修改&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;graph&#34;&gt;graph&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：以文本格式打印模块需求图(使用 replaced 模块)。每一行输出包含模块及其一个依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod init [module]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：在当前目录初始化并写一个新的 &lt;code&gt;go.mod&lt;/code&gt;，实际上是以当前目录为根创建一个新模块。&lt;code&gt;go.mod&lt;/code&gt; 一定不能已经存在。可能的话，命令会从导入注释或版本控制配置(git 等)猜测模块路径。要 覆盖猜测，可以提供模块路径参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tidy&#34;&gt;tidy&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod tidy [-v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：确保 &lt;code&gt;go.mod&lt;/code&gt; 和模块的源码匹配。拉取需要的缺失模块，删除无用模块。同时修改 &lt;code&gt;go.sum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 会输出删除模块信息到标准错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vendor&#34;&gt;vendor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod vendor [-v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：重置主模块的 &lt;code&gt;vendor&lt;/code&gt; 目录一包含编译和测试主模块所有包所需的包。目录不包含 vendored 包的测试代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 打印 vendored 模块和包的名称到标准错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;verify&#34;&gt;verify&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod verify&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：检查当前模块的依赖在下载之后不曾被修改，该依赖存储在一个本地下载的源码缓存。如果所有模块未被修改，输出 &lt;code&gt;all modules verified.&lt;/code&gt;。否则打印被修改的模块，并导致 &lt;code&gt;go mod&lt;/code&gt; 以非 0 状态码返回&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;why&#34;&gt;why&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod why [-m] [-vendor] packages...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：显示主模块到每个列举包的最短导入路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt; 将参数视为一系列模块，并为模块的每个包找到一个路径&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go run</title>
      <link>https://xueqing.github.io/translation/go-doc/command/run/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/run/</guid>
      <description>

&lt;h2 id=&#34;构建并运行程序&#34;&gt;构建并运行程序&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对于简单的程序，可以使用 &lt;code&gt;go run program.go&lt;/code&gt; 直接构建并允许程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go run&lt;/code&gt; 不会再运行目录生成任何文件，可执行文件被放在临时文件中执行，工作目录被设置为当前目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go run&lt;/code&gt; 可以跟参数，第一个不是以 &lt;code&gt;.go&lt;/code&gt; 结尾的参数会作为可执行程序的参数列表的开始&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go test</title>
      <link>https://xueqing.github.io/translation/go-doc/command/test_package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/test_package/</guid>
      <description>&lt;p&gt;用法：&lt;code&gt;go test [build/test flags] [packages] [build/test flags &amp;amp; test binary flags]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 自动测试通过导入路径命名的包。命令按下面的格式打印测试结果的概要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后是每个失败的包的详细输出。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 重新编译每个包以及所有名字匹配 “*_test.go” 的文件。这些额外的文件可以包含测试函数，基准测试函数和示例函数。查看 &lt;code&gt;go help testfunc&lt;/code&gt; 获取更多信息。每个列举的包执行一个单独的二进制测试。忽视以 “_” (包括 “_test.go”) 或 “.” 开始的文件。&lt;/p&gt;

&lt;p&gt;声明了后缀为 “_test” 的包的测试文件会作为一个单独的包被编译，然后被主二进制测试链接和运行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go tool&lt;/code&gt; 会忽视 “testdata” 命名的目录，使得可以包含测试所需的辅助数据。&lt;/p&gt;

&lt;p&gt;作为编译一个二进制测试的一部分，&lt;code&gt;go test&lt;/code&gt; 在包及其测试源文件上运行 &lt;code&gt;go vet&lt;/code&gt; 以识别显著的问题。如果 &lt;code&gt;go vet&lt;/code&gt; 发现任何问题，&lt;code&gt;go test&lt;/code&gt; 报告这些问题并且不再运行二进制测试。只使用了默认 &lt;code&gt;go vet&lt;/code&gt; 检查的高可信度的子集。这些子集包括：atomic、bool、buildtags、nilfunc 和 printf。你可以通过 &lt;code&gt;go doc cmd/vet&lt;/code&gt; 查看他们的文档以及其他的 vet 测试。使用 -vet=off 标识禁用 &lt;code&gt;go vet&lt;/code&gt; 的运行。&lt;/p&gt;

&lt;p&gt;即使测试打印输出到它自己的标准错误，所有的测试输出和总结行会被打印到 go 命令的标准输出。(保留 go 命令的标准错误用于打印编译这些测试的错误。)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 运行包括两种模式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;叫做本地目录模式。当调用 &lt;code&gt;go test&lt;/code&gt; 不带包参数时发生(如 &lt;code&gt;go test&lt;/code&gt; 或 &lt;code&gt;go test -v&lt;/code&gt;)。在这种模式，&lt;code&gt;go test&lt;/code&gt; 在当前目录找到的包源文件和测试文件，然后运行生成的二进制测试。在这种模式，禁用缓存(后面会讨论)。包测试结束之后，&lt;code&gt;go test&lt;/code&gt; 打印一个总结行显示测试状态(“ok” 或 “FAIL”)、包名和用时。&lt;/li&gt;
&lt;li&gt;叫做包列表模式。当调用 &lt;code&gt;go test&lt;/code&gt; 携带显式的包参数时发送(如 &lt;code&gt;go test math&lt;/code&gt;、&lt;code&gt;go test ./...&lt;/code&gt; 甚至 &lt;code&gt;go test ..&lt;/code&gt;)。在这种模式，&lt;code&gt;go test&lt;/code&gt; 编译和测试命令行列举的每个包。如果一个包测试通过，&lt;code&gt;go test&lt;/code&gt; 只打印最后的 “ok” 总结行。如果一个包测试失败，&lt;code&gt;go test&lt;/code&gt; 打印完整的测试输出。如果调用时携带 -bench 或 -v 标识，&lt;code&gt;go test&lt;/code&gt; 也会为通过测试包打印完整的输出，以显示请求的基准测试结果或错误日志。当所有列举的包测试结束且打印了他们的输出之后，如果任何一个包测试失败，&lt;code&gt;go test&lt;/code&gt; 打印一个最终的 “FAIL” 状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只有在包列表模式，&lt;code&gt;go test&lt;/code&gt; 会缓存成功的包测试结果以避免不必要的重复运行测试。当一个测试的结果可从缓存中恢复时，&lt;code&gt;go test&lt;/code&gt; 会再次显示之前的输出而不是再次运行二进制测试。这时，&lt;code&gt;go test&lt;/code&gt; 打印 “(cached)” 取代总结行中的用时。&lt;/p&gt;

&lt;p&gt;缓存匹配的规则是 go 命令调用相同的二进制测试，且命令行标识完全来自受限的可缓存的测试标识集合，被定义为 -cpu、-list、-parallel、-run、-short 和 -v。如果允许一次 &lt;code&gt;go test&lt;/code&gt; 包含任何这个集合之外的测试标识或非测试标识，结果都是不可缓存的。要禁用测试缓存，使用除了可缓存的标识以外的任意的测试标识或参数。惯用的显式禁用测试缓存的方法是使用 -count=1。打开在包的源根(通常是 $GOPATH)或者查询环境变量的测试只有在这些文件和环境变量不改变时才会与之后的运行匹配。一个缓存的测试结果被视为立刻执行，因此无论如何设置 -timeout，一个成功的包测试结果会被缓存且重用。&lt;/p&gt;

&lt;p&gt;除了编译标志，&lt;code&gt;go test&lt;/code&gt; 专属的标识包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;args：传递命令行的剩余部分(-args 之后的所有)给二进制测试，不解释且不修改。因为这个标识使用了命令行的剩余部分，包列表(如果有)必须出现在这个标识之前。&lt;/li&gt;
&lt;li&gt;-c：编译二进制测试为 pkg.test 但不要运行(pkg 是包导入路径的最后一个元素)。文件名可以使用 -o 标识修改。&lt;/li&gt;
&lt;li&gt;-exec xprog：使用 xprog 运行二进制测试。这个行为和 &lt;code&gt;go run&lt;/code&gt; 相同。查看 &lt;code&gt;go run&lt;/code&gt; 获取更多信息。&lt;/li&gt;
&lt;li&gt;-i：安装测试的依赖包。不要运行测试。&lt;/li&gt;
&lt;li&gt;-json：将测试输出转化为 JSON 用于自动处理。查看 &lt;code&gt;go doc test2json&lt;/code&gt; 获取编码信息。&lt;/li&gt;
&lt;li&gt;-o file：编译二进制测试到指定名称的文件。测试仍然运行(除非指定 -c 或 -i)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二进制测试也接收控制测试执行的标识；这些标识也可被 &lt;code&gt;go test&lt;/code&gt; 访问。查看 &lt;code&gt;go help testflag&lt;/code&gt; 获取更多信息。&lt;/p&gt;

&lt;p&gt;需要更多关于编译标识，查看 &lt;code&gt;go help build&lt;/code&gt;。需要更多关于指定包的，查看 &lt;code&gt;go help package&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;查看其他：&lt;code&gt;go build&lt;/code&gt;、&lt;code&gt;go vet&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go 互斥锁</title>
      <link>https://xueqing.github.io/blog/go/basic/go_mutex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_mutex/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#syncmutex&#34;&gt;sync.Mutex&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sync-mutex&#34;&gt;sync.Mutex&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;互斥：保证每次只有一个 goroutine 可以访问一个共享的变量&lt;/li&gt;

&lt;li&gt;&lt;p&gt;go 标准库提供 &lt;code&gt;sync.Mutex&lt;/code&gt; 互斥锁类型及两个方法： &lt;code&gt;Lock&lt;/code&gt; 和 &lt;code&gt;Unlock&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在代码前调用 &lt;code&gt;Lock&lt;/code&gt;，在代码后调用 &lt;code&gt;Unlock&lt;/code&gt; 保证这段代码的互斥执行&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可用 &lt;code&gt;defer&lt;/code&gt; 语句保证互斥锁一定会被解锁&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;sync&amp;quot;
&amp;quot;time&amp;quot;
)

// SafeCounter is safe to use concurrently.
type SafeCounter struct {
v   map[string]int
mux sync.Mutex
}

// Inc increments the counter for the given key.
func (c *SafeCounter) Inc(key string) {
c.mux.Lock()
// Lock so only one goroutine at a time can access the map c.v.
c.v[key]++
c.mux.Unlock()
}

// Value returns the current value of the counter for the given key.
func (c *SafeCounter) Value(key string) int {
c.mux.Lock()
// Lock so only one goroutine at a time can access the map c.v.
defer c.mux.Unlock()
return c.v[key]
}

func main() {
c := SafeCounter{v: make(map[string]int)}
for i := 0; i &amp;lt; 1000; i++ {
go c.Inc(&amp;quot;somekey&amp;quot;)
}

time.Sleep(time.Second)
fmt.Println(c.Value(&amp;quot;somekey&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 函数</title>
      <link>https://xueqing.github.io/blog/go/basic/go_function/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_function/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0-function&#34;&gt;函数 function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e7%94%a8%e6%b3%95&#34;&gt;函数用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e5%80%bc&#34;&gt;函数值&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%bf%e5%90%8d%e5%87%bd%e6%95%b0&#34;&gt;匿名函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%af%e5%8f%98%e5%87%bd%e6%95%b0-variadic-function&#34;&gt;可变函数 variadic function&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95-vs-%e5%87%bd%e6%95%b0&#34;&gt;方法 vs 函数&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95%e7%9a%84%e5%80%bc%e6%8e%a5%e6%94%b6%e8%80%85-vs-%e5%87%bd%e6%95%b0%e7%9a%84%e5%80%bc%e5%8f%82%e6%95%b0&#34;&gt;方法的值接收者 vs 函数的值参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95%e7%9a%84%e6%8c%87%e9%92%88%e6%8e%a5%e6%94%b6%e8%80%85%e5%92%8c%e5%87%bd%e6%95%b0%e7%9a%84%e6%8c%87%e9%92%88%e5%8f%82%e6%95%b0&#34;&gt;方法的指针接收者和函数的指针参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;函数-function&#34;&gt;函数 function&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;函数是基本的代码块，用于执行一个任务&lt;/li&gt;
&lt;li&gt;最少有一个 main 函数，且 main 函数必须在 main 包中&lt;/li&gt;
&lt;li&gt;可通过函数划分不同功能，逻辑上每个函数执行指定的任务&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数声明包含名称、返回类型和参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参数可选，类似于占位符，是函数的形参。当连续两个或多个已命名形参类型相同时，除最后一个类型外，其它都可以忽略&lt;/li&gt;
&lt;li&gt;值传递：调用函数时将实际参数复制一份传递给函数，函数内修改参数不会影响实际参数&lt;/li&gt;
&lt;li&gt;引用传递：调用函数时传递参数的地址，函数内修改参数会影响到实际的值&lt;/li&gt;
&lt;li&gt;默认使用值传递&lt;/li&gt;
&lt;li&gt;返回类型可选&lt;/li&gt;
&lt;li&gt;多值返回：函数可以返回任意数量的返回值&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命名返回值：返回值可以是命名的，可以当做是定义在函数顶部的变量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这些名字应当具有一定的意义，可作为文档使用用于记录返回值的含义&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个不带参数的 &lt;code&gt;return&lt;/code&gt; 语句返回命名返回值，也就是直接返回。直接返回语句应只用于短函数，否则会破坏函数的可读性&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func func_name( [param_list] ) [return_types] {
// func_body
}

func swap(x, y string) (string, string) {
return y, x
}

// 命名返回值
func split(sum int) (x, y int) {
sx = sum * 4 / 9
sy = sum - x
sreturn
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;函数用法&#34;&gt;函数用法&lt;/h2&gt;

&lt;h2 id=&#34;函数值&#34;&gt;函数值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;函数作为值，即定义后作为值使用&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数值可以像其他值一样传递，可以用作函数的参数或返回值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

func compute(fn func(float64, float64) float64) float64 {
return fn(3, 4)
}

func main() {
hypot := func(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}
fmt.Println(hypot(5, 12))

fmt.Println(compute(hypot))
fmt.Println(compute(math.Pow))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;匿名函数&#34;&gt;匿名函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;闭包，即匿名函数，在动态编程中使用&lt;/li&gt;
&lt;li&gt;闭包是一个函数值，它引用了其函数体外的变量。该函数可以访问并赋予其引用的变量的值，即该函数被这些变量“绑定”在一起&lt;/li&gt;

&lt;li&gt;&lt;p&gt;匿名函数是一个“内联”语句或表达式，其优越性在于可以直接使用函数内的变量，不必声明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getSequence() func() int {
i := 0
return func() int {
    i += 1
    return i
}
}

nextNum := getSequence() //i=0
fmt.Println(nextNum()) //i=1
fmt.Println(nextNum()) //i=2
fmt.Println(nextNum()) //i=3

nextNum1 := getSequence() //i=0
fmt.Println(nextNum1()) //i=1
fmt.Println(nextNum1()) //i=2
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func fibonacci() func() int {
before := 0
val := 1
return func() int {
    ret := before
    before = val
    val = ret + val
    return ret
}
}

func main() {
f := fibonacci()
for i := 0; i &amp;lt; 10; i++ {
    fmt.Println(f())
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;可变函数-variadic-function&#34;&gt;可变函数 variadic function&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可变函数的参数数目是可变的，当最后一个参数用&lt;code&gt;...T&lt;/code&gt;表示时，函数就可以接受任意数目的类型 T 作为最后一个参数&lt;/li&gt;
&lt;li&gt;可变函数实际是将传递的可变数目的参数转成一个新建的切片作为参数&lt;/li&gt;
&lt;li&gt;不能直接传递一个切片作为参数给可变函数，还需要在切片后面加上&lt;code&gt;...&lt;/code&gt;，才可以将切片作为可变函数的参数，而且不用创建新切片，而是直接传递原始的切片&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方法-vs-函数&#34;&gt;方法 vs 函数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;方法是包含了接收者的函数&lt;/li&gt;
&lt;li&gt;可以把接收者作为函数的参数来实现方法&lt;/li&gt;
&lt;li&gt;为什么使用方法

&lt;ul&gt;
&lt;li&gt;go 不是一个纯粹的面向对象的变成语言，可以使用方法来实现和类类似的行为&lt;/li&gt;
&lt;li&gt;可以定义类型不同的同名方法，但是不能定义同名函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;方法的值接收者-vs-函数的值参数&#34;&gt;方法的值接收者 vs 函数的值参数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;具有值参数的函数，只能接受值作为参数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具有值接收者的方法，可以接受指针和值接收者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type rectangle struct {
len float64
width float64
}

func area(rec rectangle) {
fmt.Println(&amp;quot;area: %f * %f = %f&amp;quot;, rec.len, rec.width, (rec.len * rec.width))
}

func (rec rectangle) area() {
fmt.Println(&amp;quot;area: %f * %f = %f&amp;quot;, rec.len, rec.width, (rec.len * rec.width))
}

func caller() {
r := rectangle(
    len: 3,
    width: 4,
)

area(r)
r.area()

p := &amp;amp;r
//area(p),编译错误
p.area() //go 会解释成(*p).area()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;方法的指针接收者和函数的指针参数&#34;&gt;方法的指针接收者和函数的指针参数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;具有指针参数的函数，只能接受指针作为参数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;具有指针接收者的方法，可以接受指针和值接收者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type rectangle struct {
len float64
width float64
}

func area(rec *rectangle) {
fmt.Println(&amp;quot;area: %f * %f = %f&amp;quot;, rec.len, rec.width, (rec.len * rec.width))
}

func (rec *rectangle) area() {
fmt.Println(&amp;quot;area: %f * %f = %f&amp;quot;, rec.len, rec.width, (rec.len * rec.width))
}

func caller() {
r := rectangle(
    len: 3,
    width: 4,
)

p := &amp;amp;r
area(p)
p.area()

//area(r),编译错误
r.area() //go 会解释成(&amp;amp;p).area()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 切片</title>
      <link>https://xueqing.github.io/blog/go/basic/go_slice/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_slice/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#slice&#34;&gt;slice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#slice-%e9%95%bf%e5%ba%a6%e5%92%8c%e5%ae%b9%e9%87%8f&#34;&gt;slice 长度和容量&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#append-%e8%bf%bd%e5%8a%a0%e5%88%b0-slice&#34;&gt;append 追加到 slice&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#copy-%e5%af%b9-slice-%e6%8b%b7%e8%b4%9d&#34;&gt;copy 对 slice 拷贝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%b9-slice-%e5%88%87%e7%89%87&#34;&gt;对 slice 切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#slice-vs-array&#34;&gt;slice vs array&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba-array-%e5%92%8c-slice&#34;&gt;创建 array 和 slice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%87%e7%89%87%e5%ba%95%e5%b1%82%e6%98%af%e6%95%b0%e7%bb%84&#34;&gt;切片底层是数组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-make-%e5%87%bd%e6%95%b0%e5%88%9b%e5%bb%ba-slice&#34;&gt;使用 make 函数创建 slice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#slice-%e5%86%85%e5%ad%98%e5%82%a8-slice&#34;&gt;slice 内存储 slice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e5%ad%98%e4%bc%98%e5%8c%96&#34;&gt;内存优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;slice&#34;&gt;slice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;切片是对数组的抽象，是一种“动态数组”，长度不固定，可以追加元素&lt;/li&gt;
&lt;li&gt;定义 &lt;code&gt;var slice_name []type&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化

&lt;ul&gt;
&lt;li&gt;直接初始化&lt;code&gt;slice_name := [] int {var1, var2..., varn}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;引用数组初始化&lt;code&gt;slice_name := arr_name[:]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;引用部分数组初始化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice_name := arr_name[startIndex:endIndex]&lt;/code&gt;，引用下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice_name := arr_name[startIndex:]&lt;/code&gt;，引用下标 startIndex 到最后一个元素创建为一个新的切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice_name := arr_name[startIndex:]&lt;/code&gt;，引用第一个元素到 endIndex-1 下的元素创建为一个新的切片&lt;/li&gt;
&lt;li&gt;通过切片初始化&lt;code&gt;slice_name := origina_slice[startIndex:endIndex]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;slice-长度和容量&#34;&gt;slice 长度和容量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;len(slice_name)&lt;/code&gt; 方法获取切片长度，指的是 slice 中元素的数目&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;cap(slice_name)&lt;/code&gt; 方法获取切片容量，即最长可以达到多少，指的是底层数组的元素数目，起始下标是创建切片时的起始下标&lt;/li&gt;
&lt;li&gt;空切片 nil，即未初始化的切片，长度为 0，容量为 0，没有底层数组&lt;/li&gt;
&lt;li&gt;切片截取&lt;code&gt;slice_name[lower_bound : upper_bound]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;下限默认为 0&lt;/li&gt;
&lt;li&gt;上限默认为 len(slice_name)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;增加切片容量：创建一个更大的数组并把原数组的内容拷贝到新数组，新切片的容量增加一倍

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;append(slice_name, [param_list])&lt;/code&gt; 函数往切片追加新元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[param_list]&lt;/code&gt;也可以是一个切片，用&lt;code&gt;...&lt;/code&gt;，如&lt;code&gt;newslice := append(slice1, slice2...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;copy(dst_slice, ori_slice) int&lt;/code&gt; 函数拷贝切片&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;append-追加到-slice&#34;&gt;append 追加到 slice&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;func append(slice_name []T, [param_list]) []T&lt;/code&gt; 函数往切片追加新元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;slice 的类型是 T&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[param_list]&lt;/code&gt;是要追加到 slice 的 T 类型的值，也可以是一个切片，用 &lt;code&gt;...&lt;/code&gt;，如 &lt;code&gt;newslice := append(slice1, slice2...)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回值是一个 slice，包含了 slice_name 的所有元素以及追加的所有元素&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果 slice_name 不能包含所有追加的元素，会分配一个更大的数组，返回的 slice 指向新分配的数组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
)

func main() {
var s []int
printSlice(s) //len=0 cap=0 []

s = append(s, 0)
printSlice(s) //len=1 cap=1 [0]

s = append(s, 1)
printSlice(s) //len=2 cap=2 [0 1]

s = append(s, 2, 3, 4)
printSlice(s) //len=5 cap=6 [0 1 2 3 4]

a := []int{7, 8, 9}
s = append(s, a...) //使用 ... 语法将参数展开为参数列表
printSlice(s)       //len=8 cap=12 [0 1 2 3 4 7 8 9]
}

func printSlice(s []int) {
fmt.Printf(&amp;quot;len=%d cap=%d %v\n&amp;quot;, len(s), cap(s), s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;copy-对-slice-拷贝&#34;&gt;copy 对 slice 拷贝&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;copy(dst_slice, ori_slice) int&lt;/code&gt; 函数拷贝切片

&lt;ul&gt;
&lt;li&gt;将 ori_slice 的元素复制到 dst_slice&lt;/li&gt;
&lt;li&gt;返回复制元素的数目&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;对-slice-切片&#34;&gt;对 slice 切片&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当 slice 容量足够大，可以对一个 slice 进行再切片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
s := []int{2, 3, 5, 7, 11, 13}
printSlice(s) //len=6 cap=6 [2 3 5 7 11 13]

s = s[:0]     //分割 slice 长度为 0
printSlice(s) //len=0 cap=6 []

s = s[:4]     //扩展 slice 长度
printSlice(s) //len=4 cap=6 [2 3 5 7]

s = s[2:]     //丢弃前两个值
printSlice(s) //len=2 cap=4 [5 7]

s = s[:4]     //扩展 slice
printSlice(s) //len=4 cap=4 [5 7 11 13]

// s = s[:6] //error: slice bounds out of range [:6] with capacity 4
}

func printSlice(s []int) {
fmt.Printf(&amp;quot;len=%d cap=%d %v\n&amp;quot;, len(s), cap(s), s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;slice-vs-array&#34;&gt;slice vs array&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;https://blog.go-zh.org/go-slices-usage-and-internals&#34; target=&#34;_blank&#34;&gt;Go 切片：用法和本质&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;创建-array-和-slice&#34;&gt;创建 array 和 slice&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建一个数组 &lt;code&gt;[3] bool {true, true, false}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建一个相同的数组，并且创建数组的一个 slice 引用 &lt;code&gt;[] bool {true, true, false}&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;切片没有指定元素的数目&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
slice1 := []int{2, 3, 5, 7, 11, 13}
fmt.Println(slice1)

slice2 := []bool{true, false, true, true, false, true}
fmt.Println(slice2)

st := []struct{
    i int
    b bool
} {
    {2, true},
    {3, false},
    {5, true},
    {7, true},
    {11, false},
    {13, true},
}
fmt.Println(st)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;切片底层是数组&#34;&gt;切片底层是数组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;slice 是一个数组片段的描述。它包含了指向数组的指针、片段的长度和容量(片段的最大长度)

&lt;ul&gt;
&lt;li&gt;长度是 slice 引用的元素数目&lt;/li&gt;
&lt;li&gt;容量是底层数组的元素数目(从切片指针开始计数)&lt;/li&gt;
&lt;li&gt;切片增长不能超出其容量，否则会导致运行时异常。也不能使用小于零的索引访问切片之前的元素&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;slice 其实是对底层数组的引用，本身不存储数据，对 slice 的修改会修改底层的数组，其他共享底层数据的 slice 也会看到底层数组的修改

&lt;ul&gt;
&lt;li&gt;slice 操作不会复制底层指向的元素。它创建一个新的 slice 并复用之前 slice 的底层数组&lt;/li&gt;
&lt;li&gt;slice 操作和数组索引一样高效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;slice 作为函数变量，函数内对 slice 的修改也会影响调用者底层数组的元素&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func sliceTest() {
arr := [...]int{1, 2, 3, 4, 5, 6, 7}
sli := arr[1:4]
fmt.Printf(&amp;quot;slice len=%d, cap=%d&amp;quot;, len(sli), cap(sli)) //1,2,3,4,5,6,7
fmt.Println(&amp;quot;original array &amp;quot;, arr) //1,2,3,4,5,6,7
for i := range sli {
sli[i]++
}
fmt.Println(&amp;quot;modifiled array &amp;quot;, arr) //1,3,4,5,5,6,7
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用-make-函数创建-slice&#34;&gt;使用 make 函数创建 slice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可使用内置 &lt;code&gt;make&lt;/code&gt; 函数创建切片&lt;code&gt;var slice_name []type = make([]type, len, cap)&lt;/code&gt;或&lt;code&gt;slice_name := make([]type, len, cap)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt; 函数创建一个数组，然后返回一个引用数组的切片&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt; 是数组的长度也是切片的初始长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cap&lt;/code&gt; 容量参数可选，默认为指定的长度大小&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;make&lt;/code&gt; 函数初始化&lt;code&gt;slice_name := make([]type, len, cap)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
s := make([]int, 5) //长度和容量为 5，初始值都为 0
printSlice(&amp;quot;s&amp;quot;, s)  //s len=5 cap=5 [0 0 0 0 0]

a := make([]int, 0, 5) //长度为 0，容量为 5，初始为空
printSlice(&amp;quot;a&amp;quot;, a)     //a len=0 cap=5 []

b := a[:2]         //长度为 2，容量为 5，初始值为 0
printSlice(&amp;quot;b&amp;quot;, b) //b len=2 cap=5 [0 0]

c := b[2:5]        //长度为 3，容量为 3，初始值为 0
printSlice(&amp;quot;c&amp;quot;, c) //c len=3 cap=3 [0 0 0]
}

func printSlice(str string, s []int) {
fmt.Printf(&amp;quot;%s len=%d cap=%d %v\n&amp;quot;, str, len(s), cap(s), s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;slice-内存储-slice&#34;&gt;slice 内存储 slice&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;slice 可以存储任何类型，包含其他 slice&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;strings&amp;quot;
)

func main() {
board := [][]string{
    []string{&amp;quot;_&amp;quot;, &amp;quot;_&amp;quot;, &amp;quot;_&amp;quot;},
    []string{&amp;quot;_&amp;quot;, &amp;quot;_&amp;quot;, &amp;quot;_&amp;quot;},
    []string{&amp;quot;_&amp;quot;, &amp;quot;_&amp;quot;, &amp;quot;_&amp;quot;},
}

board[0][0] = &amp;quot;X&amp;quot;
board[0][2] = &amp;quot;X&amp;quot;
board[1][0] = &amp;quot;O&amp;quot;
board[1][2] = &amp;quot;X&amp;quot;
board[2][2] = &amp;quot;O&amp;quot;

for i := 0; i &amp;lt; len(board); i++ {
    fmt.Printf(&amp;quot;%s\n&amp;quot;, strings.Join(board[i], &amp;quot; &amp;quot;))
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内存优化&#34;&gt;内存优化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;slice 是对底层数组的引用，因此只要 slice 在内存中，数组就不能被回收&lt;/li&gt;
&lt;li&gt;当切片只引用了一小部分数组的数据来处理，可以使用&lt;code&gt;func copy(dst, src []T) int&lt;/code&gt;来赋值切片，然后使用新切片就可以回收原始的较大的数组&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 包</title>
      <link>https://xueqing.github.io/blog/go/basic/go_package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_package/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#package&#34;&gt;package&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%bb%98%e8%ae%a4%e5%af%bc%e5%85%a5&#34;&gt;默认导入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%bc%e5%87%ba%e5%8c%85%e5%86%85%e6%a0%87%e8%af%86%e7%ac%a6&#34;&gt;导出包内标识符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%bc%e5%85%a5%e5%8c%85%e7%9a%84%e9%87%8d%e5%91%bd%e5%90%8d&#34;&gt;导入包的重命名&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e7%bc%96%e8%af%91%e9%80%9f%e5%ba%a6%e5%bf%ab&#34;&gt;Go 编译速度快&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%bc%e5%85%a5%e5%8c%bf%e5%90%8d%e5%8c%85&#34;&gt;导入匿名包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e5%85%a5%e5%8f%a3-init&#34;&gt;包的初始化入口 init&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e9%83%a8%e5%8c%85&#34;&gt;内部包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e7%9a%84%e6%96%87%e6%a1%a3%e5%8c%96&#34;&gt;包的文档化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;package&#34;&gt;package&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package pkg_name&lt;/code&gt;定义程序属于哪个包，每个 go 文件第一行&lt;/li&gt;
&lt;li&gt;package 用于组织 go 的源码改善可用性和易读性，提供代码的模块化&lt;/li&gt;
&lt;li&gt;代码包的导入路径是相对于 Go 语言自身的源码目录（即 &lt;code&gt;$GOROOT/src&lt;/code&gt;）或在环境变量 &lt;code&gt;GOPATH&lt;/code&gt; 中指定的某个目录的 &lt;code&gt;src&lt;/code&gt; 子目录下的子路径，使用 &lt;code&gt;/&lt;/code&gt; 分隔路径&lt;/li&gt;
&lt;li&gt;导入的包名使用双引号包围，习惯上将文件夹的最后一个元素命名与包名一致。例外的情况

&lt;ul&gt;
&lt;li&gt;如果某包定义一条命令(可执行的 Go 程序)，那么总是使用 &lt;code&gt;main&lt;/code&gt;。这是告诉 &lt;code&gt;go build&lt;/code&gt; 必须调用链接器生成可执行文件&lt;/li&gt;
&lt;li&gt;目录中一些文件以 &lt;code&gt;test.go&lt;/code&gt; 结尾，包名会以 &lt;code&gt;_test&lt;/code&gt; 结尾，这是外部测试包。其他的文件是普通包。&lt;code&gt;_test&lt;/code&gt; 后缀告诉 &lt;code&gt;go test&lt;/code&gt; 两个包都需要构建，并指明文件属于哪个包&lt;/li&gt;
&lt;li&gt;外部测试包用于避免测试所依赖的导入图中的循环依赖&lt;/li&gt;
&lt;li&gt;一些依赖管理工具会在包导入路径末尾追加版本号，包名仍然不包含版本号后缀&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;默认导入&#34;&gt;默认导入&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;单行导入：&lt;code&gt;import pkg_name&lt;/code&gt; 导入包&lt;/li&gt;
&lt;li&gt;多行导入：导入多个包时，建议使用 &lt;code&gt;()&lt;/code&gt; 将导入的包放在一起，即分组导入&lt;/li&gt;
&lt;li&gt;包分组：导入的包之间通过添加空行分组。通常将来自不同组织的包独立分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;导出包内标识符&#34;&gt;导出包内标识符&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;导出名：首字母大写的名字是导出的名字，首字母小写只能包内使用。导入包之后只能使用包导出的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;导入包的重命名&#34;&gt;导入包的重命名&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;导入包后可以自定义引用的包名&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入包的重命名：如果同时导入两个名字相同的包，那么导入声明必须至少为一个同名包指定一个新的包名避免冲突&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
&amp;quot;crypto/rand&amp;quot;
mrand &amp;quot;math/rand&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入包的重命名只影响当前源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;导入包重命名不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;选择用简短名称重命名导入包时候最好统一，以避免包名混乱&lt;/li&gt;
&lt;li&gt;选择另一个包名称还可以帮助避免和本地普通变量名产生冲突&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-编译速度快&#34;&gt;Go 编译速度快&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;有三个主要原因

&lt;ul&gt;
&lt;li&gt;所有的导入必须在每一个源文件的开头进行显示列出，这样编译器不需要读取和处理整个文件来确定依赖性&lt;/li&gt;
&lt;li&gt;包的依赖性形成有向无环图，因为没有环，包可以独立甚至并行编译&lt;/li&gt;
&lt;li&gt;Go 包编译输出的目标文件不仅记录它自己的导出信息，也记录所依赖包的导出信息。当编译一个包时，编译器对于每一个导入必须读取一个目标文件，但是不需要超出这些文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;导入匿名包&#34;&gt;导入匿名包&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;go 导入一个包之后不在代码中使用是不合法的

&lt;ul&gt;
&lt;li&gt;导入包，只需要调用包中的 init 函数：在包名之前加下划线和空格&lt;code&gt;import _  pkg_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;暂时导入包，之后才会需要，建议在 import 之后紧跟语句&lt;code&gt;var _ = pkg_name.SomeFunc // error silencer&lt;/code&gt;，此语句可避免编译错误&lt;/li&gt;
&lt;li&gt;在真正使用包中的代码之后就删掉此语句&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;包的初始化入口-init&#34;&gt;包的初始化入口 init&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;init 函数用于执行初始化任务，或者在执行之前验证程序的正确性&lt;/li&gt;
&lt;li&gt;init 函数的特性

&lt;ul&gt;
&lt;li&gt;每个源码可以使用 1 个 init 函数&lt;/li&gt;
&lt;li&gt;init 函数会在程序执行前(main 函数执行前)被自动调用&lt;/li&gt;
&lt;li&gt;调用顺序为 main 中引用的包，以深度优先顺序初始化&lt;/li&gt;
&lt;li&gt;假设包的引用关系 &lt;code&gt;main-&amp;gt;A-&amp;gt;B-&amp;gt;C&lt;/code&gt;，那么这些包的 init 函数调用顺序为 &lt;code&gt;C.init-&amp;gt;B.init-&amp;gt;A.init-&amp;gt;main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同一个包中的多个 init 函数的调用顺序不可预期&lt;/li&gt;
&lt;li&gt;init 函数不应有返回值，不应包括任何参数，不能在源码中显式调用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;包的初始化顺序

&lt;ul&gt;
&lt;li&gt;初始化包级别的变量&lt;/li&gt;
&lt;li&gt;调用 init 函数，如果有多个 init 函数（在一个或多个文件中），按照编译器接收顺序调用：go 会从 main 包开始检查其引用的所有包，每个包也可能包含其他的包。编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。在运行时，被最后导入的包会最先初始化并调用 init 函数&lt;/li&gt;
&lt;li&gt;导入的包先初始化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个包只初始化一次&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;geometry.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;geometry/rectangle&amp;quot;
&amp;quot;log&amp;quot;
)

var recLen, recWidth float64 = 3, -4

func init() {
fmt.Println(&amp;quot;Geometry init func&amp;quot;)
if recLen &amp;lt; 0 {
  log.Fatal(&amp;quot;length is less than zero&amp;quot;)
}

if recWidth &amp;lt; 0 {
  log.Fatal(&amp;quot;width is less than zero&amp;quot;)
}
}

func main() {
fmt.Println(&amp;quot;Geometry main func&amp;quot;)
fmt.Println(&amp;quot;rectangle area: %.2f&amp;quot;, rectangle.Area(recLen, recWidth))
fmt.Println(&amp;quot;rectangle diagonal: %.2f&amp;quot;, rectangle.Diagonal(recLen, recWidth))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;rectangle.go&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package rectangle

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

func init() {
fmt.Println(&amp;quot;Rectangle init func&amp;quot;)
}

func Area(len, width float64) float64 {
area := len * width
return area
}

func Diagonal(len, width float64) float64 {
diagonal := math.Sqrt(len*len + width*width)
return diagonal
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内部包&#34;&gt;内部包&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;内部包只能被另一个包导入。这个包位于以 internal 目录的父目录为根目录的树中&lt;/li&gt;
&lt;li&gt;内部包可以不需要导出标识符就可以被满足条件的包访问&lt;/li&gt;
&lt;li&gt;例如有下面的文件夹 &lt;code&gt;net/http&lt;/code&gt; &lt;code&gt;net/http/internal/chunked&lt;/code&gt; &lt;code&gt;net/http/httputil&lt;/code&gt; &lt;code&gt;net/url&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;net/http/httputil&lt;/code&gt; 和 &lt;code&gt;net/http&lt;/code&gt; 可以导入 &lt;code&gt;net/http/internal/chunked&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net/url&lt;/code&gt; 不可以导入 &lt;code&gt;net/http/internal/chunked&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;net/url&lt;/code&gt; 可以导入 &lt;code&gt;net/http/httputil&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;包的文档化&#34;&gt;包的文档化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文档注释是完整的语句，使用声明的包名作为开头的第一句注释通常是总结

&lt;ul&gt;
&lt;li&gt;可以出现在任何文件，但是必须只有一个&lt;/li&gt;
&lt;li&gt;文件名通常是 &lt;code&gt;doc.go&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;函数参数和其他的标识符不用括号或特别标注&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 变量</title>
      <link>https://xueqing.github.io/blog/go/basic/go_variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_variables/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;变量声明使用关键字 var。可以用于包内或函数内&lt;/li&gt;

&lt;li&gt;&lt;p&gt;变量声明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定类型不赋值，使用默认值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var vname vtype = value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提供初始化值时可省略类型，根据初始化值自行判定变量类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var vname = value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;省略 var，注意&lt;code&gt;:=&lt;/code&gt;左侧的变量不应该是已经声明过的，否则会导致编译错误&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vname := value&lt;/code&gt;，省略了变量类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只能用于函数体内，建议使用。函数外的每个语句都是以关键字(&lt;code&gt;var/func&lt;/code&gt;等)开头，因此不能使用 &lt;code&gt;:=&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a int = 10
var b = 10
c := 10
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多变量声明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;var&lt;/code&gt; 声明&lt;/li&gt;
&lt;li&gt;可出现在包或函数级别&lt;/li&gt;
&lt;li&gt;类型相同，非全局变量

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var vname1 vname2 vname3 vtype = v1, v2, v3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不声明类型，自动推断

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var vname1, vname2, vname3 = v1, v2, v3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;短变量声明：使用&lt;code&gt;:=&lt;/code&gt;，左侧的变量是未声明过的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vname1, vname2, vname3 := v1, v2, v3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只能在函数体中使用&lt;/strong&gt;，建议使用&lt;/li&gt;
&lt;li&gt;必须一次初始化所有的变量&lt;/li&gt;
&lt;li&gt;左边至少有一个变量是未声明过的，否则编译错误&lt;code&gt;no new variables on left side of :=&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因式分解关键字：一般用于声明全局变量，在一个语句中声明不同类型的变量，即“分组”成一个语法块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
vname1 vtype1
vname2 vtype2
)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;已声明的变量不能再使用&lt;code&gt;:=&lt;/code&gt;赋值&lt;/li&gt;
&lt;li&gt;定义变量之前使用会是编译错误&lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在代码块定义局部变量未使用是编译错误&lt;code&gt;declared but not used&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全局变量运行只定义不使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以并行赋值/同时赋值&lt;code&gt;a, b, c = 5, 7, &amp;quot;abc&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在实际更新变量前，右边所有的表达式被推演&lt;/li&gt;
&lt;li&gt;如果表达式比较复杂，避免使用多重赋值形式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;交换变量值，必须类型相同&lt;code&gt;a, b = b, a&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空白标识符&lt;code&gt;_&lt;/code&gt;用于抛弃值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个只写变量，不能得到值&lt;/li&gt;
&lt;li&gt;可以接收函数返回值，但是只使用部分返回值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持给变量赋值，该值在运行时计算&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c := math.Min(a, b)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;go 是强类型语言，不支持隐式类型转换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;age := 20
age = &amp;quot;kiki&amp;quot; //error: cannot use &amp;quot;kiki&amp;quot; (type string) as type int in assignment
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 变量作用域</title>
      <link>https://xueqing.github.io/blog/go/basic/go_scope_rule/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_scope_rule/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;函数内定义的变量是局部变量，只作用于函数体内，参数和返回值都是局部变量&lt;/li&gt;
&lt;li&gt;函数外定义的变量是全局变量，全局变量可在整个包甚至外部包（导出后）使用

&lt;ul&gt;
&lt;li&gt;函数内的局部变量可以覆盖全局变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;函数定义中的变量是形式参数，形式参数作为函数的局部变量使用&lt;/li&gt;
&lt;li&gt;变量默认值，即默认初始化的值

&lt;ul&gt;
&lt;li&gt;int 默认值 0&lt;/li&gt;
&lt;li&gt;float32 默认值 0&lt;/li&gt;
&lt;li&gt;pointer 默认值 nil&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 基础语法</title>
      <link>https://xueqing.github.io/blog/go/basic/go_basic_syntax/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_basic_syntax/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;行分隔符：一行就是一个语句；多个语句放一行需要手动加&lt;code&gt;;&lt;/code&gt;，但是不建议&lt;/li&gt;
&lt;li&gt;注释不被编译，但是建议每个包一个注释&lt;/li&gt;
&lt;li&gt;标识符：用于命名变量、类型等程序实体，以字母或下划线开头&lt;/li&gt;
&lt;li&gt;关键字，25 个

&lt;ul&gt;
&lt;li&gt;break, case, chan, const, continue&lt;/li&gt;
&lt;li&gt;default, defer, else, fallthrough, for&lt;/li&gt;
&lt;li&gt;func, go, goto, if, import&lt;/li&gt;
&lt;li&gt;interface, map, package, range, return&lt;/li&gt;
&lt;li&gt;select, struct, switch, type, var&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;预定义标识符，36 个

&lt;ul&gt;
&lt;li&gt;append, bool, byte, cap, close, complex&lt;/li&gt;
&lt;li&gt;complex64, complex128, copy, false, float32, float64&lt;/li&gt;
&lt;li&gt;imag, int, int8, int16, int32, int64&lt;/li&gt;
&lt;li&gt;iota, len, make, new, nil, panic&lt;/li&gt;
&lt;li&gt;print, println, real, recover, string, true&lt;/li&gt;
&lt;li&gt;uint, uint8, uint16, uint32, unit64&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;空格：变量声明需要空格隔开；适当空格增加易阅读性&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 常量</title>
      <link>https://xueqing.github.io/blog/go/basic/go_constant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_constant/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e9%87%8f&#34;&gt;常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e5%80%bc%e5%b8%b8%e9%87%8f&#34;&gt;数值常量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;常量&#34;&gt;常量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;定义类似于变量声明，但是需要 &lt;code&gt;const&lt;/code&gt; 关键字

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const vname [vtype] = value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显式类型定义&lt;code&gt;const vname vtype = value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;隐式类型定义&lt;code&gt;const vname = value&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不能使用 &lt;code&gt;:=&lt;/code&gt; 声明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;相同类型声明 &lt;code&gt;const vname1, vname2, vname3 = value1, value2, value3&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用于枚举&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const {
  Unknown = 0
  Famale = 1
  Male = 2
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常量可使用 &lt;code&gt;len()&lt;/code&gt;, &lt;code&gt;cap()&lt;/code&gt;, &lt;code&gt;unsafe.Sizeof()&lt;/code&gt; 函数计算表达式的值，函数必须是内置函数，否则编译错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = &amp;quot;abc&amp;quot;
unsafe.Sizeof(a) //16，字符串类型在 go 中是个结构，包括指向数组的指针和长度，每部分都是 8 字节，所以是 16 个字节
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;iota: 特殊常量，一个可被编译器修改的常量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;const&lt;/code&gt; 关键字出现时被重置为 0（const 内部的第一行之前）&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 中每新增一行常量声明，&lt;code&gt;iota&lt;/code&gt; 计数一次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const {
a = iota //a=0
b = iota //b=1，也可写 b
c = iota //c=2，也可写 c
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常量必须在编译时确定&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;数值常量&#34;&gt;数值常量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数值常量是高精度值，一个没有类型的常量根据上下文确定自身的类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

const (
Big = 1 &amp;lt;&amp;lt; 100
Small = Big &amp;gt;&amp;gt; 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
return x * 0.1
}

func main() {
fmt.Println(needInt(Small))
fmt.Println(needInt(Big))     //error: constant 1267650600228229401496703205376 overflows int
fmt.Println(needFloat(Small))
fmt.Println(needFloat(Big))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 循环语句</title>
      <link>https://xueqing.github.io/blog/go/basic/go_loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_loop/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#for-%e5%be%aa%e7%8e%af&#34;&gt;for 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%22while%22-%e5%be%aa%e7%8e%af&#34;&gt;&amp;ldquo;while&amp;rdquo; 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%be%aa%e7%8e%af%e5%b5%8c%e5%a5%97&#34;&gt;循环嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%be%aa%e7%8e%af%e6%8e%a7%e5%88%b6%e8%af%ad%e5%8f%a5&#34;&gt;循环控制语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%97%a0%e9%99%90%e5%be%aa%e7%8e%af&#34;&gt;无限循环&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;for-循环&#34;&gt;for 循环&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;go 循环只有 for 结构。包含 3 个组件

&lt;ul&gt;
&lt;li&gt;初始化语句：通常是短变量声明，声明的变量只对 for 循环可见&lt;/li&gt;
&lt;li&gt;条件语句：条件为 false 时退出循环&lt;/li&gt;
&lt;li&gt;后置语句&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上述三个组件不需要小括号，但是需要大括号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
sum := 0
for i := 0; i &amp;lt; 10; i++ {
sum += i
}
fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;while-循环&#34;&gt;&amp;ldquo;while&amp;rdquo; 循环&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化语句和后置语句是可选的，此时可以去掉两个分号，相当于 C 的 &lt;code&gt;while&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
sum := 1
for sum &amp;lt; 1000 { //或 &amp;quot;for ; sum &amp;lt; 1000; {&amp;quot;
sum += sum
}
fmt.Println(sum)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;循环嵌套&#34;&gt;循环嵌套&lt;/h2&gt;

&lt;p&gt;for 循环嵌套 for 循环&lt;/p&gt;

&lt;h2 id=&#34;循环控制语句&#34;&gt;循环控制语句&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;break&lt;/li&gt;
&lt;li&gt;continue&lt;/li&gt;
&lt;li&gt;goto&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;无限循环&#34;&gt;无限循环&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;省略条件语句，或设置循环条件为永真，就是无限循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for { //或 &amp;quot;for true {&amp;quot;
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 指针</title>
      <link>https://xueqing.github.io/blog/go/basic/go_pointer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_pointer/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;指针变量指向一个值的内存地址：不是所有值都有地址，但是所有变量都有地址

&lt;ul&gt;
&lt;li&gt;每一个聚合类型变量的组成(结构体的成员或数组中的元素)都是变量，都有一个地址&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;先声明指针才可以使用指针&lt;/li&gt;
&lt;li&gt;声明&lt;code&gt;var ptr_name *ptr_type&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ptr_type&lt;/code&gt;是指针类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ptr_name&lt;/code&gt;是指针变量名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;用于指定变量是作为一个指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过 &lt;code&gt;&amp;amp;&lt;/code&gt; 生成一个变量的指针变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i := 42
p = &amp;amp;i
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;*ptr&lt;/code&gt;在指针类型前加&lt;code&gt;*&lt;/code&gt;获取指针所指向的内容，也就是“间接引用”或“重定向”&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;fmt.Println(*p)
*p = 21
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和 C 不同，go 的指针没有数学运算&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空指针 &lt;code&gt;nil&lt;/code&gt;：指针定义后未分配到变量时值为 &lt;code&gt;nil&lt;/code&gt;，类似其他语言的 &lt;code&gt;null/None/nil/NULL&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针变量通常缩写为 ptr&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针数组，来存储地址，声明&lt;code&gt;var ptr_name [len]*ptr_type&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指向指针的指针，声明&lt;code&gt;var pptr_name **pptr_type&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;**pptr&lt;/code&gt;在指针的指针类型前加&lt;code&gt;**&lt;/code&gt;获取指针所指向的内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;指针作为函数参数，通过引用或地址传参可在函数内部改变变量值&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 接口</title>
      <link>https://xueqing.github.io/blog/go/basic/go_interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_interface/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9d%9e%e4%be%b5%e5%85%a5%e5%bc%8f%e8%ae%be%e8%ae%a1&#34;&gt;非侵入式设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89&#34;&gt;接口定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3%e5%ae%9e%e7%8e%b0&#34;&gt;接口实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3%e5%80%bc&#34;&gt;接口值&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ba%95%e5%b1%82%e5%80%bc%e4%b8%ba-nil-%e7%9a%84%e6%8e%a5%e5%8f%a3%e5%80%bc&#34;&gt;底层值为 nil 的接口值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3%e5%80%bc%e4%b8%ba-nil&#34;&gt;接口值为 nil&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a9%ba%e6%8e%a5%e5%8f%a3&#34;&gt;空接口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80type-assertion&#34;&gt;类型断言(type assertion)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b1%bb%e5%9e%8b%e9%80%89%e6%8b%a9type-switch&#34;&gt;类型选择(type switch)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%85%b3%e7%b3%bb&#34;&gt;接口和类型的关系&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%9e%8b%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e5%a4%9a%e4%b8%aa%e6%8e%a5%e5%8f%a3&#34;&gt;一个类型可以实现多个接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%9a%e4%b8%aa%e7%b1%bb%e5%9e%8b%e5%8f%af%e4%bb%a5%e5%ae%9e%e7%8e%b0%e7%9b%b8%e5%90%8c%e7%9a%84%e6%8e%a5%e5%8f%a3&#34;&gt;多个类型可以实现相同的接口&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;非侵入式设计&#34;&gt;非侵入式设计&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现&lt;/li&gt;
&lt;li&gt;非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少&lt;/li&gt;
&lt;li&gt;传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。对于 Go 语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用 Go 语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么”，以及“我能实现什么”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;接口定义&#34;&gt;接口定义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构&lt;/li&gt;
&lt;li&gt;在面向对象中，接口定义了一个对象的行为&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 type 和 interface 关键字定义接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type interface_name interface {
method_name1([param_list]) [return_type]
method_name2([param_list]) [return_type]
method_name3([param_list]) [return_type]
...
method_namen([param_list]) [return_type]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;interface_name&lt;/code&gt;：接口类型名。使用 type 将接口定义为自定义的类型名。Go 语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;method_name&lt;/code&gt;：方法名。当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包之外的代码访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;param_list&lt;/code&gt; &lt;code&gt;return_type&lt;/code&gt;：参数列表和返回值列表中的参数变量名可以被忽略&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;接口实现&#34;&gt;接口实现&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;接口类型是由一组方法签名定义的集合，接口类型的变量可以保存任何实现了这些方法的值&lt;/li&gt;
&lt;li&gt;接口把所有的具有共性的方法定义在一起，如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型&lt;/li&gt;
&lt;li&gt;实现关系在 Go 语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go 语言中没有类似于 implements 的关键字。Go 编译器将自动在需要的时候检查两个类型之间的实现关系&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接口的方法与实现接口的类型方法格式一致&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口中所有方法均被实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

type abser interface {
Abs() float64
}

func main() {
var a abser
f := myFloat(-math.Sqrt2)
v := vertex{3, 4}

a = f // a myFloat 实现了 abser
fmt.Println(a.Abs())

a = &amp;amp;v // a *vertex 实现了 abser
fmt.Println(a.Abs())

// a = v // error: v 是一个 vertex(而不是 *vertex), 所以没有实现 abser
}

type myFloat float64

func (f myFloat) Abs() float64 {
if f &amp;lt; 0 {
return float64(-f)
}
return float64(f)
}

type vertex struct {
X, Y float64
}

func (v *vertex) Abs() float64 {
return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;接口值&#34;&gt;接口值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;接口也是值

&lt;ul&gt;
&lt;li&gt;接口值可用作函数的参数或返回值&lt;/li&gt;
&lt;li&gt;在内部，接口值可看做包含值和具体类型的元组 &lt;code&gt;(value, type)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;%v&lt;/code&gt; 和 &lt;code&gt;%T&lt;/code&gt; 可以访问接口的值和类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;接口值保存了一个具体底层类型的具体值&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口值调用方法时会执行其底层类型的同名方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

type myInterface interface {
M()
}

type st struct {
S string
}

func (t *st) M() {
fmt.Println(t.S)
}

type myFloat float64

func (f myFloat) M() {
fmt.Println(f)
}

func main() {
var i myInterface

i = &amp;amp;st{&amp;quot;Hello&amp;quot;}
describe(i)
i.M()

i = myFloat(math.Pi)
describe(i)
i.M()
}

func describe(i myInterface) {
fmt.Printf(&amp;quot;(%v, %T)\n&amp;quot;, i, i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;底层值为-nil-的接口值&#34;&gt;底层值为 nil 的接口值&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;接口内的具体值为 nil，方法仍然会被 nil 接收者调用。&lt;strong&gt;保存了 nil 具体值的接口本身并不为 nil&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

type myInterface interface {
M()
}

type st struct {
S string
}

func (t *st) M() {
if t == nil {
    fmt.Println(&amp;quot;&amp;lt;nil&amp;gt;&amp;quot;)
    return
}
fmt.Println(t.S)
}

func main() {
var i myInterface

i = &amp;amp;st{&amp;quot;Hello&amp;quot;}
describe(i)
i.M()

var stp *st
i = stp
describe(i)
i.M()
}

func describe(i myInterface) {
fmt.Printf(&amp;quot;(%v, %T)\n&amp;quot;, i, i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;接口值为-nil&#34;&gt;接口值为 nil&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;nil 接口值既不保存值也不保存具体类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为 nil 接口调用方法会报运行时错误，因为接口的元组内并未包含可以指明该调用哪个具体方法的类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
)

type myInterface interface {
M()
}

func main() {
var i myInterface
describe(i)
i.M() // panic: runtime error: invalid memory address or nil pointer dereference
}

func describe(i myInterface) {
fmt.Printf(&amp;quot;(%v, %T)\n&amp;quot;, i, i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;空接口&#34;&gt;空接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;指定了零个方法的接口值称为 “空接口” &lt;code&gt;interface{}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;空接口可保存任何类型的值(因为每个类型都至少实现了零个方法)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;空接口用于处理未知类型的值。如 &lt;code&gt;fmt.Print&lt;/code&gt; 可接受类型为 &lt;code&gt;interface{}&lt;/code&gt; 的任意数量的参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
var i interface{}
describe(i)

i = 42
describe(i)

i = &amp;quot;hello&amp;quot;
describe(i)
}

func describe(i interface{}) {
fmt.Printf(&amp;quot;(%v, %T)\n&amp;quot;, i, i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;类型断言-type-assertion&#34;&gt;类型断言(type assertion)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;类型断言提供了访问接口值底层具体值的方式 &lt;code&gt;t := i.(T)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t&lt;/li&gt;
&lt;li&gt;若 i 未保存 T 类型的值，会触发一个 panic&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类型断言可返回两个值：其底层值，一个布尔值判断断言是否成功 &lt;code&gt;t, ok := i.(T)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
var i interface{} = &amp;quot;hello&amp;quot;

s := i.(string)
fmt.Println(s)

s, ok := i.(string)
fmt.Println(s, ok)

f, ok := i.(float64)
fmt.Println(f, ok)

f = i.(float64) // 报错(panic)
fmt.Println(f)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;类型选择-type-switch&#34;&gt;类型选择(type switch)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型选择语句用于判断某个 interface 变量中实际存储的变量类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func do(i interface{}) {
switch v := i.(type) {
case int:
    fmt.Printf(&amp;quot;Twice %v is %v\n&amp;quot;, v, v*2)
case string:
    fmt.Printf(&amp;quot;%q is %v bytes long\n&amp;quot;, v, len(v))
default:
    fmt.Printf(&amp;quot;I don&#39;t know about type %T!\n&amp;quot;, v)
}
}

func main() {
do(21)
do(&amp;quot;hello&amp;quot;)
do(true)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;接口和类型的关系&#34;&gt;接口和类型的关系&lt;/h2&gt;

&lt;h3 id=&#34;一个类型可以实现多个接口&#34;&gt;一个类型可以实现多个接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;接口间彼此独立，不知道对方的实现&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Socket 结构的 Write() 方法实现了 io.Writer 以及 io.Closer 接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Socket struct {
}

func (s *Socket) Write(p []byte) (n int, err error) {
  return 0, nil
}

func (s *Socket) Close() error {
  return nil
}

func usingWriter( writer io.Writer){
  writer.Write( nil ) // 使用io.Writer的代码, 并不知道Socket和io.Closer的存在
}

func usingCloser( closer io.Closer) {
  closer.Close() // 使用io.Closer, 并不知道Socket和io.Writer的存在
}

func main() {
  s := new(Socket) // 实例化Socket
  usingWriter(s)
  usingCloser(s)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;多个类型可以实现相同的接口&#34;&gt;多个类型可以实现相同的接口&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;接口的方法可以通过在类型中嵌入其他类型或者结构体来实现&lt;/li&gt;

&lt;li&gt;&lt;p&gt;示例：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）&lt;/li&gt;
&lt;li&gt;使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Service interface {
Start()  // 开启服务
Log(string)  // 日志输出
}

type Logger struct {
}

func (g *Logger) Log(l string) {
}

type GameService struct {
Logger  // 嵌入日志器
}

func (g *GameService) Start() {
}

func main() {
var s Service = new(GameService)
s.Start()
s.Log(&amp;quot;hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 散列表</title>
      <link>https://xueqing.github.io/blog/go/basic/go_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_map/</guid>
      <description>

&lt;h2 id=&#34;map定义和初始化&#34;&gt;map定义和初始化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;map 是一种无序的键值对的集合，可以通过 key 快速检索数据，使用 hash 表实现&lt;/li&gt;
&lt;li&gt;定义集合

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var map_name[key_type]val_type&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 make 函数&lt;code&gt;map_name := make(map[key_type]val_type)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不初始化 map，得到的是一个 nil map，不能用于存放键值对&lt;/li&gt;

&lt;li&gt;&lt;p&gt;map 文法：类似 struct，但是需要键名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当顶级类型是一个 type 的名字时，可以忽视&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type vertex struct {
Lat, Long float64
}

var m = map[string]vertex{
&amp;quot;Bell lab&amp;quot;: vertex{
40.68433, -74.39967,
},
&amp;quot;Google&amp;quot;: vertex{
37.42202, -122.08408,
},
}

var m1 = map[string]vertex{
&amp;quot;Bell lab&amp;quot;: { 40.68433, -74.39967},
&amp;quot;Google&amp;quot;: { 37.42202, -122.08408},
}

func main() {
fmt.Println(m)
fmt.Println(m1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;修改-map&#34;&gt;修改 map&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;map_name[key]&lt;/code&gt; 查看元素在集合中是否存在

&lt;ul&gt;
&lt;li&gt;如果元素存在，返回的第一个元素是对应的键，第二个元素是 true&lt;/li&gt;
&lt;li&gt;元素不存在，在返回第二个元素是 false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;插入或更新元素 &lt;code&gt;map_name[key] = val&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;delete() 函数用于删除集合的元素&lt;code&gt;delete(map_name, key)&lt;/code&gt;，指定元素名和对应的键&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
)

func main() {
m := make(map[string]int)

m[&amp;quot;answer&amp;quot;] = 42
fmt.Println(&amp;quot;The value:&amp;quot;, m[&amp;quot;answer&amp;quot;])

m[&amp;quot;answer&amp;quot;] = 48
fmt.Println(&amp;quot;The value:&amp;quot;, m[&amp;quot;answer&amp;quot;])

delete(m, &amp;quot;answer&amp;quot;)
fmt.Println(&amp;quot;The value:&amp;quot;, m[&amp;quot;answer&amp;quot;])

val, ok := m[&amp;quot;answer&amp;quot;]
fmt.Println(&amp;quot;The value:&amp;quot;, val, &amp;quot;Present?&amp;quot;, ok)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 数据类型</title>
      <link>https://xueqing.github.io/blog/go/basic/go_data_type/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_data_type/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b&#34;&gt;数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e9%bb%98%e8%ae%a4%e5%88%9d%e5%a7%8b%e5%8c%96%e5%80%bc&#34;&gt;数据类型默认初始化值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b1%bb%e5%9e%8b%e6%8e%a8%e5%af%bc&#34;&gt;类型推导&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数据类型把数据分成所需内存大小不同的数据

&lt;ul&gt;
&lt;li&gt;布尔型：true 或 false&lt;/li&gt;
&lt;li&gt;数字类型：&lt;/li&gt;
&lt;li&gt;整型

&lt;ul&gt;
&lt;li&gt;有符号 int(int, int8, int16, int32, int64)，默认是 int&lt;/li&gt;
&lt;li&gt;int 是 32 或 64 位，取决于底层平台。建议使用 int 来表示整数，除非需要指定大小&lt;/li&gt;
&lt;li&gt;32 位系统就是 32 位，64 位 系统就是 64 位&lt;/li&gt;
&lt;li&gt;无符号 uint(uint, uint8, uint16, uint32, unit64)&lt;/li&gt;
&lt;li&gt;uint 32 或 64 位，同上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;浮点型 float(float32, float64)，默认是 float64&lt;/li&gt;
&lt;li&gt;复数 complex(complex64, complex128)

&lt;ul&gt;
&lt;li&gt;complex64 32 位实数和虚数&lt;/li&gt;
&lt;li&gt;complex128 64 位实数和虚数&lt;/li&gt;
&lt;li&gt;使用内置函数 complex 构造一个复数&lt;code&gt;func complex(r, i FloatType) ComplexType&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;实部 r 和虚部 i 应该是同一类型，float32 或 float64，返回的复数类型是 complex64 或 complex128&lt;/li&gt;
&lt;li&gt;也可直接生成复数&lt;code&gt;c := 6 + 7i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;byte 是 uint8 的别名&lt;/li&gt;
&lt;li&gt;rune 是 int32 的别名，表示 Unicode code point&lt;/li&gt;
&lt;li&gt;uintptr 无符号整型，用于存放一个指针&lt;/li&gt;
&lt;li&gt;字符串类型：字节使用 UTF-8 编码标识 Unicode 文本，是字节的集合&lt;/li&gt;
&lt;li&gt;派生类型：&lt;/li&gt;
&lt;li&gt;指针类型 pointer&lt;/li&gt;
&lt;li&gt;数组类型&lt;/li&gt;
&lt;li&gt;结构化类型 struct&lt;/li&gt;
&lt;li&gt;Channel 类型&lt;/li&gt;
&lt;li&gt;函数类型&lt;/li&gt;
&lt;li&gt;切片类型&lt;/li&gt;
&lt;li&gt;接口类型 interface&lt;/li&gt;
&lt;li&gt;map 类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;%T&lt;/code&gt; 格式化打印变量的类型，使用 &lt;code&gt;%v&lt;/code&gt; 打印变量的值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;数据类型默认初始化值&#34;&gt;数据类型默认初始化值&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;变量默认值，即默认初始化的值，对应各自的 “零” 值

&lt;ul&gt;
&lt;li&gt;int 默认值 0&lt;/li&gt;
&lt;li&gt;boolean 默认值 false&lt;/li&gt;
&lt;li&gt;string 默认值 &amp;ldquo;&amp;rdquo;&lt;/li&gt;
&lt;li&gt;float32 默认值 0&lt;/li&gt;
&lt;li&gt;pointer 默认值 nil&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;类型推导&#34;&gt;类型推导&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;当声明变量使用隐形类型(使用不带类型的 &lt;code&gt;:=&lt;/code&gt; 或 &lt;code&gt;var =&lt;/code&gt;)，需要通过右值推导变量的类型&lt;/li&gt;
&lt;li&gt;当右值的类型是声明过的，则新变量与其类型相同&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当右值是一个没有类型的数值常量时，根据常量精度推导变量类型(int/float64/complex128)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i := 42           // int
f := 3.142        // float64
g := 0.867 + 0.5i // complex128
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 数组</title>
      <link>https://xueqing.github.io/blog/go/basic/go_array/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_array/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#array&#34;&gt;array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e7%bb%84%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;数组初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%9a%e7%bb%b4%e6%95%b0%e7%bb%84&#34;&gt;多维数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e7%bb%84%e4%bd%9c%e4%b8%ba%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0&#34;&gt;数组作为函数参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;array&#34;&gt;array&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数组是具有相同类型，长度固定，已编号的数据项序列&lt;/li&gt;
&lt;li&gt;可通过索引来读写数组元素&lt;/li&gt;
&lt;li&gt;声明数组需要指定类型和元素个数 &lt;code&gt;var arr_name [size] arr_type&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;也可使用 &lt;code&gt;[...]&lt;/code&gt; 让编译器统计数组字面值中元素的数目&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;数组初始化&#34;&gt;数组初始化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;数组不需要显式初始化，可以直接使用使用数组的零值，数组元素会自动初始化为对应类型的零值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var arr1 = [5]float32{1, 2.0, 3.1, 4, 5.4}&lt;/code&gt;，也可写成 &lt;code&gt;var arr1 = [...]float32{1, 2.0, 3.1, 4, 5.4}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;中的元素个数不能大于&lt;code&gt;[]&lt;/code&gt;的数字&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;多维数组&#34;&gt;多维数组&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;多维数组声明&lt;code&gt;var arr_name [size1] [size2]...[sizen] arr_type&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;数组作为函数参数&#34;&gt;数组作为函数参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;传递数组的时候，会复制整个数组，为了避免复制，可以传递数组指针&lt;/li&gt;
&lt;li&gt;未定义长度的数组只能传给不限制数组长度的函数&lt;/li&gt;
&lt;li&gt;长度已定义的数组只能传给限制了相同数组长度的函数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;形参设定数组大小&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func myFunc(arr [10] int) {
  //...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;形参未设定数组大小&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func myFunc(arr [] int) {
  //...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 方法</title>
      <link>https://xueqing.github.io/blog/go/basic/go_method/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_method/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95-method&#34;&gt;方法 method&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95%e7%9a%84%e6%8e%a5%e6%94%b6%e8%80%85%e6%98%af-struct&#34;&gt;方法的接收者是 struct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95%e7%9a%84%e6%8e%a5%e6%94%b6%e8%80%85%e6%98%af%e9%9d%9e%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;方法的接收者是非结构体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8c%87%e9%92%88%e6%8e%a5%e6%94%b6%e8%80%85-vs-%e5%80%bc%e6%8e%a5%e6%94%b6%e8%80%85&#34;&gt;指针接收者 vs 值接收者&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e6%8c%87%e9%92%88%e6%8e%a5%e6%94%b6%e8%80%85&#34;&gt;使用指针接收者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%80%bc%e6%8e%a5%e6%94%b6%e8%80%85&#34;&gt;使用值接收者&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95%e7%9a%84%e5%8c%bf%e5%90%8d%e5%9f%9f&#34;&gt;方法的匿名域&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方法-method&#34;&gt;方法 method&lt;/h2&gt;

&lt;h3 id=&#34;方法的接收者是-struct&#34;&gt;方法的接收者是 struct&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;go 没有类，但是可以为 struct 类型定义方法&lt;/li&gt;
&lt;li&gt;方法是一类带特殊的“接收者”参数的函数

&lt;ul&gt;
&lt;li&gt;方法接收者在参数列表内，位于 &lt;code&gt;func&lt;/code&gt; 关键字和方法名之间&lt;/li&gt;
&lt;li&gt;接收者可以是命名类型或者结构体类型的个值或一个指针&lt;/li&gt;
&lt;li&gt;所有给定类型的方法属于该类型的方法集&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;语法格式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (v_name v_type) func_name() [return_type] {
  //func body
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;示例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type Circle struct {
  radius float64
}

func (c Circle) getArea() float64 {
  return 3.14 * c.radius * c.radius
}

func main() {
  var c1 Circle
  c1.radius = 10.00
  fmt.Println(c1.getArea())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;方法的接收者是非结构体&#34;&gt;方法的接收者是非结构体&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;也可以为非 struct 类型声明方法，定义作用于一个类型的方法&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;接收者的类型定义和方法声明必须在同一个包内，不能为内建类型声明方法&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可为内置类型起一个别名，然后基于别名作为接收者定义方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
if f &amp;lt; 0 {
return float64(-f)
}
return float64(f)
}

func main() {
f := MyFloat(-math.Sqrt2)
fmt.Println(f.Abs())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;指针接收者-vs-值接收者&#34;&gt;指针接收者 vs 值接收者&lt;/h2&gt;

&lt;h3 id=&#34;使用指针接收者&#34;&gt;使用指针接收者&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用指针接收者，在方法内部修改会影响调用者&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;场景 1：希望方法内部修改影响调用者&lt;/li&gt;

&lt;li&gt;&lt;p&gt;场景 2：拷贝数据结构的代价比较大&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

type Vertex struct {
X, Y float64
}

func (v Vertex) Abs() float64 {
return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {
v.X = v.X * f
v.Y = v.Y * f
}

func main() {
v := Vertex{3, 4}
v.Scale(10)
fmt.Println(v.Abs())
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;带指针参数的函数必须接受一个指针，而以指针为接收者的方法被调用时，接收者可以是值或者指针，go 会根据接收者类型自动调整&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
)

type vertex struct {
  X, Y float64
}

func (v *vertex) Scale(f float64) {
  v.X = v.X * f
  v.Y = v.Y * f
}

func scaleFunc(v *vertex, f float64) {
  v.X = v.X * f
  v.Y = v.Y * f
}

func main() {
  v := vertex{3, 4}
  v.Scale(2)
  scaleFunc(&amp;amp;v, 10)

  p := &amp;amp;vertex{4, 3}
  p.Scale(3)
  scaleFunc(p, 8)

  fmt.Println(v, p)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用值接收者&#34;&gt;使用值接收者&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用值接收者，类似于形参，方法内部的修改不影响调用者&lt;/li&gt;
&lt;li&gt;接收一个值作为参数的函数必须接受一个指定类型的值，而以值作为接收者的方法被调用时，接收者可以是值或者指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;方法的匿名域&#34;&gt;方法的匿名域&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法的接收者是一个结构体的匿名域（结构体中的结构体），可直接调用不指定匿名域&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type address struct {
city string
state string
}

func (a address) fullAddress() {
fmt.Println(&amp;quot;Full address: %s, %s&amp;quot;, a.city. a.state)
}

type person struct {
firstName string
lastName string
address
}

func printPersonInfo(p person) {
fmt.Println(&amp;quot;name: %s %s&amp;quot;, p.firstName, p.secondName)
p.fullAddress()//p.address.fullAddress()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 条件语句</title>
      <link>https://xueqing.github.io/blog/go/basic/go_decision_making/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_decision_making/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#if&#34;&gt;if&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#if-%e8%af%ad%e5%8f%a5&#34;&gt;if 语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ifelse-%e8%af%ad%e5%8f%a5&#34;&gt;if&amp;hellip;else 语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#if-%e5%b5%8c%e5%a5%97%e8%af%ad%e5%8f%a5&#34;&gt;if 嵌套语句&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#switch&#34;&gt;switch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#select&#34;&gt;select&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;if&#34;&gt;if&lt;/h2&gt;

&lt;h3 id=&#34;if-语句&#34;&gt;if 语句&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类似于 for 循环，但是不需要小括号，需要大括号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if x &amp;lt; 0 {
  return 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if 语句可以在执行条件语句之前有一个简短的语句，在这个语句声明的变量的作用范围在 if 语句末尾结束&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func pow(x, n, lim float64) float64 {
if v := math.Pow(x, n); v &amp;lt; lim {
    return v
}
return lim
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;if-else-语句&#34;&gt;if&amp;hellip;else 语句&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;if 语句中声明的变量对于匹配的 else 代码块也是可见的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func pow(x, n, lim float64) float64 {
  if v := math.Pow(x, n); v &amp;lt; lim {
      return v
  } else {
      fmt.Printf(&amp;quot;%g &amp;gt;= %g\n&amp;quot;, v, lim)
  }
  return lim
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;if-嵌套语句&#34;&gt;if 嵌套语句&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if {
    //...
    if {
        //...
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;switch&#34;&gt;switch&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个 case 分支都是唯一的，从上到下测试直到匹配，&lt;strong&gt;只执行匹配项&lt;/strong&gt;，匹配项后面不用加 break(每个测试项后面自动加上 break)，和 C++ 不同&lt;/li&gt;

&lt;li&gt;&lt;p&gt;另外一个区别是每个 case 不需要是常数，值也不必是整数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;switch var1 { //case 的值必须是相同类型
  case var1[, var11, var111]://可同时测试多个条件，用逗号分隔
      //...
  case var2:
      //...
  default:
      //...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;switch 也有简短的声明语句，声明变量只对 switch 范围可见&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;runtime&amp;quot;
)

func main() {
  switch os := runtime.GOOS; os {
  case &amp;quot;darwin&amp;quot;:
      fmt.Println(&amp;quot;OS X&amp;quot;)
  case &amp;quot;linux&amp;quot;:
      fmt.Println(&amp;quot;Linux&amp;quot;)
  default:
      fmt.Printf(&amp;quot;%s\n&amp;quot;, os)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没有条件语句的 switch 和 &lt;code&gt;switch true&lt;/code&gt; 相同。这个可以用于实现比较长的 if-then-else 链&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;time&amp;quot;
)

func main() {
  t := time.Now()
  switch {
  case t.Hour() &amp;lt; 12:
      fmt.Println(&amp;quot;Good morning&amp;quot;)
  case t.Hour() &amp;lt; 17:
      fmt.Println(&amp;quot;Good afternoon&amp;quot;)
  default:
      fmt.Println(&amp;quot;Good evening&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;select&#34;&gt;select&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; 语句使一个 goroutine 可以等待多个通信操作&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似于 &lt;code&gt;switch&lt;/code&gt; 语句，会随机执行一个可允许的 &lt;code&gt;case&lt;/code&gt;，如果没有 &lt;code&gt;case&lt;/code&gt; 可以允许则阻塞到有 &lt;code&gt;case&lt;/code&gt; 可以运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;select {
  case condition1:
      //...
  case condition2:
      //...
  default:
      //...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;case&lt;/code&gt; 必须是一个通信，所有 &lt;code&gt;channel&lt;/code&gt; 表达式会被求值&lt;/li&gt;
&lt;li&gt;所有发送的表达式会被求值&lt;/li&gt;
&lt;li&gt;任意某个 &lt;code&gt;channel&lt;/code&gt; 可以进行，就会执行，其他的被忽略&lt;/li&gt;
&lt;li&gt;如果多个 &lt;code&gt;case&lt;/code&gt; 可以执行，会随机公平选择一个执行，忽略其他&lt;/li&gt;
&lt;li&gt;没有可以执行的 &lt;code&gt;case&lt;/code&gt; 语句&lt;/li&gt;
&lt;li&gt;如果有 &lt;code&gt;default&lt;/code&gt;，则执行 &lt;code&gt;default&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;否则阻塞至某个通信可以运行，go 不会重新对 &lt;code&gt;channel&lt;/code&gt; 或值进行求值&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了在尝试发送或者接收时不发生阻塞，可使用 &lt;code&gt;default&lt;/code&gt; 分支&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func fibonacci(c, quit chan int) {
x, y := 0, 1
for {
select {
case c &amp;lt;- x:
    x, y = y, x+y
case &amp;lt;-quit:
    fmt.Println(&amp;quot;quit&amp;quot;)
    return
}
}
}

func main() {
c := make(chan int)
quit := make(chan int)
go func() {
for i := 0; i &amp;lt; 10; i++ {
    fmt.Println(&amp;lt;-c)
}
quit &amp;lt;- 0
}()
fibonacci(c, quit)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 模块</title>
      <link>https://xueqing.github.io/blog/go/basic/go_module/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_module/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8&#34;&gt;1 快速入门&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e6%96%b0%e5%bb%ba%e5%b7%a5%e7%a8%8b&#34;&gt;1.1 新建工程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%e6%af%8f%e6%97%a5%e5%b7%a5%e4%bd%9c%e6%b5%81&#34;&gt;1.2 每日工作流&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e6%96%b0%e6%a6%82%e5%bf%b5&#34;&gt;2 新概念&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-module-%e6%a8%a1%e5%9d%97&#34;&gt;2.1 module 模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-gomod&#34;&gt;2.2 go.mod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%e7%89%88%e6%9c%ac%e9%80%89%e6%8b%a9&#34;&gt;2.3 版本选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%e8%af%ad%e4%b9%89%e5%af%bc%e5%85%a5%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6&#34;&gt;2.4 语义导入版本控制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e6%a8%a1%e5%9d%97&#34;&gt;3 如何使用模块&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%e5%a6%82%e4%bd%95%e5%ae%89%e8%a3%85%e5%92%8c%e6%bf%80%e6%b4%bb%e6%a8%a1%e5%9d%97%e6%94%af%e6%8c%81&#34;&gt;3.1 如何安装和激活模块支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%e5%ae%9a%e4%b9%89%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97&#34;&gt;3.2 定义一个模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%e5%8d%87%e7%ba%a7%e5%92%8c%e9%99%8d%e7%ba%a7%e4%be%9d%e8%b5%96&#34;&gt;3.3 升级和降级依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34-%e5%87%86%e5%a4%87%e5%8f%91%e5%b8%83%e6%a8%a1%e5%9d%97&#34;&gt;3.4 准备发布模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#341-%e5%8f%91%e8%a1%8crelease%e6%89%80%e6%9c%89%e7%89%88%e6%9c%ac%e6%a8%a1%e5%9d%97&#34;&gt;3.4.1 发行(release)所有版本模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#342-%e5%8f%91%e8%a1%8c-v2-%e7%89%88%e6%9c%ac%e6%a8%a1%e5%9d%97&#34;&gt;3.4.2 发行 v2+ 版本模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#343-%e5%8f%91%e5%b8%83%e4%b8%80%e4%b8%aa%e5%8f%91%e8%a1%8c%e7%89%88%e6%9c%ac&#34;&gt;3.4.3 发布一个发行版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e8%bf%81%e7%a7%bb%e5%88%b0%e6%a8%a1%e5%9d%97&#34;&gt;4 迁移到模块&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%e8%bf%81%e7%a7%bb%e6%80%bb%e7%bb%93&#34;&gt;4.1 迁移总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%e8%bf%81%e7%a7%bb%e7%9b%b8%e5%85%b3%e7%9a%84%e8%af%9d%e9%a2%98&#34;&gt;4.2 迁移相关的话题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#421-%e4%bd%bf%e7%94%a8%e8%be%83%e6%97%a9%e7%9a%84%e4%be%9d%e8%b5%96%e7%ae%a1%e7%90%86%e5%99%a8%e8%87%aa%e5%8a%a8%e8%bf%81%e7%a7%bb&#34;&gt;4.2.1 使用较早的依赖管理器自动迁移&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#422-%e6%8f%90%e4%be%9b%e4%be%9d%e8%b5%96%e4%bf%a1%e6%81%af%e7%bb%99%e6%97%a7%e7%89%88%e6%9c%ac%e7%9a%84-go-%e5%92%8c%e9%9d%9e%e6%a8%a1%e5%9d%97%e4%bd%bf%e7%94%a8%e8%80%85&#34;&gt;4.2.2 提供依赖信息给旧版本的 Go 和非模块使用者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#423-%e6%9b%b4%e6%96%b0%e9%a2%84%e5%85%88%e5%b7%b2%e6%9c%89%e7%9a%84%e5%ae%89%e8%a3%85%e6%8c%87%e5%af%bc&#34;&gt;4.2.3 更新预先已有的安装指导&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#424-%e9%81%bf%e5%85%8d%e7%a0%b4%e5%9d%8f%e5%b7%b2%e6%9c%89%e7%9a%84%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84&#34;&gt;4.2.4 避免破坏已有的导入路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#425-%e5%bd%93%e7%ac%ac%e4%b8%80%e6%ac%a1%e9%87%87%e7%94%a8%e6%a8%a1%e5%9d%97%e4%b8%94%e6%a8%a1%e5%9d%97%e6%9c%89-v2-%e7%9a%84%e5%8c%85%e6%97%b6%e5%8d%87%e7%ba%a7%e4%b8%bb%e7%89%88%e6%9c%ac%e5%8f%b7&#34;&gt;4.2.5 当第一次采用模块且模块有 v2+ 的包时升级主版本号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#426-v2-%e6%a8%a1%e5%9d%97%e5%85%81%e8%ae%b8%e4%b8%80%e6%ac%a1%e7%bc%96%e8%af%91%e4%b8%ad%e6%9c%89%e5%a4%9a%e4%b8%aa%e4%b8%bb%e7%89%88%e6%9c%ac%e5%8f%b7&#34;&gt;4.2.6 v2+ 模块允许一次编译中有多个主版本号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#427-%e9%9d%9e%e6%a8%a1%e5%9d%97%e4%bb%a3%e7%a0%81%e4%bd%bf%e7%94%a8%e6%a8%a1%e5%9d%97&#34;&gt;4.2.7 非模块代码使用模块&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4271-%e9%9d%9e%e6%a8%a1%e5%9d%97%e4%bb%a3%e7%a0%81%e4%bd%bf%e7%94%a8-v0v1-%e6%a8%a1%e5%9d%97&#34;&gt;4.2.7.1 非模块代码使用 v0/v1 模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4272-%e9%9d%9e%e6%a8%a1%e5%9d%97%e4%bb%a3%e7%a0%81%e4%bd%bf%e7%94%a8-v2-%e6%a8%a1%e5%9d%97&#34;&gt;4.2.7.2 非模块代码使用 v2+ 模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#428-%e7%bb%99%e9%a2%84%e5%85%88%e5%b7%b2%e6%9c%89%e7%9a%84-v2-%e5%8c%85%e4%bd%9c%e8%80%85%e4%bd%bf%e7%94%a8%e7%9a%84%e7%ad%96%e7%95%a5&#34;&gt;4.2.8 给预先已有的 v2+ 包作者使用的策略&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4281-%e8%a6%81%e6%b1%82%e5%ae%a2%e6%88%b7%e4%bd%bf%e7%94%a8-1971103111-%e7%89%88%e6%9c%ac%e7%9a%84-go&#34;&gt;4.2.8.1 要求客户使用 1.9.7+/1.10.&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.11+ 版本的 Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4282-%e5%85%81%e8%ae%b8%e5%ae%a2%e6%88%b7%e4%bd%bf%e7%94%a8%e6%9b%b4%e6%97%a7%e7%89%88%e6%9c%ac%e7%9a%84-go%e5%a6%82-go18&#34;&gt;4.2.8.2 允许客户使用更旧版本的 Go，如 Go1.8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4283-%e7%ad%89%e5%be%85%e9%80%89%e6%8b%a9%e6%a8%a1%e5%9d%97&#34;&gt;4.2.8.3 等待选择模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%e5%85%b6%e4%bb%96%e8%b5%84%e6%ba%90&#34;&gt;5 其他资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%e5%88%9d%e5%a7%8b-vgo-%e5%bb%ba%e8%ae%ae%e4%b9%8b%e5%90%8e%e7%9a%84%e6%94%b9%e5%8f%98&#34;&gt;6 初始 Vgo 建议之后的改变&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-github-issues&#34;&gt;7 Github issues&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-faqs&#34;&gt;8 FAQs&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81-%e5%a6%82%e4%bd%95%e6%a0%87%e8%ae%b0%e7%89%88%e6%9c%ac%e6%98%af%e4%b8%8d%e5%85%bc%e5%ae%b9%e7%9a%84&#34;&gt;8.1 如何标记版本是不兼容的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#82-%e4%bd%95%e6%97%b6%e6%98%af%e6%97%a7%e8%a1%8c%e4%b8%ba-vs-%e6%96%b0%e7%9a%84%e5%9f%ba%e4%ba%8e%e6%a8%a1%e5%9d%97%e7%9a%84%e8%a1%8c%e4%b8%ba&#34;&gt;8.2 何时是旧行为 vs 新的基于模块的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#83-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%9a%e8%bf%87-go-get-%e5%ae%89%e8%a3%85%e4%b8%80%e4%b8%aa%e5%b7%a5%e5%85%b7%e6%8a%a5%e9%94%99-cannot-find-main-module&#34;&gt;8.3 为什么通过 &lt;code&gt;go get&lt;/code&gt; 安装一个工具报错 &lt;code&gt;cannot find main module&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#84-%e5%a6%82%e4%bd%95%e4%b8%ba%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97%e8%b7%9f%e8%b8%aa%e5%b7%a5%e5%85%b7%e4%be%9d%e8%b5%96&#34;&gt;8.4 如何为一个模块跟踪工具依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#85-%e6%a8%a1%e5%9d%97%e6%94%af%e6%8c%81%e7%9a%84%e7%8a%b6%e6%80%81%e5%9c%a8-ide%e7%bc%96%e8%be%91%e5%99%a8%e5%92%8c%e6%a0%87%e5%87%86%e5%b7%a5%e5%85%b7%e6%af%94%e5%a6%82-goimportgorename%e7%ad%89-%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84&#34;&gt;8.5 模块支持的状态在 IDE，编辑器和标准工具(比如 goimport，gorename等) 是什么样的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-faqs-%e5%85%b6%e4%bb%96%e6%8e%a7%e5%88%b6&#34;&gt;9 FAQs-其他控制&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#91-%e5%9c%a8%e6%a8%a1%e5%9d%97%e4%b8%8a%e5%b7%a5%e4%bd%9c%e6%97%b6%e5%8f%af%e7%94%a8%e7%9a%84%e7%a4%be%e5%8c%ba%e5%b7%a5%e5%85%b7&#34;&gt;9.1 在模块上工作时可用的社区工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#92-%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e4%bd%bf%e7%94%a8-replace-%e6%8c%87%e4%bb%a4&#34;&gt;9.2 什么时候使用 replace 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#93-%e8%83%bd%e5%90%a6%e5%ae%8c%e5%85%a8%e5%9c%a8%e6%9c%ac%e5%9c%b0%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e4%bd%86%e5%9c%a8-vcs-%e4%b9%8b%e5%a4%96%e5%b7%a5%e4%bd%9c&#34;&gt;9.3 能否完全在本地文件系统但在 VCS 之外工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#94-%e6%a8%a1%e5%9d%97%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-vendor%e6%98%af%e5%90%a6%e4%b8%8d%e5%86%8d%e9%9c%80%e8%a6%81-vendor&#34;&gt;9.4 模块如何使用 vendor？是否不再需要 vendor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#941-%e6%a8%a1%e5%9d%97%e4%b8%8b%e8%bd%bd%e5%92%8c%e9%aa%8c%e8%af%81&#34;&gt;9.4.1 模块下载和验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#942-%e6%a8%a1%e5%9d%97%e5%92%8c%e7%9b%ae%e5%bd%95&#34;&gt;9.4.2 模块和目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#95-%e6%98%af%e5%90%a6%e6%9c%89-always-on-%e7%9a%84%e6%a8%a1%e5%9d%97%e4%bb%93%e5%ba%93%e5%92%8c%e4%bc%81%e4%b8%9a%e4%bb%a3%e7%90%86&#34;&gt;9.5 是否有 always on 的模块仓库和企业代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#96-%e8%83%bd%e5%90%a6%e6%8e%a7%e5%88%b6%e4%bd%95%e6%97%b6%e6%9b%b4%e6%96%b0-gomodgo-%e5%b7%a5%e5%85%b7%e4%bd%95%e6%97%b6%e4%bd%bf%e7%94%a8%e7%bd%91%e7%bb%9c%e6%bb%a1%e8%b6%b3%e4%be%9d%e8%b5%96&#34;&gt;9.6 能否控制何时更新 go.mod，go 工具何时使用网络满足依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#961-goflags-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34;&gt;9.6.1 GOFLAGS 环境变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#962--modreadonly-%e6%a0%87%e8%af%86%e5%a6%82-go-build--modreadonly&#34;&gt;9.6.2 -mod=readonly 标识(如 &lt;code&gt;go build -mod=readonly&lt;/code&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#963-go-mod-vendor-%e5%91%bd%e4%bb%a4&#34;&gt;9.6.3 go mod vendor 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#964--modvendor-%e6%a0%87%e8%af%86%e5%a6%82-go-build--modvendor&#34;&gt;9.6.4 -mod=vendor 标识(如 &lt;code&gt;go build -mod=vendor&lt;/code&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#965-go111moduleoff-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34;&gt;9.6.5 GO111MODULE=off 环境变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#966-goproxyoff-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34;&gt;9.6.6 GOPROXY=off 环境变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#967-goproxyfilefilesystempath-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34;&gt;9.6.7 GOPROXY=file:///filesystem/path 环境变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#968-%e5%bc%80%e6%ba%90%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e6%a8%a1%e5%9d%97%e4%bb%93%e5%ba%93%e5%a6%82-athens-%e5%b7%a5%e7%a8%8b&#34;&gt;9.6.8 开源的分布式模块仓库，如 Athens 工程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#969-go-mod-download-%e5%91%bd%e4%bb%a4&#34;&gt;9.6.9 go mod download 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9610-gomod-%e4%b8%ad%e7%9a%84-replace-%e6%8c%87%e4%bb%a4&#34;&gt;9.6.10 go.mod 中的 replace 指令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#97-%e5%9c%a8-ci-%e7%b3%bb%e7%bb%9f%e5%a6%82-travis-%e6%88%96-circleci-%e4%b8%ad%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e6%a8%a1%e5%9d%97&#34;&gt;9.7 在 CI 系统(如 Travis 或 CircleCI) 中如何使用模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10-faqs-gomod-%e5%92%8c-gosum&#34;&gt;10 FAQs-go.mod 和 go.sum&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#101-%e4%b8%ba%e4%bb%80%e4%b9%88-go-mod-tidy-%e8%ae%b0%e5%bd%95-gomod-%e7%9a%84%e9%97%b4%e6%8e%a5%e5%92%8c%e6%b5%8b%e8%af%95%e4%be%9d%e8%b5%96&#34;&gt;10.1 为什么 go mod tidy 记录 go.mod 的间接和测试依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#102-gosum-%e6%98%af%e5%90%a6%e6%98%af%e9%94%81%e6%96%87%e4%bb%b6%e4%b8%ba%e4%bb%80%e4%b9%88-gosum-%e5%8c%85%e5%90%ab%e4%b8%8d%e5%86%8d%e4%bd%bf%e7%94%a8%e7%9a%84%e6%a8%a1%e5%9d%97%e7%89%88%e6%9c%ac%e4%bf%a1%e6%81%af&#34;&gt;10.2 go.sum 是否是锁文件？为什么 go.sum 包含不再使用的模块版本信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#103-%e6%98%af%e5%90%a6%e5%ba%94%e8%af%a5%e6%8f%90%e4%ba%a4-gosum-%e5%92%8c-gomod-%e6%96%87%e4%bb%b6&#34;&gt;10.3 是否应该提交 go.sum 和 go.mod 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#104-%e5%a6%82%e6%9e%9c%e6%b2%a1%e6%9c%89%e4%bb%bb%e4%bd%95%e4%be%9d%e8%b5%96%e6%98%af%e5%90%a6%e4%bb%8d%e5%ba%94%e8%af%a5%e5%a2%9e%e5%8a%a0%e4%b8%80%e4%b8%aa-gomod-%e6%96%87%e4%bb%b6&#34;&gt;10.4 如果没有任何依赖是否仍应该增加一个 go.mod 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11-faqs-%e8%af%ad%e4%b9%89%e5%af%bc%e5%85%a5%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6&#34;&gt;11 FAQs-语义导入版本控制&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%bb%e7%89%88%e6%9c%ac%e5%8f%b7%e5%bf%85%e9%a1%bb%e5%87%ba%e7%8e%b0%e5%9c%a8%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84&#34;&gt;11.1 为什么主版本号必须出现在导入路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#112-%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%bb%e7%89%88%e6%9c%ac%e5%8f%b7-v0v1-%e8%a2%ab%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84%e5%bf%bd%e8%a7%86&#34;&gt;11.2 为什么主版本号 v0/v1 被导入路径忽视&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#113-%e4%bd%bf%e7%94%a8%e4%b8%bb%e7%89%88%e6%9c%ac%e5%8f%b7-v0v1-%e7%bb%99%e9%a1%b9%e7%9b%ae%e6%89%93%e6%a0%87%e7%ad%be%e6%88%96%e4%bd%bf%e7%94%a8-v2-%e6%a0%87%e8%ae%b0%e7%a0%b4%e5%9d%8f%e6%80%a7%e7%9a%84%e5%8f%98%e5%8c%96%e7%9a%84%e5%bd%b1%e5%93%8d%e6%98%af%e4%bb%80%e4%b9%88&#34;&gt;11.3 使用主版本号 v0/v1 给项目打标签或使用 v2+ 标记破坏性的变化的影响是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#114-%e6%a8%a1%e5%9d%97%e8%83%bd%e5%90%a6%e4%bd%bf%e7%94%a8%e6%b2%a1%e6%9c%89%e9%80%89%e6%8b%a9%e5%8a%a0%e5%85%a5%e6%a8%a1%e5%9d%97%e7%9a%84%e5%8c%85&#34;&gt;11.4 模块能否使用没有选择加入模块的包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#115-%e6%a8%a1%e5%9d%97%e8%83%bd%e5%90%a6%e4%bd%bf%e7%94%a8%e6%b2%a1%e6%9c%89%e5%8a%a0%e5%85%a5%e6%a8%a1%e5%9d%97%e7%9a%84-v2-%e5%8c%85-incompatible-%e6%84%8f%e5%91%b3%e7%9d%80%e4%bb%80%e4%b9%88&#34;&gt;11.5 模块能否使用没有加入模块的 v2+ 包？ +incompatible 意味着什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#116-%e7%a6%81%e7%94%a8%e6%a8%a1%e5%9d%97%e6%94%af%e6%8c%81%e6%97%b6%e5%9c%a8%e7%bc%96%e8%af%91%e4%b8%ad%e5%a6%82%e4%bd%95%e5%af%b9%e5%be%85-v2-%e6%a8%a1%e5%9d%97%e6%9c%80%e5%b0%8f%e6%a8%a1%e5%9d%97%e5%85%bc%e5%ae%b9%e6%80%a7%e5%9c%a8-go197go1103go111-%e4%b8%ad%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c&#34;&gt;11.6 禁用模块支持时在编译中如何对待 v2+ 模块？最小模块兼容性在 Go1.9.7+/Go1.10.3+/Go1.11 中如何工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#117-%e5%a6%82%e6%9e%9c%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa-gomod-%e4%bd%86%e6%98%af%e4%bb%93%e5%ba%93%e4%b8%8d%e4%bd%bf%e7%94%a8-semver-%e6%a0%87%e7%ad%be%e4%bc%9a%e5%8f%91%e7%94%9f%e4%bb%80%e4%b9%88&#34;&gt;11.7 如果创建一个 go.mod 但是仓库不使用 semver 标签会发生什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#118-%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97%e8%83%bd%e5%90%a6%e4%be%9d%e8%b5%96%e8%87%aa%e8%ba%ab%e4%b8%8d%e5%90%8c%e7%9a%84%e7%89%88%e6%9c%ac&#34;&gt;11.8 一个模块能否依赖自身不同的版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-faqs-%e5%a4%9a%e6%a8%a1%e5%9d%97%e4%bb%93%e5%ba%93&#34;&gt;12 FAQs-多模块仓库&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121-%e4%bb%80%e4%b9%88%e6%98%af%e5%a4%9a%e6%a8%a1%e5%9d%97%e4%bb%93%e5%ba%93&#34;&gt;12.1 什么是多模块仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#122-%e6%98%af%e5%90%a6%e5%ba%94%e8%af%a5%e5%9c%a8%e4%b8%80%e4%b8%aa%e4%bb%93%e5%ba%93%e5%8c%85%e5%90%ab%e5%a4%9a%e4%b8%aa%e6%a8%a1%e5%9d%97&#34;&gt;12.2 是否应该在一个仓库包含多个模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#123-%e8%83%bd%e5%90%a6%e7%bb%99%e5%a4%9a%e6%a8%a1%e5%9d%97%e4%bb%93%e5%ba%93%e5%a2%9e%e5%8a%a0%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97&#34;&gt;12.3 能否给多模块仓库增加一个模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#124-%e8%83%bd%e5%90%a6%e4%bb%8e%e5%a4%9a%e6%a8%a1%e5%9d%97%e4%bb%93%e5%ba%93%e5%88%a0%e9%99%a4%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97&#34;&gt;12.4 能否从多模块仓库删除一个模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#125-%e6%a8%a1%e5%9d%97%e8%83%bd%e5%90%a6%e4%be%9d%e8%b5%96%e5%8f%a6%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97%e7%9a%84-internal&#34;&gt;12.5 模块能否依赖另一个模块的 internal/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#126-%e8%83%bd%e5%90%a6%e5%a2%9e%e5%8a%a0%e4%b8%80%e4%b8%aa-gomod-%e6%96%87%e4%bb%b6%e6%8e%92%e9%99%a4%e4%b8%8d%e9%9c%80%e8%a6%81%e7%9a%84%e5%86%85%e5%ae%b9%e6%a8%a1%e5%9d%97%e6%98%af%e5%90%a6%e6%9c%89%e7%ad%89%e4%bb%b7%e7%9a%84-gitignore-%e6%96%87%e4%bb%b6&#34;&gt;12.6 能否增加一个 go.mod 文件排除不需要的内容？模块是否有等价的 .gitignore 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-faqs-%e6%9c%80%e5%b0%8f%e7%89%88%e6%9c%ac%e9%80%89%e6%8b%a9&#34;&gt;13 FAQs-最小版本选择&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#131-%e6%9c%80%e5%b0%8f%e7%89%88%e6%9c%ac%e9%80%89%e6%8b%a9%e6%98%af%e5%90%a6%e4%bc%9a%e4%bd%bf%e5%bc%80%e5%8f%91%e8%80%85%e5%be%97%e5%88%b0%e9%87%8d%e8%a6%81%e7%9a%84%e6%9b%b4%e6%96%b0&#34;&gt;13.1 最小版本选择是否会使开发者得到重要的更新&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-faqs-%e5%8f%af%e8%83%bd%e7%9a%84%e9%97%ae%e9%a2%98&#34;&gt;14 FAQs-可能的问题&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#141-%e5%a6%82%e6%9e%9c%e5%8f%91%e7%8e%b0%e9%97%ae%e9%a2%98%e6%9c%89%e5%93%aa%e4%ba%9b%e9%80%9a%e7%94%a8%e7%9a%84%e4%b8%9c%e8%a5%bf%e5%8f%af%e4%bb%a5%e5%ae%9a%e4%bd%8d%e6%a3%80%e6%9f%a5&#34;&gt;14.1 如果发现问题，有哪些通用的东西可以定位检查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#142-%e5%a6%82%e6%9e%9c%e6%b2%a1%e6%9c%89%e7%9c%8b%e5%88%b0%e9%a2%84%e6%9c%9f%e7%9a%84%e4%be%9d%e8%b5%96%e7%89%88%e6%9c%ac%e5%8f%af%e4%bb%a5%e6%a3%80%e6%9f%a5%e4%bb%80%e4%b9%88&#34;&gt;14.2 如果没有看到预期的依赖版本，可以检查什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#143-%e4%b8%ba%e4%bb%80%e4%b9%88%e5%be%97%e5%88%b0%e9%94%99%e8%af%af-cannot-find-module-providing-package-foo&#34;&gt;14.3 为什么得到错误 cannot find module providing package foo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#144-%e4%b8%ba%e4%bb%80%e4%b9%88-go-mod-init-%e6%8a%a5%e9%94%99-cannot-determine-module-path-for-source-directory&#34;&gt;14.4 为什么 go mod init 报错 cannot determine module path for source directory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#145-%e6%9c%89%e4%b8%80%e4%b8%aa%e5%a4%8d%e6%9d%82%e7%9a%84%e4%b8%94%e6%b2%a1%e6%9c%89%e5%8a%a0%e5%85%a5%e6%a8%a1%e5%9d%97%e7%9a%84%e4%be%9d%e8%b5%96%e5%87%ba%e7%8e%b0%e9%97%ae%e9%a2%98%e8%83%bd%e5%90%a6%e4%bd%bf%e7%94%a8%e5%ae%83%e7%9b%ae%e5%89%8d%e7%9a%84%e4%be%9d%e8%b5%96%e7%ae%a1%e7%90%86%e5%99%a8%e7%9a%84%e4%bf%a1%e6%81%af&#34;&gt;14.5 有一个复杂的且没有加入模块的依赖出现问题。能否使用它目前的依赖管理器的信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#146-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e7%94%b1%e4%ba%8e%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84%e5%92%8c%e5%a3%b0%e6%98%8e%e6%a8%a1%e5%9d%97%e8%ba%ab%e4%bb%bd%e4%b8%8d%e5%8c%b9%e9%85%8d%e5%af%bc%e8%87%b4%e7%9a%84-parsing-gomod-unexpected-module-path-%e5%92%8c-error-loading-module-requirements-%e9%94%99%e8%af%af&#34;&gt;14.6 如何解决由于导入路径和声明模块身份不匹配导致的 parsing go.mod: unexpected module path 和 error loading module requirements 错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1461-%e5%87%ba%e7%8e%b0%e9%97%ae%e9%a2%98%e7%9a%84%e5%8e%9f%e5%9b%a0&#34;&gt;14.6.1 出现问题的原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1462-%e5%9c%ba%e6%99%af%e7%a4%ba%e4%be%8b&#34;&gt;14.6.2 场景示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1463-%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95&#34;&gt;14.6.3 解决方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#147-%e4%b8%ba%e4%bb%80%e4%b9%88-go-build-%e8%a6%81%e6%b1%82-gcc%e4%b8%ba%e4%bb%80%e4%b9%88%e9%a2%84%e7%bc%96%e8%af%91%e5%8c%85%e5%a6%82-nethttp-%e4%b8%8d%e7%94%a8&#34;&gt;14.7 为什么 go build 要求 gcc？为什么预编译包(如 net/http) 不用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#148-%e6%a8%a1%e5%9d%97%e8%83%bd%e5%90%a6%e5%9c%a8%e7%9b%b8%e5%af%b9%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84%e5%a6%82-import-%22subdir%22%e6%ad%a3%e5%b8%b8%e5%b7%a5%e4%bd%9c&#34;&gt;14.8 模块能否在相对导入路径(如 import &amp;ldquo;./subdir&amp;rdquo;)正常工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#149-%e6%9f%90%e4%ba%9b%e9%9c%80%e8%a6%81%e7%9a%84%e6%96%87%e4%bb%b6%e5%8f%af%e8%83%bd%e4%b8%8d%e5%9c%a8%e5%ae%9a%e4%bd%8d%e7%9a%84-vendor-%e7%9b%ae%e5%bd%95&#34;&gt;14.9 某些需要的文件可能不在定位的 vendor 目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-%e7%9b%b8%e5%85%b3%e9%93%be%e6%8e%a5&#34;&gt;15 相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-快速入门&#34;&gt;1 快速入门&lt;/h2&gt;

&lt;h3 id=&#34;1-1-新建工程&#34;&gt;1.1 新建工程&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 1 在 GPOPATH 之外创建工程
mkdir -p /tmp/mygopro/repo
# 2 切换到工程目录
cd /tmp/mygopro/repo
# 3 初始化工程
git init
# 4 添加远程仓库路径
git remote add origin https://github.com/my/repo
# 5 初始化一个新模块, 会创建一个 go.mod 文件
go mod init github.com/my/repo
# 6 写 go 源码
cat &amp;lt;&amp;lt;EOF &amp;gt; hello.go
&amp;gt; package main
&amp;gt;
&amp;gt; import (
&amp;gt;     &amp;quot;fmt&amp;quot;
&amp;gt;     &amp;quot;rsc.io/quote&amp;quot;
&amp;gt; )
&amp;gt;
&amp;gt; func main() {
&amp;gt;     fmt.Println(quote.Hello())
&amp;gt; }
&amp;gt; EOF
# 7 编译和运行
go build -o hello
./hello
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;1-2-每日工作流&#34;&gt;1.2 每日工作流&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;添加 &lt;code&gt;import&lt;/code&gt; 语句到 &lt;code&gt;.go&lt;/code&gt; 代码&lt;/li&gt;
&lt;li&gt;标准命令(&lt;code&gt;go build&lt;/code&gt; 或 &lt;code&gt;go test&lt;/code&gt;) 会自动增加新依赖的最高版本以满足导入(更新 &lt;code&gt;go.mod&lt;/code&gt; 的 &lt;code&gt;require&lt;/code&gt; 命令，并下载新的依赖)&lt;/li&gt;
&lt;li&gt;需要时，可以使用命令(&lt;code&gt;go get foo@v1.2.3&lt;/code&gt; 或 &lt;code&gt;go get foo@master&lt;/code&gt; 或 &lt;code&gt;go get foo@commitid&lt;/code&gt; 或 &lt;code&gt;go get foo@master&lt;/code&gt;)或直接编辑 &lt;code&gt;go.mod&lt;/code&gt; 选择依赖的具体版本&lt;/li&gt;
&lt;li&gt;其他有用的命令

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go list -m all&lt;/code&gt;: 查看编译会使用的所有的直接或间接依赖的最终版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -u -m all&lt;/code&gt;: 查看可用的所有的直接或间接依赖的次级和补丁升级版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -u ./...&lt;/code&gt; 或 &lt;code&gt;go list -u=patch ./...&lt;/code&gt; (从模块根路径): 升级所有直接或间接依赖到最新的次级或补丁升级(忽视 pre-release)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build ./...&lt;/code&gt; 或 &lt;code&gt;go test ./...&lt;/code&gt; (从模块根路径):编译或测试模块内的所有包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod tidy&lt;/code&gt;: 从 &lt;code&gt;go.mod&lt;/code&gt; 删除不再需要的依赖，增加新依赖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt; &lt;code&gt;gohack&lt;/code&gt;: 使用依赖的一个 fork 或本地拷贝或精确版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod vendor&lt;/code&gt;: 可选的步骤，创建一个 &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-新概念&#34;&gt;2 新概念&lt;/h2&gt;

&lt;h3 id=&#34;2-1-module-模块&#34;&gt;2.1 module 模块&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;模块是相关的 Go 包的集合，它们作为一个单一的单元被打上版本号&lt;/li&gt;
&lt;li&gt;模块记录精确的依赖需求，创建可再复制的构建&lt;/li&gt;
&lt;li&gt;最常见的是，一个版本控制仓库包含确切的一个模块，在仓库的根目录定义。(可在一个仓库支持多模块，但是通常导致在持续进行的基础上比一个仓库一个模块工作更多)&lt;/li&gt;
&lt;li&gt;仓库、模块和包的关系：

&lt;ul&gt;
&lt;li&gt;一个仓库包含一个或多个 Go 模块&lt;/li&gt;
&lt;li&gt;每个模块包含一个或多个 Go 包&lt;/li&gt;
&lt;li&gt;每个包由一个单一的目录内的一个或多个 Go 源文件组成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模块必须根据 semver 打上版本号，通常是 &lt;code&gt;v(major).(minor).(patch)&lt;/code&gt;，如 &lt;code&gt;v0.1.0&lt;/code&gt;/&lt;code&gt;v1.2.3&lt;/code&gt;/&lt;code&gt;v1.5.0-rc.1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-go-mod&#34;&gt;2.2 go.mod&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;有 4 个指令 &lt;code&gt;module/require/replace/exclude&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;module: 声明模块身份，提供了模块路径。包的导入路径由模块路径和包目录与 &lt;code&gt;go.mod&lt;/code&gt; 的相对路径决定&lt;/li&gt;
&lt;li&gt;require:&lt;/li&gt;
&lt;li&gt;replace: 只作用于当前(主)模块&lt;/li&gt;
&lt;li&gt;exclude: 只作用于当前(主)模块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-3-版本选择&#34;&gt;2.3 版本选择&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;源码增加新的导入语句，且在 &lt;code&gt;go.mod&lt;/code&gt; 的 &lt;code&gt;require&lt;/code&gt; 指令未覆盖时，大多数命令会自动查找合适的模块，增加最高版本到 &lt;code&gt;go.mod&lt;/code&gt; 的 &lt;code&gt;require&lt;/code&gt; 指令&lt;/li&gt;
&lt;li&gt;编译时使用最小版本选择算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-4-语义导入版本控制&#34;&gt;2.4 语义导入版本控制&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;导入兼容性规则(import compatibility rule)：如果一个旧包和新包又相同的导入路径，那么新包必须向后兼容旧包&lt;/li&gt;
&lt;li&gt;semver 要求当向后不兼容时需要修改主版本号&lt;/li&gt;
&lt;li&gt;语义导入版本控制(Semantic Import Versioning) 就是同时遵循导入兼容性规则和 semver的结果，即在导入路径添加主版本号——确保当主版本号因为兼容性破坏增加时导入路径也会改变

&lt;ul&gt;
&lt;li&gt;遵循 semver&lt;/li&gt;
&lt;li&gt;对于 v0 或者 v1 版本，不要增加主版本号在模块路径或者导入路径&lt;/li&gt;
&lt;li&gt;如果模块版本是 v2+，模块路径和包导入路径必须增加 &lt;code&gt;/vN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;上面适用于已经使用模块或者导入其他模块。下面是未使用模块的三个过渡异常

&lt;ul&gt;
&lt;li&gt;gopkg.in&lt;/li&gt;
&lt;li&gt;当导入非模块的 v2+ 包时使用 &lt;code&gt;+incompatible&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当未启用模块模式时使用最小模块兼容性(Minimal module compatibility)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-如何使用模块&#34;&gt;3 如何使用模块&lt;/h2&gt;

&lt;h3 id=&#34;3-1-如何安装和激活模块支持&#34;&gt;3.1 如何安装和激活模块支持&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装方法

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/dl/&#34; target=&#34;_blank&#34;&gt;安装最新的 Go1.11 发行版&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/install/source&#34; target=&#34;_blank&#34;&gt;用 master 分支源码安装 Go 工具链&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;激活支持方法

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;$GOPATH/src&lt;/code&gt; 之外调用 go 命令，且在当前目录或任意父目录存在有效的 &lt;code&gt;go.mod&lt;/code&gt; 文件且环境变量 &lt;code&gt;GO111MODULE&lt;/code&gt; 未设置(或显式设置成 &lt;code&gt;auto&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;调用 go 命令设置 &lt;code&gt;GO111MODULE=on&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-2-定义一个模块&#34;&gt;3.2 定义一个模块&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为已有工程创建一个 &lt;code&gt;go.mod&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 1 切换到模块源码树的根路径($GOPATH 之外，可以不设置 GO111MODULE 来激活模块模式)
cd &amp;lt;project path outside $GOPATH/src&amp;gt;
## 1.1 对于在 $GOPATH/src 目录之内的工程，需要手动激活
export GO111MODULE=on
cd $GOPATH/src/&amp;lt;project path&amp;gt;
# 2 创建初始模块定义，并从 dep 或其他依赖管理器转化依赖信息，增加 require 声明到 go.mod 以匹配现有配置
go mod init
## 2.1 可以指定模块路径(命令不能自动确定模块路径，或需要覆盖该路径)
go mod init github.com/my/repo
# 3 编译模块。在模块根路径执行，互编译当前模块的所有包。go build 会自动添加缺失或未转化的依赖
go build ./...
# 4 按照配置测试模块，确认对于选中的版本是正常的
go test ./...
# 5 可选。运行模块和所有直接或间接依赖的测试，检查兼容性
go test all
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：当依赖包含 v2+ 版本，或者正在初始化一个 v2+ 模块，需要在运行 &lt;code&gt;go mod init&lt;/code&gt; 之后，编辑 &lt;code&gt;go.mod&lt;/code&gt; 和 &lt;code&gt;.go&lt;/code&gt; 代码，添加 &lt;code&gt;/vN&lt;/code&gt; 到导入路径。参考 &lt;a href=&#34;https://github.com/golang/go/wiki/Modules#semantic-import-versioning&#34; target=&#34;_blank&#34;&gt;Semantic Import Versioning&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：执行 &lt;code&gt;go build ./...&lt;/code&gt; 或类似命令成功之后才可以允许 &lt;code&gt;go mod tidy&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-3-升级和降级依赖&#34;&gt;3.3 升级和降级依赖&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;直接编辑 &lt;code&gt;go.mod&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt;: 对依赖升级或降级，此命令会自动更新 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt;/&lt;code&gt;go test&lt;/code&gt;/&lt;code&gt;go list&lt;/code&gt;: 会自动增加新依赖以满足导入(更新 &lt;code&gt;go.mod&lt;/code&gt; 的 &lt;code&gt;require&lt;/code&gt; 命令，并下载新的依赖)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -u -m all&lt;/code&gt;: 查看可用的所有的直接或间接依赖的次级和补丁升级版本&lt;/li&gt;
&lt;li&gt;将当前模块的所有直接或间接依赖升级到最新版本，可在模块根目录执行下面的命令

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go get -u ./...&lt;/code&gt;: 使用最新的次级或补丁发布(增加 &lt;code&gt;-t&lt;/code&gt; 也会升级测试依赖)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get -u=patch ./...&lt;/code&gt;: 使用最新的补丁发布(增加 &lt;code&gt;-t&lt;/code&gt; 也会升级测试依赖)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get foo&lt;/code&gt;/&lt;code&gt;go get foo@latest&lt;/code&gt;: 升级 &lt;code&gt;foo&lt;/code&gt; 到最新版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get -u foo&lt;/code&gt;/&lt;code&gt;go get -u foo@latest&lt;/code&gt;: 升级 &lt;code&gt;foo&lt;/code&gt; 及其直接或间接依赖到最新版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get foo@v1.6.2&lt;/code&gt;/&lt;code&gt;go get foo@e3702bed2&lt;/code&gt;/&lt;code&gt;go get foo@&#39;&amp;lt;v1.6.2&#39;&lt;/code&gt;: 升级或降级到具体版本，可以添加版本后缀或 &lt;a href=&#34;https://golang.org/cmd/go/#hdr-Module_queries&#34; target=&#34;_blank&#34;&gt;module query&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;module query 不能得到一个 &lt;a href=&#34;https://semver.org/&#34; target=&#34;_blank&#34;&gt;semver 标签&lt;/a&gt;，会在 &lt;code&gt;go.mod&lt;/code&gt; 记录一个&lt;a href=&#34;https://tip.golang.org/cmd/go/#hdr-Pseudo_versions&#34; target=&#34;_blank&#34;&gt;伪版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get foo@master&lt;/code&gt;: 使用分支名，获取分支的最新版本，不需要有 semver 标签&lt;/li&gt;
&lt;li&gt;模块可以使用没有转成模块的包，包括记录可用的 semver 标签和使用这些标签升级或降级。模块也可以使用没有合适的 semver 标签的包，此时记录的是伪版本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go test all&lt;/code&gt;: 升级或降级所有依赖后，可以为所有包运行测试以检查兼容性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-4-准备发布模块&#34;&gt;3.4 准备发布模块&lt;/h3&gt;

&lt;h4 id=&#34;3-4-1-发行-release-所有版本模块&#34;&gt;3.4.1 发行(release)所有版本模块&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;去掉多余依赖，增加依赖 &lt;code&gt;go mod tidy&lt;/code&gt;。&lt;code&gt;go build&lt;/code&gt; 和 &lt;code&gt;go test&lt;/code&gt; 不会从 &lt;code&gt;go.mod&lt;/code&gt; 删除不需要的依赖&lt;/li&gt;
&lt;li&gt;测试模块 &lt;code&gt;go test all&lt;/code&gt;，包括测试直接或间接依赖，验证当前选择包版本的兼容性&lt;/li&gt;
&lt;li&gt;确保 &lt;code&gt;go.sum&lt;/code&gt; 文件和 &lt;code&gt;go.mod&lt;/code&gt; 文件一起提交了&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;3-4-2-发行-v2-版本模块&#34;&gt;3.4.2 发行 v2+ 版本模块&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将一个工程改成模块时，升级主版本号：使用的时候直接在导入路径添加新的主版本号更简单；也便于在旧版本上修改和完善&lt;/li&gt;
&lt;li&gt;有两个可选机制发行 v2+ 版本的模块。当推送新的标签时，使用者可以知道新模块的发布。比如创建一个 &lt;code&gt;v3.0.0&lt;/code&gt; 发行

&lt;ul&gt;
&lt;li&gt;主分支：更新 &lt;code&gt;go.mod&lt;/code&gt; 文件在 &lt;code&gt;module&lt;/code&gt; 命令的模块路径末尾添加 &lt;code&gt;/v3&lt;/code&gt;;更新模块内的 import 语句；给本次发行添加标签 &lt;code&gt;v3.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主子目录：创建一个 &lt;code&gt;v3&lt;/code&gt; 子目录；放一个新的 &lt;code&gt;go.mod&lt;/code&gt; 文件在 &lt;code&gt;v3&lt;/code&gt; 目录；更新模块内的 import 语句；给本次发行添加标签 &lt;code&gt;v3.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这个可以提供更好的向后兼容性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-4-3-发布一个发行版本&#34;&gt;3.4.3 发布一个发行版本&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;通过推送一个标签到苍鹭发布新模块版本。标签包括两个字符串：前缀和版本号

&lt;ul&gt;
&lt;li&gt;前缀指明模块在仓库内定义的位置：如果定义在仓库根目录，前缀为空。标签就是版本号&lt;/li&gt;
&lt;li&gt;在多模块仓库中，前缀区分不同模块的版本。前缀是仓库内定义模块的目录。如果仓库是主子目录形式，前缀不包含主版本号后缀&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;比如，有一个模块 &lt;code&gt;example.com/repo/sub/v2&lt;/code&gt;，需要发布 &lt;code&gt;v2.1.6&lt;/code&gt;，仓库主目录是 &lt;code&gt;example.com/repo&lt;/code&gt;，模块在仓库内的 &lt;code&gt;sub/v2/go.mod&lt;/code&gt; 定义，则模块的前缀是 &lt;code&gt;sub/&lt;/code&gt;，这次发布完整的标签是 &lt;code&gt;sub/v2.1.6&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-迁移到模块&#34;&gt;4 迁移到模块&lt;/h2&gt;

&lt;h3 id=&#34;4-1-迁移总结&#34;&gt;4.1 迁移总结&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;设计模块系统是为了允许整个 Go 生态系统的不同包按不同比率选择性加入&lt;/li&gt;
&lt;li&gt;v2+ 版本的包在迁移时因为 &lt;a href=&#34;#24-%e8%af%ad%e4%b9%89%e5%af%bc%e5%85%a5%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6&#34;&gt;语义导入版本控制&lt;/a&gt;需要考虑更多&lt;/li&gt;
&lt;li&gt;新包以及 v0/v1 的包在选择模块时考虑较少&lt;/li&gt;
&lt;li&gt;Go1.11 定义的模块可被旧版本的 Go 使用(但是 Go 版本依靠主模块及其依赖使用的策略)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-2-迁移相关的话题&#34;&gt;4.2 迁移相关的话题&lt;/h3&gt;

&lt;h4 id=&#34;4-2-1-使用较早的依赖管理器自动迁移&#34;&gt;4.2.1 使用较早的依赖管理器自动迁移&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go mod init&lt;/code&gt; 自动将需要的信息翻译到 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果创建 v2+ 的模块，确保 &lt;code&gt;go.mod&lt;/code&gt; 中的 &lt;code&gt;module&lt;/code&gt; 指令增加了 &lt;code&gt;/vN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果导入 v2+ 的模块，可能需要手动调整 &lt;code&gt;go.mod&lt;/code&gt; 中的 &lt;code&gt;require&lt;/code&gt; 指令增加了 &lt;code&gt;/vN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod init&lt;/code&gt; 不会修改源码文件的导入声明&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-2-提供依赖信息给旧版本的-go-和非模块使用者&#34;&gt;4.2.2 提供依赖信息给旧版本的 Go 和非模块使用者&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/li&gt;
&lt;li&gt;旧版本的 Go 以及禁用模块模式的 Go1.11/Go1.12+ 都可以使用 &lt;code&gt;go mod vendor&lt;/code&gt; 生成的 &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-3-更新预先已有的安装指导&#34;&gt;4.2.3 更新预先已有的安装指导&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;先前的模块，通常使用 &lt;code&gt;go get -u&lt;/code&gt; 安装。如果是发布模块，基于模块的使用者考虑使用 &lt;code&gt;go get&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; 指示 go 工具升级模块的所有直接或间接依赖&lt;/li&gt;
&lt;li&gt;模块使用者之后可以选择使用 &lt;code&gt;go get -u&lt;/code&gt;，但是一开始安装使用 &lt;code&gt;go get&lt;/code&gt; 可以有更多好处。参考&lt;a href=&#34;https://github.com/golang/proposal/blob/master/design/24301-versioned-go.md#update-timing--high-fidelity-builds&#34; target=&#34;_blank&#34;&gt;高保真的构建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get -u&lt;/code&gt; 仍然有效，且对安装指令是有效选择&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 对于基于模块的使用者不是严格必须的

&lt;ul&gt;
&lt;li&gt;简单的增加导入语句，后续的 &lt;code&gt;go build&lt;/code&gt;/&lt;code&gt;go test&lt;/code&gt; 会根据需求自动下载模块并更新 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基于模块的消费者默认不使用 &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-4-避免破坏已有的导入路径&#34;&gt;4.2.4 避免破坏已有的导入路径&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;当模块导入路径和对应模块的声明路径不匹配时会报 &lt;code&gt;unexpected module path&lt;/code&gt; 错误。破坏的情况包括

&lt;ul&gt;
&lt;li&gt;模块导入路径发生变化：比如不再使用 &lt;code&gt;gopkg.in&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改变路径大小写：导入路径和对应模块路径是大小写敏感的&lt;/li&gt;
&lt;li&gt;选择模块之后，修改模块路径&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-5-当第一次采用模块且模块有-v2-的包时升级主版本号&#34;&gt;4.2.5 当第一次采用模块且模块有 v2+ 的包时升级主版本号&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;如果有 v2+ 包，在第一此采用模块时，建议升级主版本号&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-6-v2-模块允许一次编译中有多个主版本号&#34;&gt;4.2.6 v2+ 模块允许一次编译中有多个主版本号&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;因为规则说明——“不同的导入路径包是不同的包”&lt;/li&gt;
&lt;li&gt;此时，包级别状态会有多个拷贝，且每个主版本会运行自己的 &lt;code&gt;init&lt;/code&gt; 函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-7-非模块代码使用模块&#34;&gt;4.2.7 非模块代码使用模块&lt;/h4&gt;

&lt;h5 id=&#34;4-2-7-1-非模块代码使用-v0-v1-模块&#34;&gt;4.2.7.1 非模块代码使用 v0/v1 模块&lt;/h5&gt;

&lt;h5 id=&#34;4-2-7-2-非模块代码使用-v2-模块&#34;&gt;4.2.7.2 非模块代码使用 v2+ 模块&lt;/h5&gt;

&lt;h4 id=&#34;4-2-8-给预先已有的-v2-包作者使用的策略&#34;&gt;4.2.8 给预先已有的 v2+ 包作者使用的策略&lt;/h4&gt;

&lt;h5 id=&#34;4-2-8-1-要求客户使用-1-9-7-1-10-3-1-11-版本的-go&#34;&gt;4.2.8.1 要求客户使用 1.9.7+/1.10.&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.11+ 版本的 Go&lt;/h5&gt;

&lt;h5 id=&#34;4-2-8-2-允许客户使用更旧版本的-go-如-go1-8&#34;&gt;4.2.8.2 允许客户使用更旧版本的 Go，如 Go1.8&lt;/h5&gt;

&lt;h5 id=&#34;4-2-8-3-等待选择模块&#34;&gt;4.2.8.3 等待选择模块&lt;/h5&gt;

&lt;h2 id=&#34;5-其他资源&#34;&gt;5 其他资源&lt;/h2&gt;

&lt;h2 id=&#34;6-初始-vgo-建议之后的改变&#34;&gt;6 初始 Vgo 建议之后的改变&lt;/h2&gt;

&lt;h2 id=&#34;7-github-issues&#34;&gt;7 Github issues&lt;/h2&gt;

&lt;h2 id=&#34;8-faqs&#34;&gt;8 FAQs&lt;/h2&gt;

&lt;h3 id=&#34;8-1-如何标记版本是不兼容的&#34;&gt;8.1 如何标记版本是不兼容的&lt;/h3&gt;

&lt;h3 id=&#34;8-2-何时是旧行为-vs-新的基于模块的行为&#34;&gt;8.2 何时是旧行为 vs 新的基于模块的行为&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;模块在 Go1.11 开始，因此按照设计旧行为会默认保留&lt;/li&gt;
&lt;li&gt;什么时候是旧的 1.10 状态行为(查找 &lt;code&gt;vendor&lt;/code&gt; 目录和 GOPATH 来寻找依赖)，什么时候是新的基于模块的行为

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH&lt;/code&gt; 之内: 默认是旧的 1.10 行为，会忽视模块&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH&lt;/code&gt; 之外且在文件树之内有一个 &lt;code&gt;go.mod&lt;/code&gt; 文件: 默认是模块行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GO111MODULE&lt;/code&gt; 环境变量&lt;/li&gt;
&lt;li&gt;不设置或 &lt;code&gt;auto&lt;/code&gt;: 上述默认行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on&lt;/code&gt;: 强制支持模块，与目录位置无关&lt;/li&gt;
&lt;li&gt;&lt;code&gt;off&lt;/code&gt;: 强制不支持模块，与目录位置无关&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;8-3-为什么通过-go-get-安装一个工具报错-cannot-find-main-module&#34;&gt;8.3 为什么通过 &lt;code&gt;go get&lt;/code&gt; 安装一个工具报错 &lt;code&gt;cannot find main module&lt;/code&gt;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;因为设置了 &lt;code&gt;GO111MODULE=on&lt;/code&gt;，但是所在文件树没有 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主要原因是 &lt;code&gt;go.mod&lt;/code&gt; 记录了依赖信息，但是设置了 &lt;code&gt;GO111MODULE=on&lt;/code&gt;，而 &lt;code&gt;go get&lt;/code&gt; 不能获取依赖信息&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;最简单的方法设置 &lt;code&gt;GO111MODULE=auto&lt;/code&gt;，或者不设置&lt;/li&gt;
&lt;li&gt;临时使用 Go1.10 行为 &lt;code&gt;GO111MODULE=off go get&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建一个临时的 &lt;code&gt;go.mod&lt;/code&gt; 文件然后丢弃，这样可以避免报错 &lt;code&gt;cannot use path@version syntax in GOPATH mode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&#34;https://github.com/myitcv/gobin#usage&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;gobin&lt;/code&gt;&lt;/a&gt;：&lt;code&gt;gobin&lt;/code&gt; 默认会安装/运行主包而不用先手动创建一个模块。也可以使用 &lt;code&gt;-m&lt;/code&gt; 使用现有的模块解决依赖(由环境变量 GOMOD 指定)&lt;/li&gt;
&lt;li&gt;为全局安装的工具创建 &lt;code&gt;go.mod&lt;/code&gt;，比如 &lt;code&gt;~/global-tools/go.mod&lt;/code&gt;，然后切换到那个目录，再运行 &lt;code&gt;go get&lt;/code&gt;/&lt;code&gt;go install&lt;/code&gt; 安装全局工具&lt;/li&gt;
&lt;li&gt;为每个工具在单独的目录创建 &lt;code&gt;go.mod&lt;/code&gt;，比如 &lt;code&gt;~/tools/gorename/go.mod&lt;/code&gt;/&lt;code&gt;~/tools/goimports/go.mod&lt;/code&gt;，然后切换到合适的目录，再运行 &lt;code&gt;go get&lt;/code&gt;/&lt;code&gt;go install&lt;/code&gt; 安装工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;8-4-如何为一个模块跟踪工具依赖&#34;&gt;8.4 如何为一个模块跟踪工具依赖&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果：

&lt;ul&gt;
&lt;li&gt;在模块中想要是有一个基于 go 的工具(比如 &lt;code&gt;stringer&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;想要在自己模块的 &lt;code&gt;go.mod&lt;/code&gt; 中跟踪工具的版本，并确保每个人使用相同版本的工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;建议在模块添加一个 &lt;code&gt;tools.go&lt;/code&gt; 文件，添加感兴趣的工具的导入语句(比如 &lt;code&gt;import _ &amp;quot;golang.org/x/tools/cmd/stringer&amp;quot;&lt;/code&gt;)，并增加 &lt;code&gt;// +build tools&lt;/code&gt; 编译限制。&lt;a href=&#34;https://github.com/go-modules-by-example/index/blob/master/010_tools/README.md&#34; target=&#34;_blank&#34;&gt;例子参考&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;导入语句允许 go 命令精确记录工具的版本信息到 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;编译限制阻止正常的编译导入工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;8-5-模块支持的状态在-ide-编辑器和标准工具-比如-goimport-gorename等-是什么样的&#34;&gt;8.5 模块支持的状态在 IDE，编辑器和标准工具(比如 goimport，gorename等) 是什么样的&lt;/h3&gt;

&lt;h2 id=&#34;9-faqs-其他控制&#34;&gt;9 FAQs-其他控制&lt;/h2&gt;

&lt;h3 id=&#34;9-1-在模块上工作时可用的社区工具&#34;&gt;9.1 在模块上工作时可用的社区工具&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/rogpeppe/gohack&#34; target=&#34;_blank&#34;&gt;github.com/rogpeppe/gohack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marwan-at-work/mod&#34; target=&#34;_blank&#34;&gt;github.com/marwan-at-work/mod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/akyoto/mgit&#34; target=&#34;_blank&#34;&gt;github.com/akyoto/mgit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/goware/modvendor&#34; target=&#34;_blank&#34;&gt;github.com/goware/modvendor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/psampaz/go-mod-outdated&#34; target=&#34;_blank&#34;&gt;github.com/psampaz/go-mod-outdated&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;9-2-什么时候使用-replace-指令&#34;&gt;9.2 什么时候使用 replace 指令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt; 允许提供另外一个导入路径，控制实际使用的依赖，而不用更新源码中的导入路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt; 允许顶层模块控制依赖的实际版本：&lt;code&gt;replace example.com/some/dependency =&amp;gt; example.com/some/dependency v1.2.3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt; 允许使用一个 fork 依赖：&lt;code&gt;replace example.com/original/import/path =&amp;gt; /your/forked/import/path&lt;/code&gt;，当需要修改一些依赖时，可以有一个本地 fork，并修改顶层模块的 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt; 可用于多模块项目中，告诉 go 工具一个模块在磁盘上的的相对和绝对路径：&lt;code&gt;replace example.com/project/foo =&amp;gt; ../foo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;9-3-能否完全在本地文件系统但在-vcs-之外工作&#34;&gt;9.3 能否完全在本地文件系统但在 VCS 之外工作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。VCS 不需要。如果再 VCS 之外，可以在 &lt;code&gt;require&lt;/code&gt; 指令中使用版本号 &lt;code&gt;v0.0.0&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Go1.11 中必须手动在 &lt;code&gt;require&lt;/code&gt; 指令中增加版本号 &lt;code&gt;v0.0.0&lt;/code&gt;，Go1.12 之后不再需要手动添加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;9-4-模块如何使用-vendor-是否不再需要-vendor&#34;&gt;9.4 模块如何使用 vendor？是否不再需要 vendor&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vgo&lt;/code&gt; 的初始系统建议完全丢掉 vendor。但是社区返回导致保留对 vendor 的支持&lt;/li&gt;
&lt;li&gt;简单来说，模块使用 vendor

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go mod vendor&lt;/code&gt;： 重置主模块的 &lt;code&gt;vendor&lt;/code&gt; 目录一包含编译和测试主模块所有包所需的包(根据 &lt;code&gt;go.mod&lt;/code&gt; 状态和 Go 源码)。目录不包含 vendored 包的测试代码&lt;/li&gt;
&lt;li&gt;默认的，&lt;code&gt;go build&lt;/code&gt; 等 go 命令在模块模式时会忽视 &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mod=vendor&lt;/code&gt; 标识指示 go 命令使用主模块顶层的 vendor 目录来满足依赖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GOFLAGS=-mod=vendor&lt;/code&gt; 可以设置使用 vendor 目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当模块模式禁用时，旧版本的 Go 可以使用 vendor 目录。因此，vendor 是使得模块提供依赖给旧版本 Go 的模块使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-4-1-模块下载和验证&#34;&gt;9.4.1 模块下载和验证&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;根据 &lt;code&gt;GOPROXY&lt;/code&gt;，go 命令可以从一个代理或直连到源码控制服务拉取代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GOPROXY&lt;/code&gt; 默认设置是 &lt;code&gt;https://proxy.golang.org,direct&lt;/code&gt;，即尝试 Google 运行的 Go 模块代理，如果代理报告没有模块(HTTP 错误码 404 或 410)，会尝试直连&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GOPROXY&lt;/code&gt; 为 &lt;code&gt;off&lt;/code&gt; 时，不允许从任何源码下载模块。否则，&lt;code&gt;GOPROXY&lt;/code&gt; 是逗号分隔的模块代理的 URL，go 命令会从这些代理拉取模块

&lt;ul&gt;
&lt;li&gt;对于每个请求，go 命令按顺序尝试代理，当代理返回 404 或 410 HTTP 状态码时，会继续尝试下个代理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;direct&lt;/code&gt; 之后的代理都不会尝试&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GOPRIVATE&lt;/code&gt; 和 &lt;code&gt;GONOPPROXY&lt;/code&gt; 允许对指定的模块绕过代理&lt;/li&gt;
&lt;li&gt;对于所有的模块，go 命令会根据已知的校验值检查下载，检测未预料的变化。检查先查询当前模块的 &lt;code&gt;go.sum&lt;/code&gt; 文件，失败时检查 Go 的校验值数据库，后者由 &lt;code&gt;GOSUMDB&lt;/code&gt; 和 &lt;code&gt;GONOSUMDB&lt;/code&gt; 控制&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-4-2-模块和目录&#34;&gt;9.4.2 模块和目录&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用模块时，go 命令会完全忽视 &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;默认的，go 命令通过从源码下载模块和使用这些下载的备份(在验证之后)&lt;/li&gt;
&lt;li&gt;为了和旧版本的 Go 交互，或者保证编译使用的所有文件被存储在一个单独的目录树，&lt;code&gt;go mod vendor&lt;/code&gt; 在当前主模块的根目录创建一个 &lt;code&gt;vendor&lt;/code&gt; 目录，用于存储编译和测试主模块所需的依赖模块的所有包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build -mod=vendor&lt;/code&gt;: 使用模块的顶层的 &lt;code&gt;vendor&lt;/code&gt; 目录来编译以满足依赖(不使用通常的网络源码和本地缓存)。&lt;strong&gt;注意&lt;/strong&gt;只有主模块的顶层 &lt;code&gt;vendor&lt;/code&gt; 目录会使用，其他位置的 &lt;code&gt;vendor&lt;/code&gt; 目录仍然忽略&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;9-5-是否有-always-on-的模块仓库和企业代理&#34;&gt;9.5 是否有 always on 的模块仓库和企业代理&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://proxy.golang.org/&#34; target=&#34;_blank&#34;&gt;proxy.golang.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gocenter.io/&#34; target=&#34;_blank&#34;&gt;gocenter.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://mirrors.aliyun.com/goproxy&#34; target=&#34;_blank&#34;&gt;mirrors.aliyun.com/goproxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://goproxy.cn/&#34; target=&#34;_blank&#34;&gt;goproxy.cn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://goproxy.io/&#34; target=&#34;_blank&#34;&gt;goproxy.io&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gomods/athens&#34; target=&#34;_blank&#34;&gt;Athens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://athens.azurefd.net/&#34; target=&#34;_blank&#34;&gt;athens.azurefd.net&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/goproxy/goproxy&#34; target=&#34;_blank&#34;&gt;Goproxy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://thumbai.app/&#34; target=&#34;_blank&#34;&gt;THUMBAI&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;9-6-能否控制何时更新-go-mod-go-工具何时使用网络满足依赖&#34;&gt;9.6 能否控制何时更新 go.mod，go 工具何时使用网络满足依赖&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;默认的，类似于 &lt;code&gt;go build&lt;/code&gt; 目录会忽视 &lt;code&gt;vendor&lt;/code&gt; 目录，在需要的时候访问网络满足导入&lt;/li&gt;
&lt;li&gt;go 工具提供了一些参数来支持一些行为 &lt;code&gt;-mod=readonly&lt;/code&gt;/&lt;code&gt;-mod=vendor&lt;/code&gt;/&lt;code&gt;GOFLAGS&lt;/code&gt;/&lt;code&gt;GOPROXY=off&lt;/code&gt;/&lt;code&gt;GOPROXY=file:///filesystem/path&lt;/code&gt;/&lt;code&gt;go mod vendor&lt;/code&gt;/&lt;code&gt;go mod download&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-1-goflags-环境变量&#34;&gt;9.6.1 GOFLAGS 环境变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;允许设置特殊 go 命令的默认标识&lt;/li&gt;
&lt;li&gt;对于 CI 和测试工作流有用，可用于定义每天开发的默认标识或行为，比如设置 &lt;code&gt;GOFLAGS=-mod=vendor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-2-mod-readonly-标识-如-go-build-mod-readonly&#34;&gt;9.6.2 -mod=readonly 标识(如 &lt;code&gt;go build -mod=readonly&lt;/code&gt;)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;禁止大多数 go 命令(除了&lt;code&gt;go get&lt;/code&gt;/&lt;code&gt;go mod&lt;/code&gt;)修改 &lt;code&gt;go.mod&lt;/code&gt;，导致想要隐式更新 &lt;code&gt;go.mod&lt;/code&gt; 的命令失败&lt;/li&gt;
&lt;li&gt;用于检查 &lt;code&gt;go.mod&lt;/code&gt; 不需要更新，比如集成或测试时&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-3-go-mod-vendor-命令&#34;&gt;9.6.3 go mod vendor 命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;重置主模块的 &lt;code&gt;vendor&lt;/code&gt; 目录一包含编译和测试主模块所有包所需的包(根据 &lt;code&gt;go.mod&lt;/code&gt; 状态和 Go 源码)&lt;/li&gt;
&lt;li&gt;不同团队对于 vendor 的哲学观点不同。vendor 可用于记录依赖到源码的版本控制，同事在外部源码出问题(宕机、消失或移动)时提供弹性&lt;/li&gt;
&lt;li&gt;可为使用旧版本 Go 的用户提供相同的依赖&lt;/li&gt;
&lt;li&gt;支持 CI 过程旧版本 Go(比如 Go1.9/Go1.10) 的测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-4-mod-vendor-标识-如-go-build-mod-vendor&#34;&gt;9.6.4 -mod=vendor 标识(如 &lt;code&gt;go build -mod=vendor&lt;/code&gt;)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;默认的，&lt;code&gt;go build&lt;/code&gt; 等 go 命令在模块模式时会忽视 &lt;code&gt;vendor&lt;/code&gt; 目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mod=vendor&lt;/code&gt; 标识指示 go 命令使用主模块顶层的 &lt;code&gt;vendor&lt;/code&gt; 目录来满足依赖(j禁用网络资源和本地缓存)&lt;/li&gt;
&lt;li&gt;想要一直使用设置 &lt;code&gt;GOFLAGS=-mod=vendor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-5-go111module-off-环境变量&#34;&gt;9.6.5 GO111MODULE=off 环境变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;go 命令不会支持新的模块。而是查找 &lt;code&gt;vendor&lt;/code&gt; 目录和 GOPATH 来寻找依赖(遵循 pre-1.11 行为)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-6-goproxy-off-环境变量&#34;&gt;9.6.6 GOPROXY=off 环境变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;模块模式的 go 命令不允许使用网络依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-7-goproxy-file-filesystem-path-环境变量&#34;&gt;9.6.7 GOPROXY=file:///filesystem/path 环境变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;go 命令会使用文件系统(本地或远程)解决依赖，不再有实际运行的代理进程&lt;/li&gt;
&lt;li&gt;go 命令存储下载的依赖在本地缓存(&lt;code&gt;$GOPATH/pkg/mod&lt;/code&gt;)，而且缓存格式和代理的需求相同，因此缓存可当做内容被基于文件系统的 GOPROXY 或简单的用作 GOPROXY 的 web 服务使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod download&lt;/code&gt; 定位到 &lt;code&gt;$GOPATH/pkg/mod/cache/download&lt;/code&gt;，意味着这个命令可用于预先定位或更新 GOPROXY 的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-8-开源的分布式模块仓库-如-athens-工程&#34;&gt;9.6.8 开源的分布式模块仓库，如 Athens 工程&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;一个目标是提供 “always on” 的模块仓库&lt;/li&gt;
&lt;li&gt;一个不同的目标是单独的代理服务器，可被一个组织部署和控制可用的模块&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-9-go-mod-download-命令&#34;&gt;9.6.9 go mod download 命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;大多数每日工作不需要这个命令(因为通常 go命令会自动下载需要的模块)&lt;/li&gt;
&lt;li&gt;主要用于在一些 CI 中，用于 docker 编译的缓存预热(pre-warming caches)&lt;/li&gt;
&lt;li&gt;也可能被代理事宜作为缓存缺失时获取模块的一种方式&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;9-6-10-go-mod-中的-replace-指令&#34;&gt;9.6.10 go.mod 中的 replace 指令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以控制顶层的 &lt;code&gt;go.mod&lt;/code&gt; 以满足 Go 源码或 go.mod 文件实际使用的依赖&lt;/li&gt;
&lt;li&gt;一个用例：如果需要修改一个依赖的内容，可以有本地 fork，在顶层的 &lt;code&gt;go.mod&lt;/code&gt; 使用 &lt;code&gt;replace example.com/original/import/path =&amp;gt; your/forked/import/path&lt;/code&gt;，而不用更新代码中的导入路径。&lt;code&gt;replace&lt;/code&gt; 指令允许提供另外一个导入路径(可能在 VCS 的另外一个模块，或者在本地文件系统)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace&lt;/code&gt; 也允许顶层模块实际使用依赖的具体版本，如 &lt;code&gt;replace example.com/some/dependency =&amp;gt; example.com/some/dependency@v1.2.3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;9-7-在-ci-系统-如-travis-或-circleci-中如何使用模块&#34;&gt;9.7 在 CI 系统(如 Travis 或 CircleCI) 中如何使用模块&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;最简单的方法就是设置 &lt;code&gt;GO111MODULE=off&lt;/code&gt;，大部分 CI 系统都可以使用&lt;/li&gt;
&lt;li&gt;对于 Go1.11 的 CI，无论模块启用还是禁用，假设用户还没有适用模块，可以考虑使用 vendor&lt;/li&gt;
&lt;li&gt;参考

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://arslan.io/2018/08/26/using-go-modules-with-vendor-support-on-travis-ci/&#34; target=&#34;_blank&#34;&gt;Using Go modules with vendor support on Travis CI&lt;/a&gt; by Fatih Arslan&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@toddkeech/go-modules-and-circleci-c0d6fac0b000&#34; target=&#34;_blank&#34;&gt;Go Modules and CircleCI&lt;/a&gt; by Todd Keech&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;10-faqs-go-mod-和-go-sum&#34;&gt;10 FAQs-go.mod 和 go.sum&lt;/h2&gt;

&lt;h3 id=&#34;10-1-为什么-go-mod-tidy-记录-go-mod-的间接和测试依赖&#34;&gt;10.1 为什么 go mod tidy 记录 go.mod 的间接和测试依赖&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;模块系统在 &lt;code&gt;go.mod&lt;/code&gt; 记录精确的依赖需求&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod tidy&lt;/code&gt; 更新当前的 &lt;code&gt;go.mod&lt;/code&gt; 以包含模块中测试所需的依赖——如果一个测试失败，必须知道使用的依赖以重复该失败&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod tidy&lt;/code&gt; 同时确保当前的 &lt;code&gt;go.mod&lt;/code&gt; 反映了对所有的操作系统、架构和编译标签的组合的依赖需求。相反的，其他的命令(如 &lt;code&gt;go build&lt;/code&gt;/&lt;code&gt;go test&lt;/code&gt;)只更新 &lt;code&gt;go.mod&lt;/code&gt; 以提供当前的 &lt;code&gt;GOOS&lt;/code&gt;，&lt;code&gt;GOARCH&lt;/code&gt; 和编译标签被请求的包导入的包(这也是 &lt;code&gt;go mod tidy&lt;/code&gt; 可能增加其他 go 命令没有增加的需求的原因之一)&lt;/li&gt;
&lt;li&gt;如果你的模块的依赖本身没有一个 &lt;code&gt;go.mod&lt;/code&gt;(比如因为依赖还没有选择加入模块)，或依赖的 &lt;code&gt;go.mod&lt;/code&gt; 缺少一些依赖(比如因为模块的作者没有运行 &lt;code&gt;go mod tidy&lt;/code&gt;)，那么缺失的依赖会加入到你的模块的需求，并带有一个 &lt;code&gt;// indirect&lt;/code&gt; 注释表明依赖不是从你的模块直接导入的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt;这也意味着你的模块的直接或间接依赖缺失的测试依赖也会被记录在当前的 &lt;code&gt;go.mod&lt;/code&gt;。比如，&lt;code&gt;go test all&lt;/code&gt; 运行你的模块所有的直接或间接依赖的测试，这是验证当前版本组合有效的一种方式。如果允许时某个依赖的一个测试失败，记录完整的测试依赖信息是很重要的，以便可以重复 &lt;code&gt;go test all&lt;/code&gt; 行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go.mod&lt;/code&gt; 有 &lt;code&gt;// indirect&lt;/code&gt; 依赖的另外一个原因：当升级或降级一个间接依赖且超出直接依赖的需求时(比如运行 &lt;code&gt;go get -u&lt;/code&gt;/&lt;code&gt;go get foo@1.2.3&lt;/code&gt;)，go 工具需要在某个地方记录新版本信息，并且记录在 &lt;code&gt;go.mod&lt;/code&gt; 文件(并且不会去更改依赖的 &lt;code&gt;go.mod&lt;/code&gt; 文件)&lt;/li&gt;
&lt;li&gt;一般的，上述是模块通过记录精确的依赖信息提供 100% 可重复编译和测试的一部分行为&lt;/li&gt;
&lt;li&gt;相关命令

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go mod why -m &amp;lt;module&amp;gt;&lt;/code&gt; 显示 &lt;code&gt;go.mod&lt;/code&gt; 中指定模块出现的原因&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod graph&lt;/code&gt;/&lt;code&gt;go list -m all&lt;/code&gt; 检查需要的模块及其版本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;10-2-go-sum-是否是锁文件-为什么-go-sum-包含不再使用的模块版本信息&#34;&gt;10.2 go.sum 是否是锁文件？为什么 go.sum 包含不再使用的模块版本信息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不是。&lt;code&gt;go.sum&lt;/code&gt; 在一次编译中提供足够的信息支持 100% 可重复的编译&lt;/li&gt;
&lt;li&gt;出于验证的目的，&lt;code&gt;go.sum&lt;/code&gt; 包含预期的对指定模块版本内容的加密校验值&lt;/li&gt;
&lt;li&gt;在某种程度上，因为 &lt;code&gt;go.sum&lt;/code&gt; 不是锁文件，它在停止使用一个模块或者模块的某个版本之后仍然为模块版本保留加密校验值。这允许在之后重新使用一些模块时提供校验，也提供了额外的安全性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go.sum&lt;/code&gt; 记录一次编译所有的直接或间接依赖的校验值(因此 &lt;code&gt;go.sum&lt;/code&gt; 经常会比 &lt;code&gt;go.mod&lt;/code&gt; 有更多的模块)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;10-3-是否应该提交-go-sum-和-go-mod-文件&#34;&gt;10.3 是否应该提交 go.sum 和 go.mod 文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通常应该一起提交 &lt;code&gt;go.sum&lt;/code&gt; 和 &lt;code&gt;go.mod&lt;/code&gt; 文件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go.sum&lt;/code&gt; 包含预期的对指定模块版本内容的加密校验值&lt;/li&gt;
&lt;li&gt;如果某人克隆仓库并使用 go 命令下载依赖，当他们下载的依赖拷贝和 &lt;code&gt;go.sum&lt;/code&gt; 对应的条目不匹配时会报错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go mod verify&lt;/code&gt; 检查模块的磁盘缓存备份仍然和 &lt;code&gt;go.sum&lt;/code&gt; 的条目匹配&lt;/li&gt;
&lt;li&gt;注意，&lt;code&gt;go.sum&lt;/code&gt; 不是一个锁文件(一些可选的依赖管理系统使用的锁文件)。&lt;code&gt;go.mod&lt;/code&gt; 提供足够的信息支持可重复的编译&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;10-4-如果没有任何依赖是否仍应该增加一个-go-mod-文件&#34;&gt;10.4 如果没有任何依赖是否仍应该增加一个 go.mod 文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;是的。

&lt;ul&gt;
&lt;li&gt;支持在 GOPATH 之外工作&lt;/li&gt;
&lt;li&gt;有助于和模块生态圈沟通&lt;/li&gt;
&lt;li&gt;其中的 &lt;code&gt;module&lt;/code&gt; 指令可作为代码身份的明确声明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;11-faqs-语义导入版本控制&#34;&gt;11 FAQs-语义导入版本控制&lt;/h2&gt;

&lt;h3 id=&#34;11-1-为什么主版本号必须出现在导入路径&#34;&gt;11.1 为什么主版本号必须出现在导入路径&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;为了遵循最小兼容原则，简化了系统其它部分&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-2-为什么主版本号-v0-v1-被导入路径忽视&#34;&gt;11.2 为什么主版本号 v0/v1 被导入路径忽视&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;忽视 v1 有两个原因

&lt;ul&gt;
&lt;li&gt;许多开发人员会创建一个包，该包在发布 v1 之后永远不会有破坏性的变化，这也是一开始鼓励的。当开发人员没有计划发布 v2 时，不应该强迫他们有显式的 v1。那样只会是干扰。当最终创建 v2 时，才需要加 v2 以便区分默认的 v1&lt;/li&gt;
&lt;li&gt;大量已有的代码建议忽视 v1，而不是在每个地方都加上 v1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;忽视 v0

&lt;ul&gt;
&lt;li&gt;根据 semver 规定，对于 v0 没有任何兼容性保证。因此要求显式的 v0 对于兼容性没有什么帮助；必须指明完全精确的类似 v0.1.2，而每次库更新时需要更新所有的导入路径。这是过犹不及的。相反的，我们希望开发人员会简单地查看依赖的模块列表，并适当地谨慎任何 v0.x.y 版本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;忽视 v0/v1 的影响：将没办法从区分路径区分它们，但是 v0 通常是通向 v1 的一系列破坏性变化，因此将 v1 视为破坏性变化的最后阶段是有意义的
&amp;gt;&amp;gt;&amp;gt; 通过使用 v0.x，你正在接受 v0.(x+1) 可能迫使你修改代码。那么为什么 v0.(x+1) 叫做 v1.0 是一个问题呢？&lt;/li&gt;
&lt;li&gt;忽视 v0/v1 是强制性而非可选的，因此这是包的一个规范导入路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-3-使用主版本号-v0-v1-给项目打标签或使用-v2-标记破坏性的变化的影响是什么&#34;&gt;11.3 使用主版本号 v0/v1 给项目打标签或使用 v2+ 标记破坏性的变化的影响是什么&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;和 API 兼容性相关&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-4-模块能否使用没有选择加入模块的包&#34;&gt;11.4 模块能否使用没有选择加入模块的包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。对于没有加入模块的仓库

&lt;ul&gt;
&lt;li&gt;但是具有有效的 semver 标签(包括要求的前导 &lt;code&gt;v&lt;/code&gt;)：可使用 &lt;code&gt;go get&lt;/code&gt; 获取这些标签，并记录对应 semver 版本到导入模块的 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有有效的 semver 标签：使用伪版本(如 &lt;code&gt;v0.0.0-20171006230638-a6e239ea1c69&lt;/code&gt;，包含时间戳，commit-id，如此设计以允许给版本排序)记录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-5-模块能否使用没有加入模块的-v2-包-incompatible-意味着什么&#34;&gt;11.5 模块能否使用没有加入模块的 v2+ 包？ +incompatible 意味着什么&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。如果导入的 v2+ 包具有有效的 semver 标签，将会在记录时添加 &lt;code&gt;+incompatible&lt;/code&gt; 后缀&lt;/li&gt;
&lt;li&gt;当 go 工具在模块模式(如 &lt;code&gt;GO111MODULE=on&lt;/code&gt;)操作时，下面的核心原则总为真

&lt;ul&gt;
&lt;li&gt;1 包的导入路径定义了包的身份&lt;/li&gt;
&lt;li&gt;导入路径不同的包视为不同的包&lt;/li&gt;
&lt;li&gt;导入路径相同的包视为相同的包(即使 VCS 标签表明二者主版本号不同)&lt;/li&gt;
&lt;li&gt;2 没有 &lt;code&gt;/vN&lt;/code&gt; 的导入路径视为 v0/v1 模块(即使导入包没有加入模块，且 VCS 标签表明主版本号大于 1)&lt;/li&gt;
&lt;li&gt;3 模块的 &lt;code&gt;go.mod&lt;/code&gt; 开始声明的模块路径(如 &lt;code&gt;module foo/v2&lt;/code&gt;)是&lt;/li&gt;
&lt;li&gt;该模块身份的确定性声明&lt;/li&gt;
&lt;li&gt;该模块必须被使用代码如何导入的确定性声明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+incompatible&lt;/code&gt; 后缀表明上述原则 2 实际上在下面情况下为真

&lt;ul&gt;
&lt;li&gt;导入的包没有加入模块&lt;/li&gt;
&lt;li&gt;且其 VCS 标签表明主版本号大于 1&lt;/li&gt;
&lt;li&gt;且原则 2 会覆盖 VCS 标签——没有 &lt;code&gt;/vN&lt;/code&gt; 的导入路径视为 v0/v1 模块(即使 VCS 标签主版本号大于 1)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;即，当在模块模式操作时，go 工具将认为非模块的 v2+ 包不知道语义导入版本控制，并将其视作包 v1 版本系列的(非兼容的)扩展( &lt;code&gt;+incompatible&lt;/code&gt; 后缀指示 go 工具这样做)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-6-禁用模块支持时在编译中如何对待-v2-模块-最小模块兼容性在-go1-9-7-go1-10-3-go1-11-中如何工作&#34;&gt;11.6 禁用模块支持时在编译中如何对待 v2+ 模块？最小模块兼容性在 Go1.9.7+/Go1.10.3+/Go1.11 中如何工作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;主子目录方式：v2+ 模块会创建子目录(如&lt;code&gt;mymodule/v2&lt;/code&gt;/&lt;code&gt;mymodule/v3&lt;/code&gt;)，并将合适的包移动或拷贝到子目录，这种方式的包是可以被不支持或禁用模块的 Go 使用&lt;/li&gt;
&lt;li&gt;主分支方式：通过 &lt;code&gt;go.mod&lt;/code&gt; 和提交 semver 标签确定模块版本信息(经常在 &lt;code&gt;master&lt;/code&gt; 分支)。由此引入了最小模块兼容性。主要目的是

&lt;ul&gt;
&lt;li&gt;允许旧版本 Go(1.9.7+/1.10.3+) 更容易编译使用语义导入版本控制的模块，并提供和 Go1.11 禁用模块时相同的行为&lt;/li&gt;
&lt;li&gt;允许旧代码使用 v2+ 模块，而不用旧代码修改导入路径添加 &lt;code&gt;/vN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不用依赖模块作者创建 &lt;code&gt;/vN&lt;/code&gt; 子目录而实现上述两种行为&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-7-如果创建一个-go-mod-但是仓库不使用-semver-标签会发生什么&#34;&gt;11.7 如果创建一个 go.mod 但是仓库不使用 semver 标签会发生什么&lt;/h3&gt;

&lt;h3 id=&#34;11-8-一个模块能否依赖自身不同的版本&#34;&gt;11.8 一个模块能否依赖自身不同的版本&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。但是两个包不能循环依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;12-faqs-多模块仓库&#34;&gt;12 FAQs-多模块仓库&lt;/h2&gt;

&lt;h3 id=&#34;12-1-什么是多模块仓库&#34;&gt;12.1 什么是多模块仓库&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;多模块仓库是指一个仓库包含多个模块，每个模块有自己的 &lt;code&gt;go.mod&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;每个模块起始于包含它自己的 &lt;code&gt;go.mod&lt;/code&gt; 的目录，并且包含此目录及其子目录下的所有包，不包含包含另外的 &lt;code&gt;go.mod&lt;/code&gt; 文件的子树&lt;/li&gt;
&lt;li&gt;每个模块有自己的版本信息。位于仓库跟木库下的模块的版本标签必须包含相关目录作为前缀

&lt;ul&gt;
&lt;li&gt;有一个文件 &lt;code&gt;my-repo/foo/rop/go.mod&lt;/code&gt;，那么模块 &lt;code&gt;my-repo/foo/rop&lt;/code&gt; 的 1.2.3 版本的标签是 &lt;code&gt;foo/rop/v1.2.3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一个顶层模块的路径时另外一个模块路径的前缀&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;12-2-是否应该在一个仓库包含多个模块&#34;&gt;12.2 是否应该在一个仓库包含多个模块&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;相比一个仓库包含多个模块，一个仓库一个模块在增加模块、删除模块、给模块打版本号方面更简单

&lt;ul&gt;
&lt;li&gt;在仓库根路径执行 &lt;code&gt;go test ./...&lt;/code&gt; 不会再测试仓库所有代码&lt;/li&gt;
&lt;li&gt;需要用 &lt;code&gt;replace&lt;/code&gt; 指令管理模块之间的关系&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一个仓库包含多个模块的应用场景

&lt;ul&gt;
&lt;li&gt;有一个用法例子，且例子有复杂的依赖关系。这种情况可以创建一个 &lt;code&gt;examples&lt;/code&gt;/&lt;code&gt;_examples&lt;/code&gt; 目录包含自己的 &lt;code&gt;go.mod&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;某个仓库有复杂的依赖集合，但是有一个客户端 API 只有少数依赖。在某些场景下，创建一个 &lt;code&gt;api&lt;/code&gt;/&lt;code&gt;clientapi&lt;/code&gt; 或类似的目录持有自己的 &lt;code&gt;go.mod&lt;/code&gt;，或者将 &lt;code&gt;clientapi&lt;/code&gt; 单独分出一个仓库比较好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;上述两种场景，如果只是为了一个大量间接依赖的性能或者下载大小，建议首先尝试 &lt;code&gt;GOPOROXY&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;12-3-能否给多模块仓库增加一个模块&#34;&gt;12.3 能否给多模块仓库增加一个模块&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。但是有两类问题

&lt;ul&gt;
&lt;li&gt;新增模块的包不在版本控制中。需要做的事情包括：增加包和 &lt;code&gt;go.mod&lt;/code&gt; 在同一提交，给提交打标签，推送标签&lt;/li&gt;
&lt;li&gt;增加的模块在版本控制，并且包含已有的一个或多个包。这种情况需要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;12-4-能否从多模块仓库删除一个模块&#34;&gt;12.4 能否从多模块仓库删除一个模块&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。问题同上&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;12-5-模块能否依赖另一个模块的-internal&#34;&gt;12.5 模块能否依赖另一个模块的 internal/&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。因为路径前缀是共享的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;12-6-能否增加一个-go-mod-文件排除不需要的内容-模块是否有等价的-gitignore-文件&#34;&gt;12.6 能否增加一个 go.mod 文件排除不需要的内容？模块是否有等价的 .gitignore 文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个目录中空的 &lt;code&gt;go.mod&lt;/code&gt; 文件会导致该目录及其子目录不被顶层的 Go 模块包含&lt;/li&gt;
&lt;li&gt;如果不想包含的目录不包含任何 &lt;code&gt;.go&lt;/code&gt; 文件，只需要放一个空的 &lt;code&gt;go.mod&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;13-faqs-最小版本选择&#34;&gt;13 FAQs-最小版本选择&lt;/h2&gt;

&lt;h3 id=&#34;13-1-最小版本选择是否会使开发者得到重要的更新&#34;&gt;13.1 最小版本选择是否会使开发者得到重要的更新&lt;/h3&gt;

&lt;h2 id=&#34;14-faqs-可能的问题&#34;&gt;14 FAQs-可能的问题&lt;/h2&gt;

&lt;h3 id=&#34;14-1-如果发现问题-有哪些通用的东西可以定位检查&#34;&gt;14.1 如果发现问题，有哪些通用的东西可以定位检查&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;检查启用了模块：运行 &lt;code&gt;go env&lt;/code&gt; 查看 &lt;code&gt;GOMOD&lt;/code&gt; 不为空

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;GOMOD&lt;/code&gt; 不能设置，是 &lt;code&gt;go env&lt;/code&gt; 的输出&lt;/li&gt;
&lt;li&gt;如果设置 &lt;code&gt;GO111MODULE=on&lt;/code&gt; 以启用模块，检查不要是复数形式 &lt;code&gt;GO111MODULES=on&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果预期使用 vendor，检查 &lt;code&gt;-mod=vendor&lt;/code&gt; 被传递给相关的 go 命令，或者设置了 &lt;code&gt;GOFLAGS=-mod=vendor&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;模块默认忽视 &lt;code&gt;vendor&lt;/code&gt; 除非要求 go 工具使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -m all&lt;/code&gt; 检查编译实际选择的版本列表

&lt;ul&gt;
&lt;li&gt;相比查看 &lt;code&gt;go.mod&lt;/code&gt; 会给出更多详细信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果允许 &lt;code&gt;go get foo&lt;/code&gt; 失败，或者 &lt;code&gt;go build&lt;/code&gt; 在 &lt;code&gt;foo&lt;/code&gt; 包失败。可使用 &lt;code&gt;go get -v foo&lt;/code&gt;/&lt;code&gt;go get -v -x foo&lt;/code&gt; 查看输出

&lt;ul&gt;
&lt;li&gt;一般的，&lt;code&gt;go get&lt;/code&gt; 比 &lt;code&gt;go build&lt;/code&gt; 提供更多详细的错误信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 标识请求打印更多冗长细节，不过注意一些错误(比如 404)可能基于远程仓库的配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get -v -x foo&lt;/code&gt; 也会显示调用的 git 或其他 VCS 命令(如有必要，可以经常在 go 工具上下文之外执行相同的命令用于故障排除)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;检查是否使用了旧的 git 版本

&lt;ul&gt;
&lt;li&gt;对于 vgo 原型和 Go1.11beta，使用旧的 git 是常见的错误源，但是在 GA1.11 中较少出现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Go1.11 的模块缓存有时候会导致错误，尤其是先前有网络错误或者同时执行多个 go 命令时。可以将 &lt;code&gt;$GOPATH/pkg/mod&lt;/code&gt; 到一个备份目录，运行 &lt;code&gt;go clean -modcache&lt;/code&gt;，然后检查之前的问题是否出现&lt;/li&gt;
&lt;li&gt;如果使用 Docker，检查是否可以可以在 Docker 之外复制行为(且如果行为只出现在 Docker，上述条目可用于比较 Docker 内外的结果)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-2-如果没有看到预期的依赖版本-可以检查什么&#34;&gt;14.2 如果没有看到预期的依赖版本，可以检查什么&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;执行 &lt;code&gt;go mod tidy&lt;/code&gt;。如果 &lt;code&gt;go mod tidy&lt;/code&gt; 改变了没有预期的依赖版本，先查看&lt;a href=&#34;#101-%e4%b8%ba%e4%bb%80%e4%b9%88-go-mod-tidy-%e8%ae%b0%e5%bd%95-gomod-%e7%9a%84%e9%97%b4%e6%8e%a5%e5%92%8c%e6%b5%8b%e8%af%95%e4%be%9d%e8%b5%96&#34;&gt;go mod tidy 记录 go.mod 的间接和测试依赖&lt;/a&gt;。如果没有解释，可以尝试重置 &lt;code&gt;go.mod&lt;/code&gt;，然后运行 &lt;code&gt;go list -mod=readonly all&lt;/code&gt;，可以就要求修改版本给出更多信息&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go list -m all&lt;/code&gt;，查看编译实际选择的版本列表。&lt;code&gt;go list -m all&lt;/code&gt; 显示最终选择的版本，包括间接依赖和解决共享依赖的版本。并显示了任何 &lt;code&gt;replace&lt;/code&gt; 和 &lt;code&gt;exclude&lt;/code&gt; 指令的结果&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go mod graph&lt;/code&gt;/&lt;code&gt;go mod graph | grep &amp;lt;module-of-interest&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他有用的命令包括 &lt;code&gt;go mod why -m &amp;lt;module&amp;gt;&lt;/code&gt;/&lt;code&gt;go list&lt;/code&gt;/&lt;code&gt;go list -deps -f &#39;{{with .Module}}{{.Path}} {{.Version}}{{end}}&#39; ./... | sort -u&lt;/code&gt;(显示编译使用的精确版本，不包括只用于测试的依赖)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;14-3-为什么得到错误-cannot-find-module-providing-package-foo&#34;&gt;14.3 为什么得到错误 cannot find module providing package foo&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;可能是路径不对。首先可以检查错误信息中列举的路径&lt;/li&gt;
&lt;li&gt;尝试 &lt;code&gt;go get -v foo&lt;/code&gt;/&lt;code&gt;go get -v -x foo&lt;/code&gt;。通常，&lt;code&gt;go get&lt;/code&gt; 比 &lt;code&gt;get build&lt;/code&gt; 提供更多的错误信息&lt;/li&gt;
&lt;li&gt;其他可能原因

&lt;ol&gt;
&lt;li&gt;当前目录没有 go 源码文件，但是运行了 &lt;code&gt;go build&lt;/code&gt;/&lt;code&gt;go build .&lt;/code&gt;。可以尝试运行 &lt;code&gt;go build ./...&lt;/code&gt;(&lt;code&gt;./...&lt;/code&gt; 通配符匹配当前模块的所有包)&lt;/li&gt;
&lt;li&gt;Go1.11 的模块缓存在遇到网络问题或者同时允许多个 go 命令时会导致这个错误。在 Go1.12 已经接近。参考&lt;a href=&#34;#141-%e5%a6%82%e6%9e%9c%e5%8f%91%e7%8e%b0%e9%97%ae%e9%a2%98%e6%9c%89%e5%93%aa%e4%ba%9b%e9%80%9a%e7%94%a8%e7%9a%84%e4%b8%9c%e8%a5%bf%e5%8f%af%e4%bb%a5%e5%ae%9a%e4%bd%8d%e6%a3%80%e6%9f%a5&#34;&gt;上面的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;14-4-为什么-go-mod-init-报错-cannot-determine-module-path-for-source-directory&#34;&gt;14.4 为什么 go mod init 报错 cannot determine module path for source directory&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go mod init&lt;/code&gt; 不带参数是会基于不同的暗示(VCS 元数据等)尝试猜测合适的模块路。但是，命令不能总是猜测的预期的合适路径&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;go mod init&lt;/code&gt; 报这类错，必须自己提供模块路径(&lt;code&gt;go mod init module_path&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-5-有一个复杂的且没有加入模块的依赖出现问题-能否使用它目前的依赖管理器的信息&#34;&gt;14.5 有一个复杂的且没有加入模块的依赖出现问题。能否使用它目前的依赖管理器的信息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以。这需要一些手动步骤，但是在一些复杂场景是有用的&lt;/li&gt;
&lt;li&gt;当运行 &lt;code&gt;go mod init&lt;/code&gt; 初始化模块时，命令会从先前的依赖管理器通过翻译配置文件(如 &lt;code&gt;Gopkg.lock/glide.lock/vendor.json&lt;/code&gt;)自动转换到 &lt;code&gt;go.mod&lt;/code&gt; 文件，该文件包含了对应的 &lt;code&gt;require&lt;/code&gt; 指令。先前的一些文件信息通畅描述了所有直接或间接依赖的版本信息&lt;/li&gt;
&lt;li&gt;然而，当添加一个还没有加入模块的新依赖，新依赖不会有上述类似的自动转换过程。如果该新依赖本身有一些非模块依赖，且这些依赖有破坏性的变化，那么在某些场景下，会导致不兼容问题。换句话说，不会自动使用先前对于新依赖的依赖管理器，而这会在某些场景导致非间接依赖的问题&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个方法是在有问题的非模块直接依赖运行 &lt;code&gt;go mod init&lt;/code&gt; 转化当前依赖管理器，然后使用生成的临时 &lt;code&gt;go.mod&lt;/code&gt; 的 &lt;code&gt;require&lt;/code&gt; 指令定位或更新你的模块的 &lt;code&gt;go.mod&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;临时 &lt;code&gt;go.mod&lt;/code&gt; 生成的 &lt;code&gt;require&lt;/code&gt; 信息可手动移动到你的模块实际的 &lt;code&gt;go.mod&lt;/code&gt;，或考虑使用 &lt;a href=&#34;https://github.com/rogpeppe/gomodmerge&#34; target=&#34;_blank&#34;&gt;gomodmerge&lt;/a&gt; 工具。除此之外，可能会增加 &lt;code&gt;require github.com/some/nonmodule v1.2.3&lt;/code&gt; 到你的模块实际的 &lt;code&gt;go.mod&lt;/code&gt; 以匹配手动克隆的版本&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git clone -b v1.2.3 https://github.com/some/nonmodule /tmp/scratchpad/nonmodule
cd /tmp/scratchpad/nonmodule
go mod init
cat go.mod
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-6-如何解决由于导入路径和声明模块身份不匹配导致的-parsing-go-mod-unexpected-module-path-和-error-loading-module-requirements-错误&#34;&gt;14.6 如何解决由于导入路径和声明模块身份不匹配导致的 parsing go.mod: unexpected module path 和 error loading module requirements 错误&lt;/h3&gt;

&lt;h4 id=&#34;14-6-1-出现问题的原因&#34;&gt;14.6.1 出现问题的原因&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;一般的，一个模块在 &lt;code&gt;go.mod&lt;/code&gt; 中通过 &lt;code&gt;module&lt;/code&gt; 指令声明它的身份。这个该模块的“模块路径”，并且 go 工具强制声明的模块路径和使用者的导入路径的一致性。如果一个模块的 &lt;code&gt;go.mod&lt;/code&gt; 文件读到 &lt;code&gt;module example.com/m&lt;/code&gt;，那么使用者必须使用导入语句从该模块导入包，且必须以模块路径开头(如 &lt;code&gt;import &amp;quot;example.com/m&amp;quot;&lt;/code&gt; 或&lt;code&gt;import &amp;quot;example.com/m/sub/pkg&amp;quot;&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;如果使用者的导入路径和对应的声明模块路径出现不匹配，go 命令会报错 &lt;code&gt;parsing go.mod: unexpected module path&lt;/code&gt;。此外，在某些场景下，go 命令会之后再报一个更一般的错误 &lt;code&gt;error loading module requirements&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;这个错误最常见的原因是如果有一个名字变化(如 &lt;code&gt;github.com/Sirupsen/logrus&lt;/code&gt; 到 &lt;code&gt;github.com/sirupsen/logrus&lt;/code&gt;)，或者如果一个模块有时通过两个不同于先前模块的名字(如 &lt;code&gt;github.com/golang/sync&lt;/code&gt; 和建议的 &lt;code&gt;golang.org/x/sync&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;如果有一个仍然使用旧的名字或不规范的名字导入的依赖，而该依赖之后采用模块并在 &lt;code&gt;go.mod&lt;/code&gt; 声明规范的名字，就会出现问题。这个错误可以在一次升级时触发，当此模块的升级版本声明了一个规范的模块路径，但是该路径不匹配旧的导入路径&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;14-6-2-场景示例&#34;&gt;14.6.2 场景示例&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;当前有一个间接依赖 &lt;code&gt;github.com/Quasilyte/go-consistent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此工程采用模块，然后将名字改成 &lt;code&gt;github.com/quasilyte/go-consistent&lt;/code&gt;，这是一个破坏性的变化。GitHub 从旧名字导向新的名字&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt;go get -u&lt;/code&gt;，尝试升级所有的直接或间接依赖&lt;/li&gt;
&lt;li&gt;&lt;code&gt;github.com/Quasilyte/go-consistent&lt;/code&gt; 尝试升级，但是最新的 &lt;code&gt;go.mod&lt;/code&gt; 发现现在读到的是 &lt;code&gt;module github.com/quasilyte/go-consistent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;整个升级操作会失败，错误是：
&amp;gt; go: github.com/Quasilyte/go-consistent@v0.0.0-20190521200055-c6f3937de18c: parsing go.mod: unexpected module path &amp;ldquo;github.com/quasilyte/go-consistent&amp;rdquo; go get: error loading module requirements&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;14-6-3-解决方法&#34;&gt;14.6.3 解决方法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;整个错误最常见的形式是
&amp;gt; go: example.com/some/OLD/name@vX.Y.Z: parsing go.mod: unexpected module path &amp;ldquo;example.com/some/NEW/name&amp;rdquo;&lt;/li&gt;
&lt;li&gt;如果浏览 &lt;code&gt;example.com/some/NEW/name&lt;/code&gt; 仓库，可以检查最新发布版或 &lt;code&gt;master&lt;/code&gt; 查看 &lt;code&gt;go.mod&lt;/code&gt; 文件，是否在第一行声明 &lt;code&gt;module example.com/some/NEW/name&lt;/code&gt;。如果是，示意看到的 &lt;code&gt;old module name&lt;/code&gt; 和 &lt;code&gt;new module name&lt;/code&gt; 问题&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决步骤&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 检查自己的代码是否使用 &lt;code&gt;example.com/some/OLD/name&lt;/code&gt;。如果是，更新代码使用 &lt;code&gt;module example.com/some/NEW/name&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2 如果再升级时遇到这个错误，应该尝试 Go 的 tip 版本。此版本有更多针对性的的升级逻辑，通常可以绕过这个问题，且经常对于这种情况有更好的错误信息。&lt;strong&gt;注意：&lt;/strong&gt;tip/1.13 和 1.12 的 &lt;code&gt;go get&lt;/code&gt; 参数不同。比如获取 tip 并使用 tip 更新依赖的命令如下。因为这个有问题的旧的导入经常是在间接依赖，使用 tip 升级然后运行 &lt;code&gt;go mod tidy&lt;/code&gt; 经常会升级过去有问题的版本，并且从 &lt;code&gt;go.mod&lt;/code&gt; 移除有问题的版本，然后可以使用 Go1.&lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1&lt;/sub&gt;.11 进入正常状态&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get golang.org/dl/gotip &amp;amp;&amp;amp; gotip download
gotip get -u all
gotip mod tidy
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3 如果在执行 &lt;code&gt;go get -u foo&lt;/code&gt;/&lt;code&gt;go get -u foo@latest&lt;/code&gt; 时遇到这个错误，尝试移除 &lt;code&gt;-u&lt;/code&gt;。&lt;code&gt;go get -u foo&lt;/code&gt; 不仅仅只更新 &lt;code&gt;foo&lt;/code&gt; 到最新版本，也会更新 &lt;code&gt;foo&lt;/code&gt; 的所有直接或间接依赖到最新版本。但是 &lt;code&gt;foo&lt;/code&gt; 的一些直接或间接依赖可能没有使用 semver 或模块&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4 如果上述步骤没有解决问题，下一个方法可能会比较复杂，但是大多数情况可以解决这类问题。这个方法只是有错误信息，以及简单浏览 VCS 历史&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4.1 进入 &lt;code&gt;example.com/some/NEW/name&lt;/code&gt; 仓库&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4.2 确定何时引入 &lt;code&gt;go.mod&lt;/code&gt; 文件(比如使用 &lt;a href=&#34;https://www.git-scm.com/docs/git-blame&#34; target=&#34;_blank&#34;&gt;git blame&lt;/a&gt; 或 &lt;a href=&#34;https://www.git-scm.com/docs/git-log&#34; target=&#34;_blank&#34;&gt;git log&lt;/a&gt; 命令查看 &lt;code&gt;go.mod&lt;/code&gt; 的修改历史)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4.3 选中 &lt;code&gt;go.mod&lt;/code&gt; 被引入的前一次提交或发布&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4.4 在你的 &lt;code&gt;go.mod&lt;/code&gt; 增加一个 &lt;code&gt;replace&lt;/code&gt; 语句，&lt;code&gt;reolace&lt;/code&gt; 两边都使用旧名字：&lt;code&gt;replace example.com/some/OLD/name =&amp;gt; example.com/some/OLD/name &amp;lt;version-just-before-go.mod&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在前述的场景示例中，旧名字是 &lt;code&gt;github.com/Quasilyte/go-consistent&lt;/code&gt;，新名字是 &lt;code&gt;github.com/quasilyte/go-consistent&lt;/code&gt;，可以看到 &lt;code&gt;go.mod&lt;/code&gt; 在 &lt;a href=&#34;https://github.com/quasilyte/go-consistent/tree/00c5b0cf371a96059852487731370694d75ffacf&#34; target=&#34;_blank&#34;&gt;00c5b0cf371a&lt;/a&gt; 被引入&lt;/li&gt;
&lt;li&gt;该仓库没有使用 semver 标签，因此我们必须选取前一次提交 &lt;a href=&#34;https://github.com/quasilyte/go-consistent/tree/00dd7fb039e1eff09e7c0bfac209934254409360&#34; target=&#34;_blank&#34;&gt;00dd7fb039e&lt;/a&gt;，并且使用旧的大写 Quasilyte 到 &lt;code&gt;replace&lt;/code&gt; 两侧：&lt;code&gt;replace github.com/Quasilyte/go-consistent =&amp;gt; github.com/Quasilyte/go-consistent 00dd7fb039e&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这个 &lt;code&gt;replace&lt;/code&gt; 语句使我们可以通过有效地阻止旧名字升级到 &lt;code&gt;go.mod&lt;/code&gt; 出现的新名字而越过新旧名字不匹配的问题实现升级。通常，现在通过 &lt;code&gt;go get -u&lt;/code&gt; 或类似命令升级可以避免这样的错误。如果完成升级，可以检查是否仍有代码使用旧名字导入(如 &lt;code&gt;go mod graph | grep github.com/Quasilyte/go-consistent&lt;/code&gt;)，如果没有，可以移除 &lt;code&gt;repalce&lt;/code&gt; 指令。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;这样经常生效的原因是如果使用有问题的旧导入路径，升级本身会失败。即使升级完成最后也不会使用这个路径&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;5 如果上述路径没有解决问题，可能因为某些当前依赖的最新版本中仍在使用有问题的旧导入路径。这种情况下，需要识别出谁仍在使用旧的路径，并且找出或者打开一个 issue 请求这个有问题的导入者修改代码使用规范路径。使用前述的 &lt;code&gt;gotip&lt;/code&gt; 可能识别出有问题的导入者，但是并不是所有场景有用，尤其是升级的情况。如果不确定谁在使用旧路径导入，通常可以通过创建一个干净的模块缓存找出来，执行出问题的操作，然后在模块缓存中 grep 有问题的导入路径。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GOPATH=$(mktemp -d)
go get -u foo               # peform operation that generates the error of interest
cd $GOPATH/pkg/mod
grep -R --include=&amp;quot;*.go&amp;quot; github.com/Quasilyte/go-consistent
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;6 如果这些步骤不足以解决问题，或者你是一个项目的维护者，且似乎因为循环引用不能移除旧路径的引用，可以&lt;a href=&#34;https://github.com/golang/go/wiki/Resolving-Problems-From-Modified-Module-Path&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后，上述步骤致力于如果解决一个底层的新旧名字问题。然而，如果 &lt;code&gt;go.mod&lt;/code&gt; 被放置在错误的位置或简单的是因为错误的模块路径，这会出现相同的问题。在这种情况下，导入该模块总会失败。如果你正在导入你刚刚新建的模块，且之前从未成功导入过，你应当检查 &lt;code&gt;go.mod&lt;/code&gt; 被正确放置且有对应的合适的模块路径。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;最常见的方法是一个仓库一个 &lt;code&gt;go.mod&lt;/code&gt;，且是在仓库根目录放置单一的 &lt;code&gt;go.mod&lt;/code&gt; 文件。并且使用仓库名字作为文件中声明的 &lt;code&gt;module&lt;/code&gt; 指令的模块路径&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-7-为什么-go-build-要求-gcc-为什么预编译包-如-net-http-不用&#34;&gt;14.7 为什么 go build 要求 gcc？为什么预编译包(如 net/http) 不用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;因为预编译包是非模块的(对 GOPATH 有效)，因此不能被重复使用。即在模块模式时需要重新编译标准库的包&lt;/li&gt;
&lt;li&gt;这个问题只在加入模块时出现，对于 Go1.11 可以禁用 &lt;code&gt;cgo&lt;/code&gt;(如 &lt;code&gt;GO111MODULE=on CGO_ENABLED=0 go build&lt;/code&gt;) 或者安装 gcc&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-8-模块能否在相对导入路径-如-import-subdir-正常工作&#34;&gt;14.8 模块能否在相对导入路径(如 import &amp;ldquo;./subdir&amp;rdquo;)正常工作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不能。在模块中，子目录最终会有一个名字。如果当前目录是 &lt;code&gt;module m&lt;/code&gt;，那么导入的子目录就是 &lt;code&gt;m/subdir&lt;/code&gt;，不再是 &lt;code&gt;./subdir&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-9-某些需要的文件可能不在定位的-vendor-目录&#34;&gt;14.9 某些需要的文件可能不在定位的 vendor 目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go mod vendor&lt;/code&gt; 不会拷贝没有 &lt;code&gt;.go&lt;/code&gt; 文件的目录到 &lt;code&gt;vendor&lt;/code&gt;。设计如此&lt;/li&gt;
&lt;li&gt;对于传统的 vendor：检查模块缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;15-相关链接&#34;&gt;15 相关链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/Modules&#34; target=&#34;_blank&#34;&gt;Go module wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tip.golang.org/cmd/go/#hdr-Modules_and_vendoring&#34; target=&#34;_blank&#34;&gt;Modules and vendoring&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/thepudds/go-module-knobs/blob/master/README.md&#34; target=&#34;_blank&#34;&gt;List of go module knobs for controlling CI, vendoring, and when go commands access the network&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/go1.13#modules&#34; target=&#34;_blank&#34;&gt;module 工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 程</title>
      <link>https://xueqing.github.io/blog/go/basic/go_goroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_goroutine/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#goroutine&#34;&gt;goroutine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa-goroutine&#34;&gt;创建一个 goroutine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#goroutine-%e4%bc%98%e4%ba%8e%e7%ba%bf%e7%a8%8b&#34;&gt;goroutine 优于线程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;goroutine&#34;&gt;goroutine&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;goroutine 是和其他函数或方法并发运行的函数或方法&lt;/li&gt;
&lt;li&gt;goroutine 可认为是轻量级的线程，比线程创建代价小&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建一个-goroutine&#34;&gt;创建一个 goroutine&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;go&lt;/code&gt; 可以开始一个 goroutine：&lt;code&gt;go f(x, y, z)&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 的求值发生在当前的 goroutine&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; 的执行发生在新的 goroutine- 启动一个 goroutine 时，&lt;code&gt;go&lt;/code&gt; 立即返回，继续执行下一行代码，新启动的 goroutine 的返回值都会被忽略&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;main goroutine 应当启动其他 goroutine。因为 main goroutine 终止时，程序就会终止，不会再有 goroutine 运行&lt;/li&gt;

&lt;li&gt;&lt;p&gt;goroutine 在相同的地址空间运行，因此在访问共享的内存时必须同步&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;
)

func say(s string) {
for i := 0; i &amp;lt; 5; i++ {
    time.Sleep(5000 * time.Millisecond)
    fmt.Println(s)
}
}

func main() {
go say(&amp;quot;world&amp;quot;)
say(&amp;quot;hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;goroutine-优于线程&#34;&gt;goroutine 优于线程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;goroutine 更加轻量。只有几个 Kb 大小的栈，且可根据需求增长。但是线程的栈大小是固定的？？&lt;/li&gt;
&lt;li&gt;goroutine 被复用到更少数量的线程。一个线程可能有很多 goroutine，当该线程的一个 goroutine 阻塞时，另外一个 OS 线程被创建，并将剩余的 goroutine 移到新的 OS 线程&lt;/li&gt;
&lt;li&gt;goroutine 使用 channel 通信。channel 可以防止 goroutine 访问共享内存时竞争。channel 可认为是一个管道&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 类型转换</title>
      <link>https://xueqing.github.io/blog/go/basic/go_type_casting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_type_casting/</guid>
      <description>

&lt;h2 id=&#34;类型声明&#34;&gt;类型声明&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 声明定义一个新的命名类型，它和某个已有类型使用同样的底层类型。命名；类型提供了一种方式来区分底层类型的不同或不兼容使用，这样就不会在无意中混用他们。&lt;/p&gt;

&lt;p&gt;比如，把不同计量单位的温度值转换为不同的类型。即使使用的底层类型相同，二者是不是相同的类型，不能使用算术表达式进行比较和合并。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type celsius float64
type fahrenheit float64

const (
  absoluteZeroC celsius = -273.15
  freezingC     celsius = 0
  boilingC      celsius = 100
)

func main() {
  fmt.Printf(&amp;quot;cToF(%2f) = (%2f)\n&amp;quot;, absoluteZeroC, cToF(absoluteZeroC))
  // error:cannot use boilingC (type celsius) as type fahrenheit in argument to fToC
  fmt.Printf(&amp;quot;fToC(%2f) = (%2f)\n&amp;quot;, boilingC, fToC(boilingC))
  fmt.Printf(&amp;quot;fToC(%2f) = (%2f)\n&amp;quot;, boilingC, fToC(fahrenheit(boilingC)))
}

func cToF(c celsius) fahrenheit { return fahrenheit(c*9/5 + 32) }
func fToC(f fahrenheit) celsius { return celsius((f - 32) * 5 / 9) }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;类型转换&#34;&gt;类型转换&lt;/h2&gt;

&lt;p&gt;对于每个类型 T，都有一个对应的类型转换操作 T(x) 将值转化为类型 T。如果两个类型具有相同的底层类型或二者都是指向相同底层类型变量的未命名指针类型，则二者可以相互转化。类型转化不改变；类型值的表达方式，仅改变类型。如果 x 对于类型 T 是可赋值的，类型转化也是允许的，但是通常是不必要的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;类型转换用于将一种数据类型的变量转换为另一种类型的变量，go 不支持隐式类型转换&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

func main() {
var x, y int = 3, 4
var f float64 = math.Sqrt(float64(x*x + y*y))
var z uint = f //error: cannot use f (type float64) as type uint in assignment
fmt.Println(x, y, z)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;格式&lt;code&gt;type_name(expression)&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;type_name 是类型&lt;/li&gt;
&lt;li&gt;expression 是表达式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 结构</title>
      <link>https://xueqing.github.io/blog/go/basic/go_structure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_structure/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package pkg_name&lt;/code&gt;定义包名，即程序属于哪个包，每个 go 文件第一行

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package main&lt;/code&gt;表示一个可独立执行的程序&lt;/li&gt;
&lt;li&gt;每个 go 的应用程序必须包含一个 main 包&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import pkg_name&lt;/code&gt;表示程序需要使用的包，如 fmt 实现了格式化输入输出函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;func func_name(){}&lt;/code&gt;定义了程序的函数

&lt;ul&gt;
&lt;li&gt;main 函数是每一个可执行程序必须包含的，一般来说都是在启动后第一个执行的函数&lt;/li&gt;
&lt;li&gt;有 init 函数的时候先执行 init 函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/*...*/&lt;/code&gt;和&lt;code&gt;//&lt;/code&gt;是注释&lt;/li&gt;
&lt;li&gt;标识符（常量、变量、类型、函数名、结构字段等）

&lt;ul&gt;
&lt;li&gt;以大写字母开头，则该对象可以被外部包的代码使用，即导出（类比面向对象的 public）&lt;/li&gt;
&lt;li&gt;以小写字母开头，则对外包不可见，只在包内部可见可用（类比面向对象的 protected）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;执行程序

&lt;ul&gt;
&lt;li&gt;程序以&lt;code&gt;.go&lt;/code&gt;结尾&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;go run filename.go&lt;/code&gt;可运行代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编译程序

&lt;ul&gt;
&lt;li&gt;执行&lt;code&gt;go install filename&lt;/code&gt;，会寻找&lt;code&gt;filename&lt;/code&gt;文件夹下的包含 main 函数的文件，编译生成二进制文件&lt;code&gt;filename&lt;/code&gt;放在对应的&lt;code&gt;bin&lt;/code&gt;目录下&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Note：go 语言不支持&lt;code&gt;{&lt;/code&gt;放单独一行，和 C 和 C++ 不一样&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 结构体</title>
      <link>https://xueqing.github.io/blog/go/basic/go_struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_struct/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%9a%e4%b9%89%e7%bb%93%e6%9e%84%e4%bd%93&#34;&gt;定义结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%ae%bf%e9%97%ae%e7%bb%93%e6%9e%84%e4%bd%93%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f&#34;&gt;访问结构体成员变量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;定义结构体&#34;&gt;定义结构体&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;struct&lt;/code&gt; 是域的集合&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义结构体需要使用 type 和 struct 关键字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type vertex struct {
  X int
  Y int
}

func main() {
  fmt.Println(vertex{1, 2})
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;声明结构体变量：结构体字面量代表使用列举的域给新分配的结构体赋值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;var_name := struct_name {var1, var2...,varn}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var_name := struct_name {key1 : var1, key2 : val2..., keyn : varn}&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;key:&lt;/code&gt; 可以仅列出部分字段，与字段名顺序无关&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type vertex struct {
X, Y int
}

var (
v1 = vertex{1, 2}
v2 = vertex{X : 1}
v3 = vertex{}
p = &amp;amp;vertex{2, 3}
)

func main() {
fmt.Println(v1, v2, v3, p) //{1 2} {1 0} {0 0} &amp;amp;{2 3}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;访问结构体成员变量&#34;&gt;访问结构体成员变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;访问结构体成员变量用 &lt;code&gt;.&lt;/code&gt; 操作符&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和 C++ 不一样，结构体指针访问结构体成员变量也用 &lt;code&gt;.&lt;/code&gt; 操作符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

type vertex struct {
  X int
  Y int
}

func main() {
  v := vertex{1, 2}
  fmt.Println(v)
  p := &amp;amp;v
  p.X = 1e9
  fmt.Println(v)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结构体作为函数参数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 范围</title>
      <link>https://xueqing.github.io/blog/go/basic/go_range/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_range/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;range 关键字用于 for 循环中迭代数组 array、切片 slice、通道 channel 或 集合 map 的元素&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在数组和切片中返回元素的索引和索引对应的值的拷贝，在集合中返回 key-value 对的 key 值&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
)

func main() {
  var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}
  for i, v := range pow {
      fmt.Printf(&amp;quot;2**%d = %d\n&amp;quot;, i, v)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以赋值给 &lt;code&gt;_&lt;/code&gt; 跳过索引或值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for i, _ := range pow&lt;/code&gt;。如果只想要索引，可以忽视第二个参数 &lt;code&gt;for i := range pow&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;for _, val := range pow&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
)

func main() {
pow := make([]int, 10)

for i := range pow {
  pow[i] = 1 &amp;lt;&amp;lt; uint(i) //2**i
}

for _, val := range pow {
  fmt.Printf(&amp;quot;%d\n&amp;quot;, val)
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 运算符</title>
      <link>https://xueqing.github.io/blog/go/basic/go_operator/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_operator/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;算术运算符: +, -, *, /, %, ++, &amp;ndash;&lt;/li&gt;
&lt;li&gt;关系运算符: ==, !=, &amp;gt;, &amp;lt;, &amp;gt;=, &amp;lt;=&lt;/li&gt;
&lt;li&gt;逻辑运算符: &amp;amp;&amp;amp;, ||, !&lt;/li&gt;
&lt;li&gt;位运算符: &amp;amp;, |, ^(异或), &amp;lt;&amp;lt;, &amp;gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;赋值运算符: =, +=, -=, *=, /=, %=, &amp;lt;&amp;lt;=, &amp;gt;&amp;gt;=, &amp;amp;=, |=, ^=&lt;/li&gt;
&lt;li&gt;其他运算符: &amp;amp;(返回变量存储地址), *(指针变量)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 递归函数</title>
      <link>https://xueqing.github.io/blog/go/basic/go_recursive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_recursive/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func myRecursion() {
  //myRecursion()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go 错误处理</title>
      <link>https://xueqing.github.io/blog/go/basic/go_error_handling/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_error_handling/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;go 使用 &lt;code&gt;error&lt;/code&gt; 值表示错误状态，通过内置的错误接口提供了非常简单的错误处理机制&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;error&lt;/code&gt; 是一个接口类型，定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type error interface {
  Error() string
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可在编码中通过实现 &lt;code&gt;error&lt;/code&gt; 接口类型生成错误信息&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数通常在最后一个返回值返回错误信息，使用 &lt;code&gt;errors.New&lt;/code&gt; 可返回一个错误信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;errors.new&lt;/code&gt; 接收一个字符串作为参数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果有错误信息，则得到一个非 nil 的 &lt;code&gt;error&lt;/code&gt; 对象，通常将返回值与 nil 比较&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;i, err := strconv.Atoi(&amp;quot;42&amp;quot;)
if err != nil {
fmt.Printf(&amp;quot;couldn&#39;t convert number: %v\n&amp;quot;, err)
return
}
fmt.Println(&amp;quot;Converted integer:&amp;quot;, i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打印 &lt;code&gt;error&lt;/code&gt; 的时候，调用的是内部的&lt;code&gt;Error() string&lt;/code&gt;方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;fmt.Errorf&lt;/code&gt; 函数可以给 &lt;code&gt;error&lt;/code&gt; 增加更多信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;fmt.Errorf&lt;/code&gt; 接收参数和格式化字符串&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;math&amp;quot;
)

type errNegativeSqrt float64

func (e errNegativeSqrt) Error() string {
return fmt.Sprint(&amp;quot;cannot Sqrt negative number: &amp;quot;, float64(e))
}

func mySqrt(x float64) (float64, error) {
if x &amp;lt; 0 {
return -1, errNegativeSqrt(x)
}
z := x / 2
tmp := 0.0
for math.Abs(z-tmp) &amp;gt;= 0.000000000001 {
tmp = z
z -= (z*z - x) / (2 * z)
}
return z, nil
}

func main() {
fmt.Println(mySqrt(2))
fmt.Println(mySqrt(-2))
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GOPATH 和模块</title>
      <link>https://xueqing.github.io/translation/go-doc/command/gopath_and_module/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/gopath_and_module/</guid>
      <description>&lt;p&gt;当使用模块时，不再使用 GOPATH 来解决导入。但是，它仍被用于存储下载的源码(在 GOPATH/pkg/mod)和编译好的命令(在 GOPATH/bin)。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GOPATH 环境变量</title>
      <link>https://xueqing.github.io/translation/go-doc/command/gopath_env_var/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/gopath_env_var/</guid>
      <description>&lt;p&gt;Go 路径用于解决导入语句，它通过 go/build 包实现，并记录在 go/build 包。&lt;/p&gt;

&lt;p&gt;GOPATH 环境变量列举了寻找 Go 代码的位置。在 Unix 上，其值是一个冒号分隔的字符串。在 Windows 上，其值是一个分号分隔的字符串。在 Plan 9 上，其值是一个列表。&lt;/p&gt;

&lt;p&gt;如果环境变量未被设置，GOPATH 默认是用户主目录下的一个 “go” 子目录(Unix 下是 &lt;code&gt;$HOME/go&lt;/code&gt;，Windows 下是 &lt;code&gt;%USERPROFILE%\go&lt;/code&gt;)，除非那个目录存在一个 Go 发行版本。运行 &lt;code&gt;go env GOPATH&lt;/code&gt; 查看当前的 GOPATH。&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;../wiki/set_gopath.md&#34;&gt;SettingGOPATH&lt;/a&gt; 设置一个自定义的 GOPATH。&lt;/p&gt;

&lt;p&gt;GOPATH 下的每个目录必须有一个规定的结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;src 目录持有源码。src 下的目录确定了导入路径或可执行文件名字。&lt;/li&gt;
&lt;li&gt;pkg 目录持有安装的包对象。在 Go 树中，每个目标操作系统和架构对有其自己的包的子目录(pkg/GOOS_ARCH).&lt;/li&gt;
&lt;li&gt;如果 DIR 是GOPATH 下的一个目录，包的源码在 DIR/src/foo/bar，那么包可以导出为 “foo/bar”，且将其编译文件安装到 “DIR/pkg/GOOS_GOARCH/foo/bar.a”。&lt;/li&gt;
&lt;li&gt;bin 目录持有编译的命令。每个命令命名为它的源码目录，但是只有最后一个元素，而不是整个路径。也就是说，一个命令的源码在 DIR/src/foo/quux，那么它被安装到 DIR/bin/quux。这个 “foo/” 前缀被除去以便你可以增加 DIR/bin 到你的 PATH 来获取安装的命令。如果设置了 GOBIN 环境变量，命令被安装到 GOBIN 命名的目录而不是 DIR/bin。GOBIN 必须是一个绝对路径。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里是一个目录格式示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;GOPATH=/home/user/go

/home/user/go/
    src/
        foo/
            bar/               (包 bar 中的 go 代码)
                x.go
            quux/              (包 main 中的 go 代码)
                y.go
    bin/
        quux                   (安装的命令)
    pkg/
        linux_amd64/
            foo/
                bar.a          (安装的包对象)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 搜索 GOPATH 列举的每个目录来查找源码，但是新包总是下载到列表中的第一个目录。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&#34;../golangdoc/code.md&#34;&gt;如何编写 Go 代码&lt;/a&gt;的例子。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>hash map</title>
      <link>https://xueqing.github.io/blog/cplusplus/hash_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/hash_map/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class hash_map {
  hash_map() {set_load(); v.reserve(max_load*b.size());}
  // 表“太满”(如 75% 满)时性能会恶化
  void set_load(float m=0.7, float g=1.6) {max_load=m; grow=g;}

  // 查找
  mapped_type&amp;amp; operator[] (const key_type&amp;amp; k) {
    // 先计算散列值，查找表索引
    size_type i = hash(k) % b.size();
    // 找到之后遍历散列链匹配
    for(Entry* p=b[i]; p; p=p-&amp;gt;next) {
      if(eq(k, p-&amp;gt;key)) { // 找到则插入表
        if(p-&amp;gt;erased) {
          p-&amp;gt;erased = false;
          no_of_erased--;
          return p-&amp;gt;val = default_value;
        }
        return p-&amp;gt;val;
      }
    }
    // 找不到则插入散列表
    // 若表已经“满”了，增大存储
    if(size_tye(b.size() * max_load) &amp;lt;= v.size()) {
      resize(b.size() * grow);
      return operator[](k);
    }
    // 插入元素
    v.push_back(Entry(k, default_value, b[i]));
    b[i] = &amp;amp;v.back();
    return b[i]-&amp;gt;val;
  }

  // 调整散列表大小
  void resize(size_type s) {
    // 计算 erased 元素数目，同时从存储中删除对应元素
    size_type i = v.size()
    while(no_of_erased) {
      if(v[--i].erased) {
        v.erase(&amp;amp;v[i]);
        --no_of_erased;
      }
    }
    // 如果 b.size() &amp;gt;= s，返回
    if(s &amp;lt;= b.size()) return;
    // 如果 b.size() &amp;lt; s，增大 b，b 全部清 0，重新计算
    b.resize(s);
    fill(b.begin(), b.end(), 0);
    // 重新分配底层存储
    v.reserve(s * max_load);
    // 重新计算元素散列值
    for(size_type i=0; i&amp;lt;v.size(); i++) {
      size_type ii = hash(v[i].key) % b.size();
      v[i].next = b[ii];
      b[ii] = &amp;amp;v[i];
    }
  }

private:
  struct Entry {
    key_type key;
    mapped_type val;
    bool erased;
    Entry* next;          // 散列链
  };
  vector&amp;lt;Entry&amp;gt; v;        // 实际存储
  vector&amp;lt;Entry*&amp;gt; b;       // 散列表，保存实际存储的指针

  float max_load;         // 保持 v.size() &amp;lt;= b.size()*max_load
  float grow;             // 接近太满时自动改变大小 resize(bucket_count() * grow)
  size_type no_of_erased; // erased 元素项的数目
  Hasher hash;            // 散列函数
  key_equal eq;           // 相等判断

  const T default_value;  // entry 默认值
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HLS 学习</title>
      <link>https://xueqing.github.io/blog/hls/hls/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/hls/hls/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hls-%e6%a6%82%e8%bf%b0&#34;&gt;HLS 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%80%e4%ba%9b%e6%a6%82%e5%bf%b5&#34;&gt;一些概念&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#media-playlist&#34;&gt;media playlist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#master-playlist&#34;&gt;master playlist&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hls-%e5%8d%8f%e8%ae%ae%e7%ae%80%e4%bb%8b&#34;&gt;HLS 协议简介&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%be%93%e5%85%a5%e8%a7%86%e9%a2%91%e6%88%96%e9%9f%b3%e9%a2%91&#34;&gt;输入视频或音频&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%bb%84%e4%bb%b6&#34;&gt;服务器组件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%87%e4%bb%b6%e5%88%87%e7%89%87%e5%99%a8&#34;&gt;文件切片器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%aa%92%e4%bd%93%e7%89%87%e6%ae%b5%e6%96%87%e4%bb%b6&#34;&gt;媒体片段文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95%e6%96%87%e4%bb%b6playlists&#34;&gt;索引文件(Playlists)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e7%bb%84%e4%bb%b6&#34;&gt;分布式组件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af%e8%bd%af%e4%bb%b6&#34;&gt;客户端软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bc%9a%e8%af%9d%e6%a8%a1%e5%bc%8f&#34;&gt;会话模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e5%ae%b9%e5%8a%a0%e5%af%86&#34;&gt;内容加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%93%e5%ad%98%e5%92%8c%e5%8f%91%e9%80%81%e5%8d%8f%e8%ae%ae&#34;&gt;缓存和发送协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b5%81%e5%88%87%e6%8d%a2&#34;&gt;流切换&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ffmpeg-%e5%8a%a0%e5%af%86%e5%91%bd%e4%bb%a4%e8%a1%8c&#34;&gt;ffmpeg 加密命令行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ffmpeg-%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb&#34;&gt;ffmpeg 源码解读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;hls-概述&#34;&gt;HLS 概述&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HLS(HTTP Live Streaming)是 Apple 的动态码率自适应技术，主要用于 PC 端和移动端的音视频服务。包括一个 m3u(8) 的索引文件、TS 媒体分片文件和 key 加密串文件&lt;/li&gt;
&lt;li&gt;HLS 是基于 HTTP 的流媒体网络传输协议。工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8)playlist 文件，用于寻找可用的媒体流&lt;/li&gt;
&lt;li&gt;HLS 只请求基本的 HTTP 报文，与实时传输协议(RTP)不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;一些概念&#34;&gt;一些概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个多媒体演示通过一个 playlist 的 URL (uniform resource identifier， 统一资源标识符) 指定。&lt;/li&gt;
&lt;li&gt;一个 playlist 是一个 media playlist  或 master playlist。二者都是 UTF-8 的文本文件，包含 URI 和描述性标记。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;media-playlist&#34;&gt;media playlist&lt;/h3&gt;

&lt;p&gt;一个 media playlist 包含媒体片段的列表，当顺序播放时，会播放多媒体演示。&lt;/p&gt;

&lt;p&gt;想要播放这个 playlist，客户端首先下载 playlist 文件，然后下载和播放 playlist 文件内声明的媒体片段。客户端重新加载 playlist 以查找新增加的片段。数据&lt;strong&gt;应当&lt;/strong&gt;使用 HTTP 下载。但是，一个 URI 通常可以指定任何协议，能够可靠地传输需要的指定资源。&lt;/p&gt;

&lt;h3 id=&#34;master-playlist&#34;&gt;master playlist&lt;/h3&gt;

&lt;p&gt;一个 master playlist 提供 variant stream 的集合，每个描述了相同内容的不同版本。&lt;/p&gt;

&lt;p&gt;一个 variant stream 包含一个 media playlist，指定了以特定比特率、特定格式编码的媒体，包含视频的媒体包含特定的分辨率。&lt;/p&gt;

&lt;p&gt;一个 variant stream 也可以指定一个 rendition 的集合。rendition 是内容的可选版本，必须不同语言的音频或不同摄像角度录制的视频。&lt;/p&gt;

&lt;p&gt;客户端应该根据网络条件切换不同的 variant stream。客户端也应该根据用户偏好选择 rendition。&lt;/p&gt;

&lt;h2 id=&#34;hls-协议简介&#34;&gt;HLS 协议简介&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HLS 协议规定

&lt;ul&gt;
&lt;li&gt;视频的封装格式是 TS&lt;/li&gt;
&lt;li&gt;视频的编码格式为 H264，音频编码格式为 MP3、AAC 或者 AC-3&lt;/li&gt;
&lt;li&gt;除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件(文本文件)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;HLS 方案如图&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/hls/images/hls_arch.png&#34; alt=&#34;HLS解决方案&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;输入视频或音频&#34;&gt;输入视频或音频&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;输入的音视频格式不限，与服务器的通信协议不限(如 RTMP)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;服务器组件&#34;&gt;服务器组件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;媒体编码器：将输入的音视频编码成 HEVC 视频和 AC-3 音频，并且输出 MPEG-4(H.264 视频和 AAC 音频)文件碎片或 MPEG-2 传输流&lt;/li&gt;
&lt;li&gt;流切片器(stream segmenter)：通过本地网络从上面的媒体编码器中读取数据，将 MPEG-2 传输流切片，分割成一组相等时间间隔的小媒体文件，保存为一个或多个系列的媒体文件和索引文件(m3u8)，防止在网络服务器上

&lt;ul&gt;
&lt;li&gt;视频是 .ts 文件；纯音频会被编码为一些音频小片段，通常为 ADTS 头的 AAC、MP3、或者 AC-3 格式&lt;/li&gt;
&lt;li&gt;索引文件会包含这些切片文件的引用。每当一个切片文件生成后，索引文件都会进行更新。索引用于追踪切片文件的有效性和定位切片文件的位置&lt;/li&gt;
&lt;li&gt;切片器也可以同时对媒体片段进行加密并且创建一个密钥文件作为整个过程的一部分&lt;/li&gt;
&lt;li&gt;将索引文件的 URL 发布在网络服务器上。客户端软件读取索引，然后按序请求并展示列举的媒体文件，且媒体文件之间没有暂停或跳跃&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;文件切片器&#34;&gt;文件切片器&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;如果已经有编码后的文件(而不是编码流)，可以使用文件切片器，通过它对编码后的媒体文件进行 MPEG-2 流的封装并且将它们分割为等长度的小片段&lt;/li&gt;
&lt;li&gt;文件切片器允许使用已经存在的音视频库用于 HLS 服务。它和流切片器的功能相似，但是处理的源从流替换为文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;媒体片段文件&#34;&gt;媒体片段文件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;HLS 发送音频和视频为一系列的小文件，通常是 6 秒时长的文件，称为媒体片段文件&lt;/li&gt;
&lt;li&gt;媒体片段是由切片器生成的，基于编码后的媒体源，是由一系列的 .ts 格式的文件组成，包含了通过 MPEG-2 传送流携带的 H.264 视频 和 AAC /MP3/AC-3 音频&lt;/li&gt;
&lt;li&gt;对于纯音频的广播，切片器可以产生 MPEG 基础音频流，其中包含了 ADTS 头的 AAC、MP3、或者 AC3 等音频&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;索引文件-playlists&#34;&gt;索引文件(Playlists)&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;索引文件，或 playlist，提供媒体片段文件的 URL 的一个有序列表。HLS 的索引文件保存为 M3U8 playlist，是 MP3 playlist 使用的 M3U 的一个扩展&lt;/li&gt;
&lt;li&gt;通常由切片器附带生成，保存为 .m3u8 格式，.m3u 一般用于 MP3 音频的索引文件&lt;/li&gt;
&lt;li&gt;客户端访问索引文件的 URL，然后按序请求索引的文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果你的扩展名是 .m3u，并且系统支持 .mp3 文件，那客户的软件可能要与典型的 MP3 playList 保持一致来完成流网络音频的播放&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;分布式组件&#34;&gt;分布式组件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;分布式系统是一个网络服务或者一个网络缓存系统，通过 HTTP 向客户端发送媒体文件和索引文件&lt;/li&gt;
&lt;li&gt;不用自定义服务模块发送内容。通常仅仅需要很简单的网络配置即可使用。而且这种配置一般就是限制指定 .m3u8 文件和 .ts 文件的 MIME 类型&lt;/li&gt;
&lt;li&gt;实际部署 HLS，你需要为浏览器创建一个 HTML 页面或创建一个作为接收者的客户端应用。你也需要使用网络服务器以及一种方式，将实时流编码为 MPEG-4 媒体文件碎片(包含 HEVC 或 H264 视频，AAC或 AC-3 音频)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;客户端软件&#34;&gt;客户端软件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;客户端软件负责选择请求合适的媒体、下载媒体资源，并组装媒体资源以便可以向用户连续的流&lt;/li&gt;
&lt;li&gt;客户端开始会抓取索引文件(.m3u8/.m3u)，用 URL 来标记不同的流

&lt;ul&gt;
&lt;li&gt;索引文件可以指定可用媒体文件的位置、解密的密钥，以及任何可以切换的流&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于选中的流，客户端会有序的下载每一个可获得的文件。每一个文件包含流的一个连续碎片。一旦下载到足够量的数据，客户端会开始向用户展示重新组装好的媒体资源&lt;/li&gt;
&lt;li&gt;客户端负责抓取任何解密密钥、认证或者展示一个用于认证的用户界面，以及解密需要的文件&lt;/li&gt;
&lt;li&gt;这个过程会一直持续直到索引文件出现标记 #EXT-X-ENDLIST。如果结束标记不出现，该索引就是持续广播的一部分。客户端会定期的加载一些新的索引文件。客户端会从新更新的索引文件中去查找新的媒体文件和密钥文件并且将关联的 URL 加入到请求队列&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;会话模式&#34;&gt;会话模式&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;通常包含 Live broadcasts (直播)和 VOD (video on  demand, 点播)两种

&lt;ul&gt;
&lt;li&gt;点播 VOD 的特点就是当前时间点可以获取到所有 index 文件和 ts 文件，二级 index 文件中记录了所有 ts 文件的地址。这种模式允许客户端访问全部内容目录。除非客户端进行比特率切换，否则无需再下载任何 index 文件，只需顺序下载 ts 文件并播放&lt;/li&gt;
&lt;li&gt;Live 会话是实时生成 m3u8 和 ts 文件。它的索引文件一直处于动态变化，播放的时候需要不断下载二级 index 文件然后移除旧的索引文件，以获得最新生成的 ts 文件播放视频。如果一个二级 index 文件的末尾没有 #EXT-X-ENDLIST 标志，说明它是一个 Live 视频流&lt;/li&gt;
&lt;li&gt;这种类型通过向索引文件添加媒体地址可以很容易的转化为 VOD 类型。在转化时不要移除原来旧的源，而是通过添加一个 #ET-X-ENDLIST 标记来终止实时事件&lt;/li&gt;
&lt;li&gt;转化时如果索引文件中包含 EXT-X-PLAYLIST-TYPE 标签，需要将值从 EVENT 改为 VOD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;内容加密&#34;&gt;内容加密&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;如果内容需要加密，可以在索引文件中找到密钥的相关信息。如果索引文件中包含了一个密钥文件的信息，那接下来的媒体文件就必须使用密钥解密后才能解密打开&lt;/li&gt;
&lt;li&gt;当前的 HLS 支持使用 16-octet 类型密钥的 AES-128 加密。这个密钥格式是一个用二进制格式中的 16 个八进制组的数组打包而成&lt;/li&gt;
&lt;li&gt;加密的配置模式通常包含三种

&lt;ul&gt;
&lt;li&gt;模式一：允许在磁盘上制定一个密钥文件路径，切片器会在索引文件中插入存在的密钥文件的 URL。所有的媒体文件都使用该密钥进行加密&lt;/li&gt;
&lt;li&gt;模式二：切片器会生成一个随机密钥文件，将它保存在指定的路径，并在索引文件中引用它。所有的媒体文件都会使用这个随机密钥进行加密&lt;/li&gt;
&lt;li&gt;模式三：每 n 个片段生成一个随机密钥文件，并保存到指定的位置，在索引中引用它。这个模式的密钥处于轮流加密状态。每一组 n 个片段文件会使用不同的密钥加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;理论上，不定期的碎片个数生成密钥会更安全，但是定期的生成密钥不会对系统的性能产生太大的影响&lt;/li&gt;
&lt;li&gt;可以通过 HTTP 或者 HTTPS 提供密钥。也可以选择使用基于会话的认证安排去保护发送的 key&lt;/li&gt;
&lt;li&gt;密钥文件需要一个 initialization vector (IV) 去解码加密的媒体文件。IV 可以随着密钥定期的改变&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;缓存和发送协议&#34;&gt;缓存和发送协议&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;HTTPS 通常用于发送密钥，同时也可以用于平时的媒体片段和索引文件的传输&lt;/li&gt;
&lt;li&gt;当扩展性更重要时，这样做是不推荐的：HTTPS 请求通常都是绕开网络服务缓存，导致所有内容请求都是通过服务进行转发，这有悖于分布式网络连接系统的目的&lt;/li&gt;
&lt;li&gt;当处于实况广播模式时索引文件不会像分片媒体文件一样长时间的被缓存，而是动态不停地变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;流切换&#34;&gt;流切换&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;如果视频具备流切换功能，这对于用户来说是一个非常棒的体验，处于不同的带宽、不同的网速播放不同清晰度的视频流，这样智能的流切换可以保证用户感觉到非常流畅的观影体验，同时不同的设备也可以作为选择的条件，比如视网膜屏可以再网速良好的情况下播放清晰度更高的视频流&lt;/li&gt;
&lt;li&gt;这种功能的实现在于，索引文件的特殊结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/hls/images/hls_playlist.png&#34; alt=&#34;HLS索引文件&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;具备流热切换的索引通常由主索引和链接不同带宽速率的资源的子索引，由子索引再链接对应得到 .ts 视频切片文件&lt;/li&gt;
&lt;li&gt;客户端播放 HLS 视频流的逻辑：先下载一级 Index file，它里面记录了二级索引文件(Alternate-A、Alternate-B、Alternate-C)的地址，然后客户端再去下载二级索引文件，二级索引文件中又记录了 ts 文件的下载地址，这样客户端就可以按顺序下载 ts 视频文件并连续播放

&lt;ul&gt;
&lt;li&gt;主索引文件和子索引文件都是 .m3u8 的 playlist&lt;/li&gt;
&lt;li&gt;主索引文件只需下载一次，但对于直播节目子索引文件定期重新加载&lt;/li&gt;
&lt;li&gt;通常会先使用主索引中列出的第一个子索引，之后才会根据当时的网络情况去动态切换合适的流&lt;/li&gt;
&lt;li&gt;客户端可能会在任何时候改变到备用流，所有的切换都应该使用相同的音频文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ffmpeg-加密命令行&#34;&gt;ffmpeg 加密命令行&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ffmpeg -i input.mp4 -c copy -bsf:v h264_mp4toannexb -hls_time 10 -hls_key_info_file key_info playlist.m3u8&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hls_time seconds&lt;/code&gt;: 设置目标分片的长度，单位秒。默认值是 2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hls_key_info_file key_info_file&lt;/code&gt;: 使用 &lt;code&gt;key_info_file&lt;/code&gt; 信息用于加密&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;key_info_file&lt;/code&gt; 文件格式如下：一共三行&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;key URI&lt;/code&gt;: 指定写入播放列表的 &lt;code&gt;key URI&lt;/code&gt;。它在回放时用于访问加密密钥&lt;/li&gt;
&lt;li&gt;&lt;code&gt;key file path&lt;/code&gt;: 指定加密过程获得密钥的文件路径。该密钥文件以二进制格式读取，长度为 16 个八进制字符数组&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;IV&lt;/code&gt;: 可选行。指定初始向量(initialization vector, IV)作为十六进制的字符串使用，加密时默认使用分片序列号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;key URI
key file path
IV (optional)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;key_info_file&lt;/code&gt; 实例&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;http://server/file.key
/path/to/file.key
0123456789ABCDEF0123456789ABCDEF
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/sh
BASE_URL=${1:-&#39;.&#39;}
openssl rand 16 &amp;gt; file.key
echo $BASE_URL/file.key &amp;gt; file.keyinfo
echo file.key &amp;gt;&amp;gt; file.keyinfo
echo $(openssl rand -hex 16) &amp;gt;&amp;gt; file.keyinfo
ffmpeg -f lavfi -re -i testsrc -c:v h264 -hls_flags delete_segments -hls_key_info_file file.keyinfo out.m3u8
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ffmpeg-源码解读&#34;&gt;ffmpeg 源码解读&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;文件 &lt;code&gt;libavformat/hls.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Images</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/images/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/images/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Images
Remember the picture generator you wrote earlier? Let&#39;s write another one, but this time it will return an implementation of image.Image instead of a slice of data.

Define your own Image type, implement the necessary methods, and call pic.ShowImage.

Bounds should return a image.Rectangle, like image.Rect(0, 0, w, h).

ColorModel should return color.RGBAModel.

At should return a color; the value v in the last picture generator corresponds to color.RGBA{v, v, 255, 255} in this one.
*/

package main

import (
  &amp;quot;image&amp;quot;
  &amp;quot;image/color&amp;quot;
  &amp;quot;math&amp;quot;

  &amp;quot;golang.org/x/tour/pic&amp;quot;
)

/*
type Image interface {
  // ColorModel returns the Image&#39;s color model.
  ColorModel() color.Model
  // Bounds returns the domain for which At can return non-zero color.
  // The bounds do not necessarily contain the point (0, 0).
  Bounds() Rectangle
  // At returns the color of the pixel at (x, y).
  // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.
  // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.
  At(x, y int) color.Color
}
*/

type myImage struct{}

func (img myImage) ColorModel() color.Model {
  return color.NRGBAModel
}

func (img myImage) Bounds() image.Rectangle {
  return image.Rect(0, 0, 100, 100)
}

func (img myImage) At(x, y int) color.Color {
  val := float64(x ^ y)
  v := uint8(math.Abs(val))
  return color.RGBA{v, v, 255, 255}
}

func main() {
  m := myImage{}
  pic.ShowImage(m)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iotest 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/iotest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/iotest/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95&#34;&gt;索引&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/testing/iotest/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;testing/iotest&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;iotest 包实现了主要用于 testing 的 Reader 和 Writer。&lt;/p&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/iotest/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>json 解析时用到的结构体标签</title>
      <link>https://xueqing.github.io/blog/go/traps/json_struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/traps/json_struct/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%8f%aa%e6%9c%89%e5%af%bc%e5%87%ba%e7%9a%84%e7%bb%93%e6%9e%84%e4%bd%93%e6%88%90%e5%91%98%e5%af%b9%e5%a4%96%e9%83%a8%e7%a8%8b%e5%ba%8f-json-%e5%8f%af%e8%a7%81&#34;&gt;1 只有导出的结构体成员对外部程序 (json) 可见&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e7%bb%93%e6%9e%84%e4%bd%93%e5%bf%85%e9%a1%bb%e8%a7%a3%e6%9e%90%e7%9a%84%e5%ad%97%e6%ae%b5required-%e6%a0%87%e7%ad%be&#34;&gt;2 结构体必须解析的字段(required 标签)&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e7%bb%93%e6%9e%84%e4%bd%93%e6%a0%87%e7%ad%be&#34;&gt;2.1 结构体标签&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-json-%e8%a7%a3%e6%9e%90%e5%b5%8c%e5%a5%97%e5%9f%9f&#34;&gt;2.2 json 解析嵌套域&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-json-%e7%bc%96%e7%a0%81%e6%97%b6%e4%bc%9a%e5%af%b9%e6%8c%87%e9%92%88%e8%a7%a3%e5%bc%95%e7%94%a8%e4%bd%bf%e7%94%a8%e7%9a%84%e6%98%af%e5%ae%9e%e9%99%85%e5%80%bc&#34;&gt;2.3 json 编码时会对指针解引用，使用的是实际值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-encodingjsonunmarshal-%e5%ae%9e%e7%8e%b0-required-%e6%a0%87%e7%ad%be&#34;&gt;2.4 encoding/json.Unmarshal 实现 required 标签&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25-%e5%bd%93-json-%e5%92%8c-stream-%e7%9b%b8%e5%85%b3%e6%97%b6%e4%bd%bf%e7%94%a8-encoderdecoder&#34;&gt;2.5 当 json 和 stream 相关时，使用 Encoder/Decoder&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26-%e5%ae%9a%e4%b9%89%e6%88%90-jsonrawmessage-%e7%9a%84%e5%9f%9f%e5%8f%af%e4%bb%a5%e5%bb%b6%e8%bf%9f%e8%a7%a3%e6%9e%90&#34;&gt;2.6 定义成 json.RawMessage 的域可以延迟解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27-%e4%bd%bf%e7%94%a8-interface-%e5%92%8c-jsonrawmessage-%e8%a7%a3%e6%9e%90%e5%8a%a8%e6%80%81-json&#34;&gt;2.7 使用 interface 和 json.RawMessage 解析动态 json&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#271-%e5%ae%9e%e7%8e%b0-marshaljsonunmarshaljson-%e6%8e%a5%e5%8f%a3&#34;&gt;2.7.1 实现 MarshalJson/UnmarshalJSON 接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#272-%e5%b0%86-json-%e8%a7%a3%e6%9e%90%e6%88%90-interface&#34;&gt;2.7.2 将 json 解析成 interface&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#273-%e4%bd%bf%e7%94%a8%e6%8c%87%e9%92%88%e5%a2%9e%e5%8a%a0%e4%bb%a3%e7%a0%81%e6%a3%80%e6%9f%a5&#34;&gt;2.7.3 使用指针增加代码检查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-ginbindingbind&#34;&gt;3 gin/binding.Bind&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e7%9b%b8%e5%85%b3%e9%93%be%e6%8e%a5&#34;&gt;4 相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-只有导出的结构体成员对外部程序-json-可见&#34;&gt;1 只有导出的结构体成员对外部程序 (json) 可见&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下面的代码中无法解析 gender 域。且编码成 json 时，gender 域不会包含&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;encoding/json&amp;quot;
&amp;quot;fmt&amp;quot;
)

// JSONStruct a struct to be used in json decode
type myJSONStruct struct {
Name   string
Age    float64
gender string
}

var rawJSON = []byte(`{
  &amp;quot;name&amp;quot;: &amp;quot;kiki&amp;quot;,
  &amp;quot;age&amp;quot;: 18,
  &amp;quot;gender&amp;quot;: &amp;quot;female&amp;quot;
}`)

func main() {
var s myJSONStruct
err := json.Unmarshal(rawJSON, &amp;amp;s)
if err != nil {
  panic(err)
}

// [Name=kiki] [Age=18.000000] [gender=]
fmt.Printf(&amp;quot;[Name=%s] [Age=%f] [gender=%s]\n&amp;quot;, s.Name, s.Age, s.gender)

buf, err := json.Marshal(s)
if err != nil {
  panic(err)
}
// [buf={&amp;quot;Name&amp;quot;:&amp;quot;kiki&amp;quot;,&amp;quot;Age&amp;quot;:18}]
fmt.Printf(&amp;quot;[buf=%s]\n&amp;quot;, buf)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-结构体必须解析的字段-required-标签&#34;&gt;2 结构体必须解析的字段(required 标签)&lt;/h2&gt;

&lt;h3 id=&#34;2-1-结构体标签&#34;&gt;2.1 结构体标签&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解析 json 到结构体时，不适用结构体的字段会被抛弃&lt;/strong&gt;。json.Unmarshal 找到结构体对应值的流程。比如给定 json 的 key 是 &lt;code&gt;name&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;1 查找标签名字为 name 的字段&lt;/li&gt;
&lt;li&gt;2 查找名字为 name 的字段&lt;/li&gt;
&lt;li&gt;3 查找名字为 Name 等大小写不敏感的匹配字段&lt;/li&gt;
&lt;li&gt;4 如果都没有找到，就直接忽略这个 key，不会报错。当从众多数据中只选择部分使用时非常方便。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;json 的 encode/decode 不支持 required 标签。支持的标签包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FieldName&lt;/code&gt; 指定实际要查找的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;omitempty&lt;/code&gt; 值为空时不要包含到 JSON 中。当丢弃空属性不想包含在输出时很方便&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-&lt;/code&gt; 跳过一些域。当查找到值时会被解析，但是不会被输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;encoding/json&amp;quot;
&amp;quot;fmt&amp;quot;
)

// JSONStruct a struct to be used in json decode
type myJSONStruct struct {
Name   string  `json:&amp;quot;nickname&amp;quot;`
Age    float64 `json:&amp;quot;-&amp;quot;`
Gender string  `json:&amp;quot;,omitempty&amp;quot;`
}

var rawJSON = []byte(`{
&amp;quot;nickname&amp;quot;: &amp;quot;kiki&amp;quot;,
&amp;quot;age&amp;quot;: 18,
&amp;quot;gender&amp;quot;: &amp;quot;&amp;quot;
}`)

func main() {
var s myJSONStruct
err := json.Unmarshal(rawJSON, &amp;amp;s)
if err != nil {
panic(err)
}

// [NickName=kiki] [Age=0.000000] [gender=]
fmt.Printf(&amp;quot;[NickName=%s] [Age=%f] [gender=%s]\n&amp;quot;, s.Name, s.Age, s.Gender)

buf, err := json.Marshal(s)
if err != nil {
panic(err)
}
// [buf={&amp;quot;nickname&amp;quot;:&amp;quot;kiki&amp;quot;}]
fmt.Printf(&amp;quot;[buf=%s]\n&amp;quot;, buf)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-json-解析嵌套域&#34;&gt;2.2 json 解析嵌套域&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;encoding/json&amp;quot;
  &amp;quot;fmt&amp;quot;
)

type myName struct {
  FirstName string `json:&amp;quot;fname&amp;quot;`
  LastName  string `json:&amp;quot;lname&amp;quot;`
}

// JSONStruct a struct to be used in json decode
type myJSONStruct struct {
  myName
  Age    float64 `json:&amp;quot;-&amp;quot;`
  Gender string  `json:&amp;quot;,omitempty&amp;quot;`
}

var rawJSON = []byte(`{
    &amp;quot;fname&amp;quot;: &amp;quot;kiki&amp;quot;,
    &amp;quot;lname&amp;quot;: &amp;quot;kity&amp;quot;,
    &amp;quot;age&amp;quot;: 18,
    &amp;quot;gender&amp;quot;: &amp;quot;&amp;quot;
}`)

func main() {
  var s myJSONStruct
  err := json.Unmarshal(rawJSON, &amp;amp;s)
  if err != nil {
    panic(err)
  }

  // [FirstName=kiki] [LastName=kity] [Age=0.000000] [gender=]
  fmt.Printf(&amp;quot;[FirstName=%s] [LastName=%s] [Age=%f] [gender=%s]\n&amp;quot;, s.FirstName, s.LastName, s.Age, s.Gender)

  buf, err := json.Marshal(s)
  if err != nil {
    panic(err)
  }
  // [buf={&amp;quot;fname&amp;quot;:&amp;quot;kiki&amp;quot;,&amp;quot;lname&amp;quot;:&amp;quot;kity&amp;quot;}]
  fmt.Printf(&amp;quot;[buf=%s]\n&amp;quot;, buf)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-json-编码时会对指针解引用-使用的是实际值&#34;&gt;2.3 json 编码时会对指针解引用，使用的是实际值&lt;/h3&gt;

&lt;h3 id=&#34;2-4-encoding-json-unmarshal-实现-required-标签&#34;&gt;2.4 encoding/json.Unmarshal 实现 required 标签&lt;/h3&gt;

&lt;h3 id=&#34;2-5-当-json-和-stream-相关时-使用-encoder-decoder&#34;&gt;2.5 当 json 和 stream 相关时，使用 Encoder/Decoder&lt;/h3&gt;

&lt;h3 id=&#34;2-6-定义成-json-rawmessage-的域可以延迟解析&#34;&gt;2.6 定义成 json.RawMessage 的域可以延迟解析&lt;/h3&gt;

&lt;h3 id=&#34;2-7-使用-interface-和-json-rawmessage-解析动态-json&#34;&gt;2.7 使用 interface 和 json.RawMessage 解析动态 json&lt;/h3&gt;

&lt;h4 id=&#34;2-7-1-实现-marshaljson-unmarshaljson-接口&#34;&gt;2.7.1 实现 MarshalJson/UnmarshalJSON 接口&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JSON 模块包含两个接口 &lt;code&gt;Marshaler&lt;/code&gt; 和 &lt;code&gt;Unmarshaler&lt;/code&gt;。两个接口都需要一个方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Marshaler 接口定义了怎么把某个类型 encode 成 JSON 数据
type Marshaler interface {
  MarshalJSON() ([]byte, error)
}

// Unmarshaler 接口定义了怎么把 JSON 数据 decode 成特定的类型数据。如果后续还要使用 JSON 数据，必须把数据拷贝一份
type Unmarshaler interface {
  UnmarshalJSON([]byte) error
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果将这两个接口增加到自定义类型，就可以被编码成 JSON 或者把 JSON 解析成自定义类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个很好的例子就是 &lt;code&gt;time.Time&lt;/code&gt; 类型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Month struct {
MonthNumber int
YearNumber int
}

func (m Month) MarshalJSON() ([]byte, error){
return []byte(fmt.Sprintf(&amp;quot;%d/%d&amp;quot;, m.MonthNumber, m.YearNumber)), nil
}

func (m *Month) UnmarshalJSON(value []byte) error {
parts := strings.Split(string(value), &amp;quot;/&amp;quot;)
m.MonthNumber = strconv.ParseInt(parts[0], 10, 32)
m.YearNumber = strconv.ParseInt(parts[1], 10, 32)

return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-7-2-将-json-解析成-interface&#34;&gt;2.7.2 将 json 解析成 interface&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;interface{}&lt;/code&gt; 在 Go 中意味着可以是任何东西，Go 在运行时会分配的合适的内存来存储&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;encoding/json&amp;quot;
&amp;quot;fmt&amp;quot;
)

type myName struct {
FirstName string `json:&amp;quot;fname&amp;quot;`
LastName  string `json:&amp;quot;lname&amp;quot;`
}

// JSONStruct a struct to be used in json decode
type myJSONStruct struct {
myName
Age    float64 `json:&amp;quot;-&amp;quot;`
Gender string  `json:&amp;quot;,omitempty&amp;quot;`
}

var rawJSON = []byte(`{
  &amp;quot;fname&amp;quot;: &amp;quot;kiki&amp;quot;,
  &amp;quot;lname&amp;quot;: &amp;quot;kity&amp;quot;,
  &amp;quot;age&amp;quot;: 18
}`)

func main() {
var s map[string]interface{}
err := json.Unmarshal(rawJSON, &amp;amp;s)
if err != nil {
  panic(err)
}

fmt.Printf(&amp;quot;[map=%v]&amp;quot;, s)
if s[&amp;quot;gender&amp;quot;] == nil {
  panic(&amp;quot;Gender is nil&amp;quot;)
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;2-7-3-使用指针增加代码检查&#34;&gt;2.7.3 使用指针增加代码检查&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;结构体字段使用指针，解析之后判断是否为 nil&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;encoding/json&amp;quot;
&amp;quot;fmt&amp;quot;
)

// JSONStruct a struct to be used in json decode
type JSONStruct struct {
Name *string
Age  *float64
}

var rawJSON = []byte(`{
  &amp;quot;name&amp;quot;: &amp;quot;We do not provide a Age&amp;quot;
}`)

func main() {
var s *JSONStruct
err := json.Unmarshal(rawJSON, &amp;amp;s)
if err != nil {
  panic(err)
}

if s.Name == nil {
  panic(&amp;quot;Name is missing or null!&amp;quot;)
}

if s.Age == nil {
  panic(&amp;quot;Age is missing or null!&amp;quot;)
}

fmt.Printf(&amp;quot;Name: %s  Age: %f\n&amp;quot;, *s.Name, *s.Age)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-gin-binding-bind&#34;&gt;3 gin/binding.Bind&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;binding:&amp;quot;required&amp;quot;&lt;/code&gt; 指定某个域是必须的。当 binding 时该字段为空会返回错误&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;time&amp;quot;

&amp;quot;net/http&amp;quot;

&amp;quot;github.com/gin-gonic/gin&amp;quot;
)

type myJSONStruct struct {
Name string
Age  int `binding:&amp;quot;required&amp;quot;`
}

func addUser(c *gin.Context) {
var response interface{}
data := new(myJSONStruct)
if err := c.Bind(data); err != nil {
  // [err=Key: &#39;myJSONStruct.Age&#39; Error:Field validation for &#39;Age&#39; failed on the &#39;required&#39; tag]
  fmt.Printf(&amp;quot;addUser error [Bind error] [err=%s]\n&amp;quot;, err)
  c.JSON(http.StatusBadRequest, response)
  return
}
fmt.Printf(&amp;quot;addUser success [data=%v]\n&amp;quot;, data)
c.JSON(http.StatusOK, response)
}

func main() {
router := gin.New()
api := router.Group(&amp;quot;/api/adduser&amp;quot;)
api.POST(&amp;quot;&amp;quot;, addUser)

httpServer := &amp;amp;http.Server{
  Addr:              &amp;quot;0.0.0.0:10300&amp;quot;,
  Handler:           router,
  ReadHeaderTimeout: 5 * time.Second,
}
httpServer.ListenAndServe()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-相关链接&#34;&gt;4 相关链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://eager.io/blog/go-and-json/&#34; target=&#34;_blank&#34;&gt;Go JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/issues/17163&#34; target=&#34;_blank&#34;&gt;encoding/json 增加 required 标签被拒绝&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/19633763/unmarshaling-json-in-golang-required-field&#34; target=&#34;_blank&#34;&gt;使用 json.Unmarshal 实现 required 标签&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://eagain.net/articles/go-dynamic-json/&#34; target=&#34;_blank&#34;&gt;Go 的动态 JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gin-gonic/gin#model-binding-and-validation&#34; target=&#34;_blank&#34;&gt;gin binding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>lambda 表达式</title>
      <link>https://xueqing.github.io/blog/cplusplus/lambda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/lambda/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95&#34;&gt;解决方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%94%e5%9b%9e%e7%b1%bb%e5%9e%8b&#34;&gt;返回类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%22%e6%8d%95%e8%8e%b7%22%e5%8f%98%e9%87%8f&#34;&gt;&amp;ldquo;捕获&amp;rdquo;变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-lambda-%e4%bd%9c%e4%b8%ba%e5%8f%98%e9%87%8f&#34;&gt;使用 lambda 作为变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C++ 包含一些有用的通用函数，比如 &lt;code&gt;std::for_each&lt;/code&gt; 和 &lt;code&gt;std::transform&lt;/code&gt;，用起来很方便。但是使用比较复杂，尤其是使用的仿函数(functor)是唯一的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

namespace {
struct f {
    void operator()(int i) {
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
    }
};
}

void func(std::vector&amp;lt;int&amp;gt;&amp;amp; v) {
f f;
std::for_each(v.begin(), v.end(), f);
}

int main()
{
int arr[] = {1,10,9};
std::vector&amp;lt;int&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果只使用上述 &lt;code&gt;f&lt;/code&gt; 一次，看起来写一个完整的类来完成一些微小的事情是过犹不及的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++11 介绍了 lambda，支持写一个内联、匿名仿函数来替换 &lt;code&gt;struct f&lt;/code&gt;。对于简单的例子代码会更易读，且易于维护&lt;/li&gt;

&lt;li&gt;&lt;p&gt;形式定义 &lt;code&gt;[]() {}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;int&amp;gt;&amp;amp; v) {
std::for_each(v.begin(), v.end(), [](int i) {std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;});
}

int main()
{
int arr[] = {1,10,9};
std::vector&amp;lt;int&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;返回类型&#34;&gt;返回类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单的例子中，lambda 的返回类型是编译器推断出来的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;double&amp;gt; &amp;amp;v) {
std::transform(v.begin(), v.end(), v.begin(),
               [](double d) {return d &amp;lt; 0.00001 ? 0 : d;}
);
std::for_each(v.begin(), v.end(), [](double d) {std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;});
}

int main()
{
double arr[] = {0.000001,1.0,0.000009};
std::vector&amp;lt;double&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是当实现更加复杂的 lambda 时，会遇到一些情况，编译器不能推断返回类型。此时可以显式地指明lambda 函数的返回值，使用 &lt;code&gt;-&amp;gt; T&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;double&amp;gt; &amp;amp;v) {
std::transform(v.begin(), v.end(), v.begin(),
               [](double d) -&amp;gt; double {
                    if(d &amp;lt; 0.00001)
                        return 0;
                    else
                        return d;
                }
);
std::for_each(v.begin(), v.end(), [](double d) {std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;});
}

int main()
{
double arr[] = {0.000001,1.0,0.000009};
std::vector&amp;lt;double&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;捕获-变量&#34;&gt;&amp;ldquo;捕获&amp;rdquo;变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;也可以使用 lambda 内部的变量。如果想要是有其他变量可以使用捕获语句 &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;double&amp;gt; &amp;amp;v, const double &amp;amp;val) {
std::transform(v.begin(), v.end(), v.begin(),
               [val](double d) -&amp;gt; double {
                    if(d &amp;lt; val)
                        return 0;
                    else
                        return d;
                }
);
std::for_each(v.begin(), v.end(), [](double d) {std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;});
}

int main()
{
double arr[] = {0.000001,1.0,0.000009};
std::vector&amp;lt;double&amp;gt; v(arr,arr+3);
double val = 0.000005;
func(v, val);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以捕获引用和值，分别使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;=&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[&amp;amp;val]&lt;/code&gt; 捕获引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt; 捕获当前范围使用的所有变量的引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[=]&lt;/code&gt; 捕获当前范围使用的所有变量的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;amp;, val]&lt;/code&gt; 类似于 &lt;code&gt;[&amp;amp;]&lt;/code&gt;，但是 val 捕获值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[=, &amp;amp;val]&lt;/code&gt; 类似于 &lt;code&gt;[=]&lt;/code&gt;，但是 val 捕获引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成的操作符 &lt;code&gt;()&lt;/code&gt; 默认是 &lt;code&gt;const&lt;/code&gt;，捕获默认也是 &lt;code&gt;const&lt;/code&gt;，使得每次相同的输入产生相同的结果&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;[]() mutable -&amp;gt; T {}&lt;/code&gt;，允许改变以值捕获的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用-lambda-作为变量&#34;&gt;使用 lambda 作为变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用 &lt;code&gt;functional&lt;/code&gt; 头文件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::function&amp;lt;double(int, bool)&amp;gt; f = [](int a, bool b) -&amp;gt; double {//...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通常可让编译器推断类型 &lt;code&gt;auto f = [](int a, bool b) -&amp;gt; double {//...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11&#34; target=&#34;_blank&#34;&gt;What is a lambda expression in C++11?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>live playlist (滑动窗口)构造</title>
      <link>https://xueqing.github.io/translation/hls/live_playlist_sliding_window_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/live_playlist_sliding_window_construction/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/live_playlist_sliding_window_construction&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;示例&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#extm3u&#34;&gt;EXTM3U&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-version&#34;&gt;EXT-X-VERSION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#extinf&#34;&gt;EXTINF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%b4%e6%96%b0-playlist-%e6%96%87%e4%bb%b6&#34;&gt;更新 playlist 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在直播会话中，当生成新的媒体文件且可访问时，通过从文件中移除媒体 URL 来更新索引文件。EXT-X-ENDLIST 标记不会在 live playlist 中出现，表示当新的媒体文件可访问时会被追加到索引文件。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的代码是一个第一个出现在直播会话中的 live playlist 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:1
#EXTINF:10.0,
fileSequence1.ts
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.0,
fileSequence4.ts
#EXTINF:10.0,
fileSequence5.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;live playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/h3&gt;

&lt;p&gt;提供了适用于整个 playlist 文件的易变信息。这个标记可能包含一个 EVENT 或 VOD 值。如果标记存在且值为 EVENT，服务器一定不能修改或删除 playlist 文件的任意部分(但是它可以追加行到 playlist 文件)。如果标记存在且值为 VOD，playlist 文件一定不能改变。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/h3&gt;

&lt;p&gt;指定最大的媒体文件时长。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-version&#34;&gt;EXT-X-VERSION&lt;/h3&gt;

&lt;p&gt;表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/h3&gt;

&lt;p&gt;表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：对于每个从 playlist 文件移除的 URL，EXT-X-MEDIA-SEQUENCE 标记值必须加 1。媒体 URL 必须按照出现在 playlist 中的顺序移除。更新的索引文件展示了移动窗口为一个持续流。这种会话类型适用于持续的广播。&lt;/p&gt;

&lt;h3 id=&#34;extinf&#34;&gt;EXTINF&lt;/h3&gt;

&lt;p&gt;一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。&lt;/p&gt;

&lt;h2 id=&#34;更新-playlist-文件&#34;&gt;更新 playlist 文件&lt;/h2&gt;

&lt;p&gt;下面的示例展示了使用新的媒体 URL 更新的同一 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:2
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.00,
fileSequence4.ts
#EXTINF:10.00,
fileSequence5.ts
#EXTINF:10.0,
fileSequence6.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当增加新的媒体 URL 时继续更新 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:4
#EXTINF:10.00,
fileSequence4.ts
#EXTINF:10.00,
fileSequence5.ts
#EXTINF:10.0,
fileSequence6.ts,
#EXTINF:10.0,
fileSequence7.ts,
#EXTINF:10.0,
fileSequence8.ts,
#EXTINF:10.0,
fileSequence9.ts
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Loops and Functions</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/loops_and_functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/loops_and_functions/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: Loops and Functions
As a way to play with functions and loops, let&amp;rsquo;s implement a square root function: given a number x, we want to find the number z for which z² is most nearly x.&lt;/p&gt;

&lt;p&gt;Computers typically compute the square root of x using a loop. Starting with some guess z, we can adjust z based on how close z² is to x, producing a better guess:&lt;/p&gt;

&lt;p&gt;z -= (z*z - x) / (2*z)
Repeating this adjustment makes the guess better and better until we reach an answer that is as close to the actual square root as can be.&lt;/p&gt;

&lt;p&gt;Implement this in the func Sqrt provided. A decent starting guess for z is 1, no matter what the input. To begin with, repeat the calculation 10 times and print each z along the way. See how close you get to the answer for various values of x (1, 2, 3, &amp;hellip;) and how quickly the guess improves.&lt;/p&gt;

&lt;p&gt;Hint: To declare and initialize a floating point value, give it floating point syntax or use a conversion:&lt;/p&gt;

&lt;p&gt;z := 1.0
z := float64(1)
Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small amount). See if that&amp;rsquo;s more or fewer than 10 iterations. Try other initial guesses for z, like x, or x/2. How close are your function&amp;rsquo;s results to the math.Sqrt in the standard library?&lt;/p&gt;

&lt;p&gt;(Note: If you are interested in the details of the algorithm, the z² − x above is how far away z² is from where it needs to be (x), and the division by 2z is the derivative of z², to scale how much we adjust z by how quickly z² is changing. This general approach is called Newton&amp;rsquo;s method. It works well for many functions but especially well for square root.)
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;fmt&amp;rdquo;
    &amp;ldquo;math&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;func mySqrt(x float64) float64 {
    // z := x / 2
    z := x
    tmp := 0.0
    for math.Abs(z-tmp) &amp;gt;= 0.000000000001 {
        tmp = z
        z -= (z*z - x) / (2 * z)
        fmt.Println(z)
    }
    return z
}&lt;/p&gt;

&lt;p&gt;func main() {
    fmt.Println(mySqrt(2))
    fmt.Println(math.Sqrt(2))
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Maps</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/maps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/maps/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: Maps
Implement WordCount. It should return a map of the counts of each “word” in the string s. The wc.Test function runs a test suite against the provided function and prints success or failure.&lt;/p&gt;

&lt;p&gt;You might find strings.Fields helpful.
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;strings&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;golang.org/x/tour/wc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;)&lt;/p&gt;

&lt;p&gt;func wordCount(s string) map[string]int {
    m := make(map[string]int)
    var ss []string
    ss = strings.Fields(s)
    for i := 0; i &amp;lt; len(ss); i++ {
        m[ss[i]]++
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;func main() {
    wc.Test(wordCount)
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Markdownlint Rules</title>
      <link>https://xueqing.github.io/blog/markdown/markdownlint_rules/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/markdown/markdownlint_rules/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#md001---heading-levels-should-only-increment-by-one-level-at-a-time&#34;&gt;MD001 - Heading levels should only increment by one level at a time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md002---first-heading-should-be-a-top-level-heading&#34;&gt;MD002 - First heading should be a top level heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md003---heading-style&#34;&gt;MD003 - Heading style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md004---unordered-list-style&#34;&gt;MD004 - Unordered list style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md005---inconsistent-indentation-for-list-items-at-the-same-level&#34;&gt;MD005 - Inconsistent indentation for list items at the same level&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md006---consider-starting-bulleted-lists-at-the-beginning-of-the-line&#34;&gt;MD006 - Consider starting bulleted lists at the beginning of the line&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md007---unordered-list-indentation&#34;&gt;MD007 - Unordered list indentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md009---trailing-spaces&#34;&gt;MD009 - Trailing spaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md010---hard-tabs&#34;&gt;MD010 - Hard tabs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md011---reversed-link-syntax&#34;&gt;MD011 - Reversed link syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md012---multiple-consecutive-blank-lines&#34;&gt;MD012 - Multiple consecutive blank lines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md013---line-length&#34;&gt;MD013 - Line length&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md014---dollar-signs-used-before-commands-without-showing-output&#34;&gt;MD014 - Dollar signs used before commands without showing output&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md018---no-space-after-hash-on-atx-style-heading&#34;&gt;MD018 - No space after hash on atx style heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md019---multiple-spaces-after-hash-on-atx-style-heading&#34;&gt;MD019 - Multiple spaces after hash on atx style heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md020---no-space-inside-hashes-on-closed-atx-style-heading&#34;&gt;MD020 - No space inside hashes on closed atx style heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md021---multiple-spaces-inside-hashes-on-closed-atx-style-heading&#34;&gt;MD021 - Multiple spaces inside hashes on closed atx style heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md022---headings-should-be-surrounded-by-blank-lines&#34;&gt;MD022 - Headings should be surrounded by blank lines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md023---headings-must-start-at-the-beginning-of-the-line&#34;&gt;MD023 - Headings must start at the beginning of the line&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md024---multiple-headings-with-the-same-content&#34;&gt;MD024 - Multiple headings with the same content&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md025---multiple-top-level-headings-in-the-same-document&#34;&gt;MD025 - Multiple top level headings in the same document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md026---trailing-punctuation-in-heading&#34;&gt;MD026 - Trailing punctuation in heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md027---multiple-spaces-after-blockquote-symbol&#34;&gt;MD027 - Multiple spaces after blockquote symbol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md028---blank-line-inside-blockquote&#34;&gt;MD028 - Blank line inside blockquote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md029---ordered-list-item-prefix&#34;&gt;MD029 - Ordered list item prefix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md030---spaces-after-list-markers&#34;&gt;MD030 - Spaces after list markers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md031---fenced-code-blocks-should-be-surrounded-by-blank-lines&#34;&gt;MD031 - Fenced code blocks should be surrounded by blank lines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md032---lists-should-be-surrounded-by-blank-lines&#34;&gt;MD032 - Lists should be surrounded by blank lines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md033---inline-html&#34;&gt;MD033 - Inline HTML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md034---bare-url-used&#34;&gt;MD034 - Bare URL used&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md035---horizontal-rule-style&#34;&gt;MD035 - Horizontal rule style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md036---emphasis-used-instead-of-a-heading&#34;&gt;MD036 - Emphasis used instead of a heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md037---spaces-inside-emphasis-markers&#34;&gt;MD037 - Spaces inside emphasis markers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md038---spaces-inside-code-span-elements&#34;&gt;MD038 - Spaces inside code span elements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md039---spaces-inside-link-text&#34;&gt;MD039 - Spaces inside link text&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md040---fenced-code-blocks-should-have-a-language-specified&#34;&gt;MD040 - Fenced code blocks should have a language specified&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md041---first-line-in-file-should-be-a-top-level-heading&#34;&gt;MD041 - First line in file should be a top level heading&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md042---no-empty-links&#34;&gt;MD042 - No empty links&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md043---required-heading-structure&#34;&gt;MD043 - Required heading structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md044---proper-names-should-have-the-correct-capitalization&#34;&gt;MD044 - Proper names should have the correct capitalization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#md045---images-should-have-alternate-text-alt-text&#34;&gt;MD045 - Images should have alternate text (alt text)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This document contains a description of all rules, what they are checking for,
as well as an examples of documents that break the rule and corrected
versions of the examples.&lt;/p&gt;

&lt;h2 id=&#34;md001-heading-levels-should-only-increment-by-one-level-at-a-time&#34;&gt;MD001 - Heading levels should only increment by one level at a time&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: heading-increment, header-increment&lt;/p&gt;

&lt;p&gt;This rule is triggered when you skip heading levels in a markdown document, for
example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1

### Heading 3

We skipped out a 2nd level heading in this document
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When using multiple heading levels, nested headings should increase by only one
level at a time:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1

## Heading 2

### Heading 3

#### Heading 4

## Another Heading 2

### Another Heading 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md002-first-heading-should-be-a-top-level-heading&#34;&gt;MD002 - First heading should be a top level heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: first-heading-h1, first-header-h1&lt;/p&gt;

&lt;p&gt;Parameters: level (number; default 1)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Note: &lt;em&gt;MD002 has been deprecated and is disabled by default.&lt;/em&gt;
&lt;a href=&#34;#md041&#34;&gt;MD041/first-line-heading&lt;/a&gt; offers an improved implementation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This rule is intended to ensure document headings start at the top level and
is triggered when the first heading in the document isn&amp;rsquo;t an h1 heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;## This isn&#39;t an H1 heading

### Another heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first heading in the document should be an h1 heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Start with an H1 heading

## Then use an H2 for subsections
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: The &lt;code&gt;level&lt;/code&gt; parameter can be used to change the top level (ex: to h2) in
cases where an h1 is added externally.&lt;/p&gt;

&lt;h2 id=&#34;md003-heading-style&#34;&gt;MD003 - Heading style&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: heading-style, header-style&lt;/p&gt;

&lt;p&gt;Parameters: style (&amp;ldquo;consistent&amp;rdquo;, &amp;ldquo;atx&amp;rdquo;, &amp;ldquo;atx_closed&amp;rdquo;, &amp;ldquo;setext&amp;rdquo;,
&amp;ldquo;setext_with_atx&amp;rdquo;, &amp;ldquo;setext_with_atx_closed&amp;rdquo;; default &amp;ldquo;consistent&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;This rule is triggered when different heading styles (atx, setext, and &amp;lsquo;closed&amp;rsquo;
atx) are used in the same document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# ATX style H1

## Closed ATX style H2 ##

Setext style H1
===============
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be consistent with the style of heading used in a document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# ATX style H1

## ATX style H2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The setext_with_atx and setext_with_atx_closed doc styles allow atx-style
headings of level 3 or more in documents with setext style headings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Setext style H1
===============

Setext style H2
---------------

### ATX style H3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: the configured heading style can be a specific style to use (atx,
atx_closed, setext, setext_with_atx, setext_with_atx_closed), or simply require
that the usage be consistent within the document.&lt;/p&gt;

&lt;h2 id=&#34;md004-unordered-list-style&#34;&gt;MD004 - Unordered list style&lt;/h2&gt;

&lt;p&gt;Tags: bullet, ul&lt;/p&gt;

&lt;p&gt;Aliases: ul-style&lt;/p&gt;

&lt;p&gt;Parameters: style (&amp;ldquo;consistent&amp;rdquo;, &amp;ldquo;asterisk&amp;rdquo;, &amp;ldquo;plus&amp;rdquo;, &amp;ldquo;dash&amp;rdquo;, &amp;ldquo;sublist&amp;rdquo;; default
&amp;ldquo;consistent&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;This rule is triggered when the symbols used in the document for unordered
list items do not match the configured unordered list style:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* Item 1
+ Item 2
- Item 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this issue, use the configured style for list items throughout the
document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* Item 1
* Item 2
* Item 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The configured list style can be a specific symbol to use (asterisk, plus, dash),
can require that usage be consistent within the document, or can require that each
sublist have a consistent symbol that is different from its parent list.&lt;/p&gt;

&lt;p&gt;For example, the following is valid for the &lt;code&gt;sublist&lt;/code&gt; style because the outer-most
indent uses asterisk, the middle indent uses plus, and the inner-most indent uses dash:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* Item 1
  + Item 2
    - Item 3
  + Item 4
* Item 4
  + Item 5
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md005-inconsistent-indentation-for-list-items-at-the-same-level&#34;&gt;MD005 - Inconsistent indentation for list items at the same level&lt;/h2&gt;

&lt;p&gt;Tags: bullet, ul, indentation&lt;/p&gt;

&lt;p&gt;Aliases: list-indent&lt;/p&gt;

&lt;p&gt;This rule is triggered when list items are parsed as being at the same level,
but don&amp;rsquo;t have the same indentation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* Item 1
  * Nested Item 1
  * Nested Item 2
   * A misaligned item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Usually this rule will be triggered because of a typo. Correct the indentation
for the list to fix it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* Item 1
  * Nested Item 1
  * Nested Item 2
  * Nested Item 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sequentially-ordered list markers are usually left-aligned such that all items
have the same starting column:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;...
8. Item
9. Item
10. Item
11. Item
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This rule also supports right-alignment of list markers such that all items have
the same ending column:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;...
 8. Item
 9. Item
10. Item
11. Item
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md006-consider-starting-bulleted-lists-at-the-beginning-of-the-line&#34;&gt;MD006 - Consider starting bulleted lists at the beginning of the line&lt;/h2&gt;

&lt;p&gt;Tags: bullet, ul, indentation&lt;/p&gt;

&lt;p&gt;Aliases: ul-start-left&lt;/p&gt;

&lt;p&gt;This rule is triggered when top level lists don&amp;rsquo;t start at the beginning of a
line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text

  * List item
  * List item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix, ensure that top level list items are not indented:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some test

* List item
* List item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Starting lists at the beginning of the line means that nested list
items can all be indented by the same amount when an editor&amp;rsquo;s indent function
or the tab key is used to indent. Starting a list 1 space in means that the
indent of the first nested list is less than the indent of the second level (3
characters if you use 4 space tabs, or 1 character if you use 2 space tabs).&lt;/p&gt;

&lt;p&gt;Note: This rule is triggered for the following scenario because the unordered
sublist is not recognized as such by the parser. Not being nested 3 characters
as required by the outer ordered list, it creates a top-level unordered list
instead.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. List item
  - List item
  - List item
1. List item
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md007-unordered-list-indentation&#34;&gt;MD007 - Unordered list indentation&lt;/h2&gt;

&lt;p&gt;Tags: bullet, ul, indentation&lt;/p&gt;

&lt;p&gt;Aliases: ul-indent&lt;/p&gt;

&lt;p&gt;Parameters: indent (number; default 2)&lt;/p&gt;

&lt;p&gt;This rule is triggered when list items are not indented by the configured
number of spaces (default: 2).&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* List item
   * Nested list item indented by 3 spaces
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Corrected Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* List item
  * Nested list item indented by 2 spaces
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale (2 space indent): indenting by 2 spaces allows the content of a
nested list to be in line with the start of the content of the parent list
when a single space is used after the list marker.&lt;/p&gt;

&lt;p&gt;Rationale (4 space indent): Same indent as code blocks, simpler for editors to
implement. See
&lt;a href=&#34;https://www.cirosantilli.com/markdown-style-guide/#indentation-of-content-inside-lists&#34; target=&#34;_blank&#34;&gt;https://www.cirosantilli.com/markdown-style-guide/#indentation-of-content-inside-lists&lt;/a&gt; for more
information.&lt;/p&gt;

&lt;p&gt;In addition, this is a compatibility issue with multi-markdown parsers, which
require a 4 space indents. See
&lt;a href=&#34;http://support.markedapp.com/discussions/problems/21-sub-lists-not-indenting&#34; target=&#34;_blank&#34;&gt;http://support.markedapp.com/discussions/problems/21-sub-lists-not-indenting&lt;/a&gt;
for a description of the problem.&lt;/p&gt;

&lt;p&gt;Note: This rule applies to a sublist only if its parent lists are all also
unordered (otherwise, extra indentation of ordered lists interferes with the
rule).&lt;/p&gt;

&lt;h2 id=&#34;md009-trailing-spaces&#34;&gt;MD009 - Trailing spaces&lt;/h2&gt;

&lt;p&gt;Tags: whitespace&lt;/p&gt;

&lt;p&gt;Aliases: no-trailing-spaces&lt;/p&gt;

&lt;p&gt;Parameters: br_spaces, list_item_empty_lines (number; default 2, boolean; default false)&lt;/p&gt;

&lt;p&gt;This rule is triggered on any lines that end with unexpected whitespace. To fix this,
remove the trailing space from the end of the line.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;br_spaces&lt;/code&gt; parameter allows an exception to this rule for a specific number
of trailing spaces, typically used to insert an explicit line break. The default
value allows 2 spaces to indicate a hard break (&amp;lt;br&amp;gt; element).&lt;/p&gt;

&lt;p&gt;Note: You must set &lt;code&gt;br_spaces&lt;/code&gt; to a value &amp;gt;= 2 for this parameter to take effect.
Setting &lt;code&gt;br_spaces&lt;/code&gt; to 1 behaves the same as 0, disallowing any trailing spaces.&lt;/p&gt;

&lt;p&gt;Using spaces to indent blank lines inside a list item is usually not necessary,
but some parsers require it. Set the &lt;code&gt;list_item_empty_lines&lt;/code&gt; parameter to &lt;code&gt;true&lt;/code&gt;
to allow this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;- list item text
  [2 spaces]
  list item text
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md010-hard-tabs&#34;&gt;MD010 - Hard tabs&lt;/h2&gt;

&lt;p&gt;Tags: whitespace, hard_tab&lt;/p&gt;

&lt;p&gt;Aliases: no-hard-tabs&lt;/p&gt;

&lt;p&gt;Parameters: code_blocks (boolean; default true)&lt;/p&gt;

&lt;p&gt;This rule is triggered by any lines that contain hard tab characters instead
of using spaces for indentation. To fix this, replace any hard tab characters
with spaces instead.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text

	* hard tab character used to indent the list item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Corrected example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text

    * Spaces used to indent the list item instead
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You have the option to exclude this rule for code blocks. To do so, set the
&lt;code&gt;code_blocks&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt;. Code blocks are included by default since
handling of tabs by tools is often inconsistent (ex: using 4 vs. 8 spaces).&lt;/p&gt;

&lt;h2 id=&#34;md011-reversed-link-syntax&#34;&gt;MD011 - Reversed link syntax&lt;/h2&gt;

&lt;p&gt;Tags: links&lt;/p&gt;

&lt;p&gt;Aliases: no-reversed-links&lt;/p&gt;

&lt;p&gt;This rule is triggered when text that appears to be a link is encountered, but
where the syntax appears to have been reversed (the &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt; are
reversed):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;(Incorrect link syntax)[https://www.example.com/]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, swap the &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;()&lt;/code&gt; around:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[Correct link syntax](https://www.example.com/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: &lt;a href=&#34;https://en.wikipedia.org/wiki/Markdown_Extra&#34; target=&#34;_blank&#34;&gt;Markdown Extra&lt;/a&gt;-style footnotes do not trigger this rule:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;For (example)[^1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md012-multiple-consecutive-blank-lines&#34;&gt;MD012 - Multiple consecutive blank lines&lt;/h2&gt;

&lt;p&gt;Tags: whitespace, blank_lines&lt;/p&gt;

&lt;p&gt;Aliases: no-multiple-blanks&lt;/p&gt;

&lt;p&gt;Parameters: maximum (number; default 1)&lt;/p&gt;

&lt;p&gt;This rule is triggered when there are multiple consecutive blank lines in the
document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text here


Some more text here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, delete the offending lines:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text here

Some more text here
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: this rule will not be triggered if there are multiple consecutive blank
lines inside code blocks.&lt;/p&gt;

&lt;p&gt;Note: The &lt;code&gt;maximum&lt;/code&gt; parameter can be used to configure the maximum number of
consecutive blank lines.&lt;/p&gt;

&lt;h2 id=&#34;md013-line-length&#34;&gt;MD013 - Line length&lt;/h2&gt;

&lt;p&gt;Tags: line_length&lt;/p&gt;

&lt;p&gt;Aliases: line-length&lt;/p&gt;

&lt;p&gt;Parameters: line_length, heading_line_length, code_blocks, tables, headings, headers (number; default 80, boolean; default true)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;headings&lt;/code&gt; is not provided, &lt;code&gt;headers&lt;/code&gt; (deprecated) will be used.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This rule is triggered when there are lines that are longer than the
configured &lt;code&gt;line_length&lt;/code&gt; (default: 80 characters). To fix this, split the line
up into multiple lines. To set a different maximum length for headings, use
&lt;code&gt;heading_line_length&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This rule has an exception where there is no whitespace beyond the configured
line length. This allows you to still include items such as long URLs without
being forced to break them in the middle.&lt;/p&gt;

&lt;p&gt;You have the option to exclude this rule for code blocks, tables, or headings.
To do so, set the &lt;code&gt;code_blocks&lt;/code&gt;, &lt;code&gt;tables&lt;/code&gt;, or &lt;code&gt;headings&lt;/code&gt; parameter(s) to false.&lt;/p&gt;

&lt;p&gt;Code blocks are included in this rule by default since it is often a
requirement for document readability, and tentatively compatible with code
rules. Still, some languages do not lend themselves to short lines.&lt;/p&gt;

&lt;h2 id=&#34;md014-dollar-signs-used-before-commands-without-showing-output&#34;&gt;MD014 - Dollar signs used before commands without showing output&lt;/h2&gt;

&lt;p&gt;Tags: code&lt;/p&gt;

&lt;p&gt;Aliases: commands-show-output&lt;/p&gt;

&lt;p&gt;This rule is triggered when there are code blocks showing shell commands to be
typed, and the shell commands are preceded by dollar signs ($):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;$ ls
$ cat foo
$ less bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The dollar signs are unnecessary in the above situation, and should not be
included:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;ls
cat foo
less bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, an exception is made when there is a need to distinguish between
typed commands and command output, as in the following example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;$ ls
foo bar
$ cat foo
Hello world
$ cat bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: it is easier to copy and paste and less noisy if the dollar signs
are omitted when they are not needed. See
&lt;a href=&#34;https://www.cirosantilli.com/markdown-style-guide/#dollar-signs-in-shell-code&#34; target=&#34;_blank&#34;&gt;https://www.cirosantilli.com/markdown-style-guide/#dollar-signs-in-shell-code&lt;/a&gt;
for more information.&lt;/p&gt;

&lt;h2 id=&#34;md018-no-space-after-hash-on-atx-style-heading&#34;&gt;MD018 - No space after hash on atx style heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers, atx, spaces&lt;/p&gt;

&lt;p&gt;Aliases: no-missing-space-atx&lt;/p&gt;

&lt;p&gt;This rule is triggered when spaces are missing after the hash characters
in an atx style heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#Heading 1

##Heading 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, separate the heading text from the hash character by a single
space:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1

## Heading 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md019-multiple-spaces-after-hash-on-atx-style-heading&#34;&gt;MD019 - Multiple spaces after hash on atx style heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers, atx, spaces&lt;/p&gt;

&lt;p&gt;Aliases: no-multiple-space-atx&lt;/p&gt;

&lt;p&gt;This rule is triggered when more than one space is used to separate the
heading text from the hash characters in an atx style heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#  Heading 1

##  Heading 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, separate the heading text from the hash character by a single
space:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1

## Heading 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md020-no-space-inside-hashes-on-closed-atx-style-heading&#34;&gt;MD020 - No space inside hashes on closed atx style heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers, atx_closed, spaces&lt;/p&gt;

&lt;p&gt;Aliases: no-missing-space-closed-atx&lt;/p&gt;

&lt;p&gt;This rule is triggered when spaces are missing inside the hash characters
in a closed atx style heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#Heading 1#

##Heading 2##
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, separate the heading text from the hash character by a single
space:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1 #

## Heading 2 ##
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: this rule will fire if either side of the heading is missing spaces.&lt;/p&gt;

&lt;h2 id=&#34;md021-multiple-spaces-inside-hashes-on-closed-atx-style-heading&#34;&gt;MD021 - Multiple spaces inside hashes on closed atx style heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers, atx_closed, spaces&lt;/p&gt;

&lt;p&gt;Aliases: no-multiple-space-closed-atx&lt;/p&gt;

&lt;p&gt;This rule is triggered when more than one space is used to separate the
heading text from the hash characters in a closed atx style heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;#  Heading 1  #

##  Heading 2  ##
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, separate the heading text from the hash character by a single
space:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1 #

## Heading 2 ##
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: this rule will fire if either side of the heading contains multiple
spaces.&lt;/p&gt;

&lt;h2 id=&#34;md022-headings-should-be-surrounded-by-blank-lines&#34;&gt;MD022 - Headings should be surrounded by blank lines&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers, blank_lines&lt;/p&gt;

&lt;p&gt;Aliases: blanks-around-headings, blanks-around-headers&lt;/p&gt;

&lt;p&gt;Parameters: lines_above, lines_below (number; default 1)&lt;/p&gt;

&lt;p&gt;This rule is triggered when headings (any style) are either not preceded or not
followed by at least one blank line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1
Some text

Some more text
## Heading 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure that all headings have a blank line both before and after
(except where the heading is at the beginning or end of the document):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Heading 1

Some text

Some more text

## Heading 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Aside from aesthetic reasons, some parsers, including kramdown, will
not parse headings that don&amp;rsquo;t have a blank line before, and will parse them as
regular text.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;lines_above&lt;/code&gt; and &lt;code&gt;lines_below&lt;/code&gt; parameters can be used to specify a different
number of blank lines (including 0) above or below each heading.&lt;/p&gt;

&lt;p&gt;Note: If &lt;code&gt;lines_above&lt;/code&gt; or &lt;code&gt;lines_below&lt;/code&gt; are configured to require more than one
blank line, &lt;a href=&#34;#md012&#34;&gt;MD012/no-multiple-blanks&lt;/a&gt; should also be customized.&lt;/p&gt;

&lt;h2 id=&#34;md023-headings-must-start-at-the-beginning-of-the-line&#34;&gt;MD023 - Headings must start at the beginning of the line&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers, spaces&lt;/p&gt;

&lt;p&gt;Aliases: heading-start-left, header-start-left&lt;/p&gt;

&lt;p&gt;This rule is triggered when a heading is indented by one or more spaces:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text

  # Indented heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure that all headings start at the beginning of the line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text

# Heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Headings that don&amp;rsquo;t start at the beginning of the line will not be
parsed as headings, and will instead appear as regular text.&lt;/p&gt;

&lt;h2 id=&#34;md024-multiple-headings-with-the-same-content&#34;&gt;MD024 - Multiple headings with the same content&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: no-duplicate-heading, no-duplicate-header&lt;/p&gt;

&lt;p&gt;Parameters: siblings_only, allow_different_nesting (boolean; default &lt;code&gt;false&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;This rule is triggered if there are multiple headings in the document that have
the same text:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Some text

## Some text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure that the content of each heading is different:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Some text

## Some more text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Some markdown parses generate anchors for headings based on the
heading name, and having headings with the same content can cause problems with
this.&lt;/p&gt;

&lt;p&gt;If the parameter &lt;code&gt;siblings_only&lt;/code&gt; (alternatively &lt;code&gt;allow_different_nesting&lt;/code&gt;) is
set to &lt;code&gt;true&lt;/code&gt;, heading duplication is allowed for non-sibling headings (common
in change logs):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Change log

## 1.0.0

### Features

## 2.0.0

### Features
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md025-multiple-top-level-headings-in-the-same-document&#34;&gt;MD025 - Multiple top level headings in the same document&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: single-title, single-h1&lt;/p&gt;

&lt;p&gt;Parameters: level, front_matter_title (number; default 1, string; default &amp;ldquo;^\s*title:&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;This rule is triggered when a top level heading is in use (the first line of
the file is an h1 heading), and more than one h1 heading is in use in the
document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Top level heading

# Another top level heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix, structure your document so that there is a single h1 heading that is
the title for the document, and all later headings are h2 or lower level
headings:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Title

## Heading

## Another heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: A top level heading is an h1 on the first line of the file, and
serves as the title for the document. If this convention is in use, then there
can not be more than one title for the document, and the entire document
should be contained within this heading.&lt;/p&gt;

&lt;p&gt;Note: The &lt;code&gt;level&lt;/code&gt; parameter can be used to change the top level (ex: to h2) in
cases where an h1 is added externally.&lt;/p&gt;

&lt;p&gt;If &lt;a href=&#34;https://en.wikipedia.org/wiki/YAML&#34; target=&#34;_blank&#34;&gt;YAML&lt;/a&gt; front matter is present and contains
a &lt;code&gt;title&lt;/code&gt; property (commonly used with blog posts), this rule treats that as a top
level heading and will report a violation for any subsequent top level headings.
To use a different property name in front matter, specify the text of a regular
expression via the &lt;code&gt;front_matter_title&lt;/code&gt; parameter. To disable the use of front
matter by this rule, specify &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; for &lt;code&gt;front_matter_title&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;md026-trailing-punctuation-in-heading&#34;&gt;MD026 - Trailing punctuation in heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: no-trailing-punctuation&lt;/p&gt;

&lt;p&gt;Parameters: punctuation (string; default &amp;ldquo;.,;:!?&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;This rule is triggered on any heading that has a punctuation character as the
last character in the line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# This is a heading.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, remove any trailing punctuation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# This is a heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: The punctuation parameter can be used to specify what characters class
as punctuation at the end of the heading. For example, you can set it to
&lt;code&gt;&amp;quot;.,;:!&amp;quot;&lt;/code&gt; to allow headings with question marks in them, such as might be used
in an FAQ.&lt;/p&gt;

&lt;h2 id=&#34;md027-multiple-spaces-after-blockquote-symbol&#34;&gt;MD027 - Multiple spaces after blockquote symbol&lt;/h2&gt;

&lt;p&gt;Tags: blockquote, whitespace, indentation&lt;/p&gt;

&lt;p&gt;Aliases: no-multiple-space-blockquote&lt;/p&gt;

&lt;p&gt;This rule is triggered when blockquotes have more than one space after the
blockquote (&lt;code&gt;&amp;gt;&lt;/code&gt;) symbol:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt;  This is a block quote with bad indentation
&amp;gt;  there should only be one.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix, remove any extraneous space:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; This is a blockquote with correct
&amp;gt; indentation.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md028-blank-line-inside-blockquote&#34;&gt;MD028 - Blank line inside blockquote&lt;/h2&gt;

&lt;p&gt;Tags: blockquote, whitespace&lt;/p&gt;

&lt;p&gt;Aliases: no-blanks-blockquote&lt;/p&gt;

&lt;p&gt;This rule is triggered when two blockquote blocks are separated by nothing
except for a blank line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; This is a blockquote
&amp;gt; which is immediately followed by

&amp;gt; this blockquote. Unfortunately
&amp;gt; In some parsers, these are treated as the same blockquote.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure that any blockquotes that are right next to each other
have some text in between:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; This is a blockquote.

And Jimmy also said:

&amp;gt; This too is a blockquote.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, if they are supposed to be the same quote, then add the
blockquote symbol at the beginning of the blank line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;gt; This is a blockquote.
&amp;gt;
&amp;gt; This is the same blockquote.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Some markdown parsers will treat two blockquotes separated by one
or more blank lines as the same blockquote, while others will treat them as
separate blockquotes.&lt;/p&gt;

&lt;h2 id=&#34;md029-ordered-list-item-prefix&#34;&gt;MD029 - Ordered list item prefix&lt;/h2&gt;

&lt;p&gt;Tags: ol&lt;/p&gt;

&lt;p&gt;Aliases: ol-prefix&lt;/p&gt;

&lt;p&gt;Parameters: style (&amp;ldquo;one&amp;rdquo;, &amp;ldquo;ordered&amp;rdquo;, &amp;ldquo;one_or_ordered&amp;rdquo;, &amp;ldquo;zero&amp;rdquo;; default &amp;ldquo;one_or_ordered&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;This rule is triggered for ordered lists that do not either start with &amp;lsquo;1.&amp;rsquo; or
do not have a prefix that increases in numerical order (depending on the
configured style). The less-common pattern of using &amp;lsquo;0.&amp;rsquo; for all prefixes is
also supported.&lt;/p&gt;

&lt;p&gt;Example valid list if the style is configured as &amp;lsquo;one&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. Do this.
1. Do that.
1. Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example valid list if the style is configured as &amp;lsquo;ordered&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. Do this.
2. Do that.
3. Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both examples are valid when the style is configured as &amp;lsquo;one_or_ordered&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;Example valid list if the style is configured as &amp;lsquo;zero&amp;rsquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;0. Do this.
0. Do that.
0. Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example invalid list for all styles:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1. Do this.
3. Done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This rule supports 0-prefixing ordered list items for uniform indentation:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;...
08. Item
09. Item
10. Item
11. Item
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md030-spaces-after-list-markers&#34;&gt;MD030 - Spaces after list markers&lt;/h2&gt;

&lt;p&gt;Tags: ol, ul, whitespace&lt;/p&gt;

&lt;p&gt;Aliases: list-marker-space&lt;/p&gt;

&lt;p&gt;Parameters: ul_single, ol_single, ul_multi, ol_multi (number; default 1)&lt;/p&gt;

&lt;p&gt;This rule checks for the number of spaces between a list marker (e.g. &amp;lsquo;&lt;code&gt;-&lt;/code&gt;&amp;rsquo;,
&amp;lsquo;&lt;code&gt;*&lt;/code&gt;&amp;rsquo;, &amp;lsquo;&lt;code&gt;+&lt;/code&gt;&amp;rsquo; or &amp;lsquo;&lt;code&gt;1.&lt;/code&gt;&amp;rsquo;) and the text of the list item.&lt;/p&gt;

&lt;p&gt;The number of spaces checked for depends on the document style in use, but the
default is 1 space after any list marker:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* Foo
* Bar
* Baz

1. Foo
1. Bar
1. Baz

1. Foo
   * Bar
1. Baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A document style may change the number of spaces after unordered list items
and ordered list items independently, as well as based on whether the content
of every item in the list consists of a single paragraph, or multiple
paragraphs (including sub-lists and code blocks).&lt;/p&gt;

&lt;p&gt;For example, the style guide at
&lt;a href=&#34;https://www.cirosantilli.com/markdown-style-guide/#spaces-after-list-marker&#34; target=&#34;_blank&#34;&gt;https://www.cirosantilli.com/markdown-style-guide/#spaces-after-list-marker&lt;/a&gt;
specifies that 1 space after the list marker should be used if every item in
the list fits within a single paragraph, but to use 2 or 3 spaces (for ordered
and unordered lists respectively) if there are multiple paragraphs of content
inside the list:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* Foo
* Bar
* Baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;vs.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;*   Foo

    Second paragraph

*   Bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;1.  Foo

    Second paragraph

1.  Bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure the correct number of spaces are used after list marker
for your selected document style.&lt;/p&gt;

&lt;h2 id=&#34;md031-fenced-code-blocks-should-be-surrounded-by-blank-lines&#34;&gt;MD031 - Fenced code blocks should be surrounded by blank lines&lt;/h2&gt;

&lt;p&gt;Tags: code, blank_lines&lt;/p&gt;

&lt;p&gt;Aliases: blanks-around-fences&lt;/p&gt;

&lt;p&gt;This rule is triggered when fenced code blocks are either not preceded or not
followed by a blank line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text
```
Code block
```

```
Another code block
```
Some more text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure that all fenced code blocks have a blank line both before
and after (except where the block is at the beginning or end of the document):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text

```
Code block
```

```
Another code block
```

Some more text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Aside from aesthetic reasons, some parsers, including kramdown, will
not parse fenced code blocks that don&amp;rsquo;t have blank lines before and after them.&lt;/p&gt;

&lt;h2 id=&#34;md032-lists-should-be-surrounded-by-blank-lines&#34;&gt;MD032 - Lists should be surrounded by blank lines&lt;/h2&gt;

&lt;p&gt;Tags: bullet, ul, ol, blank_lines&lt;/p&gt;

&lt;p&gt;Aliases: blanks-around-lists&lt;/p&gt;

&lt;p&gt;This rule is triggered when lists (of any kind) are either not preceded or not
followed by a blank line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text
* Some
* List

1. Some
2. List
Some text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure that all lists have a blank line both before and after
(except where the block is at the beginning or end of the document):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Some text

* Some
* List

1. Some
2. List

Some text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Aside from aesthetic reasons, some parsers, including kramdown, will
not parse lists that don&amp;rsquo;t have blank lines before and after them.&lt;/p&gt;

&lt;p&gt;Note: List items without hanging indents are a violation of this rule; list
items with hanging indents are okay:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;* This is
not okay

* This is
  okay
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md033-inline-html&#34;&gt;MD033 - Inline HTML&lt;/h2&gt;

&lt;p&gt;Tags: html&lt;/p&gt;

&lt;p&gt;Aliases: no-inline-html&lt;/p&gt;

&lt;p&gt;Parameters: allowed_elements (array of string; default empty)&lt;/p&gt;

&lt;p&gt;This rule is triggered whenever raw HTML is used in a markdown document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&amp;lt;h1&amp;gt;Inline HTML heading&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, use &amp;lsquo;pure&amp;rsquo; markdown instead of including raw HTML:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Markdown heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Raw HTML is allowed in markdown, but this rule is included for
those who want their documents to only include &amp;ldquo;pure&amp;rdquo; markdown, or for those
who are rendering markdown documents in something other than HTML.&lt;/p&gt;

&lt;p&gt;Note: To allow specific HTML elements, use the &amp;lsquo;allowed_elements&amp;rsquo; parameter.&lt;/p&gt;

&lt;h2 id=&#34;md034-bare-url-used&#34;&gt;MD034 - Bare URL used&lt;/h2&gt;

&lt;p&gt;Tags: links, url&lt;/p&gt;

&lt;p&gt;Aliases: no-bare-urls&lt;/p&gt;

&lt;p&gt;This rule is triggered whenever a URL is given that isn&amp;rsquo;t surrounded by angle
brackets:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;For more information, see https://www.example.com/.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, add angle brackets around the URL:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;For more information, see &amp;lt;https://www.example.com/&amp;gt;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Without angle brackets, the URL isn&amp;rsquo;t converted into a link in many
markdown parsers.&lt;/p&gt;

&lt;p&gt;Note: if you do want a bare URL without it being converted into a link,
enclose it in a code block, otherwise in some markdown parsers it &lt;em&gt;will&lt;/em&gt; be
converted:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;`https://www.example.com`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md035-horizontal-rule-style&#34;&gt;MD035 - Horizontal rule style&lt;/h2&gt;

&lt;p&gt;Tags: hr&lt;/p&gt;

&lt;p&gt;Aliases: hr-style&lt;/p&gt;

&lt;p&gt;Parameters: style (&amp;ldquo;consistent&amp;rdquo;, &amp;ldquo;&amp;mdash;&amp;rdquo;, &amp;ldquo;***&amp;ldquo;, or other string specifying the
horizontal rule; default &amp;ldquo;consistent&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;This rule is triggered when inconsistent styles of horizontal rules are used
in the document:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---

- - -

***

* * *

****
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, ensure any horizontal rules used in the document are consistent,
or match the given style if the rule is so configured:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;---

---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: by default, this rule is configured to just require that all horizontal
rules in the document are the same, and will trigger if any of the horizontal
rules are different than the first one encountered in the document. If you
want to configure the rule to match a specific style, the parameter given to
the &amp;lsquo;style&amp;rsquo; option is a string containing the exact horizontal rule text that
is allowed.&lt;/p&gt;

&lt;h2 id=&#34;md036-emphasis-used-instead-of-a-heading&#34;&gt;MD036 - Emphasis used instead of a heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers, emphasis&lt;/p&gt;

&lt;p&gt;Aliases: no-emphasis-as-heading, no-emphasis-as-header&lt;/p&gt;

&lt;p&gt;Parameters: punctuation (string; default &amp;ldquo;.,;:!?&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;This check looks for instances where emphasized (i.e. bold or italic) text is
used to separate sections, where a heading should be used instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;**My document**

Lorem ipsum dolor sit amet...

_Another section_

Consectetur adipiscing elit, sed do eiusmod.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, use markdown headings instead of emphasized text to denote
sections:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# My document

Lorem ipsum dolor sit amet...

## Another section

Consectetur adipiscing elit, sed do eiusmod.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: this rule looks for single line paragraphs that consist entirely of
emphasized text.  It won&amp;rsquo;t fire on emphasis used within regular text,
multi-line emphasized paragraphs, and paragraphs ending in punctuation.
Similarly to rule MD026, you can configure what characters are recognized as
punctuation.&lt;/p&gt;

&lt;h2 id=&#34;md037-spaces-inside-emphasis-markers&#34;&gt;MD037 - Spaces inside emphasis markers&lt;/h2&gt;

&lt;p&gt;Tags: whitespace, emphasis&lt;/p&gt;

&lt;p&gt;Aliases: no-space-in-emphasis&lt;/p&gt;

&lt;p&gt;This rule is triggered when emphasis markers (bold, italic) are used, but they
have spaces between the markers and the text:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Here is some ** bold ** text.

Here is some * italic * text.

Here is some more __ bold __ text.

Here is some more _ italic _ text.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, remove the spaces around the emphasis markers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;Here is some **bold** text.

Here is some *italic* text.

Here is some more __bold__ text.

Here is some more _italic_ text.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rationale: Emphasis is only parsed as such when the asterisks/underscores
aren&amp;rsquo;t completely surrounded by spaces. This rule attempts to detect where
they were surrounded by spaces, but it appears that emphasized text was
intended by the author.&lt;/p&gt;

&lt;h2 id=&#34;md038-spaces-inside-code-span-elements&#34;&gt;MD038 - Spaces inside code span elements&lt;/h2&gt;

&lt;p&gt;Tags: whitespace, code&lt;/p&gt;

&lt;p&gt;Aliases: no-space-in-code&lt;/p&gt;

&lt;p&gt;This rule is triggered on code span elements that have spaces right inside the
backticks:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;` some text `

`some text `

` some text`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, remove the spaces inside the codespan markers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;`some text`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: A single leading or trailing space is allowed if used to separate codespan
markers from an embedded backtick:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;`` ` embedded backtick``
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md039-spaces-inside-link-text&#34;&gt;MD039 - Spaces inside link text&lt;/h2&gt;

&lt;p&gt;Tags: whitespace, links&lt;/p&gt;

&lt;p&gt;Aliases: no-space-in-links&lt;/p&gt;

&lt;p&gt;This rule is triggered on links that have spaces surrounding the link text:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[ a link ](https://www.example.com/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, remove the spaces surrounding the link text:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[a link](https://www.example.com/)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md040-fenced-code-blocks-should-have-a-language-specified&#34;&gt;MD040 - Fenced code blocks should have a language specified&lt;/h2&gt;

&lt;p&gt;Tags: code, language&lt;/p&gt;

&lt;p&gt;Aliases: fenced-code-language&lt;/p&gt;

&lt;p&gt;This rule is triggered when fenced code blocks are used, but a language isn&amp;rsquo;t
specified:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;```
#!/bin/bash
echo Hello world
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, add a language specifier to the code block:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;```bash
#!/bin/bash
echo Hello world
```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md041-first-line-in-file-should-be-a-top-level-heading&#34;&gt;MD041 - First line in file should be a top level heading&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: first-line-heading, first-line-h1&lt;/p&gt;

&lt;p&gt;Parameters: level, front_matter_title (number; default 1, string; default &amp;ldquo;^\s*title:&amp;ldquo;)&lt;/p&gt;

&lt;p&gt;This rule is intended to ensure documents have a title and is triggered when
the first line in the file isn&amp;rsquo;t a top level (h1) heading:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;This is a file without a heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix this, add a top level heading to the beginning of the file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# File with heading

This is a file with a top level heading
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: The &lt;code&gt;level&lt;/code&gt; parameter can be used to change the top level (ex: to h2) in cases
where an h1 is added externally.&lt;/p&gt;

&lt;p&gt;If &lt;a href=&#34;https://en.wikipedia.org/wiki/YAML&#34; target=&#34;_blank&#34;&gt;YAML&lt;/a&gt; front matter is present and contains a
&lt;code&gt;title&lt;/code&gt; property (commonly used with blog posts), this rule will not report a
violation. To use a different property name in front matter, specify the text
of a regular expression via the &lt;code&gt;front_matter_title&lt;/code&gt; parameter. To disable the
use of front matter by this rule, specify &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; for &lt;code&gt;front_matter_title&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;md042-no-empty-links&#34;&gt;MD042 - No empty links&lt;/h2&gt;

&lt;p&gt;Tags: links&lt;/p&gt;

&lt;p&gt;Aliases: no-empty-links&lt;/p&gt;

&lt;p&gt;This rule is triggered when an empty link is encountered:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[an empty link]()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix the violation, provide a destination for the link:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[a valid link](https://example.com/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Empty fragments will trigger this rule:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[an empty fragment](#)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But non-empty fragments will not:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;[a valid fragment](#fragment)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;md043-required-heading-structure&#34;&gt;MD043 - Required heading structure&lt;/h2&gt;

&lt;p&gt;Tags: headings, headers&lt;/p&gt;

&lt;p&gt;Aliases: required-headings, required-headers&lt;/p&gt;

&lt;p&gt;Parameters: headings, headers (array of string; default &lt;code&gt;null&lt;/code&gt; for disabled)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If &lt;code&gt;headings&lt;/code&gt; is not provided, &lt;code&gt;headers&lt;/code&gt; (deprecated) will be used.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This rule is triggered when the headings in a file do not match the array of
headings passed to the rule. It can be used to enforce a standard heading
structure for a set of files.&lt;/p&gt;

&lt;p&gt;To require exactly the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Head
## Item
### Detail
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set the &lt;code&gt;headings&lt;/code&gt; parameter to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    &amp;quot;# Head&amp;quot;,
    &amp;quot;## Item&amp;quot;,
    &amp;quot;### Detail&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To allow optional headings as with the following structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;# Head
## Item
### Detail (optional)
## Foot
### Notes (optional)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Use the special value &lt;code&gt;&amp;quot;*&amp;quot;&lt;/code&gt; meaning &amp;ldquo;one or more unspecified headings&amp;rdquo; and set
the &lt;code&gt;headings&lt;/code&gt; parameter to:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    &amp;quot;# Head&amp;quot;,
    &amp;quot;## Item&amp;quot;,
    &amp;quot;*&amp;quot;,
    &amp;quot;## Foot&amp;quot;,
    &amp;quot;*&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When an error is detected, this rule outputs the line number of the first
problematic heading (otherwise, it outputs the last line number of the file).&lt;/p&gt;

&lt;p&gt;Note that while the &lt;code&gt;headings&lt;/code&gt; parameter uses the &amp;ldquo;## Text&amp;rdquo; ATX heading style for
simplicity, a file may use any supported heading style.&lt;/p&gt;

&lt;h2 id=&#34;md044-proper-names-should-have-the-correct-capitalization&#34;&gt;MD044 - Proper names should have the correct capitalization&lt;/h2&gt;

&lt;p&gt;Tags: spelling&lt;/p&gt;

&lt;p&gt;Aliases: proper-names&lt;/p&gt;

&lt;p&gt;Parameters: names, code_blocks (string array; default &lt;code&gt;null&lt;/code&gt;, boolean; default &lt;code&gt;true&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;This rule is triggered when any of the strings in the &lt;code&gt;names&lt;/code&gt; array do not have
the specified capitalization. It can be used to enforce a standard letter case
for the names of projects and products.&lt;/p&gt;

&lt;p&gt;For example, the language &amp;ldquo;JavaScript&amp;rdquo; is usually written with both the &amp;lsquo;J&amp;rsquo; and
&amp;rsquo;S&amp;rsquo; capitalized - though sometimes the &amp;rsquo;s&amp;rsquo; or &amp;lsquo;j&amp;rsquo; appear in lower-case. To enforce
the proper capitalization, specify the desired letter case in the &lt;code&gt;names&lt;/code&gt; array:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;[
    &amp;quot;JavaScript&amp;quot;
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Set the &lt;code&gt;code_blocks&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt; to disable this rule for code blocks.&lt;/p&gt;

&lt;h2 id=&#34;md045-images-should-have-alternate-text-alt-text&#34;&gt;MD045 - Images should have alternate text (alt text)&lt;/h2&gt;

&lt;p&gt;Tags: accessibility, images&lt;/p&gt;

&lt;p&gt;Aliases: no-alt-text&lt;/p&gt;

&lt;p&gt;This rule is triggered when an image is missing alternate text (alt text) information.
Alternate text is important for accessibility, describing the content of an image for
people who may not be able to see it.&lt;/p&gt;

&lt;p&gt;Alternate text is commonly specified inline as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;![Alternate text](image.jpg)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or with reference syntax as:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;![Alternate text][ref]

...

[ref]: image.jpg &amp;quot;Optional title&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Guidance for writing alternate text is available from the &lt;a href=&#34;https://www.w3.org/WAI/alt/&#34; target=&#34;_blank&#34;&gt;W3C&lt;/a&gt;,
&lt;a href=&#34;https://en.wikipedia.org/wiki/Alt_attribute&#34; target=&#34;_blank&#34;&gt;Wikipedia&lt;/a&gt;, and
&lt;a href=&#34;https://www.phase2technology.com/blog/no-more-excuses-definitive-guide-alt-text-field&#34; target=&#34;_blank&#34;&gt;other locations&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>module 不要在 vscode 工作区打开工程</title>
      <link>https://xueqing.github.io/blog/go/traps/mod_workspace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/traps/mod_workspace/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%97%a7%e8%a1%8c%e4%b8%ba-vs-%e5%9f%ba%e4%ba%8e%e6%a8%a1%e5%9d%97%e7%9a%84%e8%a1%8c%e4%b8%ba&#34;&gt;旧行为 vs 基于模块的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-gopath-%e4%b9%8b%e5%a4%96%e5%b7%a5%e4%bd%9c&#34;&gt;在 GOPATH 之外工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vscode-%e5%af%b9%e6%a8%a1%e5%9d%97%e7%9a%84%e6%94%af%e6%8c%81&#34;&gt;VSCode 对模块的支持&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bf%9d%e5%ad%98%e6%96%87%e4%bb%b6%e6%97%b6%e4%b8%8d%e5%86%8d%e8%87%aa%e5%8a%a8%e5%af%bc%e5%85%a5&#34;&gt;保存文件时不再自动导入&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%b8%e5%85%b3%e9%93%be%e6%8e%a5&#34;&gt;相关链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;旧行为-vs-基于模块的行为&#34;&gt;旧行为 vs 基于模块的行为&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;模块在 Go1.11 开始，因此按照设计旧行为会默认保留。因此需要注意什么时候是旧的 1.10 状态行为(查找 &lt;code&gt;vendor&lt;/code&gt; 目录和 GOPATH 来寻找依赖)，什么时候是新的基于模块的行为

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH&lt;/code&gt; 之内: 默认是旧的 1.10 行为，会忽视模块&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH&lt;/code&gt; 之外且在文件树之内有一个 &lt;code&gt;go.mod&lt;/code&gt; 文件: 默认是模块行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GO111MODULE&lt;/code&gt; 环境变量&lt;/li&gt;
&lt;li&gt;不设置或 &lt;code&gt;auto&lt;/code&gt;: 上述默认行为&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on&lt;/code&gt;: 强制支持模块，与目录位置无关&lt;/li&gt;
&lt;li&gt;&lt;code&gt;off&lt;/code&gt;: 强制不支持模块，与目录位置无关&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-gopath-之外工作&#34;&gt;在 GOPATH 之外工作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果对于一个给定的导入路径，有多个包的版本，那么要求包的开发版本放在一个指定的位置是没有意义的。如果需要同时在 v1.3 和 v1.4 版本上修改 bug，显然需要在不同的位置切换模块。实际上，这种情况下，没有必要在 GOPATH 目录工作&lt;/li&gt;
&lt;li&gt;GOPATH 做了三件事

&lt;ul&gt;
&lt;li&gt;定义依赖的版本(现在在 &lt;code&gt;go.mod&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;保存这些依赖的源码(现在在分别的 cache)&lt;/li&gt;
&lt;li&gt;提供一种方式来推测特定目录(去掉先导的 &lt;code&gt;$GOPATH/src&lt;/code&gt;)代码内的导入路径(现在有机制来确定当前目录代码的导入路径，可以停止要求程序猿在 GOPATH 工作)&lt;/li&gt;
&lt;li&gt;此机制位于 &lt;code&gt;go.mod&lt;/code&gt; 文件的 &lt;code&gt;module&lt;/code&gt; 命令。比如当前目录是 &lt;code&gt;buggy&lt;/code&gt;，且 &lt;code&gt;../go.mod&lt;/code&gt; 包含 &lt;code&gt;module &amp;quot;rsc.io/quote&amp;quot;&lt;/code&gt;，那么当前目录的导入路径就是 &lt;code&gt;rsc.io/quote/buggy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;vgo&lt;/code&gt; 原型支持在 GOPATH 之外工作。比如下面的例子，即使 Upspin 没有引入 &lt;code&gt;go.mod&lt;/code&gt; 文件也可以工作&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd $HOME
git clone https://github.com/upspin/upspin
cd upspin
# vgo 从 导入注释推测模块名字是 upsin.io，并且从 Gopkg.loc 推测需要的依赖版本
vgo test -short ./...
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vscode-对模块的支持&#34;&gt;VSCode 对模块的支持&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;新的语言服务 gopls 支持模块，设置 &lt;code&gt;&amp;quot;go.useLanguageServer&amp;quot;: true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;保存文件时不再自动导入&#34;&gt;保存文件时不再自动导入&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果不使用语言服务，插件默认使用 &lt;code&gt;goreturns&lt;/code&gt; 工具格式化文件，并自动导入缺失的包。但是 &lt;code&gt;goreturns&lt;/code&gt; 工具不支持模块，因此存文件时自动导入的特性不生效&lt;/li&gt;
&lt;li&gt;增加设置 &lt;code&gt;&amp;quot;go.formatTool&amp;quot;: &amp;quot;goimports&amp;quot;&lt;/code&gt;，然后使用 &lt;code&gt;Go: Install/Update Tools&lt;/code&gt; 安装或更新 &lt;code&gt;goimports&lt;/code&gt;，因为 &lt;code&gt;goimports&lt;/code&gt; 已经增加对模块的支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;相关链接&#34;&gt;相关链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/Modules&#34; target=&#34;_blank&#34;&gt;Go module wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/golang/go/wiki/Modules#when-do-i-get-old-behavior-vs-new-module-based-behavior&#34; target=&#34;_blank&#34;&gt;When do I get old behavior vs. new module-based behavior&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.swtch.com/vgo-cmd&#34; target=&#34;_blank&#34;&gt;Versioned Go Commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://research.swtch.com/vgo-cmd#working_outside_gopath&#34; target=&#34;_blank&#34;&gt;Working outside GOPATH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Microsoft/vscode-go/wiki/Go-modules-support-in-Visual-Studio-Code&#34; target=&#34;_blank&#34;&gt;Go modules support in Visual Studio Code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>quick 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/quick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/quick/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95&#34;&gt;索引&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/testing/quick/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;testing/quick&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;quick 包实现了帮辅助黑盒测试的工具函数。&lt;/p&gt;

&lt;p&gt;testing/quick 包被冻结，且不再接受新特性。&lt;/p&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/quick/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>RAII 资源获取即初始化</title>
      <link>https://xueqing.github.io/blog/cplusplus/raii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/raii/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-raii&#34;&gt;使用 RAII&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%8b%e5%ad%90&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e5%87%86%e5%ba%93&#34;&gt;标准库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e8%a7%a3&#34;&gt;注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;p&gt;资源获取即初始化（Resource Acquisition Is Initialization），或称 RAII，是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期绑定与一个对象的生存期相绑定。&lt;/p&gt;

&lt;h2 id=&#34;使用-raii&#34;&gt;使用 RAII&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RAII 保证资源可用于任何会访问该对象的函数（资源可用性是一种&lt;a href=&#34;https://en.wikipedia.org/wiki/Class_invariant&#34; target=&#34;_blank&#34;&gt;类不变式&lt;/a&gt;，这会消除冗余的运行时测试）。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性（对象生存期、退出作用域、初始化顺序以及栈回溯）以消除内存泄漏并保证异常安全。根据 RAII 对象的生存期在退出作用域时结束这一基本状况，此技术的另一名称是作用域界定的资源管理（ Scope-Bound Resource Management，SBRM）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RAII 可总结如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将每个资源封装入一个类，其中&lt;/li&gt;
&lt;li&gt;构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常&lt;/li&gt;
&lt;li&gt;析构函数释放资源并决不抛出异常&lt;/li&gt;
&lt;li&gt;始终经由 RAII 类的实例使用满足要求的资源，该资源&lt;/li&gt;
&lt;li&gt;自身拥有自动存储期或临时生存期，或&lt;/li&gt;
&lt;li&gt;具有与自动或临时对象的生存期绑定的生存期&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动语义使得在对象间、跨作用域，以及在线程内外安全地移动所有权，而同时维护资源安全成为可能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;

&lt;p&gt;拥有 open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy() 成员函数的类是非 RAII 类的典型的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::mutex m;

void bad()
{
    m.lock();                    // 请求互斥体
    f();                         // 若 f() 抛异常，则互斥体永远不被释放
    if(!everything_ok()) return; // 提早返回，互斥体永远不被释放
    m.unlock();                  // 若 bad() 抵达此语句，互斥才被释放
}

void good()
{
    std::lock_guard&amp;lt;std::mutex&amp;gt; lk(m); // RAII类：互斥体的请求即是初始化
    f();                               // 若 f() 抛异常，则释放互斥体
    if(!everything_ok()) return;       // 提早返回，互斥体被释放
}                                      // 若 good() 正常返回，则释放互斥体
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标准库&#34;&gt;标准库&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++ 标准库遵循 RAII 管理其自身的资源：&lt;code&gt;std::string&lt;/code&gt;、&lt;code&gt;std::vector&lt;/code&gt;、&lt;code&gt;std::thread&lt;/code&gt;，以及多数其他类在构造函数中获取其资源（错误时抛出异常），并在其析构函数中释放之（决不抛出），而不要求显式清理。&lt;/li&gt;
&lt;li&gt;另外，标准库提供几种 RAII 包装器以管理用户提供的资源：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; 及 &lt;code&gt;std::shared_ptr&lt;/code&gt; 用于管理动态分配的内存，或以用户提供的删除器管理任何以普通指针表示的资源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::lock_guard&lt;/code&gt;、&lt;code&gt;std::unique_lock&lt;/code&gt;、&lt;code&gt;std::shared_lock&lt;/code&gt; 用于管理互斥体&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;注解&#34;&gt;注解&lt;/h2&gt;

&lt;p&gt;RAII 不适用于并非在使用前请求的资源：CPU 时间、核心，以及缓存容量、熵池容量、网络带宽、电力消费、栈内存等。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.cppreference.com/w/cpp/language/raii&#34; target=&#34;_blank&#34;&gt;RAII&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Readers</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/reader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/reader/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: Readers
Implement a Reader type that emits an infinite stream of the ASCII character &amp;lsquo;A&amp;rsquo;.
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;golang.org/x/tour/reader&amp;rdquo;&lt;/p&gt;

&lt;p&gt;type myReader struct{}&lt;/p&gt;

&lt;p&gt;func (r myReader) Read(c []byte) (int, error) {
    i := 0
    for ; i &amp;lt; len&amp;copy;; i++ {
        c[i] = &amp;lsquo;A&amp;rsquo;
    }
    for ; i &amp;lt; cap&amp;copy;; i++ {
        c = append(c, &amp;lsquo;A&amp;rsquo;)
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return cap(c), nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;func main() {
    reader.Validate(myReader{})
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rot13Reader</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/rot_reader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/rot_reader/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: rot13Reader
A common pattern is an io.Reader that wraps another io.Reader, modifying the stream in some way.&lt;/p&gt;

&lt;p&gt;For example, the gzip.NewReader function takes an io.Reader (a stream of compressed data) and returns a *gzip.Reader that also implements io.Reader (a stream of the decompressed data).&lt;/p&gt;

&lt;p&gt;Implement a rot13Reader that implements io.Reader and reads from an io.Reader, modifying the stream by applying the rot13 substitution cipher to all alphabetical characters.&lt;/p&gt;

&lt;p&gt;The rot13Reader type is provided for you. Make it an io.Reader by implementing its Read method.
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;io&amp;rdquo;
    &amp;ldquo;os&amp;rdquo;
    &amp;ldquo;strings&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;type rot13Reader struct {
    r io.Reader
}&lt;/p&gt;

&lt;p&gt;func rot13(b byte) byte {
    if b &amp;gt;= &amp;lsquo;a&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;rsquo;m&amp;rsquo; {
        return b + 13
    }
    if b &amp;gt;= &amp;lsquo;n&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;lsquo;z&amp;rsquo; {
        return b - &amp;lsquo;n&amp;rsquo; + &amp;lsquo;a&amp;rsquo;
    }
    if b &amp;gt;= &amp;lsquo;A&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;rsquo;M&amp;rsquo; {
        return b + 13
    }
    if b &amp;gt;= &amp;lsquo;N&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;lsquo;Z&amp;rsquo; {
        return b - &amp;lsquo;N&amp;rsquo; + &amp;lsquo;A&amp;rsquo;
    }
    return b
}&lt;/p&gt;

&lt;p&gt;var rot13Map = make(map[byte]byte)&lt;/p&gt;

&lt;p&gt;func initializeRot13Map() {
    s1 := &amp;ldquo;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&amp;rdquo;
    s2 := &amp;ldquo;NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&amp;rdquo;
    for i := 0; i &amp;lt; len(s1); i++ {
        rot13Map[s1[i]] = s2[i]
    }
}&lt;/p&gt;

&lt;p&gt;func rot13ByMap(b byte) byte {
    val, ok := rot13Map[b]
    if ok {
        return val
    }
    return b
}&lt;/p&gt;

&lt;p&gt;func (rot rot13Reader) Read(c []byte) (int, error) {
    b := make([]byte, 8)
    n, err := rot.r.Read(b)
    initializeRot13Map()
    for i := 0; i &amp;lt; n; i++ {
        // b[i] = rot13(b[i])
        b[i] = rot13ByMap(b[i])
    }
    if err == io.EOF {
        return n, err
    }
    copy(c, b)
    return n, nil
}&lt;/p&gt;

&lt;p&gt;func main() {
    s := strings.NewReader(&amp;ldquo;Lbh penpxrq gur pbqr!&amp;rdquo;)
    r := rot13Reader{s}
    io.Copy(os.Stdout, &amp;amp;r)
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>sizeof vs strlen</title>
      <link>https://xueqing.github.io/blog/cplusplus/sizeof_strlen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/sizeof_strlen/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#sizeof&#34;&gt;sizeof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#strlen&#34;&gt;strlen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sizeof&#34;&gt;sizeof&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sizeof 是编译时一元运算符，可用于计算运算元的大小&lt;/li&gt;
&lt;li&gt;sizeof 作用于 unsigned int 时，结果一般表示为 size_t&lt;/li&gt;
&lt;li&gt;sizeof 可用于任何数据类型，包括基本类型(比如整型、浮点型、指针类型)或符合数据类型(比如结构体、联合体等)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sizeof 计算结构体的大小时，并不一定等于结构体每个成员 sizeof 计算结果之和&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原因：编译器因为对齐问题会给结构体增加填充。不同编译器的对齐约束可能不同，所以填充大小也不确定。当结构体的一个成员之和有一个更大的成员，或者在结构体最后时，前者可能会被填充&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C 编译器不允许编译器重排结构体的成员来减小填充。为了最下滑填充，结构体的成员必须按照从大到小的顺序排列&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
struct A {
int x;      //sizeof(int)=4, Padding of 4 bytes
double z;   //sizeof(double)=8
short int y;//sizeof(short int)=2, Padding of 6 bytes
};
printf(&amp;quot;Size of struct: %d&amp;quot;, sizeof(struct A));//24

struct B {
double z;   //sizeof(double)=8
int x;      //sizeof(int)=4
short int y;//sizeof(short int)=2, Padding of 2 bytes
};
printf(&amp;quot;Size of struct: %d&amp;quot;, sizeof(struct B));//16

struct C {
double z;   //sizeof(double)=8
short int y;//sizeof(short int)=2, Padding of 2 bytes
int x;      //sizeof(int)=4
};
printf(&amp;quot;Size of struct: %d&amp;quot;, sizeof(struct C));//16

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;strlen&#34;&gt;strlen&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;strlen 是 C 语言预定义的函数，包含在头文件 &lt;code&gt;string.h&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;strlen 接受指向数组的指针作为参数，并在运行时从该地址开始遍历查找 &lt;code&gt;NULL&lt;/code&gt; 字符，然后计算在找到 &lt;code&gt;NULL&lt;/code&gt; 字符钱经过的内存大小&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strlen 的主要用于计算一个数组或字符串的长度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
  
int main()
{
char ch[]={&#39;g&#39;, &#39;e&#39;, &#39;e&#39;, &#39;k&#39;, &#39;s&#39;, &#39;\0&#39;};
printf(&amp;quot;Length of string is: %d&amp;quot;, strlen(ch));//5

char str[]= &amp;quot;geeks&amp;quot;;
printf(&amp;quot;Length of string is: %d&amp;quot;, strlen(str));//5

char *str1 = &amp;quot;geeks&amp;quot;;
printf(&amp;quot;Length of string is: %d&amp;quot;, strlen(str1));//5
  
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;差异&lt;/th&gt;
&lt;th&gt;sizeof&lt;/th&gt;
&lt;th&gt;strlen&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原型&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;&lt;code&gt;size_t strlen(const char * str);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;一元运算符&lt;/td&gt;
&lt;td&gt;C 预定义的函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;支持的数据类型&lt;/td&gt;
&lt;td&gt;返回任何数据(分配的)的实际大小，单位是 Byte，包含 null 值&lt;/td&gt;
&lt;td&gt;返回字符串或字符数组的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;计算大小&lt;/td&gt;
&lt;td&gt;sizeof 是编译时表达式，返回一个类型或变量的大小，并不关心变量的值&lt;/td&gt;
&lt;td&gt;strlen 是运行时计算，返回一个 C 风格的以 NULL 结尾的字符串的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;C++ 中&lt;/td&gt;
&lt;td&gt;sizeof 常用作 &lt;code&gt;malloc/memcpy/memset&lt;/code&gt; 的参数，C++ 可用 &lt;code&gt;new/std::copy/std::fill&lt;/code&gt; 或构造函数替换&lt;/td&gt;
&lt;td&gt;C 风格的字符串使用 &lt;code&gt;char_traits::length&lt;/code&gt; 获取长度，也可用 &lt;code&gt;std::string&lt;/code&gt; 类型保存计算&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main()
{
    char str[] = &amp;quot;November&amp;quot;;
    printf(&amp;quot;Length of String is %d\n&amp;quot;, strlen(str));//8
    printf(&amp;quot;Size of String is %d\n&amp;quot;, sizeof(str));//9
}

// 字符串以 NULL 字符，即 &#39;\0&#39; 结束，strlen 计算找到 NULL 字符经过的内存大小，不会计算 NULL。而 sizeof 返回为运算元实际分配的内存，也会计算 NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;
using namespace std;
  
int main()
{
    char a[] = {&amp;quot;Geeks for&amp;quot;};
    char b[] = {&#39;G&#39;,&#39;e&#39;,&#39;e&#39;,&#39;k&#39;,&#39;s&#39;,&#39; &#39;,&#39;f&#39;,&#39;o&#39;,&#39;r&#39;};
    cout &amp;lt;&amp;lt; &amp;quot;sizeof(a) = &amp;quot; &amp;lt;&amp;lt; sizeof(a);//10
    cout &amp;lt;&amp;lt; &amp;quot;\nstrlen(a) = &amp;quot;&amp;lt;&amp;lt; strlen(a);//9
    cout&amp;lt;&amp;lt;  &amp;quot;\nsizeof(b) = &amp;quot; &amp;lt;&amp;lt; sizeof(b);//9
    cout&amp;lt;&amp;lt;  &amp;quot;\nstrlen(b) = &amp;quot; &amp;lt;&amp;lt; strlen(b);//18，不确定

    return 0;
}
// strlen 找不到 NULL 字符，返回结果是不确定的
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/difference-strlen-sizeof-string-c-reviewed/&#34; target=&#34;_blank&#34;&gt;Difference between strlen() and sizeof() for string in C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/9937181/sizeof-vs-strlen&#34; target=&#34;_blank&#34;&gt;Sizeof vs Strlen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Slices</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/slices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/slices/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Slices
Implement Pic. It should return a slice of length dy, each element of which is a slice of dx 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.

The choice of image is up to you. Interesting functions include (x+y)/2, x*y, and x^y.

(You need to use a loop to allocate each []uint8 inside the [][]uint8.)

(Use uint8(intValue) to convert between types.)
*/

package main

import &amp;quot;golang.org/x/tour/pic&amp;quot;

func myPic(dx, dy int) [][]uint8 {
  pic := make([][]uint8, dx)
  for i := 0; i &amp;lt; dx; i++ {
    pic[i] = make([]uint8, dy)
  }
  for i := 0; i &amp;lt; dx; i++ {
    for j := 0; j &amp;lt; dy; j++ {
      pic[i][j] = uint8((i ^ j))
    }
  }
  return pic
}

func main() {
  pic.Show(myPic)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>STL</title>
      <link>https://xueqing.github.io/blog/cplusplus/stl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/stl/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ae%97%e6%b3%95&#34;&gt;算法&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%b4%e6%96%87%e4%bb%b6-algorithm&#34;&gt;头文件 algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%92%e5%ba%8f&#34;&gt;排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%90%9c%e7%b4%a2&#34;&gt;搜索&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%87%8d%e8%a6%81%e7%9a%84-stl-%e7%ae%97%e6%b3%95&#34;&gt;重要的 STL 算法&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%aa%e5%8a%a0%e5%b7%a5%e7%ae%97%e6%b3%95&#34;&gt;未加工算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8a%a0%e5%b7%a5%e7%ae%97%e6%b3%95&#34;&gt;加工算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%89%e7%94%a8%e7%9a%84-array-%e7%ae%97%e6%b3%95&#34;&gt;有用的 Array 算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%92%e5%88%86%e6%93%8d%e4%bd%9c&#34;&gt;划分操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%b4%e6%96%87%e4%bb%b6-valarray&#34;&gt;头文件 valarray&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%b9%e5%99%a8&#34;&gt;容器&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%a1%ba%e5%ba%8f%e5%ae%b9%e5%99%a8&#34;&gt;顺序容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#array&#34;&gt;array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vector&#34;&gt;vector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deque&#34;&gt;deque&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#forwardlist&#34;&gt;forward_list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#list&#34;&gt;list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%b9%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8&#34;&gt;容器适配器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stack&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#queue&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#priorityqueue&#34;&gt;priority_queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e8%81%94%e5%ae%b9%e5%99%a8&#34;&gt;关联容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#set&#34;&gt;set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multiset&#34;&gt;multiset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#map&#34;&gt;map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multimap&#34;&gt;multimap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%97%a0%e5%ba%8f%e5%85%b3%e8%81%94%e5%ae%b9%e5%99%a8&#34;&gt;无序关联容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedset&#34;&gt;unordered_set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedmultiset&#34;&gt;unordered_multiset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedmap&#34;&gt;unordered_map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedmultimap&#34;&gt;unordered_multimap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%bf%e5%87%bd%e6%95%b0&#34;&gt;仿函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%ad%e4%bb%a3%e5%99%a8&#34;&gt;迭代器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;STL(Standard Template Library，标准模板库)是 C++ 模板类集合，提供了统一的编程书籍结构和函数。&lt;/li&gt;
&lt;li&gt;STL 是容器类、算法和迭代器的库，是一个通用的库，组件都是参数化的。&lt;/li&gt;
&lt;li&gt;STL 有 4 个组件：算法、容器、函数和迭代器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;定义了 STL 的基础性的算法(均为函数模板)，用于给定范围的元素。 C++98 中有 70 个算法模板函数，C++11 增加了 20 个算法模板函数，其中有 5 个定义在 &lt;code&gt;numeric&lt;/code&gt; 头文件，其他定义在 &lt;code&gt;algorithm&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numeric&lt;/code&gt; 头文件包含的算法模板函数

&lt;ul&gt;
&lt;li&gt;accumulate：累加序列值&lt;/li&gt;
&lt;li&gt;adjacent_difference：计算相邻两项的差值&lt;/li&gt;
&lt;li&gt;inner_product：计算输入序列的内积&lt;/li&gt;
&lt;li&gt;partial_sum：计算序列的部分累加值&lt;/li&gt;
&lt;li&gt;iota：保存增加的连续值序列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;头文件-algorithm&#34;&gt;头文件 algorithm&lt;/h3&gt;

&lt;h4 id=&#34;排序&#34;&gt;排序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;函数原型：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator&amp;gt;  void sort (RandomAccessIterator first, RandomAccessIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator, class Compare&amp;gt;  void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;底层使用快排实现。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;算法复杂度： O(N*lgN)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

void show(int a[])
{
for(int i=0; i&amp;lt;10; ++i)
    cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
cout &amp;lt;&amp;lt; endl;
}

int main()
{
int a[10]={1, 5, 8, 9, 6, 7, 3, 4, 2, 0};

cout &amp;lt;&amp;lt; &amp;quot;\n The array before sorting is : &amp;quot;;
show(a);

sort(a,a+10);

cout &amp;lt;&amp;lt; &amp;quot;\n The array after sorting is : &amp;quot;;
show(a);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;搜索&#34;&gt;搜索&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;广泛使用的搜索算法是二分搜索，前提是数组已经排好序。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数原型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt;  bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

void show(int a[], int arraysize)
{
for(int i=0; i&amp;lt;arraysize; ++i)
cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
cout &amp;lt;&amp;lt; endl;
}

int main()
{
int a[] = { 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 };
int asize = sizeof(a) / sizeof(a[0]);
cout &amp;lt;&amp;lt; &amp;quot;The array is : &amp;quot;;
show(a, asize);

cout &amp;lt;&amp;lt; &amp;quot;Let&#39;s say we want to search for 2 in the array&amp;quot; &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;So, we first sort the array&amp;quot; &amp;lt;&amp;lt; endl;
sort(a, a + asize);
cout &amp;lt;&amp;lt; &amp;quot;The array after sorting is : &amp;quot;;
show(a, asize);

cout &amp;lt;&amp;lt; &amp;quot;Now, we do the binary search for 2&amp;quot; &amp;lt;&amp;lt; endl;
if(binary_search(a, a + 10, 2))
cout &amp;lt;&amp;lt; &amp;quot;Element found in the array&amp;quot; &amp;lt;&amp;lt; endl;
else
cout &amp;lt;&amp;lt; &amp;quot;Element not found in the array&amp;quot; &amp;lt;&amp;lt; endl;

cout &amp;lt;&amp;lt; &amp;quot;Now, say we want to search for 10&amp;quot; &amp;lt;&amp;lt; endl;
if(binary_search(a, a + 10, 10))
cout &amp;lt;&amp;lt; &amp;quot;Element found in the array&amp;quot; &amp;lt;&amp;lt; endl;
else
cout &amp;lt;&amp;lt; &amp;quot;Element not found in the array&amp;quot; &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;重要的-stl-算法&#34;&gt;重要的 STL 算法&lt;/h4&gt;

&lt;h5 id=&#34;未加工算法&#34;&gt;未加工算法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;排序

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator&amp;gt; void sort (RandomAccessIterator first, RandomAccessIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator, class Compare&amp;gt; void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逆序

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator&amp;gt; void reverse (BidirectionalIterator first, BidirectionalIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回序列中最大值的迭代器

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator&amp;gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class Compare&amp;gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回序列中最小值的迭代器

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator&amp;gt; ForwardIterator min_element (ForwardIterator first, ForwardIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class Compare&amp;gt; ForwardIterator min_element (ForwardIterator first, ForwardIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算序列元素的累加值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T&amp;gt; T accumulate (InputIterator first, InputIterator last, T init);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T, class BinaryOperation&amp;gt; T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;numeric&amp;gt; //For accumulate operation

using namespace std;

int main()
{
int arr[] = {10, 20, 5, 23 ,42 , 15};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
cout &amp;lt;&amp;lt; &amp;quot;Vector is: &amp;quot;;
for(int i=0; i&amp;lt;n; i++) cout &amp;lt;&amp;lt; vect[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;

sort(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after sorting is: &amp;quot;;
for(int i=0; i&amp;lt;n; i++) cout &amp;lt;&amp;lt; vect[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;

reverse(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after reversing is: &amp;quot;;
for(int i=0; i&amp;lt;6; i++) cout &amp;lt;&amp;lt; vect[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;

cout &amp;lt;&amp;lt; &amp;quot;\nMaximum element of vector is: &amp;quot;;
cout &amp;lt;&amp;lt; *max_element(vect.begin(), vect.end());

cout &amp;lt;&amp;lt; &amp;quot;\nMinimum element of vector is: &amp;quot;;
cout &amp;lt;&amp;lt; *min_element(vect.begin(), vect.end());

cout &amp;lt;&amp;lt; &amp;quot;\nThe summation of vector elements is: &amp;quot;;
cout &amp;lt;&amp;lt; accumulate(vect.begin(), vect.end(), 0);
cout&amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算给定元素出现的次数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T&amp;gt; typename iterator_traits&amp;lt;InputIterator&amp;gt;::difference_type count (InputIterator first, InputIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回指向第一个等于给定元素的指针&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T&amp;gt; InputIterator find (InputIterator first, InputIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {10, 20, 5, 23 ,42, 20, 15};
int n = sizeof(arr)/sizeof(arr[0]);
vector&amp;lt;int&amp;gt; vect(arr, arr+n);

cout &amp;lt;&amp;lt; &amp;quot;Occurrences of 20 in vector : &amp;quot;;
cout &amp;lt;&amp;lt; count(vect.begin(), vect.end(), 20) &amp;lt;&amp;lt; endl;

find(vect.begin(), vect.end(), 5) != vect.end()?
cout &amp;lt;&amp;lt; &amp;quot;Element 5 found\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;Element 5 not found\n&amp;quot;;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二分查找指定元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回指向第一个不小于指定元素的迭代器(序列有序)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回指向第一个大于指定元素的迭代器(序列有序)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
sort(vect.begin(), vect.end());
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

auto q = lower_bound(vect.begin(), vect.end(), 20);
cout &amp;lt;&amp;lt; &amp;quot;The lower bound for 20 is at position: &amp;quot;;
cout &amp;lt;&amp;lt; q-vect.begin() &amp;lt;&amp;lt; endl;

auto p = upper_bound(vect.begin(), vect.end(), 20);
cout &amp;lt;&amp;lt; &amp;quot;The upper bound for 20 is at position: &amp;quot;;
cout &amp;lt;&amp;lt; p-vect.begin() &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;加工算法&#34;&gt;加工算法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过滤连续相等的元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator&amp;gt; ForwardIterator unique (ForwardIterator first, ForwardIterator last);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class BinaryPredicate&amp;gt; ForwardIterator unique (ForwardIterator first, ForwardIterator last, BinaryPredicate pred);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vect.erase(vect.begin()+1);
cout &amp;lt;&amp;lt; &amp;quot;\nVector after erasing the second element: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

sort(vect.begin(), vect.end());

cout &amp;lt;&amp;lt; &amp;quot;\nVector before removing duplicate occurrences: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vect.erase(unique(vect.begin(),vect.end()),vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after deleting duplicates: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回下一个置换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator&amp;gt; bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator, class Compare&amp;gt; bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回前一个置换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator&amp;gt; bool prev_permutation (BidirectionalIterator first, BidirectionalIterator last );&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator, class Compare&amp;gt; bool prev_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
cout &amp;lt;&amp;lt; &amp;quot;Given Vector is: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

next_permutation(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after performing next permutation: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

prev_permutation(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after performing prev permutation: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算迭代器之间的距离。用于查找下标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;包含在头文件 &lt;code&gt;iterator&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template&amp;lt;class InputIterator&amp;gt; typename iterator_traits&amp;lt;InputIterator&amp;gt;::difference_type distance (InputIterator first, InputIterator last);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);
vector&amp;lt;int&amp;gt; vect(arr, arr+n);

cout &amp;lt;&amp;lt; &amp;quot;Given Vector is: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nDistance between first to max element: &amp;quot; &amp;lt;&amp;lt; distance(vect.begin(), max_element(vect.begin(), vect.end())) &amp;lt;&amp;lt; endl;
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;有用的-array-算法&#34;&gt;有用的 Array 算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;以下算法在 C++11 开始支持&lt;/li&gt;
&lt;li&gt;测试序列是否都满足某个条件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool all_of (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测试序列是否存在一个元素满足某个条件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测试序列是否都不满足某个条件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拷贝序列元素

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class Size, class OutputIterator&amp;gt; OutputIterator copy_n (InputIterator first, Size n, OutputIterator result);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;存储增加的序列&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; void iota (ForwardIterator first, ForwardIterator last, T val);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
int arr1[] = {1, 2, 3, 4, 5, -6};
all_of(arr1, arr1+6, [](int x) {return x&amp;gt;0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;All are positive elments\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;Not all are positive elments\n&amp;quot;;
any_of(arr1, arr1+6, [](int x) {return x&amp;lt;0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;There exists a negative element\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;All are positive elments\n&amp;quot;;

int arr2[] = {1, 2, 3, 4, 5, 6};
none_of(arr2, arr2+6, [](int x) {return x&amp;lt;0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;No negative elements\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;There exists a negative element\n&amp;quot;;

int arrc[6];
copy_n(arr2, 6, arrc);
cout &amp;lt;&amp;lt; &amp;quot;Copyed array: &amp;quot;;
for_each(arrc, arrc+6, [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

int arr3[6] = {0};
iota(arr3, arr3+6, 20);
cout &amp;lt;&amp;lt; &amp;quot;Assigned array: &amp;quot;;
for_each(arr3, arr3+6, [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;划分操作&#34;&gt;划分操作&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;根据条件重排序列，返回第一个不满足条件的迭代器

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class UnaryPredicate&amp;gt; ForwardIterator partition (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据条件重排序列，且两组元素内部的相对顺序保持不变。一般是用临时缓冲区实现

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator, class UnaryPredicate&amp;gt; BidirectionalIterator stable_partition (BidirectionalIterator first, BidirectionalIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;判断序列是否是根据条件划分的

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool is_partitioned (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输入队列已经是分割过的，二分查找分界点

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class UnaryPredicate&amp;gt; ForwardIterator partition_point (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输入序列中满足条件和不满足条件的分别拷贝到两个序列中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class InputIterator, class OutputIterator1, class OutputIterator2, class UnaryPredicate pred&amp;gt; pair&amp;lt;OutputIterator1,OutputIterator2&amp;gt; partition_copy (InputIterator first, InputIterator last, OutputIterator1 result_true, OutputIterator2 result_false, UnaryPredicate pred);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
vector&amp;lt;int&amp;gt; vect1 = { 2, 1, 5, 6, 8, 7 };

cout &amp;lt;&amp;lt; &amp;quot;The vector is: &amp;quot;;
for_each(vect1.begin(), vect1.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

is_partitioned(vect1.begin(), vect1.end(), [](int i) {return i%2==0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;\nVector is partitioned&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;\nVector is not partitioned&amp;quot;;

partition(vect1.begin(), vect1.end(), [](int i){return i%2==0;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe partitioned vector is: &amp;quot;;
for_each(vect1.begin(), vect1.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

is_partitioned(vect1.begin(), vect1.end(), [](int i) {return i%2==0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;\nNow, vector is partitioned after partition operation&amp;quot;:
                cout &amp;lt;&amp;lt; &amp;quot;\nVector is still not partitioned after partition operation&amp;quot;;

vector&amp;lt;int&amp;gt; vect2 = { 2, 1, 5, 6, 8, 7 };
cout &amp;lt;&amp;lt; &amp;quot;\n\nThe vector is: &amp;quot;;
for_each(vect2.begin(), vect2.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

stable_partition(vect2.begin(), vect2.end(), [](int i) {return i%2==0;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe stable partitioned vector is: &amp;quot;;
for_each(vect2.begin(), vect2.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

auto it = partition_point(vect2.begin(), vect2.end(), [](int i) {return i%2==0;});
cout &amp;lt;&amp;lt; &amp;quot;\nBefore the partition point: &amp;quot;;
for_each(vect2.begin(), it, [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nAfter the partition point: &amp;quot;;
for_each(it, vect2.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vector&amp;lt;int&amp;gt; vect3 = { 2, 1, 5, 6, 8, 7 };
cout &amp;lt;&amp;lt; &amp;quot;\n\nThe vector is: &amp;quot;;
for_each(vect3.begin(), vect3.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vector&amp;lt;int&amp;gt; vecteven, vectodd;
int n = count_if(vect3.begin(), vect3.end(), [](int i) {return i%2==0;});
vecteven.resize(n);
vectodd.resize(vect3.size()-n);

partition_copy(vect3.begin(), vect3.end(), vecteven.begin(),
           vectodd.begin(), [](int i) {return i%2==0;});

cout &amp;lt;&amp;lt; &amp;quot;\nThe elements that return true for condition are : &amp;quot;;
for_each(vecteven.begin(), vecteven.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe elements that return false for condition are : &amp;quot;;
for_each(vectodd.begin(), vectodd.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;头文件-valarray&#34;&gt;头文件 valarray&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;valarray 类：C++98 引入的特殊容器，用于保存和提供对 array 的高效算术操作&lt;/li&gt;
&lt;li&gt;应用操作到所有的元素，返回一个新的 valarray

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;valarray apply (T func(T)) const;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;valarray apply (T func(const T&amp;amp;)) const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回所有元素的和

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T sum() const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回元素的最小值

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T min() const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回元素的最大值

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T max() const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将 valarray 的元素移位，返回新的 valarray。如果参数为正数，左移；否则右移

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;valarray shift (int n) const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将 valarray 的元素循环移位，返回新的 valarray。如果参数为正数，循环左移；否则循环右移

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;valarray cshift (int n) const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和另外一个 valarray 交换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;void swap (valarray&amp;amp; x) noexcept;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;valarray&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
valarray&amp;lt;int&amp;gt; varr1 = { 10, 2, 20, 1, 30 };
cout &amp;lt;&amp;lt; &amp;quot;The varr1 is: &amp;quot;;
for_each(begin(varr1), end(varr1), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe sum of varr1 is: &amp;quot; &amp;lt;&amp;lt; varr1.sum();
cout &amp;lt;&amp;lt; &amp;quot;\nThe max of varr1 is: &amp;quot; &amp;lt;&amp;lt; varr1.max();
cout &amp;lt;&amp;lt; &amp;quot;\nThe min of varr1 is: &amp;quot; &amp;lt;&amp;lt; varr1.min();

valarray&amp;lt;int&amp;gt; varr2;
varr2 = varr1.apply([](int i){return i=i+5;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr2 (varr1 add 5 for each element) is: &amp;quot;;
for_each(begin(varr2), end(varr2), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

valarray&amp;lt;int&amp;gt; varr3;
varr3 = varr1.shift(2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 shift 2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr3 = varr1.shift(-2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 shift -2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr3 = varr1.cshift(2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 cshift 2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr3 = varr1.cshift(-2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 cshift -2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

valarray&amp;lt;int&amp;gt; varr4 = {2, 4, 6, 8};
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr4 is: &amp;quot;;
for_each(begin(varr4), end(varr4), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr1.swap(varr4);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr4 after swap with varr1 is: &amp;quot;;
for_each(begin(varr4), end(varr4), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;容器是一个对象，保存了其他对象或对象元素的集合&lt;/li&gt;
&lt;li&gt;容器自己管理元素的存储空间，并且提供成员函数来访问元素，直接访问或通过迭代器访问&lt;/li&gt;
&lt;li&gt;容器类模板：包括顺序容器、容器适配器、关联容器和无序关联容器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;顺序容器&#34;&gt;顺序容器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;实现的数据结构可以按顺序访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;array&#34;&gt;array&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;C++11 引入，替换 C 风格数组。相比 C 风格数组的优点包括

&lt;ul&gt;
&lt;li&gt;array 知道自己的大小，因此传递参数时不需要单独传递 array 的大小&lt;/li&gt;
&lt;li&gt;C 风格的数组会有退化成指针的风险，但是 array 不会&lt;/li&gt;
&lt;li&gt;相比 C 风格数组，array 更加高效、轻量和可靠&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;at&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get&lt;/code&gt;：不是 array 的类成员函数，而是重载 tuple 类的函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;: 类似于 C 风格的数组访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;front/back&lt;/code&gt;：返回第一个/最后一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size/max_size&lt;/code&gt;：返回 array 的元素数目/可以承载的最大元素数目。二者返回值相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap&lt;/code&gt;：和另外一个 array 交换元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;empty&lt;/code&gt;：array 的大小是否是 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fill&lt;/code&gt;：使用指定值填充正哥 array&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;固定大小数组，顺序连续存储，可使用偏移量访问&lt;/li&gt;
&lt;li&gt;大小为 0 是有效的，但是不能间接引用，比如 front，back，data&lt;/li&gt;
&lt;li&gt;交换是按顺序交换每个元素，效率低&lt;/li&gt;
&lt;li&gt;可以当做 tuple（可以存储不同类型的元素的集合），重载了 get 接口等&lt;/li&gt;
&lt;li&gt;访问快，可使用偏移量访问，常数时间&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vector&#34;&gt;vector&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;大小可变数组，顺序连续存储，可使用偏移量访问&lt;/li&gt;
&lt;li&gt;一开始分配额外的存储空间，容量一般不等于实际大小&lt;/li&gt;
&lt;li&gt;使用动态分配数组存储元素，插入元素时可能需要重新分配数组，将所有元素移到新的数组，效率低&lt;/li&gt;
&lt;li&gt;访问快，和 array 一样，在尾部插入和删除也快。删除元素是常数时间，不会重新调整大小&lt;/li&gt;
&lt;li&gt;在其他位置插入和删除低效，需要线性时间。没有随机访问迭代器&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;deque&#34;&gt;deque&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;双端队列，顺序存储，可在两端增加或减小大小&lt;/li&gt;
&lt;li&gt;可用随机访问迭代器直接访问单个元素&lt;/li&gt;
&lt;li&gt;vs vector

&lt;ul&gt;
&lt;li&gt;存储可以是不连续的块，在容器增加或减小时内存分配效率更高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;forward-list&#34;&gt;forward_list&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;C++11 引入&lt;/li&gt;
&lt;li&gt;顺序存储，在任意位置插入和删除都是常数时间&lt;/li&gt;
&lt;li&gt;单向链表，存储位置可以是不同的没有关系的&lt;/li&gt;
&lt;li&gt;vs array/vector/deque

&lt;ul&gt;
&lt;li&gt;list 和 forward_list 的插入、删除更有效，对于排序算法也更快（交换更快）&lt;/li&gt;
&lt;li&gt;list 和 forward_list 没有根据位置直接访问元素的方法，同时每个节点需要额外的存储存储链接的相关信息&lt;/li&gt;
&lt;li&gt;list 和 forward_list 遍历较慢&lt;/li&gt;
&lt;li&gt;list 和 forward_list 没有 size 方法，因为很耗时，可以使用 distance 算法（包含在头文件&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;）计算 begin 和 end 之间的距离，消耗时间是线性的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;list&#34;&gt;list&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;li&gt;forward_list vs list： 前者只存储一个指向后面对象的链接，后者存储两个链接分别指向前一个和后一个对象，因此两个方向的迭代都比较搞笑，但同时每个节点需要额外的存储，且插入和删除也有额外的时间负载&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不完全是容器类，而是依赖某一个容器类提供特定的接口，封装之后提供不同于顺序容器的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;stack&#34;&gt;stack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;后进先出（LIFO），使用标准的容器（vector/deque/list）类模板实现接口，如果初始化未指定容器类，则使用 deque 实现相关接口&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;std::stack&amp;lt;int, std::vector&amp;lt;int&amp;gt; &amp;gt; mystack&lt;/code&gt;使用 vector 实现的空的 stack&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;queue&#34;&gt;queue&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;先进先出（FIFO）队列，使用标准的容器（deque/list）类模板实现接口，默认使用 deque&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;std::queue&amp;lt;int, std::list&amp;lt;int&amp;gt; &amp;gt; myqueue&lt;/code&gt;使用 list 实现的空的 queue&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;priority-queue&#34;&gt;priority_queue&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;依据严格的弱排序（strict weak ordering）标准第一个元素总是最大的元素，所有元素是非增序的&lt;/li&gt;
&lt;li&gt;使用标准的容器（vector/deque）类模板实现接口，，默认是 vector&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ 默认为 priority_queue 创建最大堆&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

void showpq(priority_queue&amp;lt;int&amp;gt; &amp;amp;gq)
{
priority_queue&amp;lt;int&amp;gt; g = gq;
while (!g.empty())
{
    cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; g.top();
    g.pop();
}
cout &amp;lt;&amp;lt; endl;
}

int main ()
{
priority_queue&amp;lt;int&amp;gt; gquiz;
gquiz.push(10);
gquiz.push(30);
gquiz.push(20);
gquiz.push(5);
gquiz.push(1);

cout &amp;lt;&amp;lt; &amp;quot;The priority queue gquiz is: &amp;quot;;
showpq(gquiz);

cout &amp;lt;&amp;lt; &amp;quot;gquiz.size(): &amp;quot; &amp;lt;&amp;lt; gquiz.size() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;gquiz.top(): &amp;quot; &amp;lt;&amp;lt; gquiz.top() &amp;lt;&amp;lt; endl;

gquiz.pop();
cout &amp;lt;&amp;lt; &amp;quot;after gquiz.pop(): &amp;quot;;
showpq(gquiz);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为 priority_queue 创建最小堆 &lt;code&gt;priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; g=gq;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下面的语法难记，因此对于数字的值，可以给每个元素乘以 -1，然后使用最大值堆达到最小值堆的效果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

void showpq(priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; &amp;amp;gq)
{
priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; g = gq;
while(!g.empty())
{
cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; g.top();
g.pop();
}
cout &amp;lt;&amp;lt; endl;
}

int main ()
{
priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; gquiz;
gquiz.push(10);
gquiz.push(30);
gquiz.push(20);
gquiz.push(5);
gquiz.push(1);

cout &amp;lt;&amp;lt; &amp;quot;The priority queue gquiz is: &amp;quot;;
showpq(gquiz);

cout &amp;lt;&amp;lt; &amp;quot;gquiz.size(): &amp;quot; &amp;lt;&amp;lt; gquiz.size() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;gquiz.top(): &amp;quot; &amp;lt;&amp;lt; gquiz.top() &amp;lt;&amp;lt; endl;

gquiz.pop();
cout &amp;lt;&amp;lt; &amp;quot;after gquiz.pop(): &amp;quot;;
showpq(gquiz);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关联容器&#34;&gt;关联容器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;实现排好序的数据结构，可以达到快速查询的时间复杂度 O(logn)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;set&#34;&gt;set&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;保存的值都是唯一的，不能修改，只能插入或删除，key 和 value 相同&lt;/li&gt;
&lt;li&gt;存储的元素总是依照严格的弱排序标准排序，通过内部的比较对象&lt;/li&gt;
&lt;li&gt;在通过 key 访问单个元素的时候通常比 unordered_set 慢，但是可以访问有序集合的一个子集&lt;/li&gt;
&lt;li&gt;通常实现为二分搜索树&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;multiset&#34;&gt;multiset&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以存储相同值的元素&lt;/li&gt;
&lt;li&gt;在通过 key 访问的那个元素的时候比 unordered_multiset 慢&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;map&#34;&gt;map&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;关联容器，存储的对象包括一个 key 和映射的 value&lt;/li&gt;
&lt;li&gt;通过 key 排序和标记唯一元素，存储的元素总是依照严格的弱排序标准排序，通过内部的比较对象&lt;/li&gt;
&lt;li&gt;在通过 key 访问单个元素的时候通常比 unordered_map 慢，但是可以访问有序集合的一个子集&lt;/li&gt;
&lt;li&gt;通常实现为二分搜索树&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;multimap&#34;&gt;multimap&lt;/h4&gt;

&lt;h3 id=&#34;无序关联容器&#34;&gt;无序关联容器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;实现无序数据结构，可以快速查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;unordered-set&#34;&gt;unordered_set&lt;/h4&gt;

&lt;h4 id=&#34;unordered-multiset&#34;&gt;unordered_multiset&lt;/h4&gt;

&lt;h4 id=&#34;unordered-map&#34;&gt;unordered_map&lt;/h4&gt;

&lt;h4 id=&#34;unordered-multimap&#34;&gt;unordered_multimap&lt;/h4&gt;

&lt;h2 id=&#34;仿函数&#34;&gt;仿函数&lt;/h2&gt;

&lt;h2 id=&#34;迭代器&#34;&gt;迭代器&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/cpp-stl-tutorial/&#34; target=&#34;_blank&#34;&gt;C++ STL Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/the-c-standard-template-library-stl/&#34; target=&#34;_blank&#34;&gt;The C++ Standard Template Library (STL)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikibooks.org/wiki/C%2B%2B/STL/Algorithm&#34; target=&#34;_blank&#34;&gt;C++/STL/Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikibooks.org/wiki/C%2B%2B/Numeric&#34; target=&#34;_blank&#34;&gt;C++/Numeric&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>STL 的 push 和 emplace</title>
      <link>https://xueqing.github.io/blog/cplusplus/stl_push_emplace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/stl_push_emplace/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdqueueemplace&#34;&gt;std::queue::emplace&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stddequeemplaceback&#34;&gt;std::deque::emplace_back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdallocatortraitsconstruct&#34;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdallocator&#34;&gt;std::allocator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stddequeallocator&#34;&gt;std::deque::allocator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdqueuepush&#34;&gt;std::queue::push&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stddequepushback&#34;&gt;std::deque::push_back&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdvector-%e7%9a%84-emplaceback-%e5%92%8c-pushback&#34;&gt;std::vector 的 emplace_back 和 push_back&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%ba%a7%e7%94%9f%e6%97%b6%e9%97%b4&#34;&gt;产生时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%8d%e6%ad%a2-1-%e4%b8%aa&#34;&gt;类型的构造函数不止 1 个&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%88%e7%8e%87&#34;&gt;效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdmap-%e7%9a%84-emplace-%e5%92%8c-insert&#34;&gt;std::map 的 emplace 和 insert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96%e5%8f%82%e8%80%83&#34;&gt;其他参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;下面的说明以 STL 的 queue 为实例，其他 STL 还有 push_back/emplace_back 等，各自的影响不尽相同

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/&#34; target=&#34;_blank&#34;&gt;deque&lt;/a&gt;: emplace/emplace_back/emplace_front/insert/push_back/push_front&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/forward_list/forward_list/&#34; target=&#34;_blank&#34;&gt;forward_list&lt;/a&gt;: emplace_after/emplace_front/insert_after/push_front&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/list/list/&#34; target=&#34;_blank&#34;&gt;list&lt;/a&gt;: emplace/emplace_back/emplace_front/insert/push_back/push_front&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/map/map/&#34; target=&#34;_blank&#34;&gt;map&lt;/a&gt;: emplace/emplace_hint/insert&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/queue/queue/&#34; target=&#34;_blank&#34;&gt;queue&lt;/a&gt;: emplace/push&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/set/set/&#34; target=&#34;_blank&#34;&gt;set&lt;/a&gt;: emplace/emplace_hint/insert&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/stack/stack/&#34; target=&#34;_blank&#34;&gt;stack&lt;/a&gt;: emplace/push&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/vector/vector/&#34; target=&#34;_blank&#34;&gt;vector&lt;/a&gt;: emplace/emplace_back/insert/push_back&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-queue-emplace&#34;&gt;std::queue::emplace&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/queue/queue/emplace/&#34; target=&#34;_blank&#34;&gt;std::queue::emplace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;： &lt;code&gt;template &amp;lt;class... Args&amp;gt; void emplace (Args&amp;amp;&amp;amp;... args);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;args：被传递作为新元素构造函数的参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：构造并插入一个元素。增加新元素到 queue 的末尾，即当前最后一个元素之后。将传入的参数作为新元素的构造函数的参数。&lt;/li&gt;
&lt;li&gt;底层容器对象调用 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/emplace_back/&#34; target=&#34;_blank&#34;&gt;emplace_back&lt;/a&gt;，并传递参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;std-deque-emplace-back&#34;&gt;std::deque::emplace_back&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/emplace_back/&#34; target=&#34;_blank&#34;&gt;std::deque::emplace_back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;template &amp;lt;class... Args&amp;gt; void emplace_back (Args&amp;amp;&amp;amp;... args);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;args：被传递作为新元素构造函数的参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：构造并在末尾插入一个元素。增加新元素到 deque 的末尾，即当前最后一个元素之后。将传入的参数作为新元素的构造函数的参数。&lt;/li&gt;
&lt;li&gt;这个操作将容器大小高效增加 1&lt;/li&gt;
&lt;li&gt;元素通过调用 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator_traits/construct/&#34; target=&#34;_blank&#34;&gt;std::allocator_traits::construct&lt;/a&gt; 和参数构造。

&lt;ul&gt;
&lt;li&gt;新元素的存储通过 &lt;code&gt;allocator_traits&amp;lt;allocator_type&amp;gt;::construct()&lt;/code&gt; 分配，失败时可能会抛异常(对于默认的 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator/&#34; target=&#34;_blank&#34;&gt;std::allocator&lt;/a&gt;，分配失败会抛 bad_alloc 异常)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迭代器有效性&lt;/strong&gt;：容器相关的所有迭代器无效，但是指针和引用是有效的，和调用函数之前指向的元素相同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常安全性&lt;/strong&gt;：强保证。如果抛出异常，则容器没有改变。如果 &lt;code&gt;std::allocator_traits::construct&lt;/code&gt; 对于传递的参数不支持，会导致未定义的行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;std-allocator-traits-construct&#34;&gt;std::allocator_traits::construct&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator_traits/construct/&#34; target=&#34;_blank&#34;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;静态成员函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;template &amp;lt;class T, class... Args&amp;gt; static void construct (allocator_type alloc, T* p, Args&amp;amp;&amp;amp;... args );&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：构造一个元素。在指针 p 指向的位置传递参数给构造函数构造一个元素对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：对象被 in-place 构造，而不用为元素分配存储。如果不可行，则调用 &lt;code&gt;::new (static_cast&amp;lt;void*&amp;gt;(p)) T (forward&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;std-allocator&#34;&gt;std::allocator&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator/&#34; target=&#34;_blank&#34;&gt;std::allocator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;template &amp;lt;class T&amp;gt; class allocator;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;T：对象分配的元素类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：默认分配器。

&lt;ul&gt;
&lt;li&gt;分配器：定义内存模型的类，被标准库的一些部分使用，大多数情况是被 STL 容器使用。&lt;/li&gt;
&lt;li&gt;allocator 是默认分配器模板，这是所有标准容器未指定最后一个(可选的)模板参数时会使用的分配器，也是标准库中唯一一个预定义的分配器。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;std-deque-allocator&#34;&gt;std::deque::allocator&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;参考&lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/get_allocator/&#34; target=&#34;_blank&#34;&gt;std::deque::get_allocator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;allocator_type get_allocator() const noexcept;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;allocator_type：是容器使用的分配器的类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：返回和 deque 对象相关的分配器对象的拷贝。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常安全性&lt;/strong&gt;：保证没有异常。拷贝默认分配器的任何实例也保存不会抛异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-queue-push&#34;&gt;std::queue::push&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/queue/queue/push/&#34; target=&#34;_blank&#34;&gt;std::queue::push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;void push (const value_type&amp;amp; val);&lt;/code&gt;或&lt;code&gt;void push (value_type&amp;amp;&amp;amp; val);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;val：经过初始化的新插入元素的值&lt;/li&gt;
&lt;li&gt;value_type：是容器元素的类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：插入一个新元素到 queue 末尾，即当前最后一个元素之后。新元素的内容被初始化为 &lt;code&gt;val&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;底层容器对象调用 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/push_back/&#34; target=&#34;_blank&#34;&gt;push_back&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;std-deque-push-back&#34;&gt;std::deque::push_back&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/push_back/&#34; target=&#34;_blank&#34;&gt;std::deque::push_back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;void push_back (const value_type&amp;amp; val);&lt;/code&gt;或&lt;code&gt;void push_back (value_type&amp;amp;&amp;amp; val);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;val：将要拷贝或移动给新对象的值&lt;/li&gt;
&lt;li&gt;value_type：是容器元素的类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新元素的存储通过容器的 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/get_allocator/&#34; target=&#34;_blank&#34;&gt;allocator&lt;/a&gt; 分配，失败时可能会抛异常(对于默认的&lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator/&#34; target=&#34;_blank&#34;&gt;std::allocator&lt;/a&gt;，分配失败会抛 bad_alloc 异常)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迭代器有效性&lt;/strong&gt;：容器相关的所有迭代器无效，但是指针和引用是有效的，和调用函数之前指向的元素相同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常安全性&lt;/strong&gt;：强保证。如果抛出异常，则容器没有改变。如果 &lt;code&gt;std::allocator_traits::construct&lt;/code&gt; 对于传递的参数不支持，会导致未定义的行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-vector-的-emplace-back-和-push-back&#34;&gt;std::vector 的 emplace_back 和 push_back&lt;/h2&gt;

&lt;h3 id=&#34;产生时间&#34;&gt;产生时间&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;push_back 是标准 C++ 创建之初就有的；emplace_back 是在 C++11 特性前提下增加的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;类型的构造函数不止-1-个&#34;&gt;类型的构造函数不止 1 个&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当类型的构造函数不止 1 个时：push_back 只接收类型的对象，emplace_back 接收类型构造函数的参数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ 11 支持从参数构造对象，因此当类型的构造函数参数只有一个时，push_back 可以传入构造函数参数，C++ 11 会构造对象，并传递对象给容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class OneParam
{
int m_i;
public:
OneParam(int ii) : m_i(ii) { cout &amp;lt;&amp;lt; &amp;quot;OneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
OneParam(const OneParam &amp;amp;copy) : m_i(copy.m_i) { cout &amp;lt;&amp;lt; &amp;quot;OneParam::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~OneParam( ) { cout &amp;lt;&amp;lt; &amp;quot;~OneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }

int get() const { return m_i; }
};

class MoreThanOneParam
{
int m_i;
string m_s;
public:
MoreThanOneParam(int ii, string s) : m_i(ii), m_s(s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
MoreThanOneParam(const MoreThanOneParam &amp;amp;copy) : m_i(copy.m_i), m_s(copy.m_s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~MoreThanOneParam( ) { cout &amp;lt;&amp;lt; &amp;quot;~MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }

int getInt() const { return m_i; }
string getString() const { return m_s; }
};

int main( )
{
vector&amp;lt;OneParam&amp;gt; vec1={ 21 , 45 }; //对于每个元素，构造一次，拷贝一次，析构一次
vec1.push_back( OneParam(34) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec1.push_back( 901 ); //构造一次，拷贝一次，析构一次
vec1.emplace_back( OneParam(7889) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec1.emplace_back( 4156 ); //构造一次
//21; 45; 34; 901; 7889; 4156;
for( auto &amp;amp;elem:vec1 ) { cout &amp;lt;&amp;lt; elem.get() &amp;lt;&amp;lt; &amp;quot;; &amp;quot;; } //21; 45; 34; 901; 7889; 4156;
cout &amp;lt;&amp;lt; endl;

vector&amp;lt;MoreThanOneParam&amp;gt; vec2={ {21,&amp;quot;String&amp;quot;} , MoreThanOneParam{45 , &amp;quot;tinger&amp;quot;} }; //对于每个元素，构造一次，拷贝一次，析构一次
vec2.push_back( MoreThanOneParam(34 , &amp;quot;Happy&amp;quot; ) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
//    vec2.push_back( 901 , &amp;quot;Doer&amp;quot; ); //Error!!
vec2.emplace_back( MoreThanOneParam(78 , &amp;quot;Gomu gomu&amp;quot; )); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec2.emplace_back( 41 , &amp;quot;Shanks&amp;quot; ); //构造一次
//21 String; 45 tinger; 34 Happy; 78 Gomu gomu; 41 Shanks;
for( auto &amp;amp;elem:vec2 ) { cout &amp;lt;&amp;lt; elem.getInt( ) &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; elem.getString( ) &amp;lt;&amp;lt; &amp;quot;; &amp;quot;; }
cout &amp;lt;&amp;lt; endl;

cin.get( );
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;效率&#34;&gt;效率&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;这里的效率指的是：代码工作更快，生成的负载更小&lt;/li&gt;
&lt;li&gt;当 vector 的类型是内置类型时，push_back 和 emplace_back 没有区别&lt;/li&gt;
&lt;li&gt;当 vector 的类型是用户自定义类型时，emplace_back 比 push_back 更高效

&lt;ul&gt;
&lt;li&gt;当尝试直接添加对象 (在对象被创建之前) 到 vector，使用 push_back 的流程是&lt;/li&gt;
&lt;li&gt;调用构造函数创建临时对象&lt;/li&gt;
&lt;li&gt;在 vector 中创建临时对象的拷贝&lt;/li&gt;
&lt;li&gt;拷贝对象完成之后，调用析构函数销毁临时对象&lt;/li&gt;
&lt;li&gt;使用 emplace_back 将不会创建临时对象，而是直接在 vector 中创建对象。因此提高了性能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-map-的-emplace-和-insert&#34;&gt;std::map 的 emplace 和 insert&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;insert 需要先创建临时对象，然后拷贝到 &lt;code&gt;std::pair&amp;lt;key, val&amp;gt;&lt;/code&gt; 中，再将 pair 拷贝到 map 中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Complicated
{
int m_i;
double m_d;
string m_s;
public:
Complicated(int i, double d, string s) : m_i(i), m_d(d), m_s(s) { cout &amp;lt;&amp;lt; &amp;quot;Complicated::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
Complicated(const Complicated &amp;amp;copy) : m_i(copy.m_i), m_d(copy.m_d), m_s(copy.m_s) { cout &amp;lt;&amp;lt; &amp;quot;Complicated::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~Complicated() { cout &amp;lt;&amp;lt; &amp;quot;~Complicated::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
};

int main()
{
map&amp;lt;int, Complicated&amp;gt; m;

m.insert( make_pair(4, Complicated(4, 4.0, &amp;quot;C++4&amp;quot;)) ); //构造一次，拷贝两次，析构两次
m.insert( 5, {5, 5.0, &amp;quot;C++5&amp;quot;} ); //构造一次，拷贝两次，析构两次
m.insert( pair&amp;lt;int, Complicated&amp;gt;(7, {7, 7.0, &amp;quot;C++7&amp;quot;}) ); //构造一次，拷贝两次，析构两次
m.emplace( piecewise_construct, forward_as_tuple(6), forward_as_tuple(6, 6.0, &amp;quot;C++6&amp;quot;) ); //构造一次

//4; 5; 6; 7;
for( auto &amp;amp;elem:m )  cout &amp;lt;&amp;lt; elem.first &amp;lt;&amp;lt; &amp;quot;; &amp;quot;;
cout &amp;lt;&amp;lt; endl;

cin.get();
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他参考&#34;&gt;其他参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://candcplusplus.com/c-difference-between-emplace_back-and-push_back-function&#34; target=&#34;_blank&#34;&gt;C++ difference between emplace_back and push_back function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>string</title>
      <link>https://xueqing.github.io/blog/cplusplus/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/string/</guid>
      <description>

&lt;h2 id=&#34;find-vs-find-first-of&#34;&gt;find vs find_first_of&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;find 函数原型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// c++11
string (1)    size_t find (const string&amp;amp; str, size_t pos = 0) const noexcept;
c-string (2)  size_t find (const char* s, size_t pos = 0) const;
buffer (3)    size_t find (const char* s, size_t pos, size_type n) const;
character (4) size_t find (char c, size_t pos = 0) const noexcept;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find_first_of 函数原型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// c++11
string (1)    size_t find_first_of (const string&amp;amp; str, size_t pos = 0) const noexcept;
c-string (2)  size_t find_first_of (const char* s, size_t pos = 0) const;
buffer (3)    size_t find_first_of (const char* s, size_t pos, size_t n) const;
character (4) size_t find_first_of (char c, size_t pos = 0) const noexcept;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对比&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;find：匹配查找整个字符串&lt;/li&gt;
&lt;li&gt;find_first_of：匹配查找指定参数的&lt;strong&gt;任意一个&lt;/strong&gt;字符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Stringers</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/stringer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/stringer/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Stringers
Make the IPAddr type implement fmt.Stringer to print the address as a dotted quad.

For instance, IPAddr{1, 2, 3, 4} should print as &amp;quot;1.2.3.4&amp;quot;.
*/

package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;strconv&amp;quot;
  &amp;quot;strings&amp;quot;
)

type iPAddr [4]byte

func (ip iPAddr) String() string {
  arr := []string{&amp;quot;0&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;0&amp;quot;}
  for i := 0; i &amp;lt; 4; i++ {
    arr[i&amp;lt;&amp;lt;1] = strconv.Itoa(int(ip[i]))
  }
  sip := strings.Join(arr, &amp;quot;&amp;quot;)
  return sip
}

func main() {
  hosts := map[string]iPAddr{
    &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
    &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
  }
  for name, ip := range hosts {
    fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, name, ip)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>testing 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/testing/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b%e5%87%bd%e6%95%b0&#34;&gt;示例函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b7%b3%e8%bf%87%e6%b5%8b%e8%af%95&#34;&gt;跳过测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%90%e6%b5%8b%e8%af%95%e9%a1%b9%e7%9b%ae%e5%92%8c%e5%ad%90%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;子测试项目和子基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#main&#34;&gt;Main&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95&#34;&gt;索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%8b%e5%ad%90&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%90%e7%9b%ae%e5%bd%95&#34;&gt;子目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/testing/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;testing&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;testing 包提供对 Go 包的自动测试。它适用于和 &lt;code&gt;go test&lt;/code&gt; 命令协作，自动执行下面格式的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestXxx(*testing.T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，Xxx 不是小写字母开头。这个函数名用于识别测试代码。&lt;/p&gt;

&lt;p&gt;在这些函数中，使用 Error、Fail 或相关的方法来标记失败。&lt;/p&gt;

&lt;p&gt;要写一个新的测试集，新建一个文件以 _test.go 结尾，其中包含上述的 TestXxx 函数。将此文件放在将要测试的同一包中。正常的包编译不会包含此文件，但是运行 &lt;code&gt;go test&lt;/code&gt; 命令时会包含。查看更多细节，运行 &lt;code&gt;go help test&lt;/code&gt; 和 &lt;code&gt;go help testflag&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一个简单的功能测试函数看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestAbs(t testing.T) {
  got := Abs(-1)
  if got != 1 {
    t.Errorf(&amp;quot;Abs(-1) = %d; want 1&amp;quot;, got)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基准测试&#34;&gt;基准测试&lt;/h3&gt;

&lt;p&gt;下面格式的函数被当做基准测试，并且当 &lt;code&gt;go test&lt;/code&gt; 命令提供 -bench 标记时会执行此函数。基准测试是顺序执行的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkXxxx(*testing.B)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对 testing 标记的描述，查看 &lt;a href=&#34;../command/test_flag.md&#34;&gt;Testing flags&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个简单的基准测试函数看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkHello(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        fmt.Sprintf(&amp;quot;hello&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基准测试函数必须运行目标代码 b.N 次。在执行基准测试期间，会调整 b.N 直到基准测试函数持续时间足够长，认为是时间可靠的。输出 &lt;code&gt;BenchmarkHello    10000000    282 ns/op&lt;/code&gt; 意味着这个循环以每次循环 282 纳秒的速度运行了 10000000 次。&lt;/p&gt;

&lt;p&gt;如果一个基准测试在运行之前需要一些耗时的设置，可重置定时器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkBigLen(b *testing.B) {
    big := NewBig()
    b.ResetTimer()
    for i := 0; i &amp;lt; b.N; i++ {
        big.Len()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个基准测试需要并行测试性能，可以使用 RunParallel 辅助函数；这样的基准测试适用于和 go test -cpu 标识一起使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkTemplateParallel(b *testing.B) {
    templ := template.Must(template.New(&amp;quot;test&amp;quot;).Parse(&amp;quot;Hello, {{.}}!&amp;quot;))
    b.RunParallel(func(pb *testing.PB) {
        var buf bytes.Buffer
        for pb.Next() {
            buf.Reset()
            templ.Execute(&amp;amp;buf, &amp;quot;World&amp;quot;)
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例函数&#34;&gt;示例函数&lt;/h3&gt;

&lt;p&gt;testing 包也会运行和验证示例代码。示例函数可以包含一个总结性的行注释，以 “Output:” 开头，并且运行测试的是和这个函数的标准输出比较。(这个比较忽视开始和末尾的空格)。下面是一个示例代码的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExampleHello() {
    fmt.Println(&amp;quot;hello&amp;quot;)
    // Output: hello
}

func ExampleSalutations() {
    fmt.Println(&amp;quot;hello, and&amp;quot;)
    fmt.Println(&amp;quot;goodbye&amp;quot;)
    // Output:
    // hello, and
    // goodbye
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释前缀 “Unordered output:” 类似于 “Output:”，但是匹配任意的行顺序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExamplePerm() {
    for _, value := range Perm(4) {
        fmt.Println(value)
    }
    // Unordered output: 4
    // 2
    // 1
    // 3
    // 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有输出注释的示例函数被编译但是不会被执行。&lt;/p&gt;

&lt;p&gt;声明包、函数 F、类型 T 和作用于类型 T 的方法 M 的示例函数的命名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Example() { ... }
func ExampleF() { ... }
func ExampleT() { ... }
func ExampleT_M() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可通过增加一个不同的后缀到函数名字后面以支持对于一个包/类型/函数/方法的多个示例函数。后缀必须以小写字母开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Example_suffix() { ... }
func ExampleF_suffix() { ... }
func ExampleT_suffix() { ... }
func ExampleT_M_suffix() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当文件包含一个单独的示例函数，及至少一个其他的函数、类型、变量或常数声明，且没有功能测试函数或者基准测试函数时，整个测试文件作为例子显示。&lt;/p&gt;

&lt;h3 id=&#34;跳过测试&#34;&gt;跳过测试&lt;/h3&gt;

&lt;p&gt;可在运行时调用 *T 或 *B 的 Skip 方法跳过功能测试或基准测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTimeConsuming(t *testing.T) {
    if testing.Short() {
        t.Skip(&amp;quot;skipping test in short mode.&amp;quot;)
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;子测试项目和子基准测试&#34;&gt;子测试项目和子基准测试&lt;/h3&gt;

&lt;p&gt;T 和 B 的 Run 方法允许定义子测试项目和子基准测试，而不需要为每个子测试项目和子基准测试定义另外的函数。这使能使用类似表驱动的基准测试和创建分级测试。它也提供了一种方式来共享共用的设置和终止代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestFoo(t *testing.T) {
    // &amp;lt;setup code&amp;gt;
    t.Run(&amp;quot;A=1&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;A=2&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;B=1&amp;quot;, func(t *testing.T) { ... })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个子测试项目和子基准测试有一个唯一的名字：结合顶层测试的名字以及传递给 Run 的名字的顺序，由斜线分隔，以及一个可选的尾随的序号以消除歧义。&lt;/p&gt;

&lt;p&gt;传递给 -run 和 -bench 命令行标识符的参数是一个不固定的正则表达式，匹配了测试的名字。参数是多个斜线分隔的元素时，比如子测试，参数是自身(斜线分隔)；表达式匹配每个名字元素。因为是不固定的，一个空的表达式匹配任意字符串。比如，使用 “matching” 表达 “谁的名字包含”：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go test -run &#39;&#39;      # Run all tests.
go test -run Foo     # Run top-level tests matching &amp;quot;Foo&amp;quot;, such as &amp;quot;TestFooBar&amp;quot;.
go test -run Foo/A=  # For top-level tests matching &amp;quot;Foo&amp;quot;, run subtests matching &amp;quot;A=&amp;quot;.
go test -run /A=1    # For all top-level tests, run subtests matching &amp;quot;A=1&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子测试也可用于控制并行度。一个父测试只有在其子测试完成时才会完成。在这个例子中，所有测试去其他测试并行运行，且只与其他测试并行，而与可能定义的其他顶层测试无关。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestGroupedParallel(t *testing.T) {
    for _, tc := range tests {
        tc := tc // capture range variable
        t.Run(tc.Name, func(t *testing.T) {
            t.Parallel()
            // ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当程序超过 8192 个并行 goroutine 时，竞争检测器会杀掉程序，因此当运行并行测试且设置了 -race 标识时需要注意。&lt;/p&gt;

&lt;p&gt;Run 只有在并行子测试结束才会返回，为一组并行测试之后的资源清理提供了一种方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTeardownParallel(t *testing.T) {
    // This Run will not return until the parallel tests finish.
    t.Run(&amp;quot;group&amp;quot;, func(t *testing.T) {
        t.Run(&amp;quot;Test1&amp;quot;, parallelTest1)
        t.Run(&amp;quot;Test2&amp;quot;, parallelTest2)
        t.Run(&amp;quot;Test3&amp;quot;, parallelTest3)
    })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;main&#34;&gt;Main&lt;/h3&gt;

&lt;p&gt;测试程序有时需要在测试之前或之后做一些额外的设置和清理。并且，测试程序有时需要控制哪些代码运行在主线程。为了满足这些需求和其他的场景，一个测试文件可以包含一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestMain(m *testing.M)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，生成的测试会调用 TestMain(m) 而不是直接运行测试。TestMain 在主的 goroutine 运行，且可以做调用 m.Run 前后所需的所有设置和清理。然后，它应该使用 m.Run 的结果调用 OS.Exit。当调用 TestMain 时，flag.Parse 还没有运行。如果 TestMain(包括这些测试包) 依赖命令行标识，应该显式调用 flag.Parse。&lt;/p&gt;

&lt;p&gt;一个简单的 TestMain 的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestMain(m *testing.M) {
    // call flag.Parse() here if TestMain uses flags
    os.Exit(m.Run())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/#pkg-examples&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;子目录&#34;&gt;子目录&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;概述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;iotest.md&#34; target=&#34;_blank&#34;&gt;iotest&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了主要用于 testing 的 Reader 和 Writer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;quick.md&#34; target=&#34;_blank&#34;&gt;quick&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了帮助黑盒测试的工具函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>using 关键字</title>
      <link>https://xueqing.github.io/blog/cplusplus/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/using/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%af%b9%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e7%9a%84-using-%e6%8c%87%e4%bb%a4&#34;&gt;1 对命名空间的 using 指令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4&#34;&gt;命名空间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-%e6%8c%87%e4%bb%a4&#34;&gt;using 指令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e5%af%b9%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e6%88%90%e5%91%98%e7%9a%84-using-%e5%a3%b0%e6%98%8e&#34;&gt;2 对命名空间成员的 using 声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e5%af%b9%e7%b1%bb%e6%88%90%e5%91%98%e7%9a%84-using-%e5%a3%b0%e6%98%8e&#34;&gt;3 对类成员的 using 声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d%e4%b8%8e%e5%88%ab%e5%90%8d%e6%a8%a1%e6%9d%bf%e5%a3%b0%e6%98%8e&#34;&gt;4 类型别名与别名模板声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-对命名空间的-using-指令&#34;&gt;1 对命名空间的 using 指令&lt;/h2&gt;

&lt;h3 id=&#34;命名空间&#34;&gt;命名空间&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;命名空间提供了在大项目中避免名字冲突的一种方法。&lt;/li&gt;
&lt;li&gt;声明于命名空间块内的符号被放入一个具名的作用域中，避免这些符号被误认为其他作用域中的同名符号。&lt;/li&gt;
&lt;li&gt;允许具有相同名字的多个命名空间块。这些块中的所有声明声明于该具名作用域。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;using-指令&#34;&gt;using 指令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;attr(可选) using namespace 嵌套名说明符(可选) 命名空间名;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;attr(C++11)：应用到此 using 指令的任意数量的属性&lt;/li&gt;
&lt;li&gt;嵌套名说明符：名字与作用域解析运算符 &lt;code&gt;::&lt;/code&gt; 的序列，以作用域解析运算符结束。单个 &lt;code&gt;::&lt;/code&gt; 代表全局命名空间&lt;/li&gt;
&lt;li&gt;命名空间名：命名空间名。查找此名时，查找只考虑命名空间声明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从 using 指令之后到指令出现的作用域结尾为止，以对任何名字的无限定名字查找的视点来说，来自 &lt;code&gt;命名空间名&lt;/code&gt; 的任何名字均可见，如同它声明于同时含有该 using 指令和 &lt;code&gt;命名空间名&lt;/code&gt; 两者的最接近外围命名空间作用域一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-对命名空间成员的-using-声明&#34;&gt;2 对命名空间成员的 using 声明&lt;/h2&gt;

&lt;h2 id=&#34;3-对类成员的-using-声明&#34;&gt;3 对类成员的 using 声明&lt;/h2&gt;

&lt;h2 id=&#34;4-类型别名与别名模板声明&#34;&gt;4 类型别名与别名模板声明&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/keyword/using&#34; target=&#34;_blank&#34;&gt;C++ keywords: using&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vector 的 resize 和 reserve</title>
      <link>https://xueqing.github.io/blog/cplusplus/vector_resize_reserve/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/vector_resize_reserve/</guid>
      <description>

&lt;h2 id=&#34;resize&#34;&gt;resize&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;原型

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void resize (size_type n);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void resize (size_type n, const value_type&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;resize 方法(传递参数来构造是一样的)调整容器大小使得包含 n 个元素

&lt;ul&gt;
&lt;li&gt;如果当前大小大于 n，会从尾部删除多余的元素&lt;/li&gt;
&lt;li&gt;如果当前大小小于 n，会在尾部插入适量的元素到 vector 达到指定的大小(有第二个可选参数指定元素的值)。如果指定值，新元素初始化为 val 的拷贝，否则使用默认构造函数初始化&lt;/li&gt;
&lt;li&gt;如果当前容量(capacity) 小于 n，需要重新分配内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;它会影响 &lt;code&gt;size()&lt;/code&gt;，如果不需要重新分配内存，则 &lt;code&gt;capacity()&lt;/code&gt; 也不会改变&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reserver&#34;&gt;reserver&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;原型

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void reserve (size_type n);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;reserve 方法请求修改容量(capacity)，即容量需要足够包含 n 个元素

&lt;ul&gt;
&lt;li&gt;如果当前容量小于 n，需要重新分配内存，使得容量&lt;strong&gt;不小于&lt;/strong&gt; n&lt;/li&gt;
&lt;li&gt;如果当前容量不小于 n，不会重新分配内存，也不会影响容量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;它只会影响 &lt;code&gt;capacity()&lt;/code&gt;，&lt;code&gt;size()&lt;/code&gt; 不会改变，也不会修改元素。只分配内存，但是没有初始化。容器中没有添加任何元素。如果之后插入元素，容器不会发生重新分配内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;取舍&#34;&gt;取舍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果需要初始化内存，使用 resize&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果知道需要保存元素的大小，只是为了避免多次分配，使用 reserve&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

class MoreThanOneParam
{
int m_i;
string m_s;
public:
MoreThanOneParam() : m_i(-1) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::default::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
MoreThanOneParam(int ii, string s) : m_i(ii), m_s(s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
MoreThanOneParam(const MoreThanOneParam &amp;amp;copy) : m_i(copy.m_i), m_s(copy.m_s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~MoreThanOneParam( ) { cout &amp;lt;&amp;lt; &amp;quot;~MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }

int getInt() const { return m_i; }
string getString() const { return m_s; }
};

int main( )
{
vector&amp;lt;MoreThanOneParam&amp;gt; vec2={ {1,&amp;quot;s1&amp;quot;} , MoreThanOneParam{2 , &amp;quot;s2&amp;quot;} }; //对于每个元素，构造一次，拷贝一次，析构一次
cout &amp;lt;&amp;lt; &amp;quot;=============at first, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.reserve(6);
cout &amp;lt;&amp;lt; &amp;quot;=============after reserve(6), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.push_back( MoreThanOneParam(3 , &amp;quot;s3&amp;quot; ) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec2.emplace_back( MoreThanOneParam(4 , &amp;quot;s4&amp;quot; )); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec2.emplace_back( 5 , &amp;quot;s5&amp;quot; ); //构造一次
cout &amp;lt;&amp;lt; &amp;quot;=============after push_back/emplace_back 3 elements, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.emplace_back( 6 , &amp;quot;s6&amp;quot; ); //构造一次
cout &amp;lt;&amp;lt; &amp;quot;=============after push_back/emplace_back 1 elements, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.emplace_back( 7 , &amp;quot;s7&amp;quot; ); //构造一次
cout &amp;lt;&amp;lt; &amp;quot;=============after push_back/emplace_back 1 elements, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.reserve(6);
cout &amp;lt;&amp;lt; &amp;quot;=============after reserve(6), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.resize(14);
cout &amp;lt;&amp;lt; &amp;quot;=============after resize(14), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.resize(6);
cout &amp;lt;&amp;lt; &amp;quot;=============after resize(6), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7397768/choice-between-vectorresize-and-vectorreserve&#34; target=&#34;_blank&#34;&gt;Choice between vector::resize() and vector::reserve()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>VOD playlist 构造</title>
      <link>https://xueqing.github.io/translation/hls/vod_playlist_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/vod_playlist_construction/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/video_on_demand_playlist_construction&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;示例&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#extm3u&#34;&gt;EXTM3U&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-version&#34;&gt;EXT-X-VERSION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#extinf&#34;&gt;EXTINF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-endlist&#34;&gt;EXT-X-ENDLIST&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%b8%e5%af%b9%e8%b7%af%e5%be%84&#34;&gt;相对路径&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;对于 VOD(video on demand, 点播) 会话，可以访问的媒体文件表示显示的整个时间段。索引文件是静态的，且包含相关 URL 的一个完整列表，可以访问从显示开始创建的所有媒体文件。这种会话支持用户对整个程序的完整控制。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的代码是一个 VOD playlist 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:VOD
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
http://example.com/movie1/fileSequenceA.ts
#EXTINF:10.0,
http://example.com/movie1/fileSequenceB.ts
#EXTINF:10.0,
http://example.com/movie1/fileSequenceC.ts
#EXTINF:9.0,
http://example.com/movie1/fileSequenceD.ts
#EXT-X-ENDLIST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直播 playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/h3&gt;

&lt;p&gt;指定最大的媒体文件时长。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-version&#34;&gt;EXT-X-VERSION&lt;/h3&gt;

&lt;p&gt;表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/h3&gt;

&lt;p&gt;表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：EXT-X-MEDIA-SEQUENCE 标记的值&lt;/p&gt;

&lt;h3 id=&#34;extinf&#34;&gt;EXTINF&lt;/h3&gt;

&lt;p&gt;一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-endlist&#34;&gt;EXT-X-ENDLIST&lt;/h3&gt;

&lt;p&gt;表明不会再向 playlist 文件增加媒体文件了。&lt;/p&gt;

&lt;h2 id=&#34;相对路径&#34;&gt;相对路径&lt;/h2&gt;

&lt;p&gt;上述的 VOD playlist 示例对于媒体文件 playlist 条目使用完整的路径名。虽然支持这么做，更鼓励使用相对路径。相对路径比绝对路径更易移植且相对于 playlist 文件的 URL。对于单个 playlist 条目使用完整路径名比使用相对路径经常导致文本更长。下面是使用相对路径的相同的 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:VOD
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
fileSequenceA.ts
#EXTINF:10.0,
fileSequenceB.ts
#EXTINF:10.0,
fileSequenceC.ts
#EXTINF:9.0,
fileSequenceD.ts
#EXT-X-ENDLIST
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>WaitGroup 和 worker pool</title>
      <link>https://xueqing.github.io/blog/go/basic/go_waitgroup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_waitgroup/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#waitgroup&#34;&gt;WaitGroup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#worker-pool&#34;&gt;worker pool&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;waitgroup&#34;&gt;WaitGroup&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;WaitGroup 用于等待一个集合的 goroutine 执行完毕。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;WaitGroup 是一个结构体，内部使用了一个计数器，使用 Add 可以增加计数，使用 Done 可以减少计数。当计数为 0 的时候，Wait 返回&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;WaitGroup 不能使用值传递，否则会复制拷贝，将不能通知 Wait 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func goroutineProccess(index int, wg *sync.WaitGroup) {
fmt.Println(&amp;quot;start goroutineProcess &amp;quot;, index)
time.Sleep(2 * time.Second)
fmt.Printf(&amp;quot;Ended goroutineProcess %d\n&amp;quot;, index)
wg.Done()
}

func WaitgroupTest() {
routineNumber := 3
var wg sync.WaitGroup
for i := 0; i &amp;lt; routineNumber; i++ {
wg.Add(1)
go goroutineProccess(i, &amp;amp;wg)
}
wg.Wait()
fmt.Println(&amp;quot;All goroutine exit...&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;worker-pool&#34;&gt;worker pool&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;worker pool 是一个线程的集合，等待分配任务执行。任务完成之后，立刻准备下一个任务&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 buffered channel 实现 worker pool&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Job struct {
id       int
randomno int
}

type Result struct {
job         Job
sumofdigits int
}

var jobs = make(chan Job, 10)
var results = make(chan Result, 10)

func digits(number int) int {
sum := 0
no := number
for no != 0 {
    sum += no % 10
    no /= 10
}
time.Sleep(2 * time.Second)
return sum
}

func dowork(wg *sync.WaitGroup) {
for job := range jobs {
    sum := Result{job, digits(job.randomno)}
    results &amp;lt;- sum
}
wg.Done()
}

func createWorkerPool(noOfWorkers int) {
var wg sync.WaitGroup
for i := 0; i &amp;lt; noOfWorkers; i++ {
    wg.Add(1)
    go dowork(&amp;amp;wg)
}
wg.Wait()
close(results)
}

func createJobs(noOfJobs int) {
for i := 0; i &amp;lt; noOfJobs; i++ {
    randomno := rand.Intn(999)
    job := Job{i, randomno}
    jobs &amp;lt;- job
}
close(jobs)
}

func getResult(done chan bool) {
for result := range results {
    fmt.Printf(&amp;quot;Job id = %2d, randomno = %3d, result = %d\n&amp;quot;, result.job.id, result.job.randomno, result.sumofdigits)
}
done &amp;lt;- true
}

func WokerPoolTest() {
startTime := time.Now()
noOfJobs := 100
go createJobs(noOfJobs)
noOfWorkers := 10
go createWorkerPool(noOfWorkers)
done := make(chan bool)
go getResult(done)
&amp;lt;-done
endTime := time.Now()
diff := endTime.Sub(startTime)
fmt.Println(&amp;quot;Cost &amp;quot;, diff.Seconds(), &amp;quot; seconds&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Web Crawler</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/web_crawler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/web_crawler/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Web Crawler
In this exercise you&#39;ll use Go&#39;s concurrency features to parallelize a web crawler.

Modify the Crawl function to fetch URLs in parallel without fetching the same URL twice.

Hint: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not safe for concurrent use!
*/

package main

import (
  &amp;quot;fmt&amp;quot;
)

type Fetcher interface {
  // Fetch returns the body of URL and
  // a slice of URLs found on that page.
  Fetch(url string) (body string, urls []string, err error)
}

// Crawl uses fetcher to recursively crawl
// pages starting with url, to a maximum of depth.
func Crawl(url string, depth int, fetcher Fetcher) {
  // TODO: Fetch URLs in parallel.
  // TODO: Don&#39;t fetch the same URL twice.
  // This implementation doesn&#39;t do either:
  if depth &amp;lt;= 0 {
    return
  }
  body, urls, err := fetcher.Fetch(url)
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Printf(&amp;quot;found: %s %q\n&amp;quot;, url, body)
  for _, u := range urls {
    Crawl(u, depth-1, fetcher)
  }
  return
}

func main() {
  Crawl(&amp;quot;https://golang.org/&amp;quot;, 4, fetcher)
}

// fakeFetcher is Fetcher that returns canned results.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
  body string
  urls []string
}

func (f fakeFetcher) Fetch(url string) (string, []string, error) {
  if res, ok := f[url]; ok {
    return res.body, res.urls, nil
  }
  return &amp;quot;&amp;quot;, nil, fmt.Errorf(&amp;quot;not found: %s&amp;quot;, url)
}

// fetcher is a populated fakeFetcher.
var fetcher = fakeFetcher{
  &amp;quot;https://golang.org/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;The Go Programming Language&amp;quot;,
    []string{
      &amp;quot;https://golang.org/pkg/&amp;quot;,
      &amp;quot;https://golang.org/cmd/&amp;quot;,
    },
  },
  &amp;quot;https://golang.org/pkg/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;Packages&amp;quot;,
    []string{
      &amp;quot;https://golang.org/&amp;quot;,
      &amp;quot;https://golang.org/cmd/&amp;quot;,
      &amp;quot;https://golang.org/pkg/fmt/&amp;quot;,
      &amp;quot;https://golang.org/pkg/os/&amp;quot;,
    },
  },
  &amp;quot;https://golang.org/pkg/fmt/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;Package fmt&amp;quot;,
    []string{
      &amp;quot;https://golang.org/&amp;quot;,
      &amp;quot;https://golang.org/pkg/&amp;quot;,
    },
  },
  &amp;quot;https://golang.org/pkg/os/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;Package os&amp;quot;,
    []string{
      &amp;quot;https://golang.org/&amp;quot;,
      &amp;quot;https://golang.org/pkg/&amp;quot;,
    },
  },
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二进制兼容的 C&#43;&#43; 接口</title>
      <link>https://xueqing.github.io/translation/cplusplus/binary_compatible_cpp_interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/cplusplus/binary_compatible_cpp_interface/</guid>
      <description>

&lt;p&gt;原文参考 &lt;a href=&#34;https://chadaustin.me/cppinterface.html&#34; target=&#34;_blank&#34;&gt;Binary-compatible C++ Interfaces&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作者：Chad Austin, 2002.02.15&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E7%9A%84-C-%E6%8E%A5%E5%8F%A3&#34;&gt;二进制兼容的 C++ 接口&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%BF%B0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%83%8C%E6%99%AF&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E5%BF%B5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95&#34;&gt;初次尝试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95&#34;&gt;第二次尝试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BF%AE%E6%AD%A3&#34;&gt;第三次修正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BF%AE%E6%AD%A3&#34;&gt;第四次修正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%8C%E6%88%90%E6%B6%A6%E8%89%B2&#34;&gt;完成润色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0&#34;&gt;最终实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;本文解释如何生成跨编译器和配置(发布/调试等)的 C++ DLL API。&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;许多平台对他们偏好的编程语言有自己的 ABI。比如，BeOS 的主要语言是 C++，所以 C++ 编译器一定可以生成保持操作系统 C++ 系统调用二(还有类等)进制兼容的代码。&lt;/p&gt;

&lt;p&gt;Windows 为 C 语言定义 API 和 ABI，因此 C++ 编译器的开发者可以自由控制 C++ ABI 的实现。但是，MS 最后为 Windows 创建面向对象的 ABI，称为 COM。为了简化 COM 的使用，他们使 C++ ABI 的虚表(vtables)映射到 COM 接口所需的虚表。由于不能使用 COM 的 Windows 编译器非常受限，其他的编译器强制执行 COM 虚表和 C++ 虚表之前的映射。&lt;/p&gt;

&lt;p&gt;ABI 包含多个方面。这篇文章只讨论在 Windows 下使用 C++ 的问题。其他平台要求不一样。(幸运的是，因为大部分其他平台不如 Windows 流行，这些平台只有一或两个编译器，因此不是很大的问题。)&lt;/p&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ABI&lt;/strong&gt;(Application Binary Interface，应用程序二进制接口)：系统之间的二进制接口。如果一个二进制接口改变，接口两端(使用者和实现)必须被重新编译。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API&lt;/strong&gt;(Application Program Interface，应用程序编程接口)：系统之间的源接口。如果一个源接口改变，使用这个接口的代码必须修改。API 改变通常暗示 ABI 改变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interface&lt;/strong&gt;(接口)：一个所有方法都是纯虚的类，因此没有内在实现。一个接口只是对象之间通讯的协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Factory&lt;/strong&gt;(工厂)：用于创建对象。在这篇文章中，我们使用一个全局的函数作为我们的工厂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLL Boundary&lt;/strong&gt;(DLL 界限)：DLL 中被实例化的代码和调用进程的代码之间的线被称为 DLL 界限。在一些情况下，代码可以在界限两侧：一个头文件中的一个内联函数在 DLL 和可执行文件中被使用。这个函数实际上在界限两侧被实例化。因此，如果内联函数有一个静态变量，会创建两个变量，分别在可执行文件和 DLL 中，&lt;strong&gt;哪个变量被使用取决于 DLL 还是可执行文件中的代码调用了这个函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;初次尝试&#34;&gt;初次尝试&lt;/h2&gt;

&lt;p&gt;假设想要创建一个可移植的 windowing API，而且想要把实现放在 DLL 中。我会创建一个名为 Window 的类，这个类可以表示不同的 windowing 系统的一个窗口，Win32，MFC，wxWindows，Qt，Gtk，Aqua，X11，Swing(gasp)等。我们会多次尝试创建一个接口直到它可以在不同的实现、编译器和编译器设置上工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

#include &amp;lt;string&amp;gt;

#ifdef WIN32
  #ifdef EXPORTING
    #define DLLIMPORT _declspec(dllexport)
  #endif
  #else
    #define DLLIMPORT _declspec(dllimport)
  #endif
  #define CALL __stdcall
#else
  #define DLLIMPORT
  #define CALL
#endif

class DLLIMPORT Window {
public:
  Window(std::string title);
  ~Window();

  void setTitle(std::string title);
  std::string getTitle();

  //...

private:
  HWND m_window;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我不会展示实现，因为我假定你已经知道如何实现。关于这个接口有一个明显的问题：它假定你使用基础的 Win32 API。即它持有一个 HWND 作为私有成员，因此引入了 Window 类和 WIn32 SDK 的依赖。一个可能的解决方案是使用 pImpl 语法从类的定义中移除这个私有成员。参考文档&lt;a href=&#34;http://www.gotw.ca/publications/mill04.htm&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;、&lt;a href=&#34;http://www.gotw.ca/publications/mill05.htm&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;、&lt;a href=&#34;http://www.gotw.ca/gotw/028.htm&#34; target=&#34;_blank&#34;&gt;3&lt;/a&gt;和&lt;a href=&#34;http://wiki.c2.com/?PimplIdiom&#34; target=&#34;_blank&#34;&gt;4&lt;/a&gt;。同时，你不能在不破坏二进制兼容的条件下向这个类增加新成员，因为这个类的大小会改变。&lt;/p&gt;

&lt;p&gt;可能这个方法最重要的问题是成员方法不是纯虚的。因此，这些成员方法被实现为专门命名的函数，且函数使用 &lt;code&gt;this&lt;/code&gt; 指针作为第一个参数。不幸的是，我不知道有哪两种编译器对方法的名称重整(name mangling)是一样的。因此不要认为你用一个编译器生成的的 DLL 可被另一个编译器编译的可执行文件使用。&lt;/p&gt;

&lt;h2 id=&#34;第二次尝试&#34;&gt;第二次尝试&lt;/h2&gt;

&lt;p&gt;对于面向对象编程，你知道每个类可以分为两个概念：接口和工厂。工厂是创建对象的一种机制，接口支持对象之间通讯。下个版本的 Window.h 会分离这些概念。注意你不再需要导出类(你需要导出工厂函数)，因为这个是抽象类：所有的方法调用经过对象的虚表(vtables)，而不是通过一个直接的链接到 DLL。只有调用这个工厂函数会直接调用 DLL。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

#include &amp;lt;string&amp;gt;

class Window {
public:
  virtual ~Window() {}
  virtual void setTitle(std::string title) = 0;
  virtual std::string getTitle() = 0;
};

Window* DLLIMPORT CreateWindow(std::string title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码更好。使用 Window 对象的代码不关心 Window 对象实际的类型，只要实现 Window 接口的类型都可以。但是，还有一个问题：不同的编译器重整符号名称不同，因此不同编译器生成的 DLL 中的 &lt;code&gt;CreateWindow&lt;/code&gt; 函数名称不同。这意味着如果你使用 Visual C++ 6 编译 windowing DLL，不能再 Bor兰 C++ 中使用，反之亦然。幸运的是，C++ 标准通过 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 使得禁用符号重整成特殊的名称。&lt;/p&gt;

&lt;p&gt;一些人可能注意到代码的另一个问题。不同的编译器对 C++ 库的实现不同。在一些不明显的情况下，一些人会用其他的(如 &lt;a href=&#34;http://stlport.org/&#34; target=&#34;_blank&#34;&gt;STLPort&lt;/a&gt;)替代编译器的库实现……由此你不能依赖跨编译器的 STL 对象是二进制兼容的，你不能在 DLL 接口中安全使用它们。&lt;/p&gt;

&lt;p&gt;如果一个 C++ ABI 曾为 Windows 创建，需要明确指定如何与标准库中的每个类交互，但是我马上就不会再看到这个事情发生了。&lt;/p&gt;

&lt;p&gt;最后一个问题比较小。出于惯例，COM 方法和 DLL 函数使用 &lt;code&gt;__stdcall&lt;/code&gt; 调用惯例。我们可以使用前面定义的 &lt;code&gt;CALL&lt;/code&gt; 宏解决这个问题。(可以在工程中重命名)&lt;/p&gt;

&lt;h2 id=&#34;第三次修正&#34;&gt;第三次修正&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

class Window {
public:
  virtual ~Window() {}
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;马上就完成了！这个特殊的接口可能在大多数情况下会有效。但是，虚析构函数使得事情有趣了……因为 COM 不使用虚析构函数，你不能依赖不同的编译器使用是一样的。然而，你可以使用一个虚方法取代虚析构函数。即在实现类中通过 &lt;code&gt;delete this&lt;/code&gt; 实现；这个方式会在 DLL 界限同一侧实现构造和析构函数。比如，如果尝试使用 VC++6 的发布版可执行程序调试 DLL，程序会崩溃或遇到类似“Value of ESP not saved across function call”的警告。发生这个错误是因为 VC++ 运行时库的调试版本和发布版的分配器(allocator)不同。因为两个分配器不兼容，我们不能在 DLL 界限一侧申请内存然后再另一侧释放这个内存。&lt;/p&gt;

&lt;p&gt;但是一个虚析构函数和一个虚方法是什么不同呢？虚析构函数不负责释放这个对象使用的内存：它们只是在释放对象之前简单地被调用执行必要的清理。使用 DLL 的可执行程序不会尝试释放对象本身的内存。另一方面， &lt;code&gt;destroy()&lt;/code&gt; 函数负责释放内存，因此所有的 new 和 delete 调用在 DLL 界限的同一侧。&lt;/p&gt;

&lt;p&gt;可以将接口的析构函数设为受保护的，以便使用接口的地方在析构函数中不小心删除它。&lt;/p&gt;

&lt;h2 id=&#34;第四次修正&#34;&gt;第四次修正&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.h

class Window {
protected:
  virtual ~Window() {} //use destroy()

public:
  virtual void CALL destroy() = 0;
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为这段代码不使用 COM 定义的语义，它可以跨编译器和配置工作。不幸的是，它不是完美的。你必须记住使用 &lt;code&gt;object-&amp;gt;destroy()&lt;/code&gt; 删除对象，这个不如 &lt;code&gt;delete object&lt;/code&gt; 直观。可能更重要的是，你不能在这个对象类型上使用 &lt;code&gt;std::auto_ptr&lt;/code&gt;，&lt;code&gt;autho_ptr&lt;/code&gt; 会使用 &lt;code&gt;delete object&lt;/code&gt; 删除它拥有的对象。有一种方式实现 &lt;code&gt;delete object&lt;/code&gt; 语法吗，实际上调用 &lt;code&gt;object-&amp;gt;destroy()&lt;/code&gt;？有的。这正使得事情有点奇怪……你可以为这个接口重载 &lt;code&gt;operator delete&lt;/code&gt;，在内部调用 &lt;code&gt;destroy()&lt;/code&gt;。因为运算符 delete 持有一个 void 指针，你需要记得你永远不会对任何非 Window 调用 &lt;code&gt;Window::operator delete&lt;/code&gt;。这是一个相当安全的假设。下面是运算符的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//...
void operator delete(void *p) {
  if(p) {
    Window* w = static_cast&amp;lt;Window*&amp;gt;(p);
    w-&amp;gt;destroy();
  }
}
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来相当好……你现在可以再使用 &lt;code&gt;autho_ptr&lt;/code&gt;，而且你仍然有一个稳定的二进制接口。当你重新编译和测试你的新代码，你会注意到在 &lt;code&gt;WindowImpl::destroy&lt;/code&gt; 有一个栈溢出！发生了什么？如果你记得 destroy 方法如何被实现，你会发现它只是简单的执行 &lt;code&gt;delete this&lt;/code&gt;。由于这个接口重载了 &lt;code&gt;operator delete&lt;/code&gt;，&lt;code&gt;WindowImpl::destroy&lt;/code&gt; 调用 &lt;code&gt;Window::operator delete&lt;/code&gt; 会调用 &lt;code&gt;WindowImpl::destroy&lt;/code&gt;……无限循环。这个特别问题的解决方法是在实现类中重载运算符 delete 来调用全局的运算符 delete&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//...
void operator delete(void *p) {
  ::operator delete(p);
}
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完成润色&#34;&gt;完成润色&lt;/h2&gt;

&lt;p&gt;如果你的系统有很多接口和实现，你会发现你想要一些方式自动化取消定义运算符 delete。幸运的是，这个也是可能的。简单地创建一个模板类叫做 DefaultDelete，然后不要从接口类 I 衍生，而是从 &lt;code&gt;class DefaultDelete&amp;lt;I&amp;gt;&lt;/code&gt; 衍生实现类。下面是 DefaultDelete 的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;typename T&amp;gt;
class DefaultDelete : public T {
public:
  void operator delete(void *p) {
    ::operator delete(p);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;最终实现&#34;&gt;最终实现&lt;/h2&gt;

&lt;p&gt;下面是最终版本的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.h

#ifdef WIN32
  #define CALL __stdcall
#else
  #define CALL
#endif

class Window {
public:
  virtual void CALL destroy() = 0;
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;

  void operator delete(void* p) {
    if(p) {
      Window* p = static_cast&amp;lt;Window*&amp;gt;(p);
      w-&amp;gt;destroy();
    }
  }
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//DefaultDelete.h

template&amp;lt;typename T&amp;gt;
class DefaultDelete : public T {
public:
  void operator delete(void* p) {
    ::operator delete(p);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.cpp

#include &amp;quot;Window.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;windows.h&amp;gt;
#include &amp;quot;DefaultDelete.h&amp;quot;

class WindowImpl : public DefaultDelete&amp;lt;Window&amp;gt; {
public:
  WindowImpl(HWND window) {
    m_window = window;
  }

  ~WindowImpl() {
    DestroyWindow(m_window);
  }

  void CALL destroy() {
    delete this;
  }

  void CALL setTitle(const char* title) {
    SetWindowtext(m_window, title);
  }

  const char* CALL getTitle() {
    char title[512];
    GetWindowText(m_window, title, 512);
    m_title = title; //save the title past the call
    return m_title.c_str();
  }

private:
  HWND m_window;
  std::string m_title;
}

Window* CALL CreateWindow(const char* title) {
  // create Win32 window object
  HWND window = ::CreateWindow(..., title, ...);
  return (window ? new WindowImple(window) : 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我会枚举一些指导方针，在创建 C++ 接口的时候需要记得。你可以回顾作为一个参考或者使用它帮助巩固你的知识。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有的接口类应该是完全抽象的。每个方法应该是纯虚的(或者内联的……你可以安全地编写内联方法调用其他方法)。&lt;/li&gt;
&lt;li&gt;所有的全局函数应该是 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 以避免不兼容的名称重整。并且，导出的函数和方法应该使用。&lt;code&gt;__stdcall&lt;/code&gt; 调用惯例，因为 DLL 函数和 COM 习惯上使用这种调用惯例。这种方式，如果这个库的使用者使用默认的 &lt;code&gt;__cdecl&lt;/code&gt; 编译，对 DLL 的调用仍然使用正确的惯例。&lt;/li&gt;
&lt;li&gt;不要使用标准 C++ 库。&lt;/li&gt;
&lt;li&gt;不要使用异常处理。&lt;/li&gt;
&lt;li&gt;不要使用虚析构函数。相反地，创建一个 &lt;code&gt;destroy()&lt;/code&gt; 方法和一个重载的 &lt;code&gt;operator delete&lt;/code&gt; 调用 &lt;code&gt;destroy()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;不要在 DLL 界限的一侧申请内存，在另一侧释放它。不同的 DLL 和 可执行文件可以使用不同的堆编译，并且使用不同的堆申请和释放内存块肯定会导致崩溃。比如，不要内联内存申请函数以便函数不会编译到不同的可执行文件和 DLL。&lt;/li&gt;
&lt;li&gt;不要在接口使用重载的方法。不同的编译器在虚表中排序不同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stlport.org/&#34; target=&#34;_blank&#34;&gt;STLPort&lt;/a&gt; 是 STL 的替代&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/&#34; target=&#34;_blank&#34;&gt;SGI&lt;/a&gt; 有另外一个标准的 C++ 库实现&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://corona.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;Corona&lt;/a&gt; 图片 I/O 库使用了本文引入的技术&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>五个方法成为更好的程序员</title>
      <link>https://xueqing.github.io/blog/coolshell/%E4%BA%94%E4%B8%AA%E6%96%B9%E6%B3%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/coolshell/%E4%BA%94%E4%B8%AA%E6%96%B9%E6%B3%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://coolshell.cn/articles/2606.html&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;好的程序员并一定是技术强的程序员，而是那些可以在不完美的工作环境下保证软件质量和工作效率的程序员&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;寻找不同观点

&lt;ul&gt;
&lt;li&gt;要经常在做事之前问自己和别人，这么做对不对&lt;/li&gt;
&lt;li&gt;做完事后问自己，还可不可以改进&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;努力去寻找别的不同的观点或方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;程序员应该经常上网，经常和同事讨论不同的实现方法，不同的技术观点，这样才能取长补短&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;千万别信自己的代码

&lt;ul&gt;
&lt;li&gt;当出现问题的时候，要学会 review 代码中所有的可疑点，千万别觉得某段代码很简单，可以略过&lt;/li&gt;
&lt;li&gt;在查错的过程中，切忌过早下结论，切忌四处乱改,停下来想一想，会是哪儿的代码有重大嫌疑，然后查看一下代码，捋一捋程序的逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;思考和放松

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;思考其实就是一种放松&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;做事前多想一想，这样做事的时候就不会不顾此失彼，手忙脚乱&lt;/li&gt;
&lt;li&gt;在工作中要学会享受，要学会放松心情&lt;/li&gt;
&lt;li&gt;善于总结成败得失，善于思考，善于调整，善于放松&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;学习历史，跟上时代

&lt;ul&gt;
&lt;li&gt;一定要学习历史，整个计算机文化的历史&lt;/li&gt;
&lt;li&gt;只有通过历史，才能明白历史上出现的问题，新技术出来的原因，这样才能够更了解新的技术和未来的方向&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用新型的技术&lt;/strong&gt;，停下来接受培训，可以工作得更快更高效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;积极推动测试活动&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;积极地在各个环节推动项目组进行测试活动&lt;/li&gt;
&lt;li&gt;只有测试才能证明软件可以正常工作，只有测试才能保证软件的质量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>作用域</title>
      <link>https://xueqing.github.io/blog/go/traps/var_scope/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/traps/var_scope/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;编译器遇到一个名字的引用时，从最内层的封闭词法块到全局块寻找其声明

&lt;ul&gt;
&lt;li&gt;没有找到会报 “undeclared name” 错误&lt;/li&gt;
&lt;li&gt;内层和外层都存在声明时，内层的先被找到。此时内层声明会覆盖外部声明，外部声明将不可访问&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;短变量声明&lt;/strong&gt;依赖一个明确的作用域。&lt;strong&gt;只有在同一个词法块中已经存在变量&lt;/strong&gt;的情况下，短声明的行为才和赋值操作一样，外层声明将被忽略。下面的代码容易覆盖全局声明的 &lt;code&gt;cwd&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;因为 cwd 和 err 在函数块内部都尚未声明，所以 &lt;code&gt;:=&lt;/code&gt; 语句将它们视为局部变量。内存 cwd 声明使得外部声明不可见&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方法是不使用 &lt;code&gt;:=&lt;/code&gt;，而是使用 &lt;code&gt;var&lt;/code&gt; 声明变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;fmt&amp;quot;
&amp;quot;os&amp;quot;
)

var cwd string

func main() {
cwd, err := os.Getwd() //compile error: cwd declared and not used
if err != nil {
fmt.Printf(&amp;quot;err=%s\n&amp;quot;, err)
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码，main 函数中的 cwd 是局部变量，会覆盖全局变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
&amp;quot;log&amp;quot;
&amp;quot;os&amp;quot;
)

var cwd string = &amp;quot;.&amp;quot;

func main() {
mylog()
cwd, err := os.Getwd()
if err != nil {
log.Fatalf(&amp;quot;os.Getwd failed: %v\n&amp;quot;, err)
}
log.Printf(&amp;quot;os.Getwd success: %s\n&amp;quot;, cwd)
mylog()
}

func mylog() {
log.Printf(&amp;quot;global cwd: %s\n&amp;quot;, cwd)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用子测试和子基准测试</title>
      <link>https://xueqing.github.io/translation/go-doc/blog/subtest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/blog/subtest/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95%e5%9f%ba%e7%a1%80&#34;&gt;表驱动测试基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e7%9a%84%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;表驱动的基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%ad%90%e6%b5%8b%e8%af%95%e7%9a%84%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95&#34;&gt;使用子测试的表驱动测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%90%e8%a1%8c%e6%8c%87%e5%ae%9a%e7%9a%84%e6%b5%8b%e8%af%95%e6%88%96%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;运行指定的测试或基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%ae%be%e7%bd%ae%e5%92%8c%e6%b8%85%e7%90%86&#34;&gt;设置和清理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b6%e8%a1%8c%e6%8e%a7%e5%88%b6&#34;&gt;并行控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b6%e8%a1%8c%e8%bf%90%e8%a1%8c%e4%b8%80%e7%bb%84%e6%b5%8b%e8%af%95&#34;&gt;并行运行一组测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%80%e7%bb%84%e5%b9%b6%e8%a1%8c%e6%b5%8b%e8%af%95%e4%b9%8b%e5%90%8e%e7%9a%84%e6%b8%85%e7%90%86&#34;&gt;一组并行测试之后的清理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bb%93%e8%ae%ba&#34;&gt;结论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%b8%e5%85%b3%e6%96%87%e7%ab%a0&#34;&gt;相关文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://blog.golang.org/subtests&#34; target=&#34;_blank&#34;&gt;Go 博客——使用子测试和子基准测试&lt;/a&gt;学习。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;  作者：Marcel van Lohuizen
  日期：2016/10/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在 Go1.7，testing 包引入了一个 Run 方法，作用于 &lt;a href=&#34;https://golang.org/pkg/testing/#T.Run&#34; target=&#34;_blank&#34;&gt;T&lt;/a&gt; 和 &lt;a href=&#34;https://golang.org/pkg/testing/#B.Run&#34; target=&#34;_blank&#34;&gt;B&lt;/a&gt; 类型，允许创建子测试和子基准测试。子测试和子基准测试的引入使得支持更好的失败处理，从命令行对运行哪个测试的细粒度控制，并行控制，并且经常生成更简单和可维护的代码。&lt;/p&gt;

&lt;h2 id=&#34;表驱动测试基础&#34;&gt;表驱动测试基础&lt;/h2&gt;

&lt;p&gt;在深入细节之前，让我们先讨论用 Go 编写测试的常用方式。可以通过对一个测试用例切片的循环实现一系列相关的检查：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTime(t *testing.T) {
    testCases := []struct {
        gmt  string
        loc  string
        want string
    }{
        {&amp;quot;12:31&amp;quot;, &amp;quot;Europe/Zuri&amp;quot;, &amp;quot;13:31&amp;quot;},     // incorrect location name
        {&amp;quot;12:31&amp;quot;, &amp;quot;America/New_York&amp;quot;, &amp;quot;7:31&amp;quot;}, // should be 07:31
        {&amp;quot;08:08&amp;quot;, &amp;quot;Australia/Sydney&amp;quot;, &amp;quot;18:08&amp;quot;},
    }
    for _, tc := range testCases {
        loc, err := time.LoadLocation(tc.loc)
        if err != nil {
            t.Fatalf(&amp;quot;could not load location %q&amp;quot;, tc.loc)
        }
        gmt, _ := time.Parse(&amp;quot;15:04&amp;quot;, tc.gmt)
        if got := gmt.In(loc).Format(&amp;quot;15:04&amp;quot;); got != tc.want {
            t.Errorf(&amp;quot;In(%s, %s) = %s; want %s&amp;quot;, tc.gmt, tc.loc, got, tc.want)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法常备表驱动测试提及。且相比为每个测试重复相同的代码，此方法减少了大量的重复代码，且使得增加测试用例更加直接。&lt;/p&gt;

&lt;h2 id=&#34;表驱动的基准测试&#34;&gt;表驱动的基准测试&lt;/h2&gt;

&lt;p&gt;在 Go1.7 之前，不能为基准测试使用相同的表驱动方法。一个基准测试测试整个函数的性能，因此遍历基准测试只是将它们作为一个整体测试。&lt;/p&gt;

&lt;p&gt;一个常用的变通方案是定义单独的顶层基准测试，每个基准测试使用不同参数调用一个公共的函数。比如，在 1.7 之前，strconv 包地狱塔 AppendFloat 的基准测试看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func benchmarkAppendFloat(b *testing.B, f float64, fmt byte, prec, bitSize int) {
    dst := make([]byte, 30)
    b.ResetTimer() // Overkill here, but for illustrative purposes.
    for i := 0; i &amp;lt; b.N; i++ {
        AppendFloat(dst[:0], f, fmt, prec, bitSize)
    }
}

func BenchmarkAppendFloatDecimal(b *testing.B) { benchmarkAppendFloat(b, 33909, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloat(b *testing.B)        { benchmarkAppendFloat(b, 339.7784, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloatExp(b *testing.B)     { benchmarkAppendFloat(b, -5.09e75, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloatNegExp(b *testing.B)  { benchmarkAppendFloat(b, -5.11e-95, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloatBig(b *testing.B)     { benchmarkAppendFloat(b, 123456789123456789123456789, &#39;g&#39;, -1, 64) }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go1.7 可使用 Run 方法，相同的基准测试现在可以表示为一个顶层的基准测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkAppendFloat(b *testing.B) {
    benchmarks := []struct{
        name    string
        float   float64
        fmt     byte
        prec    int
        bitSize int
    }{
        {&amp;quot;Decimal&amp;quot;, 33909, &#39;g&#39;, -1, 64},
        {&amp;quot;Float&amp;quot;, 339.7784, &#39;g&#39;, -1, 64},
        {&amp;quot;Exp&amp;quot;, -5.09e75, &#39;g&#39;, -1, 64},
        {&amp;quot;NegExp&amp;quot;, -5.11e-95, &#39;g&#39;, -1, 64},
        {&amp;quot;Big&amp;quot;, 123456789123456789123456789, &#39;g&#39;, -1, 64},
        ...
    }
    dst := make([]byte, 30)
    for _, bm := range benchmarks {
        b.Run(bm.name, func(b *testing.B) {
            for i := 0; i &amp;lt; b.N; i++ {
                AppendFloat(dst[:0], bm.float, bm.fmt, bm.prec, bm.bitSize)
            }
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次调用 Run 方法创建一个单独的基准测试。调用 Run 方法的闭包的基准测试函数只允许一次且不被测量。&lt;/p&gt;

&lt;p&gt;新代码行数更多，但是更易维护，更易读，且与测试常用的表驱动方法是一致的。此外，现在可以在运行时共享设置代码，同时不再需要重置计时器。&lt;/p&gt;

&lt;h2 id=&#34;使用子测试的表驱动测试&#34;&gt;使用子测试的表驱动测试&lt;/h2&gt;

&lt;p&gt;Go1.7 也引入了用于创建子测试的 Run 方法。这个测试是使用子测试对之前的例子重新的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTime(t *testing.T) {
    testCases := []struct {
        gmt  string
        loc  string
        want string
    }{
        {&amp;quot;12:31&amp;quot;, &amp;quot;Europe/Zuri&amp;quot;, &amp;quot;13:31&amp;quot;},
        {&amp;quot;12:31&amp;quot;, &amp;quot;America/New_York&amp;quot;, &amp;quot;7:31&amp;quot;},
        {&amp;quot;08:08&amp;quot;, &amp;quot;Australia/Sydney&amp;quot;, &amp;quot;18:08&amp;quot;},
    }
    for _, tc := range testCases {
        t.Run(fmt.Sprintf(&amp;quot;%s in %s&amp;quot;, tc.gmt, tc.loc), func(t *testing.T) {
            loc, err := time.LoadLocation(tc.loc)
            if err != nil {
                t.Fatal(&amp;quot;could not load location&amp;quot;)
            }
            gmt, _ := time.Parse(&amp;quot;15:04&amp;quot;, tc.gmt)
            if got := gmt.In(loc).Format(&amp;quot;15:04&amp;quot;); got != tc.want {
                t.Errorf(&amp;quot;got %s; want %s&amp;quot;, got, tc.want)
            }
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一件要注意的事情是两个实现的输出不同。原本的实现打印：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;--- FAIL: TestTime (0.00s)
    time_test.go:62: could not load location &amp;quot;Europe/Zuri&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使有两个错误，测试执行终止在对 Fatalf 的调用，且第二个测试永远不会运行。&lt;/p&gt;

&lt;p&gt;使用 Run 的实现打印两个错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)
        time_test.go:84: could not load location
    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)
        time_test.go:88: got 07:31; want 7:31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fatal 及其同属函数导致子测试被跳过，但是不会跳过父测试或后续的子测试。&lt;/p&gt;

&lt;p&gt;另外一件要注意的事情是新版本中的错误信息更短。因为子测试的名字唯一标识了一个子测试，因此不再需要在错误信息内部识别该测试。&lt;/p&gt;

&lt;p&gt;使用子测试或子基准测试还有其他的益处，下面的部分会阐明。&lt;/p&gt;

&lt;h2 id=&#34;运行指定的测试或基准测试&#34;&gt;运行指定的测试或基准测试&lt;/h2&gt;

&lt;p&gt;子测试和子基准测试可以在命令行使用 &lt;a href=&#34;../command/test_flag.md&#34;&gt;&lt;code&gt;-run 或 -bench 标识&lt;/code&gt;&lt;/a&gt;选择。两个标识都接收一个斜线分隔的正则表达式列表，匹配了子测试或子基准测试的完整名字的对应部分。&lt;/p&gt;

&lt;p&gt;子测试或子基准测试的完整名字是一个斜线分隔的列表，包括自身的名字以及所有父测试的名字，从顶层测试开始。名字是顶层测试和基准测试对应的名字，且第一个参数必须是 Run。为了避免显示和解析问题，名字使用下划线替换空格，且忽视不可打印字符。相同的处理适用于传递给 -run 或 -bench 表示的正则表达式。&lt;/p&gt;

&lt;p&gt;一些例子：&lt;/p&gt;

&lt;p&gt;使用欧洲时区运行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go test -run=TestTime/&amp;quot;in Europe&amp;quot;
--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)
        time_test.go:85: could not load location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只运行时间在午后的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -run=Time/12:[0-9] -v
=== RUN   TestTime
=== RUN   TestTime/12:31_in_Europe/Zuri
=== RUN   TestTime/12:31_in_America/New_York
--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)
        time_test.go:85: could not load location
    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)
        time_test.go:89: got 07:31; want 7:31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能有点奇怪，使用 -run=TestTime/NewYork 没有匹配任何测试。这是因为出现在位置名字的斜线被当做一个分割符。反之使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -run=TestTime//New_York
--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)
        time_test.go:88: got 07:31; want 7:31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意传递给 -run 的字符串中的 //。时区名字 America/New_York 中的 / 被当做是来自子测试的一个分隔符处理。第一个正则表达式模式 (TestTime) 匹配顶层测试。第二个正则表达式(空字符串)匹配所有，这种情况匹配时间和位置的大洲部。第三部分正则表达式(New_york)匹配位置的城市部分。&lt;/p&gt;

&lt;p&gt;把名字中的斜线当做分隔符允许用户重构测试的层次结构，而不用修改名字。它也简化了避免规则。如果这暴露一个问题的话，用户应该避免名字中的斜线，比如使用下划线替代。&lt;/p&gt;

&lt;p&gt;一个唯一的序列号被增加到不唯一的测试名字末尾。因此如果子测试没有明显的名字结构，可以只传递一个空字符串给 Run，且子测试可以简单地通过序列号识别。&lt;/p&gt;

&lt;h2 id=&#34;设置和清理&#34;&gt;设置和清理&lt;/h2&gt;

&lt;p&gt;子测试和自己准测试可用于管理公共的设置和清理代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestFoo(t *testing.T) {
    // &amp;lt;setup code&amp;gt;
    t.Run(&amp;quot;A=1&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;A=2&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;B=1&amp;quot;, func(t *testing.T) {
        if !test(foo{B:1}) {
            t.Fail()
        }
    })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果任一闭包的子测试运行，设置和清理代码会被允许且最多只运行一次。即使任何子测试调用 Skip、FAIL 或 Fatal 也适用。&lt;/p&gt;

&lt;h2 id=&#34;并行控制&#34;&gt;并行控制&lt;/h2&gt;

&lt;p&gt;子测试支持细粒度控制并行，为了理解如何用这种方式使用子测试，理解并行测试的语法是重要的。&lt;/p&gt;

&lt;p&gt;每个子测试和一个测试函数相关。如果一个测试的测试函数在其 testing.T 实例中调用 Parallel 方法，那么这个测试被称为并行测试。一个并行测试不会和一个顺序测试并发运行，且并行测试的执行被中止直到调用它的测试方法，即父测试返回。-parallel 标识定义了可以并行运行的并行测试的最大数目。&lt;/p&gt;

&lt;p&gt;一个测试会阻塞直到它的测试函数返回且它所有的子测试结束。这意味着顺序测试运行的并行测试会在任何其他一连串的顺序测试运行之前完成。&lt;/p&gt;

&lt;p&gt;这种行为对使用 Run 创建的测试和顶层测试是一样的。事实上，在底层，顶层测试被实现为一个隐藏的主测试的子测试。&lt;/p&gt;

&lt;h2 id=&#34;并行运行一组测试&#34;&gt;并行运行一组测试&lt;/h2&gt;

&lt;p&gt;上述语义支持并行运行一组测试，这组测试内部是并行的，但不与其他并行测试并行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestGroupedParallel(t *testing.T) {
    for _, tc := range testCases {
        tc := tc // capture range variable
        t.Run(tc.Name, func(t *testing.T) {
            t.Parallel()
            if got := foo(tc.in); got != tc.out {
                t.Errorf(&amp;quot;got %v; want %v&amp;quot;, got, tc.out)
            }
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外部测试一直到所有通过 Run 启动的并行测试完成之后才会结束。因此，不会有其他并行测试可以和这些并行测试并行运行。&lt;/p&gt;

&lt;p&gt;注意我们需要捕获 range 变量以确保 tc 与正确的实例绑定。&lt;/p&gt;

&lt;h2 id=&#34;一组并行测试之后的清理&#34;&gt;一组并行测试之后的清理&lt;/h2&gt;

&lt;p&gt;在上述例子中，我们在开始其他测试之前使用语义等待一组并行测试结束。相同的技术可用于在一组共享公共资源的并行测试之后清理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTeardownParallel(t *testing.T) {
    // &amp;lt;setup code&amp;gt;
    // This Run will not return until its parallel subtests complete.
    t.Run(&amp;quot;group&amp;quot;, func(t *testing.T) {
        t.Run(&amp;quot;Test1&amp;quot;, parallelTest1)
        t.Run(&amp;quot;Test2&amp;quot;, parallelTest2)
        t.Run(&amp;quot;Test3&amp;quot;, parallelTest3)
    })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待一组并行测试的行为和之前的例子是相同的。&lt;/p&gt;

&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;

&lt;p&gt;Go1.7 对子测试和子基准测试的增加允许你用正常的方式编写结构化的测试和基准测试，可以优雅的融入现有的工具。一种思考方式是 testing 包之前的版本有 1 层结构：包级别的测试被组织为一个单独的测试和基准测试的集合。现在这种组织可以递归扩展到这些单独的测试和基准测试。事实上，在实现中，顶层测试和基准测试被作为一个隐藏的主测试和基准测试的子测试和基准测试：这种处理在每一层都是相同的。&lt;/p&gt;

&lt;p&gt;对于测试来说，定义这种结构的能力使能细粒度执行指定的测试用例、共享设置和清理，以及更好地控制测试并行。我们很高兴看到人们发现其他用途。享受它！&lt;/p&gt;

&lt;h2 id=&#34;相关文章&#34;&gt;相关文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;examples.md&#34; target=&#34;_blank&#34;&gt;Go 可测试的示例函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;cover.md&#34; target=&#34;_blank&#34;&gt;关于覆盖的故事&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>信道</title>
      <link>https://xueqing.github.io/blog/go/basic/go_channel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_channel/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#channel&#34;&gt;channel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8d%95%e5%90%91-channel&#34;&gt;单向 channel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#close-%e5%85%b3%e9%97%ad%e4%bf%a1%e9%81%93&#34;&gt;close 关闭信道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%89%e7%bc%93%e5%86%b2%e7%9a%84-channel&#34;&gt;有缓冲的 channel&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;channel&#34;&gt;channel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;channel 可认为是带有类型的 pipe，goroutine 通过 channel 通信&lt;/li&gt;
&lt;li&gt;每个 channel 有一个关联的类型，这个类型是 channel 允许传输的数据类型

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chan T&lt;/code&gt; 是一个 T 类型的通道&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;channel 的初始化值是 nil，使用 make 定义&lt;code&gt;chan_name := make(chan chan_type)&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用信道操作符 &lt;code&gt;&amp;lt;-&lt;/code&gt; 发送或接收值，箭头是数据流的方向&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data := &amp;lt;- chan_name&lt;/code&gt;从 chan_name 读数据，当不需要保存读的数据时是&lt;code&gt;&amp;lt;- chan_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;chan_name &amp;lt;- data&lt;/code&gt;往 chan_name 写数据&lt;/li&gt;
&lt;li&gt;发送和接收模式是阻塞的，通过 channel 发送数据的时候，控制会阻塞在发送语句直到其他的 goroutine 从 channel 读数据，读数据亦然&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免死锁：如果等待从 channel 读或写的 goroutine 没有对应的写或读，将会阻塞&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func calcSquares(number int, squareop chan int) {
sum := 0
for number != 0 {
digit := number % 10
sum += digit * digit
number /= 10
}
squareop &amp;lt;- sum
}

func calcCubes(number int, cubeop chan int) {
sum := 0
for number != 0 {
digit := number % 10
sum += digit * digit * digit
number /= 10
}
cubeop &amp;lt;- sum
}

func ChannelTest() {
number := 54
squarech := make(chan int)
cubech := make(chan int)
go calcSquares(number, squarech)
go calcCubes(number, cubech)
squareop, cubeop := &amp;lt;-squarech, &amp;lt;-cubech
fmt.Printf(&amp;quot;squares = %d, cubes = %d\n&amp;quot;, squareop, cubeop)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;单向-channel&#34;&gt;单向 channel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以创建单向的 channel，只用来发送或接受数据，然而没有什么意义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;chan&amp;lt;- chan_type&lt;/code&gt;创建只发送/写 channel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func unidirectionalChannel(unich chan&amp;lt;- int) {
unich &amp;lt;- 1
}

func unidirectionalChannelTest() {
unich := make(chan&amp;lt;- int)
go unidirectionalChannel(unich)
// fmt.Println(&amp;lt;-unich) //invalid operation xx(received from send-only type)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;close-关闭信道&#34;&gt;close 关闭信道&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;发送者可以通过&lt;code&gt;close chan_name&lt;/code&gt;关闭 channel，通知接收者没有数据了，接收者通过&lt;code&gt;var, ok := &amp;lt;- chan_name&lt;/code&gt;接受数据，如果是已经关闭的 channel，ok 会赋值 false，主要在用 &lt;code&gt;for range&lt;/code&gt; 循环从 channel 不断接受数据时使用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只有发送者才能关闭信道&lt;/strong&gt;。向一个已经关闭的信道发送数据会引发程序 panic&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;信道与文件不同，通常情况下无需关闭&lt;/strong&gt;。只有在必须告诉接收者不再有需要发送的值时才有必要关系，例如终止一个 &lt;code&gt;for range&lt;/code&gt; 循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func chanSender(chanop chan int) {
  for i := 0; i &amp;lt; 10; i++ {
      chanop &amp;lt;- i
  }
  close(chanop)
}

func chanReceiver() {
  chanop := make(chan int)
  go chanSender(chanop)
  // for {
  //     data, ok := &amp;lt;-chanop
  //     if ok == false {
  //         break
  //     }
  //     fmt.Println(&amp;quot;Received &amp;quot;, data, ok)
  // }

  for data := range chanop {
      fmt.Println(&amp;quot;Received &amp;quot;, data)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func getDigits(number int, digitch chan int) {
  for number != 0 {
      digit := number % 10
      digitch &amp;lt;- digit
      number /= 10
  }
  close(digitch)
}

func calcSquares(number int, squareop chan int) {
  sum := 0
  digitch := make(chan int)
  go getDigits(number, digitch)
  for digit := range digitch {
      sum += digit * digit
  }
  squareop &amp;lt;- sum
}

func calcCubes(number int, cubeop chan int) {
  sum := 0
  digitch := make(chan int)
  go getDigits(number, digitch)
  for digit := range digitch {
      sum += digit * digit * digit
  }
  cubeop &amp;lt;- sum
}

func ChannelTest() {
  number := 54
  squarech := make(chan int)
  cubech := make(chan int)
  go calcSquares(number, squarech)
  go calcCubes(number, cubech)
  squareop, cubeop := &amp;lt;-squarech, &amp;lt;-cubech
  fmt.Printf(&amp;quot;squares = %d, cubes = %d\n&amp;quot;, squareop, cubeop)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;有缓冲的-channel&#34;&gt;有缓冲的 channel&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;channel 默认没有缓冲，发送和接收都会阻塞&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make(chan type, capacity)&lt;/code&gt;可以创建 buffered channel，只有缓冲满的时候发送会阻塞，只有缓冲空的时候接收会阻塞

&lt;ul&gt;
&lt;li&gt;channel 容量默认为 0，即没有缓冲，会阻塞&lt;/li&gt;
&lt;li&gt;长度是 channel 缓冲现有的元素数目，容量是 channel 缓冲最多可以容纳的数目&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于 boost 库</title>
      <link>https://xueqing.github.io/blog/cplusplus/boost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/boost/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;使用对应功能需要的库

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apt-get install mpi-default-dev&lt;/code&gt;安装 mpi 库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-get install libicu-dev&lt;/code&gt;支持正则表达式的 UNICODE 字符集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-get install python-dev&lt;/code&gt;需要 python 的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-get install libbz2-dev&lt;/code&gt;如果编译出现错误&lt;code&gt;bzlib.h: No such file or directory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解压源代码安装包，切换到对应文件夹：&lt;code&gt;./bootstrap.sh&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;生成 bjam，上述命令可以带有各种选项，具体可参考帮助文档：&lt;code&gt;./bootstrap.sh --help&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--prefix&lt;/code&gt;参数，可以指定安装路径，如果不带&lt;code&gt;--prefix&lt;/code&gt;参数的话（推荐），默认路径是&lt;code&gt;/usr/local/include&lt;/code&gt;和&lt;code&gt;/usr/local/lib&lt;/code&gt;，分别存放头文件和各种库。&lt;/li&gt;
&lt;li&gt;当前目录下，生成两个文件 bjam 和 b2，这两个是一样的，所以接下来的步骤，可以用这两个中的任意一个来执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using mpi&lt;/code&gt;如果需要 MPI 功能，需要在 /tools/build/v2/user-config.jam 文件的末尾添加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;利用生成的 bjam 脚本编译源代码

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./b2 -a -sHAVE_ICU=1&lt;/code&gt;，&lt;code&gt;-a&lt;/code&gt;参数，代表重新编译，&lt;code&gt;-sHAVE_ICU=1&lt;/code&gt;代表支持 Unicode/ICU&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编译完成后，进行安装，也就是将头文件和生成的库，放到指定的路径（&amp;ndash;prefix）下

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./b2 install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于 const</title>
      <link>https://xueqing.github.io/blog/cplusplus/const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/const/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%b8%b8%e9%87%8f%e6%ad%a3%e7%a1%ae%e6%80%a7const-correctness&#34;&gt;1 常量正确性(const correctness)&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e6%a6%82%e8%bf%b0&#34;&gt;1.1 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-const-%e5%92%8c&#34;&gt;1.2 const 和 *&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-const-%e5%92%8c&#34;&gt;1.3 const 和 &amp;amp;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;1.4 成员函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e4%ba%8c%e9%87%8d%e6%8c%87%e9%92%88&#34;&gt;2 二重指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e4%bf%ae%e6%94%b9-const&#34;&gt;3 修改 const&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-x-const-x&#34;&gt;4 X&lt;strong&gt;-&amp;gt;const X&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-reference&#34;&gt;5 reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-常量正确性-const-correctness&#34;&gt;1 常量正确性(const correctness)&lt;/h2&gt;

&lt;h3 id=&#34;1-1-概述&#34;&gt;1.1 概述&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;常量正确性：即使用关键字&lt;code&gt;const&lt;/code&gt;避免常量对象被修改&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数接收一个参数，且在调用过程中不能修改参数，实现方式有三种&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;f1/f2 中不能修改传入参数，否则会有编译警告&lt;/li&gt;
&lt;li&gt;f3 值传递，只修改局部拷贝&lt;/li&gt;

&lt;li&gt;&lt;p&gt;f1/f2 中不能调用 g1/g2，否则会有编译警告&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f1(const std::string&amp;amp; s);  //pass by reference-to-const
void f2(const std::string* sp); //pass by pointer-to-const
void f3(std::string s);         //pass by value

void g1(std::string&amp;amp; s);        //pass by reference-to-non-const
void g2(std::string* sp);       //pass by pointer-to-non-const
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常量正确性：避免意外修改不希望修改的东西&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一般来说，&lt;code&gt;const&lt;/code&gt; 作用于离它最近的左侧的类型，否则，作用于离它最近的右侧的类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则：&lt;code&gt;read it backwards&lt;/code&gt;，即倒着读&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建议：X 放在修饰符的右边&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-2-const-和&#34;&gt;1.2 const 和 *&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const X * ptr&lt;/code&gt;：ptr is a pointer to an X that is const

&lt;ul&gt;
&lt;li&gt;ptr 是一个指针变量，指向一个 X 的对象，但不能通过指针修改 X 对象, *ptr 只读&lt;/li&gt;
&lt;li&gt;不能通过 ptr 调用 X 非 const 的成员方法，否则会有编译警告&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;声明&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const int const0=96;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;int is const&lt;/td&gt;
&lt;td&gt;const1 是整型常量，不可再赋值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a pointer to an X&lt;/td&gt;
&lt;td&gt;X 对象实例的指针&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a pointer to an X that is const&lt;/td&gt;
&lt;td&gt;ptr 是一个指针变量，指向一个 X 的对象，但不能通过指针修改 X 对象, *ptr 只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const const * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X const * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X * const ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a const pointer to an X&lt;/td&gt;
&lt;td&gt;ptr 是一个常量指针，指向一个 X 的对象，不能给指针再赋值，但是可以通过指针修改 X 对象，ptr 只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const * const ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a const pointer to a const X&lt;/td&gt;
&lt;td&gt;ptr 是一个常量指针，指向一个 X 的对象，但不能给指针再赋值，也不能通过指针修改 X 对象&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X * const ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char *Function1() { return &amp;quot;Some text&amp;quot;; }
Function1()[1]=&#39;a&#39;; //error
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;常量指针指向变量：变量可修改，且未从内存移除&lt;/li&gt;
&lt;li&gt;指向常量的指针变量：函数返回常量字符串数组，防止修改返回值错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-3-const-和&#34;&gt;1.3 const 和 &amp;amp;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const X &amp;amp; obj&lt;/code&gt;：obj is a reference to an X that is const

&lt;ul&gt;
&lt;li&gt;obj 是一个 X 对象的引用，但不能通过 obj 修改 X 对象&lt;/li&gt;
&lt;li&gt;不能通过 obj 调用 X 非 const 的成员方法，否则会有编译警告&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;声明&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X &amp;amp; obj&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;obj is a reference to an X that is const&lt;/td&gt;
&lt;td&gt;obj 是一个 X 对象的引用，但不能通过 obj 修改 X 对象, obj 只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const &amp;amp; obj&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-4-成员函数&#34;&gt;1.4 成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在成员函数后加&lt;code&gt;const&lt;/code&gt;避免在内部修改成员变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass{
int m_var;
  
// modify m_var is not allowed
void SomeMethod() const;

// the var pointed to by returned pointer and returned pointer is not allowed to altered
// the var pointed to by given pointer and given pointer is const
// modify m_var is not allowed
const int * const AnotherMethod(const int * const &amp;amp;) const;

// the return value must not be reference to a member of MyClass
std::string&amp;amp; BadMethod() const;

// the return value can be reference to a member of MyClass
const std::string&amp;amp; GoodMethod() const;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-二重指针&#34;&gt;2 二重指针&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;声明&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int ** pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a pointer to a pointer to an int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int ** const pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a const pointer to a pointer to an int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int * const * pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a pointer to a const pointer to an int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int const ** pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a pointer to a pointer to a const int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int * const * const pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a const pointer to a const pointer to an int&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-修改-const&#34;&gt;3 修改 const&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个对象或变量被声明成&lt;code&gt;const&lt;/code&gt;，后续可以使用&lt;code&gt;const_cast&lt;/code&gt;修改其为可变&lt;/li&gt;
&lt;li&gt;将类的某些成员变量声明为&lt;code&gt;mutable&lt;/code&gt;，可在&lt;code&gt;const&lt;/code&gt;成员函数中修改它们&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-x-const-x&#34;&gt;4 X&lt;strong&gt;-&amp;gt;const X&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;X*&lt;/code&gt;转成&lt;code&gt;const X*&lt;/code&gt;是安全的&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将&lt;code&gt;X**&lt;/code&gt;转成&lt;code&gt;const X**&lt;/code&gt;会有编译警告，因为可能会不经 cast 操作修改一个&lt;code&gt;const X&lt;/code&gt;对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
void Modify();
}

int main()
{
const MyClass obj;
MyClass * ptr;
const MyClass ** pptr = &amp;amp;ptr; // compile error
*pptr = &amp;amp;obj; // ptr points to obj
ptr-&amp;gt;Modify();  // ptr modifies const obj
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-reference&#34;&gt;5 reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/const-correctness&#34; target=&#34;_blank&#34;&gt;const correctness&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const&#34; target=&#34;_blank&#34;&gt;What is the difference between const int*, const int * const, and int const *&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://duramecho.com/ComputerInformation/WhyHowCppConst.html&#34; target=&#34;_blank&#34;&gt;The C++ &amp;lsquo;const&amp;rsquo; Declaration: Why &amp;amp; How&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于 gitignore 文件</title>
      <link>https://xueqing.github.io/blog/git/git_ignore/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_ignore/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%bc%e5%bc%8f%e8%a7%84%e8%8c%83&#34;&gt;格式规范&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%80%9a%e9%85%8d%e7%ac%a6&#34;&gt;通配符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%9c%e7%ba%bf&#34;&gt;斜线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%a4%e4%b8%aa%e6%98%9f%e5%8f%b7&#34;&gt;两个星号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%22%22-%e5%8f%96%e6%b6%88%e5%bf%bd%e8%a7%86&#34;&gt;&amp;rdquo;!&amp;rdquo; 取消忽视&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bf%bd%e7%95%a5%e6%96%87%e4%bb%b6%e7%a4%ba%e4%be%8b&#34;&gt;忽略文件示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;格式规范&#34;&gt;格式规范&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;所有空行或者以 ＃ 开头的行都会被 git 忽略&lt;/li&gt;
&lt;li&gt;可以使用标准的 glob 模式匹配

&lt;ul&gt;
&lt;li&gt;glob 模式指 shell 所使用的简化了的正则表达式，包括&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;?&lt;/code&gt;、&lt;code&gt;[]&lt;/code&gt;、&lt;code&gt;**&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;匹配模式可以以(/)开头防止递归&lt;/li&gt;
&lt;li&gt;匹配模式可以以(/)结尾指定目录&lt;/li&gt;
&lt;li&gt;要忽略指定模式以外的文件或目录, 可以在模式前加上惊叹号(!)取反&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;通配符&#34;&gt;通配符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 匹配除了 &lt;code&gt;/&lt;/code&gt; 的所有字符，匹配零个或多个任意字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?&lt;/code&gt; 匹配除了 &lt;code&gt;/&lt;/code&gt; 的所有单字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt; 匹配任何一个列在方括号中的字符：如果在方括号中使用短划线分隔两个字符, 表示所有在这两个字符范围内的都可以匹配

&lt;ul&gt;
&lt;li&gt;比如 &lt;code&gt;[0-9]&lt;/code&gt; 表示匹配所有 0 到 9 的数字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;斜线&#34;&gt;斜线&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;行首第一个 &lt;code&gt;/&lt;/code&gt; 匹配路径的开始, 以 &lt;code&gt;.gitignore&lt;/code&gt; 当前所在路径计算相对路径&lt;/li&gt;
&lt;li&gt;如 &lt;code&gt;/*.txt&lt;/code&gt; 匹配与 &lt;code&gt;.gitignore&lt;/code&gt; 同一路径下的 txt 文件, 不包含 &lt;code&gt;.gitignore&lt;/code&gt; 当前路径下子文件内的 txt 文件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test/*.txt&lt;/code&gt; 路径的开始是 &lt;code&gt;t&lt;/code&gt; 而不是 &lt;code&gt;/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;两个星号&#34;&gt;两个星号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;**/&lt;/code&gt; 匹配任意中间目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/**&lt;/code&gt; 匹配包含的所有内容, 包括文件和文件夹, 以及子文件和子文件下的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/**/&lt;/code&gt; 匹配 0 个或多个目录&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;取消忽视&#34;&gt;&amp;rdquo;!&amp;rdquo; 取消忽视&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!pattern&lt;/code&gt; 否认 pattern, 即前一个 pattern 匹配的文件会再被包含&lt;/li&gt;
&lt;li&gt;注意: 如果一个文件的父文件夹被忽略, 那么 git 不能再包含该文件&lt;/li&gt;

&lt;li&gt;&lt;p&gt;忽视除了 /build/debug 下 除了 snap 的文件和文件夹&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gitignore&#34;&gt;## 前两句可互换顺序
build/debug/*
!build/debug
!build/debug/snap
## 如果包含下面的语句则不能再包含 snap 文件和文件夹
# build
# build/
# build/**
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;忽略文件示例&#34;&gt;忽略文件示例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;# 注释行&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*.[oa]&lt;/code&gt;        # 忽略所有以 .a 或 .o 为扩展名的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!lib.a&lt;/code&gt;        # 但是 lib.a 文件或者目录不要忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/TODO&lt;/code&gt;         # 只忽略根目录下的 TODO, 子目录的 TODO 不忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;build/&lt;/code&gt;        # 忽略所有 build/ 目录下的文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doc/*.txt&lt;/code&gt;     # 忽略 doc/&lt;em&gt;.txt, 但 doc/server/&lt;/em&gt;.txt 不忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doc/**/*.pdf&lt;/code&gt;  # 忽略 doc文件夹下所有的*.pdf&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/gitignore&#34; target=&#34;_blank&#34;&gt;教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/github/gitignore&#34; target=&#34;_blank&#34;&gt;ignore 模板&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关键字 extern 在 C 语言的使用</title>
      <link>https://xueqing.github.io/blog/cplusplus/extren_c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/extren_c/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%98%e9%87%8f%e6%88%96%e5%87%bd%e6%95%b0%e7%9a%84%e5%a3%b0%e6%98%8e%e5%92%8c%e5%ae%9a%e4%b9%89&#34;&gt;变量或函数的声明和定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a3%b0%e6%98%8e%e5%92%8c%e5%ae%9a%e4%b9%89%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e7%9a%84%e6%9c%80%e5%a5%bd%e6%96%b9%e5%bc%8f&#34;&gt;声明和定义全局变量的最好方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-1%e5%8f%af%e4%bb%a5%e5%a3%b0%e6%98%8e%e5%a4%9a%e6%ac%a1%e4%bd%86%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%80%e6%ac%a1&#34;&gt;关键点 1：可以声明多次但初始化一次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-2%e9%bb%98%e8%ae%a4%e5%ad%98%e5%82%a8%e7%b1%bb%e6%98%af-extern&#34;&gt;关键点 2：默认存储类是 extern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-3extern-%e5%8f%98%e9%87%8f%e6%88%96%e7%a8%8b%e5%ba%8f%e5%af%b9%e6%95%b4%e4%b8%aa%e7%a8%8b%e5%ba%8f%e5%8f%af%e8%a7%81&#34;&gt;关键点 3：extern 变量或程序对整个程序可见&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-4extern-%e4%bd%9c%e7%94%a8%e4%ba%8e%e5%8f%98%e9%87%8f&#34;&gt;关键点 4：extern 作用于变量&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%aa%e7%94%a8%e4%ba%8e%e5%a3%b0%e6%98%8e%e5%8f%98%e9%87%8f&#34;&gt;只用于声明变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e8%87%aa%e5%8a%a8%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;全局变量自动初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8d%e8%83%bd%e5%b1%80%e9%83%a8%e5%9c%b0%e5%88%9d%e5%a7%8b%e5%8c%96-extern-%e5%8f%98%e9%87%8f&#34;&gt;不能局部地初始化 extern 变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8d%e8%83%bd%e5%86%99%e5%85%a8%e5%b1%80%e7%9a%84%e8%b5%8b%e5%80%bc%e8%af%ad%e5%8f%a5&#34;&gt;不能写全局的赋值语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%b9%e7%b1%bb%e6%88%90%e5%91%98%e6%97%a0%e6%95%88&#34;&gt;对类成员无效&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af&#34;&gt;常见错误&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e8%a1%8c%e4%b8%ba&#34;&gt;未定义的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%96%e9%83%a8%e5%ae%9a%e4%b9%89&#34;&gt;外部定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%9a%e9%87%8d%e5%a4%96%e9%83%a8%e5%ae%9a%e4%b9%89&#34;&gt;多重外部定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%b4%e6%96%87%e4%bb%b6%e4%b8%ad%e5%8f%98%e9%87%8f%e7%9a%84%e5%a3%b0%e6%98%8e&#34;&gt;头文件中变量的声明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 用于声明 C 语言中的外部变量和函数。这个修饰符用于所有数据类型，比如 int，float，double，array，pointer，structure，function 等&lt;/li&gt;
&lt;li&gt;范围(scope)：不绑定到任何函数。作用域整个程序，是全局的&lt;/li&gt;
&lt;li&gt;默认值(default value)：全局变量的默认初始化值是 0(或 null)&lt;/li&gt;
&lt;li&gt;生命周期(lifetime)：直到整个程序执行结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 告诉编译器变量或函数(非静态的)都可以在链接时找到。适用于在模块之间共享某些全局变量，但是不想把它们放在一个头文件，或者在一个头文件中定义它们

&lt;ul&gt;
&lt;li&gt;大部分编译器编译器会优化程序确保它们不会为 &lt;code&gt;extern&lt;/code&gt; 对象保留内存，因为编译器知道定义它们的模块会保留内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;变量或函数的声明和定义&#34;&gt;变量或函数的声明和定义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明(declaration)：声明变量或函数存在程序的某个地方，但是不为它们分配内存。确定了变量或函数的类型

&lt;ul&gt;
&lt;li&gt;声明一个变量时，程序知道这个变量的类型；声明一个函数时，程序知道函数的参数、数据类型、参数顺序和函数返回类型&lt;/li&gt;
&lt;li&gt;声明是编译器需要的用于接受对标识符的引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定义(definition)：既包含声明的作用，也为变量或函数分配内存。可以认为定义是声明的一个超集&lt;/li&gt;
&lt;li&gt;因此一个函数或变量可以声明多次，但是只能定义一次(即同一个函数或变量不能存在两个位置)

&lt;ul&gt;
&lt;li&gt;定义是对标识符的实例化/实现&lt;/li&gt;
&lt;li&gt;定义时链接器需要的用于链接对这些实体的引用&lt;/li&gt;
&lt;li&gt;单一定义原则(One Definition Rule)：编译单元不应该对任意变量、函数、类类型、枚举类型或模板有多余一个的定义&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;声明和定义全局变量的最好方式&#34;&gt;声明和定义全局变量的最好方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明和定义全局变量的清晰、可靠的方式是使用一个头文件，该头文件包含变量的 &lt;code&gt;extern&lt;/code&gt; 声明

&lt;ul&gt;
&lt;li&gt;定义这些变量的源文件和引用这些变量的源文件包含此头文件&lt;/li&gt;
&lt;li&gt;对于每一个程序，有且只有一个源文件定义这些变量&lt;/li&gt;
&lt;li&gt;对于每一个程序，有且只有一个头文件声明这些变量&lt;/li&gt;
&lt;li&gt;这个头文件时重要的，它使能在独立的翻译单元(TU，translation units，源文件)之间交叉检查，同时确保一致性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;完整的程序可能还需要全局函数。C99 和 C11 要求函数在使用之前必须是已经声明或定义过的。使用一个头文件包含全局函数的 &lt;code&gt;extern&lt;/code&gt; 声明。也可以不加 &lt;code&gt;extern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽量避免使用全局函数——可以使用全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-1-可以声明多次但初始化一次&#34;&gt;关键点 1：可以声明多次但初始化一次&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个特殊的 &lt;code&gt;extern&lt;/code&gt; 变量或函数可以声明多次，但是只初始化一次。但是不可以声明一次，初始化多次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int i=25;//initializing variable i
extern int i;//again declaring variable i
int main() {
extern int i;//again declaring variable i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：25
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern void sum(int,int);//by default it is extern function
int main() {
extern void sum(int,int);//by default it is extern function
int a=5,b=10;
sum(a,b);
return 0;
}
void sum(int a, int b) {
printf(&amp;quot;%d\n&amp;quot;, a+b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int i=25;//initializing variable i
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
int i=20;//again initializing variable i
// 输出：编译错误(error: redefinition of ‘i’)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-2-默认存储类是-extern&#34;&gt;关键点 2：默认存储类是 extern&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 是所有全局变量和函数的默认存储类(storage class)，即全局变量和函数默认对整个程序可见，不需要声明或定义 &lt;code&gt;extern&lt;/code&gt; 函数。使用 &lt;code&gt;extern&lt;/code&gt; 关键字是多余的&lt;/li&gt;
&lt;li&gt;编译器会在全局函数的声明和定义前面自动加上 &lt;code&gt;extern&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在下面两个测试代码中，变量 &lt;code&gt;i&lt;/code&gt; 都是 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test1.c
#include &amp;lt;stdio.h&amp;gt;
int i;//definition of i: by default it is extern variable
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test2.c
#include &amp;lt;stdio.h&amp;gt;
extern int i;//extern variable
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误，未定义的引用(undefined reference to i)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test3.c
#include &amp;lt;stdio.h&amp;gt;
void sum(int,int);//by default it is extern function
int main() {
int a=5,b=10;
sum(a,b);
return 0;
}
void sum(int a, int b) {
printf(&amp;quot;%d\n&amp;quot;, a+b);
}
// 输出：15
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-3-extern-变量或程序对整个程序可见&#34;&gt;关键点 3：extern 变量或程序对整个程序可见&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 关键字用于扩展变量或函数的可见性。如果全局声明一个 &lt;code&gt;extern&lt;/code&gt; 变量或函数，那么它的可见性是整个程序，这个程序可能包含一个或多个文件。比如一个 C 程序，包含两个文件 &lt;code&gt;one.c&lt;/code&gt; 和 &lt;code&gt;two.c&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面程序的输出是 30&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//one.c
#include &amp;lt;conio.h&amp;gt;
int i=25;//by default extern variable
int j=5;//by default extern variable
//above two lines is initialization of variable i and j
void main() {
clrscr();
sum();
getch();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//two.c
#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaration of variable i
extern int j;//declaration of variable j
//above tow lines will search the initialization statement of variable i and j either in two.c(if initialized variable id static and static)
// or one.c(if initialized variable is extern)
void sum() {//by default extern function
int s;
s = i + j;
printf(&amp;quot;%d\n&amp;quot;, s);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个 &lt;code&gt;extern&lt;/code&gt; 变量或函数有外部(external)链接，一个外部链接的变量或函数对所有文件可见&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 作用于函数只是告诉编译链接是外部的；作用于变量只声明变量而不会定义(初始化或实例化)变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-4-extern-作用于变量&#34;&gt;关键点 4：extern 作用于变量&lt;/h2&gt;

&lt;h3 id=&#34;只用于声明变量&#34;&gt;只用于声明变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当对变量使用 &lt;code&gt;extern&lt;/code&gt; 修饰符时，它只用于声明(比如不会为这些变量分配内存)。因此在上述 &lt;code&gt;test2.c&lt;/code&gt; 中，编译器报错&lt;code&gt;undefined symbol&lt;/code&gt;。如果要定义变量(比如为 &lt;code&gt;extern&lt;/code&gt; 变量分配内存)，必须初始化变量&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化 &lt;code&gt;extern&lt;/code&gt; 变量即是定义 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i=10;//extern variable
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：10
// warning: ‘i’ initialized and declared ‘extern’
// 如果声明时也提供了初始化，那么会为变量分配内存，该变量认为是被定义过的
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译警告参考&lt;a href=&#34;https://stackoverflow.com/questions/4268589/warning-in-extern-declaration&#34; target=&#34;_blank&#34;&gt;warning in extern declaration&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//extern variable
int main() {
return 0;
}
// 编译成功。只声明变量 i 但是未使用，不会报错
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果我们声明一个变量是 &lt;code&gt;extern&lt;/code&gt;，那么编译器会搜索这个变量是否已经初始化。如果已经初始化为 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 则成功。否则编译器会报错&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;修正：初始化为 static 仍然报错????&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//it will search the initialization of i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
int i=20;//initialization of extern variable i
// 输出：20
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//it will search the initialization of i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
static int i=20;//initialization of static variable i
// 输出：编译错误(error: static declaration of ‘i’ follows non-static declaration)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;全局变量自动初始化&#34;&gt;全局变量自动初始化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果全局变量不适用 &lt;code&gt;extern&lt;/code&gt; 关键字，编译器会使用默认值自动初始化 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;extern&lt;/code&gt; 整数类型变量的默认初始化值是 0 或者 null&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
char c;
int i;
float f;
char *str;
int main() {
printf(&amp;quot;%d %d %f %s\n&amp;quot;, c, i, f, str);
return 0;
}
// 输出：0 0 0.000000 (null)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;不能局部地初始化-extern-变量&#34;&gt;不能局部地初始化 extern 变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不能在任何代码块内部局部地初始化 &lt;code&gt;extern&lt;/code&gt; 变量，不论是声明时初始化还是初始化和声明分开。我们只能全局地初始化 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i=10;
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(error: ‘i’ has both ‘extern’ and initializer)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//declaration of extern variable i
int i=10;//try to locally initialize extern variable i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(error: declaration of ‘i’ with no linkage follows extern declaration)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaration of extern variable i
int main() {
int i=10;//declare and define a local variable
printf(&amp;quot;%d\n&amp;quot;, i);//the i is local
return 0;
}
// 输出：10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//declaration of extern variable i, its memory is not allocated
i=10;//try to change the value of variable i to 10, but it doesn&#39;t exist
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(两处错误：undefined reference to i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;不能写全局的赋值语句&#34;&gt;不能写全局的赋值语句&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在声明变量时给变量赋值叫做初始化(initialization)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不在变量声明时给变量赋值叫做赋值(assignment)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int i=25;//initializing variable i
i=20;
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(error: redefinition of ‘i’)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int main() {
i=20;//assignment
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
int i=25;//initialization
// 输出：20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;对类成员无效&#34;&gt;对类成员无效&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 被类成员忽略&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;常见错误&#34;&gt;常见错误&lt;/h2&gt;

&lt;h3 id=&#34;未定义的行为&#34;&gt;未定义的行为&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://port70.net/~nsz/c/c11/n1570.html#6.9&#34; target=&#34;_blank&#34;&gt;Undefined behavior&lt;/a&gt;：使用了一个带外部链接的标识符，但是程序中不存在该标识符的外部定义，或者没有使用此标识符但是有多处定义此标识符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;外部定义&#34;&gt;外部定义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://port70.net/~nsz/c/c11/n1570.html#6.9p5&#34; target=&#34;_blank&#34;&gt;External definitions&lt;/a&gt;：外部定义指一个外部声明，同事也是函数(除了内联函数)或对象的定义。如果一个表达式中使用了一个有外部链接的标识符(除了作为 &lt;code&gt;sizeof&lt;/code&gt;或&lt;code&gt;_Alignof&lt;/code&gt;运算符的操作数的一部分，这些运算符的结果是一个证书常数)，程序的其它地方应该有且仅有一个对此标识符的外部定义&lt;/li&gt;
&lt;li&gt;因此，如果一个声明为外部链接的标识符未在表达式中被使用，不应该有它的外部定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;多重外部定义&#34;&gt;多重外部定义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://port70.net/~nsz/c/c11/n1570.html#J.5.11&#34; target=&#34;_blank&#34;&gt;Multiple external definitions&lt;/a&gt;：对于一个对象的标识符可能有多于一处的外部定义，这些定义可能有也可能没有显式使用 &lt;code&gt;extern&lt;/code&gt; 关键字；如果这些定义不一致，或者多于一处有初始化，就会导致 undefined behavior&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;头文件中变量的声明&#34;&gt;头文件中变量的声明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;声明 &lt;code&gt;int some_var;&lt;/code&gt;：如果一个头文件不使用 &lt;code&gt;extern&lt;/code&gt; 定义一个变量，那么每个包含此头文件的文件都会尝试创建一个此变量的一个定义。但是 C 标准不确保这个一定会正常工作&lt;/li&gt;
&lt;li&gt;声明 &lt;code&gt;int some_var = 13;&lt;/code&gt;：如果头文件定义并初始化一个变量，那么在给定的程序中只有一个源文件可以使用这个头文件。因为头文件主要是用来共享信息的，创建一个只能使用一次的头文件不是好的做法&lt;/li&gt;
&lt;li&gt;声明 &lt;code&gt;static int some_var =3;&lt;/code&gt;：如果头文件定义一个静态变量(不论是否初始化)，那么每个源文件都会有此“全局”变量的一份私有拷贝。而且，如果这个变量是一个复杂的数组，那么会导致大量代码的拷贝&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cquestions.com/2011/02/extern-keyword-in-c.html&#34; target=&#34;_blank&#34;&gt;extern keyword in c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/&#34; target=&#34;_blank&#34;&gt;Understanding “extern” keyword in C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files&#34; target=&#34;_blank&#34;&gt;How do I use extern to share variables between source files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dreamincode.net/forums/topic/171468-declarations-vs-definitions/&#34; target=&#34;_blank&#34;&gt;DECLARATIONS V.S. DEFINITIONS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>内容编辑参考</title>
      <link>https://xueqing.github.io/blog/django_cms/using/content_editor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/django_cms/using/content_editor/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ae%a1%e7%90%86%e9%a1%b5%e9%9d%a2&#34;&gt;管理页面&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3&#34;&gt;接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#django-cms&#34;&gt;django CMS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#site-menu&#34;&gt;Site menu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#page-menu&#34;&gt;Page menu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#language-menu&#34;&gt;Language menu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#publishing-controller&#34;&gt;Publishing controller&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ae%a1%e7%90%86%e5%91%98%e8%a7%86%e5%9b%be%e5%92%8c%e7%bb%84%e6%88%90&#34;&gt;管理员视图和组成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%a1%b5%e9%9d%a2%e5%88%97%e8%a1%a8&#34;&gt;页面列表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;管理页面&#34;&gt;管理页面&lt;/h2&gt;

&lt;h3 id=&#34;接口&#34;&gt;接口&lt;/h3&gt;

&lt;p&gt;django CMS 的工具栏包括以下几部分。&lt;/p&gt;

&lt;h4 id=&#34;django-cms&#34;&gt;django CMS&lt;/h4&gt;

&lt;p&gt;返回到网站的主页。&lt;/p&gt;

&lt;h4 id=&#34;site-menu&#34;&gt;Site menu&lt;/h4&gt;

&lt;p&gt;example.com 是网站菜单。这个菜单开放一些对网站的管理控制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Pages ...&lt;/code&gt;：直接跳转到页面编辑接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Users ...&lt;/code&gt;：直接跳转到用户管理面板&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Administration ...&lt;/code&gt;：跳转到网站管理员面板&lt;/li&gt;
&lt;li&gt;&lt;code&gt;User settings ...&lt;/code&gt;：切换管理员界面和工具栏的语言&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Disable toolbar&lt;/code&gt;：无论登录和工作状态如何，完全禁用工具栏和前端编辑。想要重新记号，需要手动或通过后端管理进入编辑模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Shortcuts ...&lt;/code&gt;：快捷键&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Logout admin&lt;/code&gt;：退出登录&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;page-menu&#34;&gt;Page menu&lt;/h4&gt;

&lt;p&gt;管理当前页面的选项。&lt;/p&gt;

&lt;h4 id=&#34;language-menu&#34;&gt;Language menu&lt;/h4&gt;

&lt;p&gt;切换当前页面的语言，管理多个翻译。支持的操作&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;增加一个缺失的翻译&lt;/li&gt;
&lt;li&gt;删除一个已有的翻译&lt;/li&gt;
&lt;li&gt;从一个已有的翻译复制所有插件及其内容到当前语言&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;publishing-controller&#34;&gt;Publishing controller&lt;/h4&gt;

&lt;p&gt;管理页面的发布状态。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Edit&lt;/code&gt;：打开页面进行编辑&lt;/li&gt;
&lt;li&gt;&lt;code&gt;View published&lt;/code&gt;：更新页面，退出编辑模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Publish page now&lt;/code&gt;：发布一个未发布的页面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Publish page changes&lt;/code&gt;：发布在页面做的修改&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;管理员视图和组成&#34;&gt;管理员视图和组成&lt;/h3&gt;

&lt;h4 id=&#34;页面列表&#34;&gt;页面列表&lt;/h4&gt;

&lt;p&gt;页面列表可以纵观页面及其状态。&lt;/p&gt;

&lt;p&gt;从左至右，列表元素具有下面的属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;展开/折叠控制：有子节点的页面有这个控制&lt;/li&gt;
&lt;li&gt;tab：用于拖拽列表元素&lt;/li&gt;
&lt;li&gt;页面 Title&lt;/li&gt;
&lt;li&gt;语言版本指示符和控制：

&lt;ul&gt;
&lt;li&gt;空白：不存在翻译；点击之后会打开基本设置&lt;/li&gt;
&lt;li&gt;灰色：翻译存在但是未发布&lt;/li&gt;
&lt;li&gt;绿色：翻译已发布&lt;/li&gt;
&lt;li&gt;蓝色：翻译有一个修改的草稿&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Menu 指示符：页面是否会出现在导航菜单&lt;/li&gt;
&lt;li&gt;编辑：修改页面设置&lt;/li&gt;
&lt;li&gt;添加子页面&lt;/li&gt;
&lt;li&gt;其他行为：拷贝页面、剪切页面、删除页面、高级设置等&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>内联</title>
      <link>https://xueqing.github.io/blog/cplusplus/inline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/inline/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8f%8f%e8%bf%b0&#34;&gt;描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%af%e8%af%ad%e5%92%8c%e5%ae%9a%e4%b9%89&#34;&gt;术语和定义&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e8%af%91%e5%8d%95%e5%85%83&#34;&gt;编译单元&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8d%95%e5%ae%9a%e4%b9%89%e8%a7%84%e5%88%99&#34;&gt;单定义规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e8%81%94%e5%a3%b0%e6%98%8e&#34;&gt;内联声明&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;成员函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8d%e9%80%82%e5%90%88%e5%86%85%e8%81%94%e6%9b%bf%e6%8d%a2%e7%9a%84%e7%94%a8%e6%b3%95&#34;&gt;不适合内联替换的用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cc-staticextern--inline&#34;&gt;C/C++ static/extern + inline&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#c8990-inline&#34;&gt;C89/90 inline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c99-inline&#34;&gt;C99 inline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-inline&#34;&gt;C++ inline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gcc-%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9&#34;&gt;GCC 编译选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0%e5%af%b9%e5%ae%89%e5%85%a8%e6%80%a7%e5%92%8c%e9%80%9f%e5%ba%a6%e7%9a%84%e5%8f%96%e8%88%8d&#34;&gt;内联函数对安全性和速度的取舍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#inline-vs-micro&#34;&gt;inline vs micro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;问题&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98c99-inline-without-static-or-extern&#34;&gt;问题：C99 inline without static or extern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++ 提出，C99 引入支持，C89 支持内联扩展&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;用于需要某个函数的定义对调用者可见的程序优化

&lt;ul&gt;
&lt;li&gt;可见性：函数需要有内部链接，或者外部链接且和调用者在同一个编译单元。此时，函数声明或定义中的&lt;code&gt;inline&lt;/code&gt;只用于指示对这个函数的调用可被展开优化&lt;/li&gt;
&lt;li&gt;当调用者和被调用的函数定义位于不同的编译单元时，&lt;code&gt;inline&lt;/code&gt;支持包含调用者的编译单元也包含一个局部(内联)的函数的定义&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;用于声明一个内联函数，可使 GCC 直接更快地调用此函数

&lt;ul&gt;
&lt;li&gt;GCC 可以将内联函数代码展开插入到调用者代码内部，因此减少了函数调用(寄存器状态的修改保存)的负载&lt;/li&gt;
&lt;li&gt;如果实参的值是常量，可在编译时计算简化，因此不是所有内联函数代码都会被包含&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可使用&lt;code&gt;-finline-functions&lt;/code&gt;选项指定 GCC 将所有“足够简单”的函数展开插入到调用者内部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;用于多个编译单元调用某个函数，但是只想暴露该函数的定义在一个头文件&lt;/li&gt;
&lt;li&gt;在关闭优化时，GCC 不会内联任何函数，必须在某处定义符号，&lt;code&gt;inline&lt;/code&gt;声明定义的函数才是可见的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;术语和定义&#34;&gt;术语和定义&lt;/h2&gt;

&lt;h3 id=&#34;编译单元&#34;&gt;编译单元&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c&#34; target=&#34;_blank&#34;&gt;What is a “translation unit” in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;编译单元(compilation/translation unit): C++ 编译的基础单元。包括一个单独的源文件，以及直接或间接包含的头文件的内容，减去条件预处理忽视的内容&lt;/li&gt;
&lt;li&gt;一个编译单元可被编译成一个目标文件、库或可执行程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;单定义规则&#34;&gt;单定义规则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/4192170/what-exactly-is-one-definition-rule-in-c&#34; target=&#34;_blank&#34;&gt;What exactly is One Definition Rule in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;单定义规则(one-definition rule)：每个程序对于其使用的每个非内联函数或对象应该只包含一个定义。定义可以显式出现在该程序中，可在标准库或用户定义的库中查找，或者隐式定义。内联函数应在每个使用的编译单元中定义&lt;/li&gt;
&lt;li&gt;每个编译单元对于所有的变量、函数、类的类型、枚举类型或模板不超过一个定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内联声明&#34;&gt;内联声明&lt;/h2&gt;

&lt;h3 id=&#34;非成员函数&#34;&gt;非成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;GCC 实现三种语法来声明内联函数

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;-finline-functions&lt;/code&gt;，同时指定参数&lt;code&gt;-std=gnu89/fgnu89-inline&lt;/code&gt;，或所有内联函数声明处有&lt;code&gt;gnu-inline&lt;/code&gt;属性&lt;/li&gt;
&lt;li&gt;指定参数&lt;code&gt;-std=c99/-std=gnu99&lt;/code&gt;，或者使用更新的 C 版本&lt;/li&gt;
&lt;li&gt;编译 C++ 代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;inline&lt;/code&gt;关键字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline int inc(int *a)
{
return (*a)++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在 ISO C90 程序的头文件中声明内联，使用&lt;code&gt;__inline__&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上述三种类型的内联行为再两种情况下是行为是类似的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于&lt;code&gt;static&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;第一次声明时未使用&lt;code&gt;inline&lt;/code&gt;关键字，定义时使用&lt;code&gt;inline&lt;/code&gt;关键字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;除了速度，上述两种方式和不使用&lt;code&gt;inline&lt;/code&gt;关键字行为相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern int inc(int *a);
inline int inc(int *a)
{
return (*a)++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个函数是&lt;code&gt;static inline&lt;/code&gt;时，如果所有调用函数的地方展开插入了此函数的代码，而且函数的地址从未被使用，那么函数自己的汇编代码从未被引用。这种情况下，除非使用&lt;code&gt;-fkeep-inline-functions&lt;/code&gt;，GCC 实际上不会为此函数生成汇编代码。如果有一处调用未展开插入代码，那么正常生成汇编代码；如果程序引用了该地址，函数必须正常编译，因为此处不能被内联&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：除非是在一个&lt;code&gt;.cpp&lt;/code&gt;文件使用，必须将内联函数定义放在一个头文件，然后从其他&lt;code&gt;.cpp&lt;/code&gt;调用，否则会有链接错误&lt;code&gt;unresolved external&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;成员函数&#34;&gt;成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GCC 将定义在类内的成员函数视作内联函数(可没有&lt;code&gt;inline&lt;/code&gt;)。可使用&lt;code&gt;-fno-default-inline&lt;/code&gt;覆盖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Fred {
public:
void f(int i, char c)
{
  // ...
}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似声明非成员函数：声明时不带&lt;code&gt;inline&lt;/code&gt;，定义时使用&lt;code&gt;inline&lt;/code&gt;，在类外部定义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;建议使用此方式，以隐藏类的实现&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Foo {
public:
void method();  // Best practice: Don&#39;t put the inline keyword here
// ...
};

inline void Foo::method()  // Best practice: Put the inline keyword here
{
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：必须将内联函数定义放在一个头文件，然后从其他&lt;code&gt;.cpp&lt;/code&gt;调用，否则会有链接错误&lt;code&gt;unresolved external&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;不适合内联替换的用法&#34;&gt;不适合内联替换的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;函数定义包含下面用法的不适合内联替换

&lt;ul&gt;
&lt;li&gt;可变参数函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;alloca&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;使用计算的&lt;code&gt;goto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用非本地的&lt;code&gt;goto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用嵌入函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;setjmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;__builtin_longjmp&lt;/code&gt;/&lt;code&gt;__builtin_return&lt;/code&gt;/&lt;code&gt;__built_apply_args&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c-c-static-extern-inline&#34;&gt;C/C++ static/extern + inline&lt;/h2&gt;

&lt;h3 id=&#34;c89-90-inline&#34;&gt;C89/90 inline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;inline：可能会被内联展开。总会生成非内联版本且对外部可见。只在一个编译单元定义，其他编译单元可见且视为非内联函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个编译单元只会拥有该函数的拷贝，每个拷贝只对编译单元内部可见，且拷贝之间不会有冲突。缺点包括两部分&lt;/li&gt;
&lt;li&gt;大型工程中，可能包含很多相同函数的拷贝，导致目标代码增大&lt;/li&gt;
&lt;li&gt;不太可能比较函数指针，因为不确定是哪份拷贝版本&lt;/li&gt;
&lt;li&gt;C89 编译器支持内联扩展&lt;/li&gt;
&lt;li&gt;MVC++：&lt;code&gt;__forceinline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GCC/Clang：在不优化时，除非指定&lt;code&gt;always_inline&lt;/code&gt;属性，GCC 不会内联任何函数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__attribute__((always_inline))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__attribute__((__always_inline__))&lt;/code&gt;：可避免与用户定义的宏&lt;code&gt;always_inline&lt;/code&gt;冲突&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编译器在某些情况下不能内联替换，此时会有编译警告&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建议使用下面的可移植代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifdef _MSC_VER
#define forceinline __forceinline
#elif defined(__GNUC__)
#define forceinline inline __attribute__((__always_inline__))
#elif defined(__CLANG__)
#if __has_attribute(__always_inline__)
    #define forceinline inline __attribute__((__always_inline__))
#else
    #define forceinline inline
#endif
#else
#define forceinline inline
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;extern inline：不会生成非内联版本对外部可见，但是可以调用(必须在其他编译单元定义，且调用的代码和内联代码相同)，&lt;code&gt;one-definition&lt;/code&gt;的原则适用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原因：C89 中定义为&lt;code&gt;extern&lt;/code&gt;的存储不会被保留，而不带&lt;code&gt;extern&lt;/code&gt;的存储一定会保留；C99 的&lt;code&gt;extern inline&lt;/code&gt;会生成非内联函数&lt;/li&gt;
&lt;li&gt;类似宏。使用方式是将函数定义(同时指定&lt;code&gt;inline&lt;/code&gt;和&lt;code&gt;extern&lt;/code&gt;关键字)放在一个头文件中，把另一个定义的拷贝(不指定&lt;code&gt;inline&lt;/code&gt;和&lt;code&gt;extern&lt;/code&gt;关键字)放在一个库文件中。头文件的定义使得大部分函数调用都是内联展开的。如果存在其他编译单元的函数调用，引用这个库文件的唯一拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static inline：不会生成外部可见的非内联版本，但是可能会生成一个局部可见的函数，&lt;code&gt;one-definition&lt;/code&gt;的原则不适用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c99-inline&#34;&gt;C99 inline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;inline：类似 C89/90的&lt;code&gt;extern inline&lt;/code&gt;，不会生成外部可见代码，但是可以调用(必须在其他编译单元定义，且调用的代码和内联代码相同)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在头文件(.h)中使用&lt;code&gt;inline&lt;/code&gt;定义，在一个编译单元的源文件(.c)中使用&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;inline&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//.h
inline double dabs(double x) {return x &amp;lt; 0.0 ? -x : x;}
//.c
extern inline double dabs(double x);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;extern inline：类似 C89/90的&lt;code&gt;inline&lt;/code&gt;，不会生成外部可见代码，至多一个编译单元可以使用此函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义为&lt;code&gt;inline&lt;/code&gt;的函数要求：程序的其他地方有且只有一处需要声明该函数为&lt;code&gt;extern inline&lt;/code&gt;或没有修饰符&lt;/li&gt;
&lt;li&gt;如果有多处声明，链接器会报重复的符号错误&lt;/li&gt;
&lt;li&gt;其他地方没有声明，链接器不会报错&lt;/li&gt;
&lt;li&gt;建议：在头文件定义&lt;code&gt;inline&lt;/code&gt;函数，为每个函数创建一个&lt;code&gt;.c&lt;/code&gt;文件，包含该函数的&lt;code&gt;extern inline&lt;/code&gt;声明以及对应的头文件：声明和包含头文件的语句先后无关&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static inline：类似 C89/90，二者之间相同&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-inline&#34;&gt;C++ inline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;inline：一处内联其他所有地方都会内联。编译器/链接器会排序该符号的多个实例

&lt;ul&gt;
&lt;li&gt;在头文件定义，对整个工程可见；且如果不能展开替换，只会生成一个外部符号&lt;/li&gt;
&lt;li&gt;在所有地方有相同的定义，必须有&lt;code&gt;inline&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;类内定义的函数会自动添加&lt;code&gt;inline&lt;/code&gt;修饰符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;extern inline：没有此定义，支持的编译器行为类似 C89/90&lt;/li&gt;
&lt;li&gt;static inline：没有此定义，支持的编译器行为类似 C89/90&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gcc-编译选项&#34;&gt;GCC 编译选项&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GCC 版本大于等于 4.2：使用 C89 的&lt;code&gt;inline&lt;/code&gt;语法，即使显式指定了&lt;code&gt;-std=c99&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GCC 版本是 5：GCC 使用 gnu11 的语法，默认使用 C99 的&lt;code&gt;inline&lt;/code&gt;语法

&lt;ul&gt;
&lt;li&gt;显式指定&lt;code&gt;-std=gnu89&lt;/code&gt;：使用 C89 语法&lt;/li&gt;
&lt;li&gt;指定&lt;code&gt;-fgnu89-inline&lt;/code&gt;或在所有&lt;code&gt;inline&lt;/code&gt;声明处增加&lt;code&gt;gnu_inline&lt;/code&gt;属性：使用 C89 语法，只会影响内联&lt;/li&gt;
&lt;li&gt;指定&lt;code&gt;-std=c99&lt;/code&gt;或&lt;code&gt;-std=c11&lt;/code&gt;或&lt;code&gt;-std=gnu99&lt;/code&gt;(不带&lt;code&gt;-fgnu89-inline&lt;/code&gt;)：确定使用 C99 语法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;-winline&lt;/code&gt;：当标记为&lt;code&gt;inline&lt;/code&gt;的函数不可替换时，编译警告&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内联函数对安全性和速度的取舍&#34;&gt;内联函数对安全性和速度的取舍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C 语言中，可以通过在结构体中放一个&lt;code&gt;void*&lt;/code&gt;实现对结构体的封装，即结构体的使用者不知道&lt;code&gt;void*&lt;/code&gt;指向的真正的数据，但可以通过调用函数将&lt;code&gt;void*&lt;/code&gt;转成合适的隐藏类型。这个做法会破坏类型的安全性，也会包括对结构体其他字段的访问(如果允许直接访问结构体的域，需要知道如何解释&lt;code&gt;void*&lt;/code&gt;的使用者就可以直接访问结构体，使得很难修改底层的数据结构)&lt;/li&gt;
&lt;li&gt;包含内联函数的目标代码的大小和执行速度的影响是不可预测的

&lt;ul&gt;
&lt;li&gt;时间性能：以空间换时间&lt;/li&gt;
&lt;li&gt;可使程序变快

&lt;ul&gt;
&lt;li&gt;减少函数调用的代价&lt;/li&gt;
&lt;li&gt;可移除函数调用所需的指令：栈和寄存器的使用&lt;/li&gt;
&lt;li&gt;不需要寄存器传递参数&lt;/li&gt;
&lt;li&gt;在引用调用、地址调用或共享调用时，不需要引用和解引用&lt;/li&gt;
&lt;li&gt;支持高级优化和调度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可使程序变慢：内联展开会增加代码大小，在内存页有限的情况下，可能增加内存页的置换和磁盘的读写&lt;/li&gt;
&lt;li&gt;目标代码大小&lt;/li&gt;
&lt;li&gt;可使程序变大：通常状况下展开代码类似于拷贝代码&lt;/li&gt;
&lt;li&gt;可使程序变小：展开函数时，编译器可能会优化代码，移除不必要的代码&lt;/li&gt;
&lt;li&gt;内存性能&lt;/li&gt;
&lt;li&gt;系统抖动(内存页置换)

&lt;ul&gt;
&lt;li&gt;调用的内联函数和当前函数可能位于不同的页，内联展开可能使其位于同一个页，可避免系统抖动&lt;/li&gt;
&lt;li&gt;可能增大二进制可执行文件大小，导致系统抖动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缓存未命中

&lt;ul&gt;
&lt;li&gt;内联通常改善了二进制代码内部引用的局部性，可减少使用缓存行来存储内部循环，使得 CPU 受限的应用运行更快&lt;/li&gt;
&lt;li&gt;可能导致对多个缓存行的循环处理，导致缓存抖动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可能和运行速度无关：大部分系统不是 CPU 受限的，而是 I/O、数据库或网络受限的，即系统整个性能的瓶颈在于文件系统、数据库或网络。因此，除非 CPU 固定在 100%，内联函数不会使得程序运行更快&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;inline-vs-micro&#34;&gt;inline vs micro&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;展开时间不同

&lt;ul&gt;
&lt;li&gt;内联展开发生在编译时，不会修改源码(text)&lt;/li&gt;
&lt;li&gt;宏展开发生在编译之前，生成不同的 text 再给编译器处理，会污染命名空间和代码，不利于调试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类型检查：C 语言中宏调用没有类型检查；内联函数会检查参数类型，必须正确执行类型转换&lt;/li&gt;
&lt;li&gt;C 语言中，宏不能像函数一样调用&lt;code&gt;return&lt;/code&gt;关键字，不能终止调用者&lt;/li&gt;
&lt;li&gt;编译错误：宏内的编译错误很难理解，因为指向的是展开的代码，而不是源代码&lt;/li&gt;
&lt;li&gt;递归：很多编译器可以内联递归函数，但是递归宏是不允许的

&lt;ul&gt;
&lt;li&gt;有的编译器可控制递归展开的深度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码的可维护性：随着函数改进，函数的内联属性可能会变化，一个函数内联与否比宏的修改要简单&lt;/li&gt;
&lt;li&gt;宏的其他问题

&lt;ul&gt;
&lt;li&gt;含&lt;a href=&#34;https://isocpp.org/wiki/faq/misc-technical-issues#macros-with-if&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;含&lt;a href=&#34;https://isocpp.org/wiki/faq/misc-technical-issues#macros-with-multi-stmts&#34; target=&#34;_blank&#34;&gt;多个语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;含&lt;a href=&#34;https://isocpp.org/wiki/faq/misc-technical-issues#macros-with-token-pasting&#34; target=&#34;_blank&#34;&gt;令牌黏贴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内联函数避免上述问题：内联函数检查每个参数一次，类似于调用普通函数，但是更快&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// A macro that returns the absolute value of i
#define unsafe(i) ( (i) &amp;gt;= 0 ? (i) : -(i) )

// An inline function that returns the absolute value of i
inline int safe(int i) { return i &amp;gt;= 0 ? i : -i; }

int f();

void userCode(int x)
{
int ans;

ans = unsafe(x++);   // Error! x is incremented twice
ans = unsafe(f());   // Danger! f() is called twice

ans = safe(x++);     // Correct! x is incremented once
ans = safe(f());     // Correct! f() is called once
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编译器不一定会内联程序员指定的函数

&lt;ul&gt;
&lt;li&gt;模板方法/函数不是总被内联展开&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;内联函数的代码暴露给调用者&lt;/li&gt;
&lt;li&gt;传统的 C 编译系统会增加内联编译时间，因为会拷贝函数体到调用者&lt;/li&gt;
&lt;li&gt;C99 的要求

&lt;ul&gt;
&lt;li&gt;如果在别处使用某内联函数，只能有一个&lt;code&gt;extern&lt;/code&gt;声明。当关掉优化禁止内联时，如果没有会有链接错误&lt;/li&gt;
&lt;li&gt;如果增加声明，放到一个库进行链接，使用链接时优化或&lt;code&gt;static inline&lt;/code&gt;，可能导致不能到达的代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C++中，普通函数只需要在一个模块中定义，但是需要在每个模块中定义使用的内联函数，否则不能编译某个单独的模块(依赖其他模块)。视编译器而定，可能会导致不能内联替换的模块的对象文件包含函数的拷贝&lt;/li&gt;
&lt;li&gt;在嵌入式软件中，可能通过类似&lt;code&gt;pragma&lt;/code&gt;编译指令将一些函数放到代码段。如果一个内存段的代码调用另一个内存段的代码，如果被调用函数内部有内联，那么可能会停到一个不应该的段。比如高性能的内存段代码空间有限，如果内部函数调用另一个高性能内存之外的函数，且被调用函数较大，内部有内联的话，可能会超出高性能内存的空间&lt;/li&gt;
&lt;li&gt;C++ 编译时链接，因此如果修改了内联函数，必须重新编译使用此函数的所有代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;问题-c99-inline-without-static-or-extern&#34;&gt;问题：C99 inline without static or extern&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/26503235/c-inline-function-and-gcc&#34; target=&#34;_blank&#34;&gt;C, inline function and GCC [duplicate]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/6312597/is-inline-without-static-or-extern-ever-useful-in-c99&#34; target=&#34;_blank&#34;&gt;Is “inline” without “static” or “extern” ever useful in C99&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/16245521/c99-inline-function-in-c-file/16245669#16245669&#34; target=&#34;_blank&#34;&gt;C99 inline function in .c file&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// main.cpp
inline int foo() {return 10 + 3;}

int main() {foo(); return 0;}
// g++ -std=c99 -x c main.cpp
// gcc -std=c99 -o a main.cpp
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GCC 链接错误&lt;code&gt;undefined reference to foo&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;问题：&lt;code&gt;inline&lt;/code&gt;只是声明内联函数，不会生成实际的代码，但是&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;用于告诉编译器将函数放在哪个对象文件，用于编译生成对应的代码(可能是拷贝)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;增加&lt;code&gt;extern inline int foo();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;增加&lt;code&gt;static&lt;/code&gt;修饰符，告诉编译器&lt;code&gt;有且只在这里&lt;/code&gt;，以便生成对应代码&lt;/li&gt;
&lt;li&gt;或使用&lt;code&gt;-O&lt;/code&gt;优化代码，编译器将标记为&lt;code&gt;inline&lt;/code&gt;的代码内联展开，在这里会忽略这部分代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Inline_function&#34; target=&#34;_blank&#34;&gt;Inline function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Inline.html&#34; target=&#34;_blank&#34;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/inline-functions&#34; target=&#34;_blank&#34;&gt;inline functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/&#34; target=&#34;_blank&#34;&gt;Myth and reality about inline in C99&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>创建一个 master playlist</title>
      <link>https://xueqing.github.io/translation/hls/creating_a_master_playlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/creating_a_master_playlist/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/creating_a_master_playlist&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;master playlist 描述了对于你的内容所有可访问的 variant(变体)。每个 variant 是一个特定比特率的流版本且被包含在一个单独的 playlist。客户端基于测量的网络比特率切换到最合适的 variant。调节客户端的播放器最小化回放的停顿，以便给用户进坑好的流体验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/translation/hls/images/hls_master_playlist.png&#34; alt=&#34;hls master playlist&#34; /&gt;&lt;/p&gt;

&lt;p&gt;master playlist 不能重复读。一旦客户端读到 master playlist，它假定 variant 集合不会改变。当客户端在其中一个单一的 variant playlist 中看到 EXT-X-ENDLIST 标记时流结束。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的示例展示了定义不同 variant 的一个 master playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/low/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/lo_mid/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/hi_mid/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/high/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=&amp;quot;mp4a.40.5&amp;quot;
http://example.com/audio/index.m3u8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;master playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-stream-inf&#34;&gt;EXT-X-STREAM-INF&lt;/h3&gt;

&lt;p&gt;表示 playlist 文件的下一个 URL 标识了另一个 playlist 文件。EXT-X-STREAM-INF 标记包含下面的参数：&lt;/p&gt;

&lt;h4 id=&#34;average-bandwidth&#34;&gt;AVERAGE-BANDWIDTH&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)一个整数，表示这个 variant 流的平均比特率。&lt;/p&gt;

&lt;h4 id=&#34;bandwidth&#34;&gt;BANDWIDTH&lt;/h4&gt;

&lt;p&gt;(必选)一个证书，表示对于每个媒体文件所有比特率的上限，单位是 比特/秒。上限值的计算包含了所有出现或将会出现在 playlist 中的容器负载。&lt;/p&gt;

&lt;h4 id=&#34;frame-rate&#34;&gt;FRAME-RATE&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)一个浮点值，描述了一个 variant 流的最大帧率。&lt;/p&gt;

&lt;h4 id=&#34;hdcp-level&#34;&gt;HDCP-LEVEL&lt;/h4&gt;

&lt;p&gt;(可选)表明使用的加密类型。有效值是 TYPE-0 和 NONE。如果只有使用 HDCP 保护输出才能播放这个流，使用 TYPE-0。&lt;/p&gt;

&lt;h4 id=&#34;resolution&#34;&gt;RESOLUTION&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)这个选项展示了播放 playlist 所有视频的大小，单位是像素。所有包含视频的流都应该包含这个参数。&lt;/p&gt;

&lt;h4 id=&#34;video-range&#34;&gt;VIDEO-RANGE&lt;/h4&gt;

&lt;p&gt;(视编码而定)一个字符串，有效值是 SDR 或 PQ。如果没有指定传输特征编码 1, 16 或 18，那么必须忽视这个参数。&lt;/p&gt;

&lt;h4 id=&#34;codecs&#34;&gt;CODECS&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)一个引用字符串，包含了一个逗号分隔的格式列表，其中每个格式指定了出现在 playlist 中的一个媒体片段的媒体采样类型。有效的格式标识是根据 RFC 6381 定义的 ISO 文件格式命名空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：虽然 CODECS 参数可选，每个 EXT-X-STREAM-INF 标记应该包含这个属性。这个属性提供了解码一个特定流所需的完整编码。它支持客户端区分只包含音频的 variant 和包含音频及视频的 variant。然后，客户端可以利用这个信息在切换流的时候提供更好的用户体验。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>制作 Python 运行环境镜像</title>
      <link>https://xueqing.github.io/blog/docker/python_img/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/docker/python_img/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8b%89%e5%8f%96%e5%9f%ba%e7%a1%80%e9%95%9c%e5%83%8f&#34;&gt;拉取基础镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e5%86%99-dockerfile&#34;&gt;编写 Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%b6%e4%bd%9c%e9%95%9c%e5%83%8f&#34;&gt;制作镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%b4%e6%96%b0%e9%95%9c%e5%83%8f&#34;&gt;更新镜像&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85-sphinx--readthedocs-%e6%94%af%e6%8c%81&#34;&gt;安装 Sphinx + ReadTheDocs 支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95-1%e8%bf%9b%e5%85%a5%e9%95%9c%e5%83%8f%e5%86%85%e9%83%a8%e6%9b%b4%e6%96%b0%e9%95%9c%e5%83%8f&#34;&gt;方法 1：进入镜像内部更新镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%b9%e6%b3%95-2%e7%bc%96%e5%86%99%e6%96%b0%e7%9a%84-dockerfile&#34;&gt;方法 2：编写新的 Dockerfile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a8%e9%80%81%e9%95%9c%e5%83%8f&#34;&gt;推送镜像&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a8%e9%80%81%e5%88%b0%e5%ae%98%e6%96%b9%e4%bb%93%e5%ba%93-docker-hub&#34;&gt;推送到官方仓库 Docker Hub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a8%e9%80%81%e5%88%b0%e7%a7%81%e6%9c%89%e4%bb%93%e5%ba%93-xxx&#34;&gt;推送到私有仓库 xxx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;拉取基础镜像&#34;&gt;拉取基础镜像&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull ubuntu:16.04
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;编写-dockerfile&#34;&gt;编写 Dockerfile&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建目录
mkdir docker-image/python &amp;amp;&amp;amp; cd docker-image/python
# 编写 Dockerfile
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM ubuntu:16.04
MAINTAINER kiki
# 更新 apt
RUN  apt-get update &amp;amp;&amp;amp; apt-get install -y
# 安装依赖
RUN  apt-get install gcc -y \
  &amp;amp;&amp;amp; apt-get install make -y \
  &amp;amp;&amp;amp; apt-get install vim -y \
  &amp;amp;&amp;amp; apt-get install openssl -y \
  &amp;amp;&amp;amp; apt-get install libssl-dev -y \
  &amp;amp;&amp;amp; apt-get install python3.5 -y \
  &amp;amp;&amp;amp; apt-get install python3-pip -y
CMD [&amp;quot;pip3&amp;quot;]
CMD [&amp;quot;python3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装出现警告信息 &lt;code&gt;debconf: delaying package configuration, since apt-utils is not installed&lt;/code&gt;。解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;RUN apt-get update &amp;amp;&amp;amp; apt-get install -y --no-install-recommends apt-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;制作镜像&#34;&gt;制作镜像&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build -t python3 .
# 查看镜像
docker images
# 运行容器
docker run -i -t python3 /bin/bash
# 进入 docker 之后，运行 python3 和 pip3
python3
pip3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;更新镜像&#34;&gt;更新镜像&lt;/h2&gt;

&lt;h3 id=&#34;安装-sphinx-readthedocs-支持&#34;&gt;安装 Sphinx + ReadTheDocs 支持&lt;/h3&gt;

&lt;h4 id=&#34;方法-1-进入镜像内部更新镜像&#34;&gt;方法 1：进入镜像内部更新镜像&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 在 docker 内部安装相关依赖
pip3 install sphinx sphinx-autobuild sphinx_rtd_theme recommonmark pypandoc
# 提交更新
docker commit -m=&amp;quot;add Sphinx + ReadTheDocs support&amp;quot; -a=&amp;quot;kiki&amp;quot; CONTAINER-ID sphinx-rtd
# 查看新镜像
docker images
# 启动新镜像
docker run -i -t -v sphinx-rtd /bin/bash
# 给镜像设置标签
docker tag CONTAINER-ID compile-blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 Python 包遇到错误：&lt;code&gt;requests.packages.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host=&#39;files.pythonhosted.org&#39;, port=443): Read timed out&lt;/code&gt;。解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 在 Dockerfile 中增加下面的参数
pip3 --default-timeout=1000 install sphinx sphinx-autobuild sphinx_rtd_theme recommonmark pypandoc
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;方法-2-编写新的-dockerfile&#34;&gt;方法 2：编写新的 Dockerfile&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-Dockerfile&#34;&gt;FROM python3
MAINTAINER kiki
# 安装依赖
RUN pip3 --default-timeout=1000 install sphinx sphinx-autobuild sphinx_rtd_theme recommonmark pypandoc
CMD [&amp;quot;pip3&amp;quot;]
CMD [&amp;quot;python3&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build -t sphinx-rtd .
# 查看镜像
docker images
# 运行容器
docker run -i -t sphinx-rtd /bin/bash
# 进入 docker 之后，运行 python3 和 pip3
python3
pip3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;推送镜像&#34;&gt;推送镜像&lt;/h2&gt;

&lt;h3 id=&#34;推送到官方仓库-docker-hub&#34;&gt;推送到官方仓库 Docker Hub&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker login -u username -p password
docker push sphinx-rtd
docker logout
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;推送到私有仓库-xxx&#34;&gt;推送到私有仓库 xxx&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 参考 https://github.com/docker/docker.github.io/blob/master/registry/insecure.md 设置 http 连接
# 给镜像添加标签
docker tag sphinx-rtd xxx:sphinx-rtd
# 推送镜像
docker push xxx:sphinx-rtd
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>制造历史</title>
      <link>https://xueqing.github.io/blog/git/git_fast_import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_fast_import/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#git-fast-import&#34;&gt;git fast-import&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#git-fast-export&#34;&gt;git fast-export&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-fast-import&#34;&gt;git fast-import&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git fast-import&lt;/code&gt;支持从一个特定格式的文本读入，从头创建 git 历史记录&lt;/li&gt;
&lt;li&gt;可用这个命令很快写一个脚本运行一次，一次迁移整个项目&lt;/li&gt;

&lt;li&gt;&lt;p&gt;写一个临时文件置于&lt;code&gt;/tmp/history&lt;/code&gt;，文本内容如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;commit refs/heads/master
committer Alice &amp;lt;alice@example.com&amp;gt; Thu, 01 Jan 1970 00:00:00 +0000
data &amp;lt;&amp;lt;EOT
Initial commit.
EOT

M 100644 inline hello.c
data &amp;lt;&amp;lt;EOT
#include &amp;lt;stdio.h&amp;gt;

int main() {
printf(&amp;quot;Hello, world!\n&amp;quot;);
return 0;
}
EOT


commit refs/heads/master
committer Bob &amp;lt;bob@example.com&amp;gt; Tue, 14 Mar 2000 01:59:26 -0800
data &amp;lt;&amp;lt;EOT
Replace printf() with write().
EOT

M 100644 inline hello.c
data &amp;lt;&amp;lt;EOT
#include &amp;lt;unistd.h&amp;gt;

int main() {
write(1, &amp;quot;Hello, world!\n&amp;quot;, 14);
return 0;
}
EOT
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 使用上述临时文件创建一个 git 仓库
mkdir project; cd project; git init
git fast-import --date-format=rfc2822 &amp;lt; /tmp/history
# 检出最新版本
git checkout master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-fast-export&#34;&gt;git fast-export&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git fast-export&lt;/code&gt;可将任意仓库转成&lt;code&gt;git fast-import&lt;/code&gt;格式&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>可重入性</title>
      <link>https://xueqing.github.io/blog/cplusplus/reentrant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/reentrant/</guid>
      <description>&lt;p&gt;常见的线程不安全函数和对应的 unix 下的线程安全函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;保持跨越多个调用状态的函数

&lt;ul&gt;
&lt;li&gt;rand，对应 rand_r&lt;/li&gt;
&lt;li&gt;strtok，对应 strtok_r&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回指向静态变量的指针的函数

&lt;ul&gt;
&lt;li&gt;asctime，对应 asctime_r&lt;/li&gt;
&lt;li&gt;ctime，对应 ctime_r&lt;/li&gt;
&lt;li&gt;gethostbyaddr，对应 gethostbyaddr_r&lt;/li&gt;
&lt;li&gt;gethostbyname，对应 gethostbyname_r&lt;/li&gt;
&lt;li&gt;inet_ntoa，&lt;/li&gt;
&lt;li&gt;localtime，对应 localtime_r&lt;/li&gt;
&lt;li&gt;gmtime，对应 gmtime_r&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可重入性

&lt;ul&gt;
&lt;li&gt;可重入函数（reentrant function）：当被多个线程调用时，不会引入任何共享数据&lt;/li&gt;
&lt;li&gt;可重入函数是线程安全函数的一个真子集&lt;/li&gt;
&lt;li&gt;显式可重入（explicitly reentrant）：函数都是传值传递的（即没有指针），并且所有的数据引用都是本地的自动栈变量（即没有引用静态或全局变量）&lt;/li&gt;
&lt;li&gt;隐式可重入（implicitly reentrant）：函数的一些参数是引用传递的（允许传递指针），传递的是非共享数据的指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>同一包不同源文件变量声明时不要带包名</title>
      <link>https://xueqing.github.io/blog/go/traps/package_var/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/traps/package_var/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;同一个包 &lt;code&gt;pkgname&lt;/code&gt; 有多个源文件，比如 &lt;code&gt;A.go&lt;/code&gt;、&lt;code&gt;B.go&lt;/code&gt;。&lt;code&gt;A.go&lt;/code&gt; 中声明了变量 &lt;code&gt;var1&lt;/code&gt;，&lt;code&gt;B.go&lt;/code&gt; 使用此变量直接写 &lt;code&gt;var1&lt;/code&gt;，如果使用 &lt;code&gt;pkgname.var1&lt;/code&gt; 会报错，找不到定义&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>多些时间能少写些代码</title>
      <link>https://xueqing.github.io/blog/coolshell/%E5%A4%9A%E4%BA%9B%E6%97%B6%E9%97%B4%E8%83%BD%E5%B0%91%E5%86%99%E4%BA%9B%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/coolshell/%E5%A4%9A%E4%BA%9B%E6%97%B6%E9%97%B4%E8%83%BD%E5%B0%91%E5%86%99%E4%BA%9B%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://coolshell.cn/articles/5686.html&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;软件的精髓在于设计

&lt;ul&gt;
&lt;li&gt;时间和空间的取舍、TCP/UDP 通信、同步异步、数据冗余&lt;/li&gt;
&lt;li&gt;&lt;em&gt;重要&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;多和客户讨论需求和未来可能的变化：避免边开发边加需求&lt;/li&gt;
&lt;li&gt;调查实现的技术难点和细节&lt;/li&gt;
&lt;li&gt;和其他人讨论并推敲架构和设计：选择成熟的框架？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TDD、快速原型和迭代可能会对软件和团队产生负面影响

&lt;ul&gt;
&lt;li&gt;TDD、快速原型和迭代更关注功能性需求&lt;/li&gt;
&lt;li&gt;需要考虑性能问题、高可用性问题、系统维护性问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;重构是噩梦，应该越少越好&lt;/li&gt;
&lt;li&gt;避免过度设计和纸上谈兵，设计不仅仅是太累和思考，还需要尝试&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>如何编写 Go 代码</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/code/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%a3%e7%a0%81%e7%bb%84%e7%bb%87&#34;&gt;代码组织&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%a7%88&#34;&gt;概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b7%a5%e4%bd%9c%e5%8c%ba&#34;&gt;工作区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gopath-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34;&gt;GOPATH 环境变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84&#34;&gt;导入路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%a8%8b%e5%ba%8f&#34;&gt;第一个程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%ba%93&#34;&gt;第一个库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e5%90%8d&#34;&gt;包名&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%9c%e7%a8%8b%e5%8c%85&#34;&gt;远程包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8b%e4%b8%80%e6%ad%a5&#34;&gt;下一步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%8e%b7%e5%8f%96%e5%b8%ae%e5%8a%a9&#34;&gt;获取帮助&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/code.html&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;此文档演示一个简单的 Go 包的发展，并介绍 &lt;a href=&#34;../command/README.md&#34;&gt;&lt;code&gt;go 工具&lt;/code&gt;&lt;/a&gt;。go 工具是拉取、编译和安装 Go 包和目录的标准方式。&lt;/p&gt;

&lt;p&gt;go 工具要求你按照指定方式组织你的代码。请仔细阅读此文档。它解释了使用 Go 安装组织和运行的最简单的方式。&lt;/p&gt;

&lt;p&gt;一个类似的解释可参考&lt;a href=&#34;https://www.youtube.com/watch?v=XCsL89YtqCs&#34; target=&#34;_blank&#34;&gt;编写、编译、安装和测试 Go 代码&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;代码组织&#34;&gt;代码组织&lt;/h2&gt;

&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Go 开发人员通常保存他们所有的 Go 代码在一个单一的工作区。&lt;/li&gt;
&lt;li&gt;一个工作区包含很多版本控制仓库(比如使用 Git 管理)。&lt;/li&gt;
&lt;li&gt;每个仓库包含一个或多个包。&lt;/li&gt;
&lt;li&gt;每个包由同一目录的一个或多个 Go 源文件组成。&lt;/li&gt;
&lt;li&gt;包目录的路径确定了导入路径。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意这个其他编程环境不同。其他编程环境的每个工程有一个单独的工作区，且工作区和版本控制仓库紧密相关。&lt;/p&gt;

&lt;h3 id=&#34;工作区&#34;&gt;工作区&lt;/h3&gt;

&lt;p&gt;一个工作区是一个目录层次架构，在其根有两个目录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;src 包含 Go 源文件，且&lt;/li&gt;
&lt;li&gt;bin 包含可执行命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;go 工具编译和安装二进制到 bin 目录。&lt;/p&gt;

&lt;p&gt;src 子目录通常包含多个版本控制仓库(比如 Git 或 Mercurial)，跟踪了一个或多个源包的发展。&lt;/p&gt;

&lt;p&gt;为了让你理解一个工作区实际上的组织，这里有一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;bin/
  hello                      # command executable
  outyet                     # command executable
src/
  github.com/golang/example/
    .git/                    # Git repository metadata
    hello/
      hello.go               # command source
    outyet/
      main.go                # command source
      main_test.go           # test source
    stringutil/
      reverse.go             # package source
      reverse_test.go        # test source
  golang.org/x/image/
    .git/                    # Git repository metadata
    bmp/
      reader.go              # package source
      writer.go              # package source
  ... (many more repositories and packages omitted) ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述树显示一个工作区有两个仓库(example 和 image)。example 仓库包含两个命令(hello 和 outyet)和一个库(stringutil)。image 仓库包含 bmp 包和&lt;a href=&#34;https://godoc.org/golang.org/x/image&#34; target=&#34;_blank&#34;&gt;其他的包&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个普通的工作区包含许多源仓库，这些仓库包含一些包和命令。大多数 Go 开发人员保存他们所有的 Go 源代码和依赖在一个单一的工作区。&lt;/p&gt;

&lt;p&gt;注意不应使用符号链接链接文件或目录到你的工作区。&lt;/p&gt;

&lt;p&gt;命令和库由不同的源包编译。我们之后会讨论&lt;a href=&#34;#包名&#34;&gt;区别&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;gopath-环境变量&#34;&gt;GOPATH 环境变量&lt;/h3&gt;

&lt;p&gt;GOPATH 环境变量指定你的工作区位置。默认是你的主目录下名字为 go 的目录，因此在 Unix 上是 $HOME/go，Plan9 上是 $home/go，Windows 上是 %USERPROFILE%\go (通常是 C:\Users\YourName\go)。&lt;/p&gt;

&lt;p&gt;如果你想要在不同的位置工作，你需要&lt;a href=&#34;../wiki/set_gopath.md&#34;&gt;设置 GOPATH&lt;/a&gt; 到那个目录。(另外一个常用的设置是设置 GOPATH=$HOME)。注意 GOPATH 一定不能和你的 Go 安装路径相同。&lt;/p&gt;

&lt;p&gt;命令 &lt;code&gt;go env GOPATH&lt;/code&gt; 打印当前实际的 GOPATH；如果该环境变量没有设置，它会打印默认的位置。&lt;/p&gt;

&lt;p&gt;方便起见，增加工作区的 bin 子目录到你的 PATH：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export PATH=$PATH:$(go env GOPATH)/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简洁起见，这个脚本在文档的其他部分使用 $GOPATH 而不是 $(go env GOPATH)。如果你还未设置 GOPATH，为了使得所写的脚本可运行，可以使用 $HOME/go 替换这些命令或者运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GOPATH=$(go env GOPATH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要了解更多关于 GOPATH 环境变量，参考 &lt;a href=&#34;../command/gopath_env_var.md&#34;&gt;&lt;code&gt;go help gopath&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要使用自定义的工作区位置，&lt;a href=&#34;../wiki/set_gopath.md&#34;&gt;设置 GOPATH 环境变量&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;导入路径&#34;&gt;导入路径&lt;/h3&gt;

&lt;p&gt;导入路径是一个唯一的标识一个包的字符串。一个包的导入路径对应它在工作区或远程仓库内的位置(下面会解释)。&lt;/p&gt;

&lt;p&gt;标准库的包使用短的导入路径类似 “fmt” 和 “net/http”。对于你自己的包，你必须选择一个基础路径，该路径不太可能与将来增加的标准库或其他外部库冲突。&lt;/p&gt;

&lt;p&gt;如果你将代码保存在其他地方的源仓库，那么你应该使用该源码库的根作为你的基础路径。比如，如果你有一个 Github 账户位于 github.com/user，那么 github.com/user 应该是你的基础路径。&lt;/p&gt;

&lt;p&gt;注意在你可以编译代码之前，你不需要发布你的代码到一个远程仓库。这只是一个组织代码的好习惯以便某天你会发布它。实际上你可以选择任意的路径名字，只要它对于标准库和更大的 Go 生态系统是唯一的。&lt;/p&gt;

&lt;p&gt;我们将会使用 github.com/user 作为我们的基础路径。在你的工作区内新建一个目录来保存源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir -p $GOPATH/src/github.com/user
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第一个程序&#34;&gt;第一个程序&lt;/h3&gt;

&lt;p&gt;为了编译和运行一个简单的程序，首先选择一个包路径(我们将会使用 github.com/user/hello)，并且在你的工作区内创建一个对应的包目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir $GOPATH/src/github.com/user/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，在目录内部创建一个名为 hello.go 的文件，包含下面的 Go 代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
  fmt.Println(&amp;quot;Hello, world.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你可以使用 go 工具编译和安装这个程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go install github.com/user/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意你可以在你的系统任何地方运行这个命令。go 工具通过在 GOPATH 指定的工作区内查找 github.com/user/hello 包找到源码。&lt;/p&gt;

&lt;p&gt;如果你从包目录运行 &lt;code&gt;go install&lt;/code&gt;，你也可以忽视包路径：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd $GOPATH/src/github.com/user/hello
go install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令编译 hello 命令，生成可执行的二进制文件。它接着安装该二进制文件到工作区的 bin 目录，安装的文件名字是 hello(或者在 Windows 上是 hello.exe)。在我们的例子中，该文件将会是 $GOPATH/bin/hello，也就是 $HOME/go/bin/hello。&lt;/p&gt;

&lt;p&gt;发生错误时，go 工具只会打印输出。因此如果这些命令没有生成输出，那么这些命令已经被正确执行。&lt;/p&gt;

&lt;p&gt;你现在可以通过在命令行输入程序的完整路径来运行它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ $GOPATH/bin/hello
Hello, world.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者，因为你已经添加 $GOPATH/bin 到你的 PATH，只需要输入二进制文件的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hello
Hello, world.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你在使用一个源码控制系统，现在将是一个好的时机来初始化一个仓库，增加这些文件，并提交你的第一次修改。重申一次，这一步是可选的：你不必使用源码控制来写 Go 代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd $GOPATH/src/github.com/user/hello
git init
git add hello.go
git commit -m &amp;quot;initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推送代码到远程仓库留作读者的一个练习。&lt;/p&gt;

&lt;h3 id=&#34;第一个库&#34;&gt;第一个库&lt;/h3&gt;

&lt;p&gt;让我们编写一个库，并在 hello 程序使用它。&lt;/p&gt;

&lt;p&gt;重申一次，第一步是选择一个包路径(我们将会使用 github.com/user/stringutil)并创建一个包目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir $GOPATH/src/github.com/user/stringutil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，在该目录创建一个名为 reverse.go 的文件，包含下面的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Package stringutil contains utility functions for working with strings.
package stringutil

// Reverse returns its argument string reversed rune-wise left to right.
func Reverse(s string) string {
  r := []rune(s)
  for i, j := 0, len(r)-1; i &amp;lt; len(r)/2; i, j = i+1, j-1 {
    r[i], r[j] = r[j], r[i]
  }
  return string(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，使用 &lt;code&gt;go build&lt;/code&gt; 编译测试这个包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build github.com/user/stringutil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者，如果你正在包的源目录，只需要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不会生成一个输出文件。反之，它将编译的包保存在本地的编译缓存。&lt;/p&gt;

&lt;p&gt;在确认编译 stringutil 包之后，修改你原始的 hello.go(在 $GOPATH/src/github.com/user/hello)，使用下面的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;

  &amp;quot;github.com/user/stringutil&amp;quot;
)

func main() {
  fmt.Println(stringutil.Reverse(&amp;quot;!oG ,olleH&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 hello 程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go install github.com/user/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个程序的新版本，你应该看到一个新的、翻转的消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hello
Hello, Go!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述步骤之后，你的工作区应该看起来是下面的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;bin/
  hello                 # command executable
src/
  github.com/user/
    hello/
      hello.go      # command source
    stringutil/
      reverse.go    # package source
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;包名&#34;&gt;包名&lt;/h3&gt;

&lt;p&gt;Go 源文件的第一个语句必须是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，name 是用于导入包的默认名字。(包内的所有文件必须使用这个名字。)&lt;/p&gt;

&lt;p&gt;Go 的管理是包名是导入路径的最后一个元素：按照 “crypto/rot13” 导入的包名应该命名为 rot13。&lt;/p&gt;

&lt;p&gt;可执行的命令必须总使用 &lt;code&gt;package main&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;不需要包名在链接所有包成一个单一的二进制文件时是唯一的，只要它的导入路径(完整的文件名)是唯一的。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&#34;effective_go.md#名字&#34; target=&#34;_blank&#34;&gt;实效 Go 编程&lt;/a&gt;了解更多关于 Go 的命名惯例。&lt;/p&gt;

&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;

&lt;p&gt;Go 有一个轻量级的测试框架，由 &lt;code&gt;go test&lt;/code&gt; 命令和 testing 包组成。&lt;/p&gt;

&lt;p&gt;你可以通过新建一个以 _test.go 结尾的文件编写测试，文件包含名字为 TestXXX，签名为 &lt;code&gt;func (t *testing.T)&lt;/code&gt; 的函数。测试框架运行每个像这样的函数；如果函数调用一个失败函数，如 t.Error 或 t.Fail，认为该测试失败。&lt;/p&gt;

&lt;p&gt;向 stringutil 包增加一个测试，新建文件 $GOPATH/src/github.com/user/stringutil/reverse_test.go，包含下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package stringutil

import &amp;quot;testing&amp;quot;

func TestReverse(t *testing.T) {
  cases := []struct {
    in, want string
  }{
    {&amp;quot;Hello, world&amp;quot;, &amp;quot;dlrow ,olleH&amp;quot;},
    {&amp;quot;Hello, 世界&amp;quot;, &amp;quot;界世 ,olleH&amp;quot;},
    {&amp;quot;&amp;quot;, &amp;quot;&amp;quot;},
  }
  for _, c := range cases {
    got := Reverse(c.in)
    if got != c.want {
      t.Errorf(&amp;quot;Reverse(%q) == %q, want %q&amp;quot;, c.in, got, c.want)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用 &lt;code&gt;go test&lt;/code&gt; 运行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go test github.com/user/stringutil
ok    github.com/user/stringutil 0.165s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和平时一样，如果你在包目录运行 go 工具，可以忽视包路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go test
ok    github.com/user/stringutil 0.165s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行 &lt;a href=&#34;../command/test_package.md&#34;&gt;&lt;code&gt;go help test&lt;/code&gt;&lt;/a&gt; 并查看 &lt;a href=&#34;../golangpkg/testing.md&#34;&gt;testing 包文档&lt;/a&gt; 获取更多信息。&lt;/p&gt;

&lt;h2 id=&#34;远程包&#34;&gt;远程包&lt;/h2&gt;

&lt;p&gt;导入路径可以描述如何使用版本控制系统(如 Git 或 Mercurial)获取包源码。go 工具使用这个属性从远程仓库自动拉取代码。比如，文档中描述的例子也保存在 &lt;a href=&#34;https://github.com/golang/example&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt; 托管的 Git 仓库。如果你在包的导入路径包含这个仓库的 URL，&lt;code&gt;go get&lt;/code&gt; 会自动拉取、编译和运行它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get github.com/golang/example/hello
$GOPATH/bin/hello
# 输出 Hello, Go examples!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果指定的包没有出现在工作区，&lt;code&gt;go get&lt;/code&gt; 会放置在 GOPATH 指定的第一个工作区。(如果包以及存在，&lt;code&gt;go get&lt;/code&gt; 会跳过远程拉取，行为类似于 &lt;code&gt;go install&lt;/code&gt;。)&lt;/p&gt;

&lt;p&gt;在执行上述 &lt;code&gt;go get&lt;/code&gt; 命令只会，工作区目录树应该看起来是下面的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;bin/
    hello                     # command executable
src/
  github.com/golang/example/
    .git/                     # Git repository metadata
    hello/
      hello.go                # command source
    stringutil/
      reverse.go              # package source
      reverse_test.go         # test source
  github.com/user/
    hello/
      hello.go                # command source
    stringutil/
      reverse.go              # package source
      reverse_test.go         # test source
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Github 托管的 hello 命令依赖相同仓库的 stringutil 包。hello.go 文件中的导入使用相同的导入路径惯例，因此 &lt;code&gt;go get&lt;/code&gt; 命令也可以定位和安装依赖依赖包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;github.com/golang/example/stringutil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此惯例是使得你的 Go 包被其他人可用的最简单的方式。&lt;a href=&#34;https://github.com/golang/go/wiki/Projects&#34; target=&#34;_blank&#34;&gt;Go 维基&lt;/a&gt; 和 &lt;a href=&#34;https://godoc.org/&#34; target=&#34;_blank&#34;&gt;go 官方文档&lt;/a&gt; 提供了外部 Go 过程的列表。&lt;/p&gt;

&lt;p&gt;要获取更多关于借助 go 工具使用远程仓库的信息，查看&lt;a href=&#34;../command/remote_import_path.md&#34;&gt;远程导入路径&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;下一步&#34;&gt;下一步&lt;/h2&gt;

&lt;p&gt;订阅 &lt;a href=&#34;https://groups.google.com/group/golang-announce&#34; target=&#34;_blank&#34;&gt;golang 宣传&lt;/a&gt; 邮件列表，接受发行新的稳定版本 Go 的通知。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&#34;effective_go.md&#34; target=&#34;_blank&#34;&gt;实效 Go 编程&lt;/a&gt;了解更多关于编写清楚、惯用的 Go 代码的建议。&lt;/p&gt;

&lt;p&gt;访问 &lt;a href=&#34;https://tour.golang.org/&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt; 学习语言规则。&lt;/p&gt;

&lt;p&gt;访问&lt;a href=&#34;README.md#文章&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt;查看关于 Go 语言及其库和工具的全面深入的文章。&lt;/p&gt;

&lt;h2 id=&#34;获取帮助&#34;&gt;获取帮助&lt;/h2&gt;

&lt;p&gt;需要实时帮助，询问有帮助的 gopher ，它位于 &lt;a href=&#34;https://freenode.net/&#34; target=&#34;_blank&#34;&gt;FreeNode&lt;/a&gt; IRC 服务的 #go-nuts。&lt;/p&gt;

&lt;p&gt;关于 Go 语言讨论的官方邮件列表在 &lt;a href=&#34;https://groups.google.com/group/golang-nuts&#34; target=&#34;_blank&#34;&gt;Go Nuts&lt;/a&gt; 群组。&lt;/p&gt;

&lt;p&gt;使用 &lt;a href=&#34;https://github.com/golang/go/issues&#34; target=&#34;_blank&#34;&gt;Go issue 跟踪&lt;/a&gt;报告错误。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>学习测试</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/learn_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/learn_testing/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e5%ae%b9&#34;&gt;内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki/LearnTesting&#34; target=&#34;_blank&#34;&gt;Go 维基官网——学习测试&lt;/a&gt;学习。&lt;/p&gt;

&lt;p&gt;原网页由 Evgeny Vereshchagin 在 2019/1/29 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/LearnTesting/_history&#34; target=&#34;_blank&#34;&gt;第 4 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;这个页面链接到关于 Go 测试的资源。&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../golangdoc/code.md&#34;&gt;如何编写 Go 代码&lt;/a&gt;，尤其是&lt;a href=&#34;../golangdoc/code.md#测试&#34;&gt;测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 学习&lt;a href=&#34;../golangpkg/testing.md&#34;&gt;测试包&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../golangdoc/faq.md#为什么-Go-没有断言&#34;&gt;为什么 Go 没有断言&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../golangdoc/faq.md#我最喜欢的测试辅助函数在哪里&#34;&gt;我最喜欢的测试辅助函数在哪里&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 观看&lt;a href=&#34;https://talks.golang.org/2014/testing.slide#1&#34; target=&#34;_blank&#34;&gt;测试技巧&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;table_driven_tests.md&#34; target=&#34;_blank&#34;&gt;表驱动测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../blog/subtest.md&#34;&gt;使用子测试项目和子基准测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>安装</title>
      <link>https://xueqing.github.io/blog/docker/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/docker/install/</guid>
      <description>&lt;p&gt;环境：ubuntu16.04&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 安装 docker
sudo apt-get install docker.io
# 启动 docker
sudo /etc/init.d/docker start
# 创建 docker 用户组
sudo groupadd docker
# 应用用户 kiki 加入 docker 用户组
sudo usermod -aG docker kiki
# 重启 docker 服务
sudo /etc/init.d/docker restart
# 切换或者退出当前账户再从新登入
su root     # 切换到root用户
su kiki  # 再切换到原来的应用用户以上配置才生效
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>安装 go</title>
      <link>https://xueqing.github.io/blog/go/basic/go_install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_install/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#linux-%e5%ae%89%e8%a3%85%e5%92%8c%e4%bd%bf%e7%94%a8-go&#34;&gt;Linux 安装和使用 go&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%ae%be%e7%bd%ae%e5%b7%a5%e4%bd%9c%e7%9b%ae%e5%bd%95-gopath&#34;&gt;设置工作目录 GOPATH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b5%8b%e8%af%95%e5%ae%89%e8%a3%85&#34;&gt;测试安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85%e5%85%b6%e4%bb%96%e7%89%88%e6%9c%ac&#34;&gt;安装其他版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#windows-%e5%ae%89%e8%a3%85%e5%92%8c%e4%bd%bf%e7%94%a8-go&#34;&gt;Windows 安装和使用 go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#macos-%e5%ae%89%e8%a3%85%e5%92%8c%e4%bd%bf%e7%94%a8-go&#34;&gt;MacOS 安装和使用 go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8d%b8%e8%bd%bd%e6%97%a7%e7%89%88%e6%9c%ac&#34;&gt;卸载旧版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vscode-%e4%bd%bf%e7%94%a8-go&#34;&gt;vscode 使用 go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%85%8d%e7%bd%ae%e4%bb%a3%e7%90%86&#34;&gt;配置代理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;linux-安装和使用-go&#34;&gt;Linux 安装和使用 go&lt;/h2&gt;

&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;下载&lt;a href=&#34;https://golang.org/dl/&#34; target=&#34;_blank&#34;&gt;安装包&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;选择最新的 &lt;a href=&#34;https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz&#34; target=&#34;_blank&#34;&gt;Linux 版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;下载&lt;code&gt;wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://golang.org/doc/install&#34; target=&#34;_blank&#34;&gt;安装&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;解压：&lt;code&gt;tar -C /usr/local -zxf go1.11.2.linux-amd64.tar.gz&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;配置环境变量

&lt;ul&gt;
&lt;li&gt;修改&lt;code&gt;/etc/profile&lt;/code&gt;或&lt;code&gt;~/.profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;追加&lt;code&gt;export PATH=$PATH:/usr/local/go/bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;source&lt;/code&gt;命令更新配置文件立即生效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;设置工作目录-gopath&#34;&gt;设置工作目录 GOPATH&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;工作目录下面有三个文件夹

&lt;ul&gt;
&lt;li&gt;src：存放源码的目录，新建项目都在该目录下&lt;/li&gt;
&lt;li&gt;pkg：编译生成的包文件存放目录&lt;/li&gt;
&lt;li&gt;bin：编译生成的可执行文件和 go 相关的工具&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;默认工作目录是 &lt;code&gt;$HOME/go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要自定义工作目录：

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;建议：&lt;/strong&gt;不要和 go 的安装目录相同&lt;/li&gt;
&lt;li&gt;修改 &lt;code&gt;~/.bashrc&lt;/code&gt;，添加 &lt;code&gt;export GOPATH=$HOME/go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;source ~/.bashrc&lt;/code&gt; 使脚本生效&lt;/li&gt;
&lt;li&gt;修改&lt;code&gt;/etc/profile&lt;/code&gt;或&lt;code&gt;~/.profile&lt;/code&gt;，添加 &lt;code&gt;export GOROOT=$HOME/go&lt;/code&gt;，将 &lt;code&gt;$HOME/go/bin&lt;/code&gt; 加入系统环境变量 &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;source&lt;/code&gt;命令更新配置文件立即生效
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;测试安装&#34;&gt;测试安装&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;创建并进入默认工作目录 &lt;code&gt;~/go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建并进入目录 &lt;code&gt;src/hello&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建文件 &lt;code&gt;hello.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
fmt.Printf(&amp;quot;Hello, world\n&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译：&lt;code&gt;go build&lt;/code&gt;，生成可执行文件 &lt;code&gt;hello&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;运行：&lt;code&gt;./hello&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装二进制文件到工作目录的 &lt;code&gt;bin&lt;/code&gt; 目录：&lt;code&gt;go install&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除工作目录的二进制文件：&lt;code&gt;go clean -i&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;安装其他版本&#34;&gt;安装其他版本&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装版本 1.10.7

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go get golang.org/dl/go1.10.7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go1.10.7 download&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用版本 1.10.7

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go1.10.7 version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;windows-安装和使用-go&#34;&gt;Windows 安装和使用 go&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;下载 Windows &lt;a href=&#34;https://golang.org/dl/&#34; target=&#34;_blank&#34;&gt;安装包&lt;/a&gt; msi 文件&lt;/li&gt;
&lt;li&gt;安装到 &lt;code&gt;c:\Go&lt;/code&gt; 目录&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;c:\Go\bin&lt;/code&gt; 加入系统环境变量 &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试安装

&lt;ul&gt;
&lt;li&gt;创建 go 的工作目录，比如 &lt;code&gt;g:\gopro&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置工作目录路径：在用户变量中加入 &lt;code&gt;GOPATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;g:\gopro\bin&lt;/code&gt; 加入系统环境变量 &lt;code&gt;PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;g:\gopro\src\hello&lt;/code&gt; 目录，创建 &lt;code&gt;hello.go&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;打开 Windows 终端，切换到 &lt;code&gt;g:\gopro\src\hello&lt;/code&gt; 目录&lt;/li&gt;
&lt;li&gt;编译：&lt;code&gt;go build&lt;/code&gt;，生成可执行文件 &lt;code&gt;hello.exe&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行：&lt;code&gt;hello&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装二进制文件到工作目录的 &lt;code&gt;bin&lt;/code&gt; 目录：&lt;code&gt;go install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除工作目录的二进制文件：&lt;code&gt;go clean -i&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;macos-安装和使用-go&#34;&gt;MacOS 安装和使用 go&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;执行 &lt;code&gt;brew install go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置环境变量

&lt;ul&gt;
&lt;li&gt;修改 &lt;code&gt;~/.profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;追加&lt;code&gt;export GOROOT=/usr/local/go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;追加&lt;code&gt;export PATH=$PATH:$GOROOT/bin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;source ~/.profile&lt;/code&gt;命令更新配置文件立即生效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;验证配置：执行 &lt;code&gt;go version&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;写测试程序&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;写 &lt;code&gt;hello.go&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
fmt.println(&amp;quot;Hello World!&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;执行 &lt;code&gt;go run hello.go&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;卸载旧版本&#34;&gt;卸载旧版本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;删除 go 目录

&lt;ul&gt;
&lt;li&gt;Linux/MacOS/FreeBSD &lt;code&gt;/usr/local/go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Windows &lt;code&gt;c:\go&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从环境变量 &lt;code&gt;PATH&lt;/code&gt; 中删除 go 的 bin 目录

&lt;ul&gt;
&lt;li&gt;Linux/FreeBSD 编辑 &lt;code&gt;/etc/profile&lt;/code&gt; 或 &lt;code&gt;~/.profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MacOS 删除 &lt;code&gt;/etc/paths.d/go&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;查看 golang 环境变量 &lt;code&gt;go env&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vscode-使用-go&#34;&gt;vscode 使用 go&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安装插件 &lt;code&gt;Go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置 vscode

&lt;ul&gt;
&lt;li&gt;选择 &lt;code&gt;File&lt;/code&gt; -&amp;gt; &lt;code&gt;Preferences&lt;/code&gt; -&amp;gt; &lt;code&gt;Settings&lt;/code&gt;，搜索 go&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go: Build On Save&amp;rdquo;: &amp;ldquo;workspace&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go: Gopath&amp;rdquo;: &amp;ldquo;/home/kiki/go&amp;rdquo;

&lt;ul&gt;
&lt;li&gt;Linux 配置: &amp;ldquo;/home/kiki/go&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Windows 配置: &amp;ldquo;G:\gopro&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Go: Goroot&amp;rdquo;

&lt;ul&gt;
&lt;li&gt;Linux 配置: &amp;ldquo;/usr/local/go&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Windows 配置：&amp;rdquo;C:\Go&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;打开 go 的工作目录，第一次打开 go 后缀结尾的文件时，会提示安装 gopkgs，选择 &lt;code&gt;Install All&lt;/code&gt;，等待安装结束&lt;/li&gt;
&lt;li&gt;vscode 自动安装失败，执行手动安装

&lt;ul&gt;
&lt;li&gt;1 在 &lt;code&gt;%GOPATH%/src/golang.org/x&lt;/code&gt; 目录下，执行 &lt;code&gt;git clone git@github.com:golang/tools.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2 进入 &lt;code&gt;%GOPATH%/src/golang.org/x/tools/cmd/gorename&lt;/code&gt; 目录，执行 &lt;code&gt;go install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3 进入 &lt;code&gt;%GOPATH%/src/golang.org/x/tools/cmd/guru&lt;/code&gt; 目录，执行 &lt;code&gt;go install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4 重启 vscode，打开 go 后缀结尾的文件，点击 &lt;code&gt;Analysis Tools Missing&lt;/code&gt;，继续之前安装失败的 go 包&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装过程中，有的包可能会安装失败&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 使用 tools 下载&lt;/li&gt;
&lt;li&gt;进入 &lt;code&gt;%GOPATH%/src/golang.org/x&lt;/code&gt; 目录，使用命令 &lt;code&gt;git clone https://github.com/golang/tools.git&lt;/code&gt; 下载插件依赖工具的源码，所需工具源码就都保存在 tools 目录中&lt;/li&gt;
&lt;li&gt;进入 &lt;code&gt;%GOPATH%&lt;/code&gt; 目录，根据之前的安装失败提示信息安装对应的依赖工具：比如 &lt;code&gt;go install github.com/mdempsky/gocode&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2 使用 lint 下载&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;go install golang.org/x/lint/golint&lt;/code&gt; 报错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;can&#39;t load package: package golang.org/x/lint/golint: cannot find package &amp;quot;golang.org/x/lint/golint&amp;quot; in any of:
/usr/local/go/src/golang.org/x/lint/golint (from $GOROOT)
/home/kiki/go/src/golang.org/x/lint/golint (from $GOPATH)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为 golint 的源码在 lint 下，而不是 tools，需要单独拉取 golint 源码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入 &lt;code&gt;%GOPATH%\src\golang.org\x&lt;/code&gt; 目录，执行命令 &lt;code&gt;git clone https://github.com/golang/lint&lt;/code&gt; 拉取 golint 源码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入 &lt;code&gt;%GOPATH%&lt;/code&gt; 目录，通过 &lt;code&gt;go install&lt;/code&gt; 安装 golint：&lt;code&gt;go install golang.org/x/lint/golint&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启 vscode 后，插件就可以正常使用了&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;配置代理&#34;&gt;配置代理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;执行 &lt;code&gt;go mod init&lt;/code&gt; 生成默认 module 文件&lt;/li&gt;
&lt;li&gt;配置环境变量 &lt;code&gt;export GOPROXY=https://goproxy.io&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启 vscode，安装插件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+Shift+P&lt;/code&gt;，输入 &lt;code&gt;go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择 &lt;code&gt;Install/Update Tools&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全选，安装。重启 vscode 即可&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>实效 Go 编程</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/effective_go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/effective_go/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%8b%e5%ad%90&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%bc%e5%bc%8f%e5%8c%96&#34;&gt;格式化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e9%87%8a&#34;&gt;注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%90%8d%e5%ad%97&#34;&gt;名字&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e5%90%8d&#34;&gt;包名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getter&#34;&gt;getter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3%e5%90%8d&#34;&gt;接口名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%a9%bc%e5%b3%b0&#34;&gt;驼峰&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%86%e5%8f%b7&#34;&gt;分号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a7%e5%88%b6%e7%bb%93%e6%9e%84&#34;&gt;控制结构&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#if&#34;&gt;if&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%87%8d%e6%96%b0%e5%a3%b0%e6%98%8e%e5%92%8c%e9%87%8d%e6%96%b0%e8%b5%8b%e5%80%bc&#34;&gt;重新声明和重新赋值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;函数&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%9a%e8%bf%94%e5%9b%9e%e5%80%bc&#34;&gt;多返回值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e5%90%8d%e7%bb%93%e6%9e%9c%e5%8f%82%e6%95%b0&#34;&gt;命名结果参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#defer&#34;&gt;defer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e6%8d%ae&#34;&gt;数据&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-new-%e5%88%86%e9%85%8d&#34;&gt;使用 new 分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e5%a4%8d%e5%90%88%e5%ad%97%e9%9d%a2%e9%87%8f&#34;&gt;构造函数和复合字面量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-make-%e5%88%86%e9%85%8d&#34;&gt;使用 make 分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e7%bb%84&#34;&gt;数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%87%e7%89%87&#34;&gt;切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%ba%8c%e7%bb%b4%e5%88%87%e7%89%87&#34;&gt;二维切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%98%a0%e5%b0%84&#34;&gt;映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%89%93%e5%8d%b0&#34;&gt;打印&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%bd%e5%8a%a0&#34;&gt;追加&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;初始化&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e6%95%b0&#34;&gt;常数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/effective_go.html&#34; target=&#34;_blank&#34;&gt;Golang 官网文档——Effective Go&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;Go 是一门新语言。虽然它从现有语言借鉴了想法，但是它有独特的属性使得实效的 Go 程序和使用其他语言编写的程序特点不同。直接将一个 C++ 或 Java 程序翻译成 Go 不太可能生成令人满意的结果——Java 程序是用 Java 写的，而不是 Go。另一方面，从 Go 的角度思考一个问题可能产生一个成功的但是完全不同的程序。换句话说，要写好 Go，理解它的特性和惯用语是很重要的。而且，了解用 Go 编程已有的惯例，比如命名、格式化、程序结构等等也很重要，以便你编写的程序容易被其他 Go 开发人员理解。&lt;/p&gt;

&lt;p&gt;此文档给出关于编写清晰、惯用的 Go 代码的建议。它增补了&lt;a href=&#34;https://golang.org/ref/spec&#34; target=&#34;_blank&#34;&gt;语言规范&lt;/a&gt;、&lt;a href=&#34;https://tour.golang.org/&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt;以及&lt;a href=&#34;code.md&#34; target=&#34;_blank&#34;&gt;如何编写 Go 代码&lt;/a&gt;，所有这些你应该先阅读。&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/src/&#34; target=&#34;_blank&#34;&gt;Go 包源码&lt;/a&gt;用于作为和核心库，也作为如何使用语言的例子。此外，很多包包含可工作的、自包含的可执行例子，你可以直接从 &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;golang.org&lt;/a&gt; 网站运行，比如&lt;a href=&#34;https://golang.org/pkg/strings/#example_Map&#34; target=&#34;_blank&#34;&gt;这个网站&lt;/a&gt;(如果需要，点击单词 “Example” 打开它)。如果你对于如何处理一个问题或一些东西是如何实现的有疑问，这个库中的文档、代码和例子可以给出答案、思想和背景。&lt;/p&gt;

&lt;h2 id=&#34;格式化&#34;&gt;格式化&lt;/h2&gt;

&lt;p&gt;格式化问题是最有争议却最不重要的。人们可以选择不同的格式风格，但是如果每个人遵循相同的风格，那么人们不需要且可以花费更少的时间在这个问题上是更好的。问题是如何在没有一个长长的风格规范指南的情况下实现这个想法。&lt;/p&gt;

&lt;p&gt;对于 Go，我们使用了一种特别的方法且交由机器注意大多数格式化问题。gofmt 程序(也可以通过 &lt;code&gt;go fmt&lt;/code&gt; 使用，它作用于包级别而不是源文件级别)读入一个 Go 程序并且以标准的风格缩进、垂直对齐、保持或者需要的话重新格式化注释，然后发出源文件。如果你想要知道如何处理一些新的格式场景，运行 gofmt；如果答案看起来不正确，重新组织你的程序(或提出一个 gofmt 的错误)，不要绕过这个问题。&lt;/p&gt;

&lt;p&gt;作为一个例子，不必花时间对结构体的域做注释对齐。gofmt 将会为你做这些。给出一个声明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    name string // 对象的名字
    value int // 对象的值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gofmt 会列对齐：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    name    string // 对象的名字
    value   int    // 对象的值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标准库中所有的 Go 代码都已经使用 gofmt 格式化过。&lt;/p&gt;

&lt;p&gt;还有一些格式化细节。非常简洁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;缩进
  我们使用 tab 键缩进，且 gofmt 默认使用 tab 键。只在必要的时候使用空格。
行长度
  Go 没有行长度限制。不要担心溢出穿孔卡片。如果感觉一行太长，包裹它并使用额外的 tab 键缩进
括号
  Go 比 C 和 Java 需要更少的括号：控制结构 (if/for/switch) 的语法没有括号。同时，操作符优先级层次更短更清晰。
  因此不像其他语言， `x&amp;lt;&amp;lt;8 + y&amp;lt;&amp;lt;16` 就是空格暗示的含义。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;

&lt;p&gt;Go 提供 C-风格的块注释 /**/ 和 C++-风格的行注释 //。行注释是常态；块注释大多出现在包注释，但是在一个表达式内部或禁用大段代码是有用的。&lt;/p&gt;

&lt;p&gt;godoc 程序，也是 web 服务器，处理 Go 源文件以提取关于包内容的文档。在顶层声明之前出现的注释，中间没有新行，和声明一起提取作为该元素的解释文本。这些注释的本性和风格决定了 godoc 生成的文档的质量。&lt;/p&gt;

&lt;p&gt;每个包应该有一个包注释，即 package 语句之前的一个块注释。对于多文件的包，包注释只需要出现在一个文件，且每个文件都可以看到。包注释应该介绍包并提供和包有关的信息作为一个整体。它会先出现在 godoc 页面，并且应该设置后面的详细文档。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
包 regexp 实现了正则表达式的一个简单库。

接收正则表达式的语法是:

    正则表达式:
        连接 { &#39;|&#39; 连接 }
    连接:
        { 闭包 }
    闭包:
        项 [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]
    项:
        &#39;^&#39;
        &#39;$&#39;
        &#39;.&#39;
        字符
        &#39;[&#39; [ &#39;^&#39; ] 字符范围 &#39;]&#39;
        &#39;(&#39; 正则表达式 &#39;)&#39;
*/
package regexp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是一个简单包，包注释可以是简洁的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 包 path 实现了功能代码，用于操作斜线分隔的文件名路径。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释不需要额外的格式比如一行星号。生成的输出可能不能显式为固定宽度的字体，因此不要依赖空格对齐——godoc 像 gofmt 一样，会注意对齐问题。注释是无解释的普通文本，因此 HTML 和其他的注解，比如 _this_，会逐字重复，不应该使用。godoc 会做的一个调整是按固定宽度的字体显示缩进文本，适用于代码片段。&lt;a href=&#34;../golangpkg/fmt.md&#34;&gt;fmt 包&lt;/a&gt;对包注释的使用恰到好处。&lt;/p&gt;

&lt;p&gt;视上下文而定，godoc 甚至可能不会重新格式化注释，因此确保他们直接看起来是格式好的：使用正确的拼写、标点符号和句子结构，折叠长行等等。&lt;/p&gt;

&lt;p&gt;在包内部，任何紧紧出现在顶层声明之前的注释作为该声明的一个文档注释。程序中每个导出的(大写开头的)名字应该有一个文档注释。&lt;/p&gt;

&lt;p&gt;文档注释最好是完整的句子，允许不同的自动化显示。第一个句子应该是一个总结句，以声明的名字开头。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Compile 解析一个正则表达式，且成功时返回一个可用于匹配文本的 Regexp 对象。
func Compile(str string) (*Regexp, error) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果每个文档注释以描述的元素名字开头，你可以使用 &lt;a href=&#34;../command/README.md&#34;&gt;go&lt;/a&gt; 工具的 &lt;a href=&#34;../command/show_doc.md&#34;&gt;doc&lt;/a&gt; 子命令并通过 grep 运行输出。设想你不能急的 “Compile” 名字但是正在查找正则表达式的解析函数，因此你运行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go doc -all regexp | grep -i parse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果包内所有的文档注释以“这个函数……”开头，grep 不会帮助你记得那个名字。但是因为包的每个文档注释以名字开始，你会看到类似下面的内容，这会回忆起你正在寻找的单词。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 的声明语法允许分组声明。一个单一的文档注释可以介绍一组相关的常量或变量。因为显示了整个声明，这样的注释通常是敷衍了事的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 解析表达式失败时返回的错误代码。
var (
    ErrInternal      = errors.New(&amp;quot;regexp: internal error&amp;quot;)
    ErrUnmatchedLpar = errors.New(&amp;quot;regexp: unmatched &#39;(&#39;&amp;quot;)
    ErrUnmatchedRpar = errors.New(&amp;quot;regexp: unmatched &#39;)&#39;&amp;quot;)
    ...
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分组也可以指示元素之间的关系，比如被一个所保护的变量集合的事实。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;名字&#34;&gt;名字&lt;/h2&gt;

&lt;p&gt;Go 中的名字和其他语言中的一样重要。它们甚至有语义影响：一个名字在包外的可见性取决于它的第一个字母是否是大写。因此值得花费一些时间讨论 Go 编程中的命名惯例。&lt;/p&gt;

&lt;h3 id=&#34;包名&#34;&gt;包名&lt;/h3&gt;

&lt;p&gt;当导入一个包时，包名成为这些内容的一个访问器。在 &lt;code&gt;import &amp;quot;bytes&amp;quot;&lt;/code&gt; 之后，导入包可以讨论 &lt;code&gt;bytes.buffer&lt;/code&gt;。每个使用该包的人可以使用相同的名字来引用包内容是有帮助的，这意味着包名应该是好的：短、简明、引起共鸣的。按照惯例，包使用小写的、单一单词的名字；不应该需要使用下划线或驼峰。Err 就是简洁的，因为每个人使用你的包都会输入那个名字。并且不予担心与先前的冲突。包名只是导入的默认名字；它不需要在所有源码范围内唯一，并且在极少冲突的情况下，导入包可选择一个不同的名字在局部使用。无论如何，混淆是稀少的，因为这个导入的文件名只决定正在使用的包。&lt;/p&gt;

&lt;p&gt;另外一个惯例是包名是源路径的基础名；在 src/encoding/base64 中的包作为 “encoding/base64” 导入，但名字是 base64，而不是 encoding_base64 或者 encodingBase64。&lt;/p&gt;

&lt;p&gt;包的导入者将会使用包名来引用它的内容，因此包中导出的名字可使用这个事实来避免停顿。(不要使用 &lt;code&gt;import .&lt;/code&gt; 符号，这可以简化必须在被测试包之外的测试，但应该被避免。)比如， bufio 包中的带缓冲的 reader 类型叫做 Reader，而不是 BufReader，因为使用者看到的是 bufio.Reader，这是一个更加清晰简洁的名字。此外，因为导入的实体总是用包名处理，bufio.Reader 和 io.Reader 不会冲突。类似的，生成 ring.Ring 实例的函数——这是 Go 中构造函数的定义——通常会使用 NewRing 调用，但是因为 Ring 是这个包导出的唯一类型，且这个包叫做 ring，这个函数只用 New 调用，这个包的使用者看到的是 ring.New。使用包结构来帮助你选择好名字。&lt;/p&gt;

&lt;p&gt;另外一个简单的例子是 once.Do；once.Do(setup) 读着不错，并且不会被写做 once.DoOrWaitUntilDone(setup) 而有改善。长名字不会自动使得东西更易读。一个有用的文档注释通常比一个特别长的名字更有价值。&lt;/p&gt;

&lt;h3 id=&#34;getter&#34;&gt;getter&lt;/h3&gt;

&lt;p&gt;Go 不提供对 getter 和 setter 的自动支持。自己提供 getter 和 setter 是没有问题的，且通常这样做事合适的。但是将 Get 放在 getter 名字中既不是惯例也非必要的。如果你有一个域叫 owner(小写的，不导出)，它的 getter 方法应叫做 Owner(大写，导出的)，而不是 GetOwner。使用大写名字导出可以区分域名和方法名。如果有必要，一个 setter 方法可能叫做 SetOwner。两个名字实际上也是易读的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;owner := obj.Owner()
if owner != user {
  obj.SetOwner(user)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;接口名&#34;&gt;接口名&lt;/h3&gt;

&lt;p&gt;按照惯例，一个方法的接口用方法名和一个 -er 后缀或类似的修改器命名，用以构造一个代理名词：Reader，Writer，Formatter，CloseNotifier 等。&lt;/p&gt;

&lt;p&gt;有许多类似的名字，且尊重这些名字及其捕获的函数名是富有成效的，Read，Write，Close，Flush，String 等等有规范的签名和含义。为了避免混淆，除非方法具有相同的签名和含义，不要使用上述这些名字给方法命名。相反地，如果你的类型实现的方法与一个熟悉的类型的方法有相同的含义，使用这个相同的名字和签名；将你的字符串转换方法命名为 String 而不是 ToString。&lt;/p&gt;

&lt;h3 id=&#34;驼峰&#34;&gt;驼峰&lt;/h3&gt;

&lt;p&gt;最后，Go 的惯例是使用 MixedCaps 或 mixedCaps 而不是下划线来写多单词的名字。&lt;/p&gt;

&lt;h2 id=&#34;分号&#34;&gt;分号&lt;/h2&gt;

&lt;p&gt;类似 C，Go 规范的语法使用分号来终止一个语句，但是和 C 不同的是，这些分号不会出现在源文件。反之，词法分析器使用一个简单的规则在扫描时自动插入分号，因此输入文本可免除大部分分号。&lt;/p&gt;

&lt;p&gt;规则如下。如果新行之前的最后一个符号是一个标识符(包括像 int 和 float64 的单词)，一个基本字面量，比如一个数字、字符串常量，或者下面的一个符号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;break continue fallthrough return ++ -- ) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;词法分析器总是在这个符号之后插入一个分号。这可以概括为，“如果在一个可以结束一句话的符号之后有一个新行，插入一个分号”。&lt;/p&gt;

&lt;p&gt;紧挨着在一个右大括号之前出现的分号也可以忽略，因此一个类似下面的语句不需要分号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go func() {for { dts &amp;lt;- &amp;lt;- src }} ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;习惯上，Go 程序只在类似于 for 循环子句中有分号，用于分隔初始化、条件和连续元素。如果你在一行中写多个语句，也需要分号来分隔语句。&lt;/p&gt;

&lt;p&gt;插入分号规则的一个结果是你不能将一个控制结构(if/for/switch/select)的左大括号放在下一行。如果你这样做，会在一个大括号之前插入分号，这会导致不想出现的影响。像这样编写代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if i &amp;lt; f() {
    g()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if i &amp;lt; f()  // 错误!
{           // 错误!
    g()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;Go 的控制结构和 C 的控制结构相关，但是很不相同。Go 没有 do 或 while 循环，只有一个稍微普遍的 for；switch 更加灵活；if 和 switch 接受一个可选的类似 for 中的初始化语句；break 和 continue 语句使用一个可选的标签来识别从哪里跳出或继续循环；Go 也有新的控制结构，包括 type switch 和多向通讯复用器 select。语法也有一点不同：Go 没有小括号，且控制结构体必须使用大括号分隔。&lt;/p&gt;

&lt;h3 id=&#34;if&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;在 Go 中，一个简单的 if 看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if x &amp;gt; 0 {
    return y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制的大括号鼓励将一个简单的 if 语句分为多行。无论如何，这样编写是一个好的风格，尤其是当代码体包含一个控制语句，比如 return 或 break。&lt;/p&gt;

&lt;p&gt;因为 if 和 switch 接受一个初始化语句，常见的是用于设置一个局部变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Go 的库中，你会发现当一个 if 没有流入下一句——即代码体以 break、continue、goto 或 return 结束——会忽略不需要的 else。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个常见情形的例子，即代码必须防止一系列错误条件。如果成功的控制流沿着页面向下，而错误出现的时候消除它们时，代码阅读体验更好。因为错误情况倾向于以 return 语句结束，生成的diamante不需要 else 语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;重新声明和重新赋值&#34;&gt;重新声明和重新赋值&lt;/h3&gt;

&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;

&lt;h3 id=&#34;多返回值&#34;&gt;多返回值&lt;/h3&gt;

&lt;p&gt;Go 其中一个非凡的特性时函数和方法可以返回多个值。这个性质可用于改善 C 程序中的一些笨拙的写法：in-band 错误返回类似 -1 的值表示错误码并修改通过地址传递的参数。&lt;/p&gt;

&lt;p&gt;在 C 语言，使用一个负的计数器标记一个写入错误，且错误码隐藏在一个不固定位置。在 Go 语言，&lt;code&gt;Write&lt;/code&gt; 可以返回一个计数器和一个错误：“是的，你写了一部分但非全部的字节，因为你已经填满了设备”。&lt;code&gt;os&lt;/code&gt; 包中作用于文件的 &lt;code&gt;Write&lt;/code&gt; 方法签名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (file *File) Write(b []byte) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;且如文档所说，当 n 不等于 b 时这个方法返回写入的字节数和一个非空的错误。这是常见的风格；查看错误处理部分获得更多例子。&lt;/p&gt;

&lt;p&gt;一个类似的方法不需要传递一个指针给返回值来模拟一个引用参数。下面是一个简单的函数，从一个字节切片的某个位置起捕获一个数字，返回该数字和下一个位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func nextInt(b []byte, i int) (int, int) {
    for ; i &amp;lt; len(b) &amp;amp;&amp;amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &amp;lt; len(b) &amp;amp;&amp;amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - &#39;0&#39;
    }
    return x, i
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以使用这个方法像下面这样来扫描一个输入切片 &lt;code&gt;b&lt;/code&gt; 的数字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;命名结果参数&#34;&gt;命名结果参数&lt;/h3&gt;

&lt;p&gt;Go 函数的返回或结果“参数”可以指定名字并作为普通变量使用，就像使用传入参数。当函数开始时，命名的参数被初始化对应类型的零值；如果函数执行一个不带参数的 &lt;code&gt;return&lt;/code&gt; 语句，返回参数的当前值被作为返回值。&lt;/p&gt;

&lt;p&gt;名字不是必须的，但是名字可以使得代码更加简短清晰：名字即是文档。如果我们将 &lt;code&gt;nextInt&lt;/code&gt; 的结果命名，很显然返回的 &lt;code&gt;int&lt;/code&gt; 含义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func nextInt(b []byte, pos int) (value, nextPos int) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为命名的结果会被初始化且绑定在一个简单的 &lt;code&gt;return&lt;/code&gt;，它们可以既简单又清晰。下面是 &lt;code&gt;oi.ReadFull&lt;/code&gt; 使用命名结果良好的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &amp;gt; 0 &amp;amp;&amp;amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;defer&#34;&gt;defer&lt;/h3&gt;

&lt;p&gt;Go 的 &lt;code&gt;defer&lt;/code&gt; 语句安排执行 &lt;code&gt;defer&lt;/code&gt; 的函数返回之前立即运行一个函数调用(即推迟的函数)。这是一个处理一些场景特别而高效的方式，比如无论函数使用哪条路径返回都必须释放的资源。经典的例子是解锁一个互斥锁或关闭一个文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Contents 将文件内容作为字符串返回。
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return &amp;quot;&amp;quot;, err
    }
    defer f.Close()  // 函数结束时会运行 f.Close。

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // 后面会讨论 append。
        if err != nil {
            if err == io.EOF {
                break
            }
            return &amp;quot;&amp;quot;, err  // 如果在这里返回，会关闭 f。
        }
    }
    return string(result), nil // 如果在这里返回，会关闭 f。
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推迟一个类似于 &lt;code&gt;Close&lt;/code&gt; 的函数调用有两个优点。其一，它保证你永远不会忘记关闭一个文件，如果你之后编辑这个函数增加一个新的返回路径，这是很容易犯的一个错误。其二，它意味着关闭挨着打开操作，这比放在函数末尾更加清晰。&lt;/p&gt;

&lt;p&gt;推迟的函数参数(当函数是一个方法时还包括接收者)在执行 &lt;code&gt;defer&lt;/code&gt; 时计算值，而不是执行调用时计算。除了避免担心在函数执行时修改变量值，这还意味着一个单一的推迟调用可以推迟多个函数执行。这里有一个丑陋的示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; 5; i++ {
    defer fmt.Printf(&amp;quot;%d &amp;quot;, i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推迟的函数按照 LIFO (后进先出)的顺序执行，因此上述代码函数返回时，会打印“ 4 3 2 1 0”。一个更加合乎情理的例子是使用一个简单的方式来跟踪程序的函数执行。我们可以写一些像这样的简单的跟踪代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func trace(s string)   { fmt.Println(&amp;quot;entering:&amp;quot;, s) }
func untrace(s string) { fmt.Println(&amp;quot;leaving:&amp;quot;, s) }

// 像这样使用它们:
func a() {
    trace(&amp;quot;a&amp;quot;)
    defer untrace(&amp;quot;a&amp;quot;)
    // 做一些事情....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以利用延迟函数的参数在执行 &lt;code&gt;defer&lt;/code&gt; 时计算这一事实做的更好。跟踪代码可以设置不跟踪代码的参数。下面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func trace(s string) string {
    fmt.Println(&amp;quot;entering:&amp;quot;, s)
    return s
}

func un(s string) {
    fmt.Println(&amp;quot;leaving:&amp;quot;, s)
}

func a() {
    defer un(trace(&amp;quot;a&amp;quot;))
    fmt.Println(&amp;quot;in a&amp;quot;)
}

func b() {
    defer un(trace(&amp;quot;b&amp;quot;))
    fmt.Println(&amp;quot;in b&amp;quot;)
    a()
}

func main() {
    b()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;entering: b
in b
entering: a
in a
leaving: a
leaving: b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于习惯块级别资源管理的其他语言的编程人员，&lt;code&gt;defer&lt;/code&gt; 可能看起来怪异的，但是它最有趣且强大的应用正来自它不是块级别而是函数级别的事实。在 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 部分，我们会看到另一个可能使用 &lt;code&gt;defer&lt;/code&gt; 的例子。&lt;/p&gt;

&lt;h2 id=&#34;数据&#34;&gt;数据&lt;/h2&gt;

&lt;h3 id=&#34;使用-new-分配&#34;&gt;使用 new 分配&lt;/h3&gt;

&lt;p&gt;Go 有两种分配原语，即内置函数 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt;。它们做了不同的事情且适用于不同类型，这可能有点难以理解，但是规则很简单。我们首先讨论 &lt;code&gt;new&lt;/code&gt;。它是一个分配内存的内置函数，但是和一些其他语言的同名函数不同，它不会初始化内存，它只是将内存置零。也就是说，&lt;code&gt;new(T)&lt;/code&gt; 为类型 T 的新条目分配置零的存储，并返回存储地址(值为类型 T*)。在 Go 的术语中， 它返回一个指针指向一个新分配的类型 T 的零值。&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;new&lt;/code&gt; 返回的内存是置零的，当将你的数据结构设计为每个类型的零值都可以直接使用不需要进一步初始化，在安排的时候是很有用的。这意味着数据结构的使用者可以使用 &lt;code&gt;new&lt;/code&gt; 创建一个对象并正常工作。比如，&lt;code&gt;bytes.Buffer&lt;/code&gt; 的文档声明“ Buffer 的零值是一个就绪的空缓冲”。类似的，&lt;code&gt;sync.Mutex&lt;/code&gt; 没有一个显式的构造函数或 &lt;code&gt;Init&lt;/code&gt; 方法。反之，&lt;code&gt;sync.Mutex&lt;/code&gt; 的零值被定义为一个未上锁的互斥锁。&lt;/p&gt;

&lt;p&gt;“零值是有用的”这一属性可以传递。考虑这个类型声明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SyncedBuffer&lt;/code&gt; 类型的值也是分配或声明时就绪的。在下一个片段中，&lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 都可以正确工作而不用进一步安排。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := new(SyncedBuffer)  // *SyncedBuffer 类型
var v SyncedBuffer      // SyncedBuffer 类型
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构造函数和复合字面量&#34;&gt;构造函数和复合字面量&lt;/h3&gt;

&lt;p&gt;有时候零值不够好，且需要一个初始化构造函数，正如下面从 &lt;code&gt;os&lt;/code&gt; 包衍生的一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewFile(fd int, name string) *File {
    if fd &amp;lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有很多模板式代码。我们可以使用一个“复合字面量”来简化代码。“复合字面量”是一个表达式，它在每次求值时创建一个新的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewFile(fd int, name string) *File {
    if fd &amp;lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;amp;f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，和 C 不同，返回一个局部变量的地址是完全可以的；和变量相关的存储在函数返回时仍存在。事实上，使用复合字面量的地址在每次求值时分配一个新的实例，因此我们可以合并后面两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;return &amp;amp;File{fd, name, nil, 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复合字面量的域按顺序放置且必须都要出现。然而，通过显式给域打像 &lt;code&gt;field:value&lt;/code&gt; 的标签，初始化列表可以按任何顺序出现，且缺失的域会分别使用对应的零值。因此我们可以写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;return &amp;amp;File{fd: fd, name: name}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为一个限制性场景，如果一个复合字面量不包含任何域，它会为类型创建零值。表达式 &lt;code&gt;new(File)&lt;/code&gt; 和 &lt;code&gt;&amp;amp;File{}&lt;/code&gt; 是等价的。&lt;/p&gt;

&lt;p&gt;复合字面量也可用于创建数组、切片和映射，使用索引或合适的键给域打标签，在这些例子中，无论 &lt;code&gt;Enone&lt;/code&gt;、&lt;code&gt;Eio&lt;/code&gt; 和 &lt;code&gt;Einval&lt;/code&gt; 的值是什么，只要它们是唯一的，初始化器都可以工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := [...]string   {Enone: &amp;quot;no error&amp;quot;, Eio: &amp;quot;Eio&amp;quot;, Einval: &amp;quot;invalid argument&amp;quot;}
s := []string      {Enone: &amp;quot;no error&amp;quot;, Eio: &amp;quot;Eio&amp;quot;, Einval: &amp;quot;invalid argument&amp;quot;}
m := map[int]string{Enone: &amp;quot;no error&amp;quot;, Eio: &amp;quot;Eio&amp;quot;, Einval: &amp;quot;invalid argument&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-make-分配&#34;&gt;使用 make 分配&lt;/h3&gt;

&lt;h3 id=&#34;数组&#34;&gt;数组&lt;/h3&gt;

&lt;h3 id=&#34;切片&#34;&gt;切片&lt;/h3&gt;

&lt;h3 id=&#34;二维切片&#34;&gt;二维切片&lt;/h3&gt;

&lt;h3 id=&#34;映射&#34;&gt;映射&lt;/h3&gt;

&lt;h3 id=&#34;打印&#34;&gt;打印&lt;/h3&gt;

&lt;h3 id=&#34;追加&#34;&gt;追加&lt;/h3&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;h3 id=&#34;常数&#34;&gt;常数&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>容器操作</title>
      <link>https://xueqing.github.io/blog/docker/container/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/docker/container/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%97%e5%87%ba%e5%ae%b9%e5%99%a8&#34;&gt;列出容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%9e%e6%8e%a5%e5%ae%b9%e5%99%a8&#34;&gt;连接容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%8e%b7%e5%8f%96%e5%ae%b9%e5%99%a8%e6%97%a5%e5%bf%97&#34;&gt;获取容器日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;列出容器&#34;&gt;列出容器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker ps [OPTIONS]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-a: 显示所有的容器，包括未运行的&lt;/li&gt;
&lt;li&gt;-f: 根据条件过滤显示的内容&lt;/li&gt;
&lt;li&gt;&amp;ndash;format: 指定返回值的模板文件&lt;/li&gt;
&lt;li&gt;-l: 显示最近创建的容器&lt;/li&gt;
&lt;li&gt;-n: 列出最近创建的n个容器&lt;/li&gt;
&lt;li&gt;&amp;ndash;no-trunc: 不截断输出&lt;/li&gt;
&lt;li&gt;-q: 静默模式，只显示容器编号&lt;/li&gt;
&lt;li&gt;-s: 显示总的文件大小&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;列出所有在运行的容器信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出详情介绍：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CONTAINER ID: 容器 ID&lt;/li&gt;
&lt;li&gt;IMAGE: 使用的镜像&lt;/li&gt;
&lt;li&gt;COMMAND: 启动容器时运行的命令&lt;/li&gt;
&lt;li&gt;CREATED: 容器的创建时间&lt;/li&gt;
&lt;li&gt;STATUS: 容器状态。状态有 7 种

&lt;ul&gt;
&lt;li&gt;created（已创建）&lt;/li&gt;
&lt;li&gt;restarting（重启中）&lt;/li&gt;
&lt;li&gt;running（运行中）&lt;/li&gt;
&lt;li&gt;removing（迁移中）&lt;/li&gt;
&lt;li&gt;paused（暂停）&lt;/li&gt;
&lt;li&gt;exited（停止）&lt;/li&gt;
&lt;li&gt;dead（死亡）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PORTS: 容器的端口信息和使用的连接类型（tcp\udp）&lt;/li&gt;
&lt;li&gt;NAMES: 自动分配的容器名称&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;列出最近创建的 5 个容器信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker ps -n 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出所有创建的容器 ID。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;连接容器&#34;&gt;连接容器&lt;/h2&gt;

&lt;p&gt;连接到正在运行中的容器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker attach [OPTIONS] CONTAINER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要 attach 上去的容器必须正在运行，可以同时连接上同一个容器来共享屏幕（与 screen 命令的 attach 类似）。&lt;/p&gt;

&lt;p&gt;容器 mynginx 将访问日志指到标准输出，连接到容器查看访问信息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker attach --sig-proxy=false mynginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;获取容器日志&#34;&gt;获取容器日志&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker logs [OPTIONS] CONTAINER
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-f: 跟踪日志输出&lt;/li&gt;
&lt;li&gt;&amp;ndash;since: 显示某个开始时间的所有日志&lt;/li&gt;
&lt;li&gt;-t: 显示时间戳&lt;/li&gt;
&lt;li&gt;&amp;ndash;tail: 仅列出最新 N 条容器日志&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;跟踪查看容器 mynginx 的日志输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker logs -f mynginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看容器 mynginx 从 2016 年 7 月 1 日后的最新 10 条日志。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker logs --since=&amp;quot;2016-07-01&amp;quot; --tail=10 mynginx
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>容器生命周期管理命令</title>
      <link>https://xueqing.github.io/blog/docker/container_life/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/docker/container_life/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e5%ae%b9%e5%99%a8&#34;&gt;创建容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%90%af%e5%8a%a8%e5%81%9c%e6%ad%a2%e9%87%8d%e5%90%af%e5%ae%b9%e5%99%a8&#34;&gt;启动/停止/重启容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9d%80%e6%8e%89%e5%ae%b9%e5%99%a8&#34;&gt;杀掉容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%a0%e9%99%a4%e5%ae%b9%e5%99%a8&#34;&gt;删除容器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建容器&#34;&gt;创建容器&lt;/h2&gt;

&lt;p&gt;创建一个新的容器并运行一个命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项&lt;/li&gt;
&lt;li&gt;-d: 后台运行容器，并返回容器ID&lt;/li&gt;
&lt;li&gt;-i: 以交互模式运行容器，通常与 -t 同时使用&lt;/li&gt;
&lt;li&gt;-P: 随机端口映射，容器内部端口随机映射到主机的高端口&lt;/li&gt;
&lt;li&gt;-p: 指定端口映射，格式为：主机(宿主)端口:容器端口&lt;/li&gt;
&lt;li&gt;-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用&lt;/li&gt;
&lt;li&gt;&amp;ndash;name string: 为容器指定一个名称&lt;/li&gt;
&lt;li&gt;&amp;ndash;dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致&lt;/li&gt;
&lt;li&gt;&amp;ndash;dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致&lt;/li&gt;
&lt;li&gt;-h &amp;ldquo;mars&amp;rdquo;: 指定容器的hostname&lt;/li&gt;
&lt;li&gt;-e username=&amp;ldquo;ritchie&amp;rdquo;: 设置环境变量&lt;/li&gt;
&lt;li&gt;&amp;ndash;env-file=[]: 从指定文件读入环境变量&lt;/li&gt;
&lt;li&gt;&amp;ndash;cpuset-cpus string: 绑定容器到指定 CPU 运行(&amp;ldquo;0-2&amp;rdquo;/&amp;ldquo;0,1,2&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;-m: 设置容器使用内存最大值&lt;/li&gt;
&lt;li&gt;&amp;ndash;net=&amp;ldquo;bridge&amp;rdquo;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型&lt;/li&gt;
&lt;li&gt;&amp;ndash;link=[]: 添加链接到另一个容器&lt;/li&gt;
&lt;li&gt;&amp;ndash;expose=[]: 开放一个端口或一组端口&lt;/li&gt;
&lt;li&gt;&amp;ndash;volume , -v: 绑定一个卷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用 docker 镜像 nginx:latest 以后台模式启动一个容器,并将容器命名为 mynginx。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run --name &amp;quot;mynginx&amp;quot; -d nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用镜像 nginx:latest 以后台模式启动一个容器,并将容器的 80 端口映射到主机随机端口。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -P -d nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -p 80:80 -v /data:/data -d nginx:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -p 127.0.0.1:80:8080/tcp ubuntu bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用镜像 nginx:latest 以交互模式启动一个容器,在容器内执行/bin/bash命令。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker run -it nginx:latest /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;启动-停止-重启容器&#34;&gt;启动/停止/重启容器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 启动一个或多个已经被停止的容器
docker start [OPTIONS] CONTAINER [CONTAINER...]
# 停止一个运行中的容器
docker stop [OPTIONS] CONTAINER [CONTAINER...]
# 重启容器
docker restart [OPTIONS] CONTAINER [CONTAINER...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动已被停止的容器 myrunoob。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker start myrunoob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;停止运行中的容器 myrunoob。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker stop myrunoob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启容器 myrunoob。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker restart myrunoob
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;杀掉容器&#34;&gt;杀掉容器&lt;/h2&gt;

&lt;p&gt;杀掉一个运行中的容器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker kill [OPTIONS] CONTAINER [CONTAINER...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-s: 向容器发送一个信号&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;杀掉运行中的容器 mynginx。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker kill -s KILL mynginx
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;删除容器&#34;&gt;删除容器&lt;/h2&gt;

&lt;p&gt;删除一个或多少容器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker rm [OPTIONS] CONTAINER [CONTAINER...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-f: 通过SIGKILL信号强制删除一个运行中的容器&lt;/li&gt;
&lt;li&gt;-l: 移除容器间的网络连接，而非容器本身&lt;/li&gt;
&lt;li&gt;-v: 删除与容器关联的卷&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;强制删除容器db01、db02。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker rm -f db01 db02
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除容器 nginx01 对容器 db01 的连接，连接名 db。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker rm -l db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除容器 nginx01，并删除容器挂载的数据卷。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker rm -v nginx01
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>常见场景</title>
      <link>https://xueqing.github.io/blog/git/git_scenario/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_scenario/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e6%81%a2%e5%a4%8d%e4%b9%8b%e5%89%8d%e5%88%a0%e9%99%a4%e7%9a%84%e6%96%87%e4%bb%b6&#34;&gt;1 恢复之前删除的文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e5%b0%86-dev-%e5%88%86%e6%94%af%e5%bf%ab%e9%80%9f%e5%90%88%e5%b9%b6%e5%88%b0-master-%e5%88%86%e6%94%af&#34;&gt;2 将 dev 分支快速合并到 master 分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e5%b0%86%e5%9f%ba%e4%ba%8e-server-%e5%88%86%e6%94%af%e7%9a%84-client-%e5%88%86%e6%94%af%e7%9a%84%e6%8f%90%e4%ba%a4%e5%92%8c-server-%e7%9a%84%e6%8f%90%e4%ba%a4%e5%bf%ab%e9%80%9f%e5%90%88%e5%b9%b6%e5%88%b0-master-%e5%88%86%e6%94%af&#34;&gt;3 将基于 server 分支的 client 分支的提交和 server 的提交快速合并到 master 分支&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e4%bb%8e%e6%89%80%e6%9c%89%e6%8f%90%e4%ba%a4%e4%b8%ad%e5%88%a0%e9%99%a4%e6%9f%90%e6%96%87%e4%bb%b6&#34;&gt;4 从所有提交中删除某文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%e5%b0%86-dev-%e6%96%b0%e6%8f%90%e4%ba%a4%e7%9a%84%e4%bb%a3%e7%a0%81%e5%90%88%e5%b9%b6%e5%88%b0-master-%e5%88%86%e6%94%af&#34;&gt;5 将 dev 新提交的代码合并到 master 分支&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#6-%e6%92%a4%e6%b6%88%e6%93%8d%e4%bd%9c&#34;&gt;6 撤消操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-恢复之前删除的文件&#34;&gt;1 恢复之前删除的文件&lt;/h2&gt;

&lt;p&gt;比方 A，B，C，D 是四个连续的提交，其中 B 基于 A 删除了一些文件。现在需要把这些删除的文件加回 D。假设现在位于 D&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 方法1：A与B的差别是那些删除的文件。可以创建一个补丁代表这些差别，然后打补丁
git diff B A | git apply
# 方法2：从 A 中把文件拿出来
git checkout A foo.c bar.h
# 方法3：把从 A 到 B 的变化视为可撤销的变更
git revert B
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-将-dev-分支快速合并到-master-分支&#34;&gt;2 将 dev 分支快速合并到 master 分支&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 找到 dev 和 master 分支最近共同祖先, 提取 dev 分支相对于最近共同祖先所做的所有提交修改并存为临时文件,
# 然后将 dev 分支 指向 master 分支, 最后将之前另存的临时文件的修改依次应用
# 等同于 git checkout dev &amp;amp;&amp;amp; git rebase master
git rebase master dev
# 切回 master 分支, 进行一次快速合并
git checkout master &amp;amp;&amp;amp; git merge dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-将基于-server-分支的-client-分支的提交和-server-的提交快速合并到-master-分支&#34;&gt;3 将基于 server 分支的 client 分支的提交和 server 的提交快速合并到 master 分支&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 取出 client 分支, 找出处于 client 和 server 分支的共同祖先之后的修改, 然后把它们在 master 分支上重放一遍
git rebase --onto master server client
# 切回 master 分支, 进行一次快速合并
git checkout master &amp;amp;&amp;amp; git merge client
# 将 server 分支变基到目标分支 master
# 等同于 git checkout server &amp;amp;&amp;amp; git rebase master
git rebase master server
# 切回 master 分支, 进行一次快速合并
git checkout master &amp;amp;&amp;amp; git merge server
# 删除两个分支
git branch -d client server
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-从所有提交中删除某文件&#34;&gt;4 从所有提交中删除某文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-将-dev-新提交的代码合并到-master-分支&#34;&gt;5 将 dev 新提交的代码合并到 master 分支&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;合并分支分两种&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;刻意制造分支，使得版本迭代历史更加清晰&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--no-off&lt;/code&gt; 即执行正常合并，在当前分支上生成一个合并节点&lt;/li&gt;
&lt;li&gt;不加 &lt;code&gt;--no-off&lt;/code&gt;，git 默认执行“快速合并（fast-forward merge）”，如果 dev 分支本来是基于最新的 master 分支开发的，合并之后 master 分支会指向当前的 dev 分支&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将提交历史直线化，使得 master 分支的提交历史没有分叉&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 1 切换到 dev 分支
git checkout dev
# 2 提交修改 git commit -a -m &amp;quot;xxx&amp;quot;
# 3 切换到 master 分支
git checkout master
# 4 拉取最新的代码
git pull --rebase origin master
# 5 合并分支
# 5.1 刻意制造分支：合并 dev 分支代码到 master 分支
git merge --no-off dev
# 5.2 将提交历史直线化
# 5.2.1 切换到要合并的分支
git checkout dev
# 5.2.2 将需要提交的代码变基到最新的 master 分支
git rebase master
# 5.2.3 切换到 master 分支
git checkout master
# 5.2.4 快速合并 dev 分支
git merge dev
# 6 推送代码到远程仓库
git push origin master
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-撤消操作&#34;&gt;6 撤消操作&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 尝试重新提交
git commit --amend
# 取消暂存文件 f1
git reset HEAD f1
# 撤消之前对文件 f1 所做的修改
git checkout -- f1
# git reset [--hard | soft | mixed | merge | keep] [HEAD | &amp;lt;commit&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>常见问题</title>
      <link>https://xueqing.github.io/blog/markdown/problem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/markdown/problem/</guid>
      <description>

&lt;h2 id=&#34;显示反引号&#34;&gt;显示反引号&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用两个反引号&lt;code&gt;`&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>常见问题解答</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/faq/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b5%b7%e6%ba%90&#34;&gt;起源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8%e6%b3%95&#34;&gt;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%ae%be%e8%ae%a1&#34;&gt;设计&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88-go-%e6%b2%a1%e6%9c%89%e6%96%ad%e8%a8%80&#34;&gt;为什么 Go 没有断言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%80%bc&#34;&gt;值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e5%86%99%e4%bb%a3%e7%a0%81&#34;&gt;编写代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8c%87%e9%92%88%e5%92%8c%e5%88%86%e9%85%8d&#34;&gt;指针和分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;并发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e5%92%8c%e6%96%b9%e6%b3%95&#34;&gt;函数和方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a7%e5%88%b6%e6%b5%81&#34;&gt;控制流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e5%92%8c%e6%b5%8b%e8%af%95&#34;&gt;包和测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%9e%e7%8e%b0&#34;&gt;实现&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%88%91%e6%9c%80%e5%96%9c%e6%ac%a2%e7%9a%84%e6%b5%8b%e8%af%95%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0%e5%9c%a8%e5%93%aa%e9%87%8c&#34;&gt;我最喜欢的测试辅助函数在哪里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%80%a7%e8%83%bd&#34;&gt;性能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8e-c-%e7%9a%84%e6%94%b9%e5%8f%98&#34;&gt;从 C 的改变&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/faq#assertions&#34; target=&#34;_blank&#34;&gt;Go 官方文档——常见问题解答&lt;/a&gt;学习。&lt;/p&gt;

&lt;h2 id=&#34;起源&#34;&gt;起源&lt;/h2&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;

&lt;h3 id=&#34;为什么-go-没有断言&#34;&gt;为什么 Go 没有断言&lt;/h3&gt;

&lt;p&gt;Go 不提供断言。他们无疑是方便的，但是我们已有的经验是开发人员依赖断言避免思考合适的错误处理和报告。合适的错误处理意味着服务在一个非严重的错误之后继续操作而不是崩溃。合适的错误处理意味着错误是直接的、扼要的，使开发人员免于解释大量的崩溃跟踪。当看到错误的开发人员不熟悉代码，错误的准确尤为重要。&lt;/p&gt;

&lt;p&gt;我们明白这是一个争论点。Go 语言和库有很多不同于现代实践的地方，只是因为我们感觉有时候值得尝试一个不同的方法。&lt;/p&gt;

&lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;

&lt;h2 id=&#34;值&#34;&gt;值&lt;/h2&gt;

&lt;h2 id=&#34;编写代码&#34;&gt;编写代码&lt;/h2&gt;

&lt;h2 id=&#34;指针和分配&#34;&gt;指针和分配&lt;/h2&gt;

&lt;h2 id=&#34;并发&#34;&gt;并发&lt;/h2&gt;

&lt;h2 id=&#34;函数和方法&#34;&gt;函数和方法&lt;/h2&gt;

&lt;h2 id=&#34;控制流&#34;&gt;控制流&lt;/h2&gt;

&lt;h2 id=&#34;包和测试&#34;&gt;包和测试&lt;/h2&gt;

&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;

&lt;h3 id=&#34;我最喜欢的测试辅助函数在哪里&#34;&gt;我最喜欢的测试辅助函数在哪里&lt;/h3&gt;

&lt;p&gt;Go 的标准 &lt;a href=&#34;../golangpkg/testing.md&#34;&gt;testing&lt;/a&gt; 包使得易于编写单元测试，但是它缺少其他语言测试框架提供的一些特性，比如断言函数。此文档&lt;a href=&#34;#为什么-Go-没有断言&#34;&gt;前面的部分&lt;/a&gt;解释了为什么 Go 没有断言，以及在测试中使用断言的相同论点。合适的错误处理意味着使得其他测试在一个测试失败时继续运行，以便调试错误的人员可以得到一个错误的完整信息。对于一个测试来说，比起报告 isPrime 对于 2 的答案是错误的并因此不再运行更多测试，报告 isPrime 对 2、3、5、7 (或 2、4、8、16) 给出错误的答案是更加有用的。触发测试错误的开发人员可能不熟悉失败的代码。在测试失败时，花费时间编写一个好的错误消息是值得的。&lt;/p&gt;

&lt;p&gt;相关的一点是测试框架趋向于发展成为他们自己的微语言，包括条件、控制和打印机制，但是 Go 已经有所有这些功能了；为什么要创建他们？我们更愿意用 Go 编写测试；它是一门学习更少的语言，而且这个方法保持测试是直截了当易于理解的。&lt;/p&gt;

&lt;p&gt;如果编写好的错误所需的额外代码数量看起来是重复的、巨大的，那么表驱动测试可能效果更好。表驱动是迭代遍历定义在一个数据结构(Go 对于数据结构字面量有极好的支持)的输入和输出列表。编写一个好的测试和错误信息的工作在测试拥挤很多时将会被分摊。标准的 Go 库有许多说明示例，比如 &lt;a href=&#34;https://golang.org/src/fmt/fmt_test.go&#34; target=&#34;_blank&#34;&gt;fmt 包的格式化测试&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;性能&#34;&gt;性能&lt;/h2&gt;

&lt;h2 id=&#34;从-c-的改变&#34;&gt;从 C 的改变&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>开发团队的效率</title>
      <link>https://xueqing.github.io/blog/coolshell/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E6%95%88%E7%8E%87/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/coolshell/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E6%95%88%E7%8E%87/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://coolshell.cn/articles/11656.html&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;几种典型的开发方式&#34;&gt;几种典型的开发方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;软件开发中的“锁”

&lt;ul&gt;
&lt;li&gt;技术能力上的锁：需要不同的语言开发一个项目，每人只会一种语言&lt;/li&gt;
&lt;li&gt;负责模块上的锁：不同的人负责不同的模块&lt;/li&gt;
&lt;li&gt;时间锁、进度锁：掌握语言或模块负责的人不同，需要协作开发&lt;/li&gt;
&lt;li&gt;沟通锁、利益锁：人员增多会增加沟通成本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个程序员应该可以掌握多个语言，能够负责多个模块甚至不同的职责&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;接力棒式软件开发

&lt;ul&gt;
&lt;li&gt;底层开发-上层开发-测试-运维。。。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不同的团队有自己的框架（开发框架和服务框架），使得其他团队可以自己接入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;保姆式软件开发

&lt;ul&gt;
&lt;li&gt;从产品到研发、测试和运维，每个团队没有较好的完成自己的工作，需要之后的团队来发现问题&lt;/li&gt;
&lt;li&gt;产品的需求不完整，后期边开发边加需求&lt;/li&gt;
&lt;li&gt;研发没有充分测试自己的代码，使得测试花更多时间来定位错误&lt;/li&gt;
&lt;li&gt;测试没有充分测试产品，使得运维需要花更多时间重新部署服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;招聘懂“需求”、注重“软件工程”、“软件质量”和“软件维护”的工程师&lt;/li&gt;
&lt;li&gt;自己管理自己&lt;/li&gt;
&lt;li&gt;支持性工作的人越少越好&lt;/li&gt;
&lt;li&gt;服务化。我服务于代表让对方做起事来更容易&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;WatchDog 软件开发

&lt;ul&gt;
&lt;li&gt;为了解决某个系统的问题，要用一个新的系统去监控&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;想好设计，多评估几个设计，简化流程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;故障驱动式软件开发

&lt;ul&gt;
&lt;li&gt;以上线为目的，出问题再改，使得后期话更多时间定为错误、重构代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;基础知识和理论知识的重要性，多使用成熟的方案&lt;/li&gt;
&lt;li&gt;考虑清楚再写实现，做好设计&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总结

&lt;ul&gt;
&lt;li&gt;软件工程师分工分得越细这个团队就越没效率，团队间的服务化是关键的关键&lt;/li&gt;
&lt;li&gt;需要在一个环节上认真，这个环节越往前就越有效率，越往后就越没效率：需求收集-设计和编码-测试&lt;/li&gt;
&lt;li&gt;“小而精的团队”+“条件和资源受限”是效率的根本，这样才会用最经济的手段做最有价值的事&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件架构上要松耦合，团队组织上要紧耦合&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;工程师文化是关键，重视过程就是重视结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>异常</title>
      <link>https://xueqing.github.io/blog/cplusplus/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/exception/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8&#34;&gt;为什么使用异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8&#34;&gt;C++ 使用异常&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8%e7%9a%84%e5%8f%8d%e5%af%b9%e8%a7%82%e7%82%b9&#34;&gt;使用异常的反对观点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88%e9%80%9a%e8%bf%87%e5%88%a4%e6%96%ad%e6%88%96%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc%e6%a3%80%e6%9f%a5%e9%94%99%e8%af%af&#34;&gt;替代方案：通过判断或函数返回值检查错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-trycatchthrow-%e8%80%8c%e4%b8%8d%e6%98%af%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad%e5%92%8c%e8%bf%94%e5%9b%9e%e9%94%99%e8%af%af%e7%a0%81%e6%9d%a5%e6%94%b9%e5%96%84%e8%bd%af%e4%bb%b6%e8%b4%a8%e9%87%8f&#34;&gt;使用 try/catch/throw 而不是条件判断和返回错误码来改善软件质量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e4%be%bf%e4%ba%8e%e4%bc%a0%e9%80%92%e9%94%99%e8%af%af%e4%bf%a1%e6%81%af&#34;&gt;异常便于传递错误信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e4%bd%bf%e5%be%97%e4%bb%a3%e7%a0%81%e6%9b%b4%e7%ae%80%e6%b4%81&#34;&gt;异常使得代码更简洁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e6%9b%b4%e6%98%93%e5%8c%ba%e5%88%86%e6%ad%a3%e5%b8%b8%e6%89%a7%e8%a1%8c%e7%9a%84%e4%bb%a3%e7%a0%81&#34;&gt;异常更易区分正常执行的代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e9%94%99%e8%af%af%e6%98%af%e5%80%bc%e5%be%97%e7%9a%84&#34;&gt;使用异常处理错误是值得的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%8f%af%e4%bb%a5%e6%8a%9b%e5%bc%82%e5%b8%b8&#34;&gt;构造函数可以抛异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%8d%e6%8a%9b%e5%bc%82%e5%b8%b8&#34;&gt;析构函数不抛异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8a%9b%e5%87%ba%e4%bb%80%e4%b9%88%e5%bc%82%e5%b8%b8&#34;&gt;抛出什么异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8d%95%e8%8e%b7%e4%bb%80%e4%b9%88%e5%bc%82%e5%b8%b8&#34;&gt;捕获什么异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#throw-%e5%86%8d%e6%ac%a1%e6%8a%9b%e5%bc%82%e5%b8%b8&#34;&gt;throw 再次抛异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e8%a7%a3&#34;&gt;注解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;为什么使用异常&#34;&gt;为什么使用异常&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用异常处理错误使得代码更简单、更干净，并且更不可能错过错误。使用 &lt;code&gt;errno&lt;/code&gt; 和 &lt;code&gt;if&lt;/code&gt; 语句使得错误处理和普通代码紧密缠绕，因此代码更加凌乱，也更难确保已经处理了所有的错误。&lt;/li&gt;
&lt;li&gt;构造函数的工作是创建类的不变性(创建成员函数运行的环境)，这经常需要获取如内存、锁、文件、套接字等资源，即 &lt;a href=&#34;https://zh.cppreference.com/w/cpp/language/raii&#34; target=&#34;_blank&#34;&gt;RAII&lt;/a&gt;(Resource Acquisition Is Initialization)。&lt;/li&gt;
&lt;li&gt;报告一个构造函数检查到的错误需要抛异常实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c-使用异常&#34;&gt;C++ 使用异常&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++ 中，异常用于指示内部不能处理的错误，比如构造函数内部获取资源失败。&lt;/li&gt;
&lt;li&gt;不要使用异常作为函数的返回值。&lt;/li&gt;
&lt;li&gt;C++ 使用异常来支持错误处理：

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;throw&lt;/code&gt; 指示错误(函数不能处理错误，或者暴露错误的后置条件)。&lt;/li&gt;
&lt;li&gt;在知道可以处理错误的时候使用 &lt;code&gt;catch&lt;/code&gt; 指定错误处理行为(可以翻译成另一种类型并且重新抛出)。&lt;/li&gt;
&lt;li&gt;不要使用 &lt;code&gt;throw&lt;/code&gt; 指示调用函数的代码错误。而是使用 &lt;code&gt;assert&lt;/code&gt; 或其他机制，或者发送进程给调试器，或者使得进程崩溃并收集崩溃日志以便程序员调试。&lt;/li&gt;
&lt;li&gt;当发现对组件不变式的意外违反时，不要使用 &lt;code&gt;throw&lt;/code&gt;，使用 &lt;code&gt;throw&lt;/code&gt; 或其他机制来终止程序。抛出异常不能解决内存崩溃甚至会导致后续使用数据的错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用异常的反对观点&#34;&gt;使用异常的反对观点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;异常是昂贵的：和没有错误处理相比，现代 C++ 实现已经将异常的负载降到 3% 左右。正常情况不抛异常，比使用返回值和检查代码运行更快。只有出现错误才会有负载。&lt;/li&gt;
&lt;li&gt;JSF++ 禁止异常：JSF++ 是&lt;a href=&#34;https://stackoverflow.com/questions/17308956/differences-between-hard-real-time-soft-real-time-and-firm-real-time&#34; target=&#34;_blank&#34;&gt;硬实时&lt;/a&gt;和严格安全性的应用(飞机控制系统)。我们必须保证响应时间，所以我们不能使用异常，甚至禁止使用释放分配的存储。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 new 调用构造函数抛异常会导致内存泄漏：这是旧编译器的 bug，现在早已经解决了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;T *p= new T;//将被编译器转换给类似下面的代码
void  allocate_and_construct()
{
// 第一步，分配原始内存，若失败则抛出bad_alloc异常
try
{
    // 第二步，调用构造函数构造对象
    new (p)T;       // placement new: 只调用T的构造函数
}
catch(...)
{
    delete p;     // 释放第一步分配的内存
    throw;          // 重抛异常，通知应用程序
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;替代方案-通过判断或函数返回值检查错误&#34;&gt;替代方案：通过判断或函数返回值检查错误&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;ofstream os(&amp;quot;myfile&amp;quot;);//需要打开一个文件
if(os.bad()) { /*打开失败需要处理错误*/ }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可以通过函数返回一个错误码或设置一个局部变量(如 errno)。

&lt;ul&gt;
&lt;li&gt;不使用全局变量：全局变量需要立即检查，因为其他函数可能会重置它；多线程也会有问题。&lt;/li&gt;
&lt;li&gt;这就需要测试每个对象。当类由许多对象组成，尤其是这些子对象互相依赖时，会导致代码一团糟。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是检查返回值要求智慧甚至不可能达到目的。比如下面的代码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于 my_negate 函数，每一个 int 返回值都是正确的，但是当使用二进制补码表示的时候，是没有最大负数的，可参考&lt;a href=&#34;http://blog.sina.com.cn/s/blog_624e65810100xm3m.html&#34; target=&#34;_blank&#34;&gt;C语言中INT_MIN的一些问题&lt;/a&gt;。这种情况下，就需要返回值对，分别表示错误码和运算结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double d = my_sqrt(-1);//错误返回 -1
if(d == -1) { /*处理错误*/ }
int x = my_negate(INT_MIN);//额。。。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-try-catch-throw-而不是条件判断和返回错误码来改善软件质量&#34;&gt;使用 try/catch/throw 而不是条件判断和返回错误码来改善软件质量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;条件语句更易犯错&lt;/li&gt;
&lt;li&gt;延迟发布时间：白盒测试需要覆盖所有条件分支&lt;/li&gt;
&lt;li&gt;增加开发花费：非必须的条件控制增加了发现 bug、解决 bug 和测试的复杂度&lt;/li&gt;
&lt;li&gt;检测到错误的代码通常需要传递错误信息，这可能是多层函数调用，这种情况下每一层调用函数都需要添加判断代码和返回值；而异常可以更简洁、干净地传递错误信息到可以处理错误的调用者&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;异常便于传递错误信息&#34;&gt;异常便于传递错误信息&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f1()
{
try {
// ...
f2();
// ...
} catch (some_exception&amp;amp; e) {
// ...code that handles the error...
}
}

void f2() { ...; f3(); ...; }
// f3 到 f9 逐层调用，f9 调用 f10

void f10()
{
// ...
if ( /*...some error condition...*/ )
throw some_exception();
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f1()
{
// ...
int rc = f2();
if (rc == 0) {
// ...
} else {
// ...code that handles the error...
}
}

int f2()
{
// ...
int rc = f3();
if (rc != 0)
return rc;
// ...
return 0;
}

// f3 到 f9 都需要增加判断代码

int f10()
{
// ...
if (...some error condition...)
return some_nonzero_error_code;
// ...
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;异常使得代码更简洁&#34;&gt;异常使得代码更简洁&lt;/h4&gt;

&lt;p&gt;Number 类支持加减乘除 4 种基本运算，但是加会溢出，除会导致除 0 错误或向下溢出等等&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(Number x, Number y)
{
try {
// ...
Number sum  = x + y;
Number diff = x - y;
Number prod = x * y;
Number quot = x / y;
// ...
}
catch (Number::Overflow&amp;amp; exception) {
// ...code that handles overflow...
}
catch (Number::Underflow&amp;amp; exception) {
// ...code that handles underflow...
}
catch (Number::DivideByZero&amp;amp; exception) {
// ...code that handles divide-by-zero...
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f(Number x, Number y)
{
// ...

Number::ReturnCode rc;
Number sum = x.add(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

Number diff = x.sub(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

Number prod = x.mul(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

Number quot = x.div(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;异常更易区分正常执行的代码&#34;&gt;异常更易区分正常执行的代码&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f()  // Using exceptions
{
try {
GResult gg = g();
HResult hh = h();
IResult ii = i();
JResult jj = j();
// ...
}
catch (FooError&amp;amp; e) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
}
catch (BarError&amp;amp; e) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f()  // Using return-codes
{
int rc;  // &amp;quot;rc&amp;quot; stands for &amp;quot;return code&amp;quot;

GResult gg = g(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

HResult hh = h(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

IResult ii = i(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

JResult jj = j(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

// ...

return Success;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用异常处理错误是值得的&#34;&gt;使用异常处理错误是值得的&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用异常处理错误需要付出

&lt;ul&gt;
&lt;li&gt;异常处理要求原则和严谨：需要学习；&lt;/li&gt;
&lt;li&gt;异常处理不是万能药：如果团队是草率没有纪律的，那么使用异常和返回值都会有问题&lt;/li&gt;
&lt;li&gt;异常处理不是通用的：应当知道什么条件应该使用返回值，什么条件使用异常&lt;/li&gt;
&lt;li&gt;异常处理会鞭策学习新技术&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;构造函数可以抛异常&#34;&gt;构造函数可以抛异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当不能正确初始化或构造一个对象时，&lt;strong&gt;应该&lt;/strong&gt;在构造函数内部抛出异常

&lt;ul&gt;
&lt;li&gt;构造函数没有返回值，所以不能使用返回错误码的方式&lt;/li&gt;
&lt;li&gt;最差的方式是使用一个内部状态码来判断是否构造成功，但是需要在每次调用构造函数的时候使用 &lt;code&gt;if&lt;/code&gt; 检查状态码，或者在成员函数内部增加 &lt;code&gt;if&lt;/code&gt; 检查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造函数抛异常也不会有内存泄漏&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;构造函数抛异常时，对象的析构函数不会运行。因为对象的生命周期是构造函数成功完成或返回，抛异常表示构造失败，生命周期没有开始。因此需要将 undone 的东西保存在对象的数据成员&lt;/li&gt;

&lt;li&gt;&lt;p&gt;比如使用智能指针保存分配的成员对象，而不是保存到原始的 Fred* 数据成员&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Fred.h
#include &amp;lt;memory&amp;gt;

class Fred {
public:
//typedef 简化了使用 Fred 对象的语法，可以使用Fred::Ptr 取代 std::unique_ptr&amp;lt;Fred&amp;gt;
typedef std::unique_ptr&amp;lt;Fred&amp;gt; Ptr;
// ...
};

//调用者 cpp
#include &amp;quot;Fred.h&amp;quot;

void f(std::unique_ptr&amp;lt;Fred&amp;gt; p);  // explicit but verbose
void f(Fred::Ptr             p);  // simpler

void g()
{
std::unique_ptr&amp;lt;Fred&amp;gt; p1( new Fred() );  // explicit but verbose
Fred::Ptr             p2( new Fred() );  // simpler
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;析构函数不抛异常&#34;&gt;析构函数不抛异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;析构函数抛异常会导致异常点之后的代码不能指向，可能造成内存泄漏问题&lt;/li&gt;
&lt;li&gt;可以在析构函数抛异常，但是该异常不能出析构函数，即需要在析构函数内部使用 &lt;code&gt;catch&lt;/code&gt; 捕获异常。否则会破坏标准库和语言的规则。&lt;/li&gt;
&lt;li&gt;处理方式是：

&lt;ul&gt;
&lt;li&gt;可以写信息到日志文件，终止进程。&lt;/li&gt;
&lt;li&gt;提供一个普通函数执行可能抛异常的操作，给客户处理错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C++ 规则是异常的 “栈展开(stack unwinding)” 进程中调用的析构函数不能抛异常：

&lt;ul&gt;
&lt;li&gt;“stack unwinding”：当抛出一个异常时，栈是 “unwound” 的，因此在 &lt;code&gt;throw&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 之间的&lt;a href=&#34;https://www.techopedia.com/definition/22304/stack-frame&#34; target=&#34;_blank&#34;&gt;栈帧&lt;/a&gt;会被弹出。&lt;/li&gt;
&lt;li&gt;在 “stack unwinding” 过程中，这些栈帧中的所有局部变量会被析构。如果其中一个析构函数抛出异常，C++ 运行时系统将进入 “no-win” 状态：两个异常只能处理一个，忽视任何一个都会丢失信息。&lt;/li&gt;
&lt;li&gt;此时 C++ 会调用 &lt;code&gt;terminate()&lt;/code&gt; 终止进程。即在发生异常的情况下调用析构函数抛出异常会导致程序崩溃。因此避免的方法就是永远不要在析构函数抛异常。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;抛出什么异常&#34;&gt;抛出什么异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;抛出对象。如果可以，写子类继承自 &lt;code&gt;std::exception&lt;/code&gt; 类，可以提供更多关于异常的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;捕获什么异常&#34;&gt;捕获什么异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以的话，捕获异常的引用：拷贝可能会有不同的行为；指针则不确定是否需要删除指向异常的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;throw-再次抛异常&#34;&gt;throw 再次抛异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可用于实现简单的 “stack-trace”，即堆栈跟踪，在程序重要函数内部增加 &lt;code&gt;catch&lt;/code&gt; 语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyException {
public:
// ...
void addInfo(const std::string&amp;amp; info);
// ...
};

void f()
{
try {
// ...
}
catch (MyException&amp;amp; e) {
e.addInfo(&amp;quot;f() failed&amp;quot;);
throw;//再次抛出当前异常
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可用于 “exception dispatcher”，即异常分发&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void handleException()
{
try {
throw;
}
catch (MyException&amp;amp; e) {
// ...code to handle MyException...
}
catch (YourException&amp;amp; e) {
// ...code to handle YourException...
}
}

void f()
{
try {
// ...something that might throw...
}
catch (...) {
handleException();
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注解&#34;&gt;注解&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不是所有编译器支持异常捕获(exception-try-block)，只有 GCC 和大多数新版本的 MSVC 支持。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化的异常不能被隐藏：构造函数内的异常处理部分必须抛出一个异常，或重新抛出捕获的异常。下面两个版本的代码是等价的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Version 1
struct A
{
Buf b_;

A(int n)
try
    : b_(n)
{
    cout &amp;lt;&amp;lt; &amp;quot;A initialized&amp;quot; &amp;lt;&amp;lt; endl;
}
catch(BufError&amp;amp; )
{
    cout &amp;lt;&amp;lt; &amp;quot;BufError caught&amp;quot; &amp;lt;&amp;lt; endl;
}
};

// Version 2
struct A
{
Buf b_;

A(int n)
try
    : b_(n)
{
    cout &amp;lt;&amp;lt; &amp;quot;A initialized&amp;quot; &amp;lt;&amp;lt; endl;
}
catch(BufError&amp;amp; be)
{
    cout &amp;lt;&amp;lt; &amp;quot;BufError caught&amp;quot; &amp;lt;&amp;lt; endl;
    throw;
}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.technion.ac.il/~imaman/programs/throwingctor.html&#34; target=&#34;_blank&#34;&gt;Throwing Catch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/810839/throwing-exceptions-from-constructors&#34; target=&#34;_blank&#34;&gt;Throwing exceptions from constructors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://writeulearn.com/exception-constructor/&#34; target=&#34;_blank&#34;&gt;Exception in constructor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/exceptions#ctors-can-throw&#34; target=&#34;_blank&#34;&gt;exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/can-a-constructor-throw-an-exception-in-java#&#34; target=&#34;_blank&#34;&gt;Can a constructor throw an exception in Java?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1371369/can-constructors-throw-exceptions-in-java&#34; target=&#34;_blank&#34;&gt;Can constructors throw exceptions in Java?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hellogiser/p/constructor-destructor-exceptions.html&#34; target=&#34;_blank&#34;&gt;C++构造函数、析构函数与抛出异常&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>异常处理</title>
      <link>https://xueqing.github.io/blog/go/basic/go_exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/go/basic/go_exception/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#defer-%e4%bd%bf%e7%94%a8&#34;&gt;defer 使用&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#defer-%e6%a0%88&#34;&gt;defer 栈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#panic-%e4%bd%bf%e7%94%a8&#34;&gt;panic 使用&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#recover-%e4%bd%bf%e7%94%a8&#34;&gt;recover 使用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Go 不支持 try..catch..finally 这种异常。使用多值返回来返回错误&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在极端情况下才用异常（如除数为 0），异常处理使用了 defer，panic，recover&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;go 可以抛出一个 panic 的异常，在 defer 中通过 recover 捕获异常，然后处理&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;defer-使用&#34;&gt;defer 使用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;defer 的参数值是在执行 defer 语句的地方立即计算的，而不是在调用实际函数的时候计算，但是会在对应环境返回时调用函数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;应用场景：与代码流无关必须执行的函数或方法调用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;等待并发结束&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开一些资源的时候，遇到错误需要提前返回，在返回前需要关闭对应的资源&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func readWritFile() bool {
file.open(&amp;quot;file&amp;quot;)
defer file.close()

if faiure1 {
    return false
}

if failure2 {
    return false
}

return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;defer-栈&#34;&gt;defer 栈&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以在函数中添加多个 defer 语句。当函数执行到最后，返回之前，会逆序执行这些语句，类似一个 defer 栈&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;
)

func main() {
  fmt.Println(&amp;quot;counting&amp;quot;)

  for i := 0; i &amp;lt; 10; i++ {
      defer fmt.Println(i)
  }

  fmt.Println(&amp;quot;done&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;panic-使用&#34;&gt;panic 使用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;panic 用来表示非常严重的不可恢复的错误。是一个内置函数&lt;/li&gt;
&lt;li&gt;函数执行到 panic，不会继续执行，但是会执行 defer 的代码，之后将控制转移给调用者，向上传递，直至遇到打印 panic 消息，打印堆栈，然后终止&lt;/li&gt;
&lt;li&gt;场景 1：一个不可恢复的错误,程序不能继续执行。如 web 服务不能绑定端口&lt;/li&gt;
&lt;li&gt;场景 2：编程错误，如空指针访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;recover-使用&#34;&gt;recover 使用&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 panic 之后，执行 defer 的时候可以将 panic 捕获，阻止 panic 向上传递。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 defer 的地方调用 recover 函数，如果有 panic，被捕获的 panic 就不会向上传递，defer 处理完之后返回&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;recover 只在 defer 中调用才有用&lt;/li&gt;
&lt;li&gt;只有在相同的 goroutine 中调用 recover 才有效&lt;/li&gt;
&lt;li&gt;运行时的 panic 也可用 recover 捕获恢复&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 recover 之后会丢失堆栈，可在 recover 中获取和打印堆栈，使用&lt;code&gt;debug.PrintStack()&lt;/code&gt;打印堆栈&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func caller() {
fmt.Println(&amp;quot;Enter caller&amp;quot;)
defer func() { //先声明 defer
fmt.Println(&amp;quot;Enter func&amp;quot;)
if err := recover(); err != nil {
    fmt.Println(err) //打印 panic 传入的内容
}
fmt.Println(&amp;quot;Leave func&amp;quot;)
}()
callee()
fmt.Println(&amp;quot;Leave caller&amp;quot;)
}

func callee() {
fmt.Println(&amp;quot;Enter callee&amp;quot;)
panic(-1)
fmt.Println(&amp;quot;Leave callee&amp;quot;)
}

func main() {
caller()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;输出结果是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Enter caller
Enter callee
Enter func
-1
Leave func
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>感兴趣的链接</title>
      <link>https://xueqing.github.io/blog/course/interesting_links/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/course/interesting_links/</guid>
      <description>

&lt;h2 id=&#34;课程链接&#34;&gt;课程链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://css.csail.mit.edu/6.824/2014/index.html&#34; target=&#34;_blank&#34;&gt;Distributed Systems&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;教程链接&#34;&gt;教程链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@mycoralhealth/code-your-own-blockchain-in-less-than-200-lines-of-go-e296282bcffc&#34; target=&#34;_blank&#34;&gt;Code your own blockchain with golang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组退化问题</title>
      <link>https://xueqing.github.io/blog/cplusplus/array_decay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/array_decay/</guid>
      <description>

&lt;h2 id=&#34;数组退化&#34;&gt;数组退化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;类型和纬度丢失就是数组退化。通常发生在通过值或指针传递数组。这种情况下，数组发送的是它的首地址，因此数组的大小不是原始大小，而是首地址在内存中占用的大小。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码中，实际数组有 7 个 int 元素，因此大小是 28。但是调用时传递值和指针，数组退化成指针，打印的是 1 个指针的大小&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

void decayByPassVal(int *p)
{
cout &amp;lt;&amp;lt; &amp;quot;Modified size of array by passing by value: &amp;quot; &amp;lt;&amp;lt; sizeof(p) &amp;lt;&amp;lt; endl;
}

void decayByPassPointer(int (*p)[7])
{
cout &amp;lt;&amp;lt; &amp;quot;Modified size of array by passing by pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(p) &amp;lt;&amp;lt; endl;
}

int main()
{
int a[7] = {1, 2, 3, 4, 5, 6, 7,};
cout &amp;lt;&amp;lt; &amp;quot;Actual size of array is: &amp;quot; &amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt;endl;
decayByPassVal(a);
decayByPassPointer(&amp;amp;a);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;如何避免数组退化&#34;&gt;如何避免数组退化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;典型的方法避免数组退化是传递数组的大小作为单独的参数，而不是使用 &lt;code&gt;sizeof&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;另外一个方法避免数组退化是传递引用，这个可以避免数组转化为指针，因此避免了退化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

void avoidByPassReference(int (&amp;amp;p)[7])
{
cout &amp;lt;&amp;lt; &amp;quot;Modified size of array by passing by reference: &amp;quot; &amp;lt;&amp;lt; sizeof(p) &amp;lt;&amp;lt; endl;
}

int main()
{
int a[7] = {1, 2, 3, 4, 5, 6, 7,};
cout &amp;lt;&amp;lt; &amp;quot;Actual size of array is: &amp;quot; &amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt;endl;
avoidByPassReference(a);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/what-is-array-decay-in-c-how-can-it-be-prevented/&#34; target=&#34;_blank&#34;&gt;What is Array Decay in C++? How can it be prevented?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>文章</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/articles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/articles/</guid>
      <description>&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki/Articles&#34; target=&#34;_blank&#34;&gt;Go 维基官网——文章&lt;/a&gt; 学习。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>新建一个页面</title>
      <link>https://xueqing.github.io/blog/django_cms/using/create_page/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/django_cms/using/create_page/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e7%ac%ac%e4%b8%80%e4%b8%aa%e9%a1%b5%e9%9d%a2&#34;&gt;创建第一个页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%91%e5%b8%83%e4%b8%80%e4%b8%aa%e9%a1%b5%e9%9d%a2&#34;&gt;发布一个页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%8d%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e9%a1%b5%e9%9d%a2&#34;&gt;再创建一个页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bf%ae%e6%94%b9%e9%a1%b5%e9%9d%a2%e9%85%8d%e7%bd%ae&#34;&gt;修改页面配置&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%a1%b5%e9%9d%a2%e9%ab%98%e7%ba%a7%e8%ae%be%e7%bd%ae&#34;&gt;页面高级设置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bb%93%e6%9e%84%e5%92%8c%e5%86%85%e5%ae%b9%e6%a8%a1%e5%bc%8f&#34;&gt;结构和内容模式&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a2%9e%e5%8a%a0%e4%b8%80%e4%b8%aa%e6%8f%92%e4%bb%b6&#34;&gt;增加一个插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建第一个页面&#34;&gt;创建第一个页面&lt;/h2&gt;

&lt;p&gt;django CMS 的 &lt;code&gt;Create Page&lt;/code&gt; 向导会打开一个新的对话框，点击 &lt;code&gt;Next&lt;/code&gt;，完善新页面的内容&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Title：标题&lt;/li&gt;
&lt;li&gt;Slug：默认为空&lt;/li&gt;
&lt;li&gt;Content：文本内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后点击 &lt;code&gt;Create&lt;/code&gt;，就可以看到这个新创建的页面。&lt;/p&gt;

&lt;p&gt;可以看到 django CMS Content 工具栏，用于管理 django CMS 的内容。&lt;/p&gt;

&lt;h2 id=&#34;发布一个页面&#34;&gt;发布一个页面&lt;/h2&gt;

&lt;p&gt;上面新建的页面只是一个草稿 draft，直到你确定时才会发布。编辑者可以看到草稿，但是其他浏览者只能看到发布的页面。&lt;/p&gt;

&lt;p&gt;点击 &lt;code&gt;View published&lt;/code&gt; 可以看到页面的发布版。&lt;/p&gt;

&lt;p&gt;点击 &lt;code&gt;Edit&lt;/code&gt; 可以切换到编辑模式。在编辑模式，双击文本段落可以修改文本。这会打开一个 Text 插件，包含了文本内容。修改之后，点击 &lt;code&gt;Save&lt;/code&gt; 保存。&lt;/p&gt;

&lt;h2 id=&#34;再创建一个页面&#34;&gt;再创建一个页面&lt;/h2&gt;

&lt;p&gt;django CMS 可以层次组织页面。新页面可以和先前的文件位于同一层级，或者成为其他页面的一个子页面。&lt;/p&gt;

&lt;p&gt;点击 &lt;code&gt;Create&lt;/code&gt; 再创建一个页面，会打开 &lt;code&gt;Create Page&lt;/code&gt; 对话框。这次多了一个选项 &lt;code&gt;New sub page&lt;/code&gt;。创建子页面并按照之前的方式完善内容。&lt;/p&gt;

&lt;p&gt;可以点击 &lt;code&gt;Publish page now&lt;/code&gt; 来发布文章。&lt;/p&gt;

&lt;h2 id=&#34;修改页面配置&#34;&gt;修改页面配置&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;切换到某个页面的编辑模式，从工具栏选择 &lt;code&gt;page&lt;/code&gt; -&amp;gt; &lt;code&gt;Page settings ...&lt;/code&gt;。弹出的 &lt;code&gt;Change page&lt;/code&gt; 对话框允许你管理页面的一些关键设置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Slug：【必选】用于构造页面的 URL。可以修改自动生成的 slug。保持 slug 简短有意义，因为这个对于读者和搜索引擎等很有用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Menu Title：【可选】默认使用创建页面时填写的 Title 显示在菜单。但是可以通过 Menu Title 字段更改显示。一般当完整的 Title 比较长时使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Page Title：【必选】页面的 &lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; 元素默认使用创建页面时填写的 Title，但是可以通过 Page Title 字段更改显示。Page Title 不会展示在当前页面，但是搜索引擎和 web 浏览器会使用，这是页面的实际标题。Page Title 会出现在浏览器顶部或者收藏夹。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Description meta tag：【可选】一个简短的文本段，由文档的 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 标签使用。供搜索引擎和其他索引系统使用(并作为页面内容概览显示在搜索结果)。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;页面高级设置&#34;&gt;页面高级设置&lt;/h3&gt;

&lt;p&gt;大多数时候不需要接触页面的高级设置。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Overwrite URL：修改默认 URL。可缩短默认 URL 保持导航栏层级不变。&lt;/li&gt;
&lt;li&gt;Redirect：可将用户定向到一个不同的页面。当移动内容到另一个页面，但是不想破坏用户可能收藏的 URL 或者影响搜索引擎的排名时可以使用重定向。&lt;/li&gt;
&lt;li&gt;Template：设置当前页面使用的模板。&lt;/li&gt;
&lt;li&gt;Id：在与网站开发人员协商之后放可使用。否则可能导致网站不可访问。&lt;/li&gt;
&lt;li&gt;Soft root：对于深度嵌套的页面，可以缩短导航层级。选中之后，页面会作为导航栏的顶层页面。&lt;/li&gt;
&lt;li&gt;Attached menu：给页面增加自定义菜单。修改之后需要重启服务，因此需要与开发人员协商。&lt;/li&gt;
&lt;li&gt;Application：给页面增加自定义应用(如 weblog)。这个也需要和开发人员协商，并重启服务以使生效。&lt;/li&gt;
&lt;li&gt;X Frame Options：控制当前页面是否可被另一个 web 页面或网站嵌套。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;结构和内容模式&#34;&gt;结构和内容模式&lt;/h2&gt;

&lt;p&gt;内容模式：双击内容以编辑。&lt;/p&gt;

&lt;p&gt;结构模式：可以在页面结构内部管理内容的放置。&lt;/p&gt;

&lt;p&gt;切换到结果模式，可以看到结构面板，包含页面用的占位符，以及占位符的插件。默认有一个 Content 占位符，包含一个 text 插件。&lt;/p&gt;

&lt;h3 id=&#34;增加一个插件&#34;&gt;增加一个插件&lt;/h3&gt;

&lt;p&gt;点击 &lt;code&gt;+&lt;/code&gt; 按钮，增加一个插件。选择可用插件类型列表中的 Text，会打开一个熟悉的文本编辑器。&lt;/p&gt;

&lt;p&gt;增加一些文本，并点击 &lt;code&gt;Save&lt;/code&gt;。现在可以在结构面板看到新的 Text 插件——可以在结构内部移动，重排序这些插件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：不需要手动保存修改，在拖动的时候会自动保存。但是需要手动发布以便其他用户可以看到修改。&lt;/p&gt;

&lt;p&gt;结构面板中的每个插件可以通过双击或点击 &lt;code&gt;Edit&lt;/code&gt; 编辑。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>本地镜像管理命令</title>
      <link>https://xueqing.github.io/blog/docker/image_cmd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/docker/image_cmd/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%97%e5%87%ba%e6%9c%ac%e5%9c%b0%e9%95%9c%e5%83%8f&#34;&gt;列出本地镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%a0%e9%99%a4%e9%95%9c%e5%83%8f&#34;&gt;删除镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e8%ae%b0%e6%9c%ac%e5%9c%b0%e9%95%9c%e5%83%8f&#34;&gt;标记本地镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e9%95%9c%e5%83%8f&#34;&gt;创建镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bf%9d%e5%ad%98%e9%95%9c%e5%83%8f&#34;&gt;保存镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%bc%e5%85%a5%e9%95%9c%e5%83%8f&#34;&gt;导入镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;列出本地镜像&#34;&gt;列出本地镜像&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker images [OPTIONS] [REPOSITORY[:TAG]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-a: 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）&lt;/li&gt;
&lt;li&gt;&amp;ndash;digests: 显示镜像的摘要信息&lt;/li&gt;
&lt;li&gt;-f: 显示满足条件的镜像&lt;/li&gt;
&lt;li&gt;&amp;ndash;format: 指定返回值的模板文件&lt;/li&gt;
&lt;li&gt;&amp;ndash;no-trunc: 显示完整的镜像信息&lt;/li&gt;
&lt;li&gt;-q: 只显示镜像ID&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;列出本地镜像中 REPOSITORY 为 ubuntu 的镜像列表。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker images ubuntu
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;删除镜像&#34;&gt;删除镜像&lt;/h2&gt;

&lt;p&gt;删除本地一个或多少镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker rmi [OPTIONS] IMAGE [IMAGE...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-f: 强制删除&lt;/li&gt;
&lt;li&gt;&amp;ndash;no-prune: 不移除该镜像的过程镜像，默认移除&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;强制删除本地镜像 runoob/ubuntu:v4。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker rmi -f runoob/ubuntu:v4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标记本地镜像&#34;&gt;标记本地镜像&lt;/h2&gt;

&lt;p&gt;标记本地镜像，将其归入某一仓库。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将镜像 ubuntu:15.10 标记为 runoob/ubuntu:v3 镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker tag ubuntu:15.10 runoob/ubuntu:v3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建镜像&#34;&gt;创建镜像&lt;/h2&gt;

&lt;p&gt;使用 Dockerfile 创建镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build [OPTIONS] PATH | URL | -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;build-arg=[]: 设置镜像创建时的变量&lt;/li&gt;
&lt;li&gt;&amp;ndash;cpu-shares: 设置 cpu 使用权重&lt;/li&gt;
&lt;li&gt;&amp;ndash;cpu-period: 限制 CPU CFS周期&lt;/li&gt;
&lt;li&gt;&amp;ndash;cpu-quota: 限制 CPU CFS配额&lt;/li&gt;
&lt;li&gt;&amp;ndash;cpuset-cpus: 指定使用的CPU id&lt;/li&gt;
&lt;li&gt;&amp;ndash;cpuset-mems: 指定使用的内存 id&lt;/li&gt;
&lt;li&gt;&amp;ndash;disable-content-trust: 忽略校验，默认开启&lt;/li&gt;
&lt;li&gt;-f: 指定要使用的Dockerfile路径&lt;/li&gt;
&lt;li&gt;&amp;ndash;force-rm: 设置镜像过程中删除中间容器&lt;/li&gt;
&lt;li&gt;&amp;ndash;isolation: 使用容器隔离技术&lt;/li&gt;
&lt;li&gt;&amp;ndash;label=[]: 设置镜像使用的元数据&lt;/li&gt;
&lt;li&gt;-m: 设置内存最大值&lt;/li&gt;
&lt;li&gt;&amp;ndash;memory-swap: 设置Swap的最大值为内存+swap，&amp;rdquo;-1&amp;rdquo;表示不限swap&lt;/li&gt;
&lt;li&gt;&amp;ndash;no-cache: 创建镜像的过程不使用缓存&lt;/li&gt;
&lt;li&gt;&amp;ndash;pull: 尝试去更新镜像的新版本&lt;/li&gt;
&lt;li&gt;&amp;ndash;quiet, -q: 安静模式，成功后只输出镜像 ID&lt;/li&gt;
&lt;li&gt;&amp;ndash;rm: 设置镜像成功后删除中间容器&lt;/li&gt;
&lt;li&gt;&amp;ndash;shm-size: 设置/dev/shm的大小，默认值是64M&lt;/li&gt;
&lt;li&gt;&amp;ndash;ulimit: Ulimit配置&lt;/li&gt;
&lt;li&gt;&amp;ndash;tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签&lt;/li&gt;
&lt;li&gt;&amp;ndash;network: 默认 default。在构建期间设置RUN指令的网络模式&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build -t runoob/ubuntu:v1 .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 URL &lt;code&gt;github.com/creack/docker-firefox&lt;/code&gt; 的 Dockerfile 创建镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build github.com/creack/docker-firefox
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以通过 -f Dockerfile 文件的位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker build -f /path/to/a/Dockerfile .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回。&lt;/p&gt;

&lt;h2 id=&#34;保存镜像&#34;&gt;保存镜像&lt;/h2&gt;

&lt;p&gt;将指定镜像保存成 tar 归档文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker save [OPTIONS] IMAGE [IMAGE...]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-o: 输出到的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker save -o my_ubuntu_v3.tar runoob/ubuntu:v3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;导入镜像&#34;&gt;导入镜像&lt;/h2&gt;

&lt;p&gt;导入使用 docker save 命令导出的镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker load [OPTIONS]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;input, -i: 指定导入的文件，代替 STDIN&lt;/li&gt;
&lt;li&gt;&amp;ndash;quiet, -q: 精简输出信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从 busybox.tar.gz 导入镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker load &amp;lt; busybox.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定导入文件 fedora.tar 导入镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker load -i fedora.tar
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>测试函数</title>
      <link>https://xueqing.github.io/translation/go-doc/command/test_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/test_func/</guid>
      <description>&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 命令预期查找对应测试包的 “*_test.go” 文件中的测试函数、基准测试函数和示例函数。&lt;/p&gt;

&lt;p&gt;测试函数命名为 TestXxx(Xxx 不以小写字母开始)，且应当有签名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestXxx(t *testing.T) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个基准测试函数命名为 BenchmarkXxx，且应该有签名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkXxx(b *testing.B) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个示例函数，类似于测试函数，但不使用 *testing.T 报告成功或失败，而是打印输出到 os.Stdout。如果函数内最后的注释以 “Output:” 开头，那么输出与注释精确比较(看下面的例子)。如果最后的注释以 “Unordered output:” 开始，那么输出和注释做比较，但是忽视行的顺序。一个不带这样的注释的示例被编译但是不执行。一个在 “Output:” 之后没有文本的示例会被编译、执行并预期不会生成输出。&lt;/p&gt;

&lt;p&gt;Godoc 显示 ExampleXxx 的消息体来演示函数、常量或变量 Xxx 的使用。一个接收类型是 T 或 *T 的方法 M 的示例函数命名为 ExampleT_M。对于一个给定的函数、常数或变量可能有多个示例，通过后缀 _xxx 区分，xxx 是一个不以大写字母开始的后缀。&lt;/p&gt;

&lt;p&gt;有一个示例函数的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExamplePrintln() {
  Println(&amp;quot;The output of\nthis example.&amp;quot;)
  // Output: The output of
  // this example.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个忽视输出顺序的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExamplePerm() {
  for _, value := range Perm(4) {
    fmt.Println(value)
  }

  // Unordered output: 4
  // 2
  // 1
  // 3
  // 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当文件包含一个单独的示例函数，及至少一个其他的函数、类型、变量或常数声明，且没有测试函数或者基准测试函数时，整个测试文件作为例子显示。&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;../wiki/golangpkg/testing.md&#34;&gt;testing 包的文档&lt;/a&gt;查看更多信息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试标识</title>
      <link>https://xueqing.github.io/translation/go-doc/command/test_flag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/test_flag/</guid>
      <description>&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 命令使用只适用于 &lt;code&gt;go test&lt;/code&gt; 的标识以及适用于生成二进制测试的标识。&lt;/p&gt;

&lt;p&gt;一些标识控制概要并且写适用于 &lt;code&gt;go tool pprof&lt;/code&gt; 的执行概要；运行 &lt;code&gt;go tool pprof -h&lt;/code&gt; 查看更多信息。pprof 的 &amp;ndash;alloc_space、&amp;ndash;alloc_objects 和 &amp;ndash;show_bytes 选项控制如何显示这些信息。&lt;/p&gt;

&lt;p&gt;下面的标识被 &lt;code&gt;go test&lt;/code&gt; 命令识别，并且控制测试的执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;-bench regexp
    Run only those benchmarks matching a regular expression.
    By default, no benchmarks are run.
    To run all benchmarks, use &#39;-bench .&#39; or &#39;-bench=.&#39;.
    The regular expression is split by unbracketed slash (/)
    characters into a sequence of regular expressions, and each
    part of a benchmark&#39;s identifier must match the corresponding
    element in the sequence, if any. Possible parents of matches
    are run with b.N=1 to identify sub-benchmarks. For example,
    given -bench=X/Y, top-level benchmarks matching X are run
    with b.N=1 to find any sub-benchmarks matching Y, which are
    then run in full.

-benchtime t
    Run enough iterations of each benchmark to take t, specified
    as a time.Duration (for example, -benchtime 1h30s).
    The default is 1 second (1s).
    The special syntax Nx means to run the benchmark N times
    (for example, -benchtime 100x).

-count n
    Run each test and benchmark n times (default 1).
    If -cpu is set, run n times for each GOMAXPROCS value.
    Examples are always run once.

-cover
    Enable coverage analysis.
    Note that because coverage works by annotating the source
    code before compilation, compilation and test failures with
    coverage enabled may report line numbers that don&#39;t correspond
    to the original sources.

-covermode set,count,atomic
    Set the mode for coverage analysis for the package[s]
    being tested. The default is &amp;quot;set&amp;quot; unless -race is enabled,
    in which case it is &amp;quot;atomic&amp;quot;.
    The values:
  set: bool: does this statement run?
  count: int: how many times does this statement run?
  atomic: int: count, but correct in multithreaded tests;
    significantly more expensive.
    Sets -cover.

-coverpkg pattern1,pattern2,pattern3
    Apply coverage analysis in each test to packages matching the patterns.
    The default is for each test to analyze only the package being tested.
    See &#39;go help packages&#39; for a description of package patterns.
    Sets -cover.

-cpu 1,2,4
    Specify a list of GOMAXPROCS values for which the tests or
    benchmarks should be executed. The default is the current value
    of GOMAXPROCS.

-failfast
    Do not start new tests after the first test failure.

-list regexp
    List tests, benchmarks, or examples matching the regular expression.
    No tests, benchmarks or examples will be run. This will only
    list top-level tests. No subtest or subbenchmarks will be shown.

-parallel n
    Allow parallel execution of test functions that call t.Parallel.
    The value of this flag is the maximum number of tests to run
    simultaneously; by default, it is set to the value of GOMAXPROCS.
    Note that -parallel only applies within a single test binary.
    The &#39;go test&#39; command may run tests for different packages
    in parallel as well, according to the setting of the -p flag
    (see &#39;go help build&#39;).

-run regexp
    Run only those tests and examples matching the regular expression.
    For tests, the regular expression is split by unbracketed slash (/)
    characters into a sequence of regular expressions, and each part
    of a test&#39;s identifier must match the corresponding element in
    the sequence, if any. Note that possible parents of matches are
    run too, so that -run=X/Y matches and runs and reports the result
    of all tests matching X, even those without sub-tests matching Y,
    because it must run them to look for those sub-tests.

-short
    Tell long-running tests to shorten their run time.
    It is off by default but set during all.bash so that installing
    the Go tree can run a sanity check but not spend time running
    exhaustive tests.

-timeout d
    If a test binary runs longer than duration d, panic.
    If d is 0, the timeout is disabled.
    The default is 10 minutes (10m).

-v
    Verbose output: log all tests as they are run. Also print all
    text from Log and Logf calls even if the test succeeds.

-vet list
    Configure the invocation of &amp;quot;go vet&amp;quot; during &amp;quot;go test&amp;quot;
    to use the comma-separated list of vet checks.
    If list is empty, &amp;quot;go test&amp;quot; runs &amp;quot;go vet&amp;quot; with a curated list of
    checks believed to be always worth addressing.
    If list is &amp;quot;off&amp;quot;, &amp;quot;go test&amp;quot; does not run &amp;quot;go vet&amp;quot; at all.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的标识被 &lt;code&gt;go test&lt;/code&gt; 命令识别，且可用于概述执行期间的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;-benchmem
    Print memory allocation statistics for benchmarks.

-blockprofile block.out
    Write a goroutine blocking profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.

-blockprofilerate n
    Control the detail provided in goroutine blocking profiles by
    calling runtime.SetBlockProfileRate with n.
    See &#39;go doc runtime.SetBlockProfileRate&#39;.
    The profiler aims to sample, on average, one blocking event every
    n nanoseconds the program spends blocked. By default,
    if -test.blockprofile is set without this flag, all blocking events
    are recorded, equivalent to -test.blockprofilerate=1.

-coverprofile cover.out
    Write a coverage profile to the file after all tests have passed.
    Sets -cover.

-cpuprofile cpu.out
    Write a CPU profile to the specified file before exiting.
    Writes test binary as -c would.

-memprofile mem.out
    Write an allocation profile to the file after all tests have passed.
    Writes test binary as -c would.

-memprofilerate n
    Enable more precise (and expensive) memory allocation profiles by
    setting runtime.MemProfileRate. See &#39;go doc runtime.MemProfileRate&#39;.
    To profile all memory allocations, use -test.memprofilerate=1.

-mutexprofile mutex.out
    Write a mutex contention profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.

-mutexprofilefraction n
    Sample 1 in n stack traces of goroutines holding a
    contended mutex.

-outputdir directory
    Place output files from profiling in the specified directory,
    by default the directory in which &amp;quot;go test&amp;quot; is running.

-trace trace.out
    Write an execution trace to the specified file before exiting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有这些标识也有一个可选的 “test.” 前缀被识别(如 -test.v)。但是当直接调用生成的二进制测试时(&lt;code&gt;go test -c&lt;/code&gt; 生成)，这个前缀是强制的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 命令在调用二进制测试之前，适当地重写或移除在可选的包列表之前或之后识别的标识。&lt;/p&gt;

&lt;p&gt;比如，命令 &lt;code&gt;go test -v -myflag testdata -cpuprofile=prof.out -x&lt;/code&gt; 将会编译二进制测试然后运行 &lt;code&gt;pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out&lt;/code&gt;。(-x 标识被移除，因为它只适用于go 命令的执行，而不是&lt;code&gt;go test&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;生成概述(除了用于覆盖)的测试标识也会将二进制测试留在 pkg.test 以便用于分析概述。&lt;/p&gt;

&lt;p&gt;当 &lt;code&gt;go test&lt;/code&gt; 运行一个二进制测试时，它从对应包源码目录内部运行。视测试而定，可能需要在直接调用一个生成的二进制测试时也这样做。&lt;/p&gt;

&lt;p&gt;命令行的包列表，如果有的话，必须出现在所有 &lt;code&gt;go test&lt;/code&gt; 命令不知道的标识之前。继续上面的例子，包列表需要出现在 -myflag 之前，但是可以出现在 -v 两侧。&lt;/p&gt;

&lt;p&gt;当 &lt;code&gt;go test&lt;/code&gt; 在列表模式运行时，&lt;code&gt;go test&lt;/code&gt; 缓存成功的包测试结果以避免不必要的重复运行测试。要禁用测试缓存，使用除了可缓存的标识以外的任意的测试标识或参数。惯用的显式禁用测试缓存的方法是使用 -count=1。&lt;/p&gt;

&lt;p&gt;要保持二进制测试的一个参数不被翻译成一个已知的标识或者包名，使用 -args (查看 &lt;code&gt;got help test&lt;/code&gt;) 换地命令行的剩余部分给二进制测试，该部分不会被解释或修改。&lt;/p&gt;

&lt;p&gt;例如，命令 &lt;code&gt;go test -v -args -x -v&lt;/code&gt; 会编译二进制测试然后运行 &lt;code&gt;pkg.test -test.v -x -v&lt;/code&gt;。类似的，&lt;code&gt;go test -args math&lt;/code&gt; 会编译二进制测试然后运行 &lt;code&gt;pkg.test math&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在第一个例子中，-x 和第二个 -v 被传递给二进制测试且未被修改，且对 go 命令本身没有影响。在第二个例子中，参数 math 被传递给二进制测试，而不是解释成包列表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>结合 C 和 C&#43;&#43; 代码</title>
      <link>https://xueqing.github.io/blog/cplusplus/mix_c_and_cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/mix_c_and_cpp/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9c%80%e8%a6%81%e4%ba%86%e8%a7%a3%e7%9a%84%e7%9f%a5%e8%af%86&#34;&gt;需要了解的知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e8%af%ad%e8%a8%80%e5%87%bd%e6%95%b0&#34;&gt;在 C++ 中调用 C 语言函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e8%af%ad%e8%a8%80%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 语言函数&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e9%87%8d%e8%bd%bd%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 重载函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e5%90%8d%e7%a7%b0%e9%87%8d%e6%95%b4&#34;&gt;C++ 名称重整&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e9%93%be%e6%8e%a5%e5%99%a8%e5%a4%84%e7%90%86-c-%e7%ac%a6%e5%8f%b7&#34;&gt;C++ 链接器处理 C 符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e5%8c%85%e5%90%ab%e4%b8%80%e4%b8%aa%e6%a0%87%e5%87%86%e7%9a%84-c-%e5%a4%b4%e6%96%87%e4%bb%b6&#34;&gt;在 C++ 中包含一个标准的 C 头文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e5%8c%85%e5%90%ab%e4%b8%80%e4%b8%aa%e9%9d%9e%e7%b3%bb%e7%bb%9f%e7%9a%84-c-%e5%a4%b4%e6%96%87%e4%bb%b6&#34;&gt;在 C++ 中包含一个非系统的 C 头文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bf%ae%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84-c-%e5%a4%b4%e6%96%87%e4%bb%b6%e4%bb%a5%e4%be%bf-c-%e5%ae%b9%e6%98%93%e4%bd%bf%e7%94%a8-include-%e8%af%ad%e5%8f%a5%e5%8c%85%e5%90%ab&#34;&gt;修改自己的 C 头文件以便 C++ 容易使用 include 语句包含&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8%e9%9d%9e%e7%b3%bb%e7%bb%9f%e7%9a%84-c-%e5%87%bd%e6%95%b0-fintcharfloat&#34;&gt;在 C++ 中调用非系统的 C 函数 f(int,char,float)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e8%a2%ab-c-%e8%b0%83%e7%94%a8%e7%9a%84-c-%e5%87%bd%e6%95%b0-fintcharfloat&#34;&gt;创建一个可被 C 调用的 C++ 函数 f(int,char,float)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%93%be%e6%8e%a5%e5%99%a8%e5%9c%a8-cc-%e8%b0%83%e7%94%a8-cc-%e5%87%bd%e6%95%b0%e6%97%b6%e6%8a%a5%e9%94%99%e7%9a%84%e5%8e%9f%e5%9b%a0&#34;&gt;链接器在 C/C++ 调用 C++/C 函数时报错的原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bc%a0%e9%80%92%e4%b8%80%e4%b8%aa-c-%e7%b1%bb%e7%9a%84%e5%af%b9%e8%b1%a1%e7%bb%99%e4%bb%8e-c-%e5%87%bd%e6%95%b0&#34;&gt;传递一个 C++ 类的对象给/从 C 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e5%87%bd%e6%95%b0%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e8%ae%bf%e9%97%ae-c-%e7%b1%bb%e5%af%b9%e8%b1%a1%e7%9a%84%e6%95%b0%e6%8d%ae&#34;&gt;C 函数是否可以直接访问 C++ 类对象的数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-c-%e6%af%94-c-%e6%9b%b4%e8%a7%89%e5%be%97%e8%bf%9c%e7%a6%bb%e6%9c%ba%e5%99%a8%e4%bb%a3%e7%a0%81&#34;&gt;使用 C++ 比 C 更觉得远离机器代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;需要了解的知识&#34;&gt;需要了解的知识&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有一些关键点(即使一些编译器尝试不要求，检查编译器厂商的文件)

&lt;ul&gt;
&lt;li&gt;当编译 &lt;code&gt;main()&lt;/code&gt; 时必须使用 C++ 编译器(比如为了静态初始化)&lt;/li&gt;
&lt;li&gt;C++ 编译器应该管理链接过程(这样才可以得到指定的库)&lt;/li&gt;
&lt;li&gt;C 和 C++ 编译器可能需要来自同一厂商，且具有兼容版本(这样才有相同的调用惯例)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;除此之外，你需要阅读剩余的章节以找到 可被 C/C++ 调用的 C++/C 函数&lt;/li&gt;
&lt;li&gt;有一个方式可以解决所有的问题：即使用 C++ 编译器编译所有的代码(即使是 C 风格的代码)

&lt;ul&gt;
&lt;li&gt;优点：可以解决结合 C 和 C++ 代码的问题，也更容易发现 C 代码的错误&lt;/li&gt;
&lt;li&gt;缺点：需要更新 C 风格的代码，&lt;a href=&#34;https://isocpp.org/wiki/faq/big-picture#back-compat-with-c&#34; target=&#34;_blank&#34;&gt;原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但是更细代码的代价可能比结合二者的代价更小，同时可以清除 C 风格的代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中调用-c-语言函数&#34;&gt;在 C++ 中调用 C 语言函数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 C++ 中用 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 声明 C 函数，然后在 C/C++ 中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int);//方式1
extern &amp;quot;C&amp;quot; {//方式2
int g(double);
double h();
};

void cppode(int i, double d)
{
f(i);
int ii = g(d);
double dd = h();
//...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//c code
void f(int i)
{
//...
}
int g(double d)
{
//...
}
double h() {
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中调用-c-语言函数-1&#34;&gt;在 C 中调用 C++ 语言函数&lt;/h2&gt;

&lt;h3 id=&#34;在-c-中调用-c-非成员函数&#34;&gt;在 C 中调用 C++ 非成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 C++ 中用 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 声明 C++ 函数，然后在 C/C++ 中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int);

void f(int i)
{
//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f(int);

void ccode(int i)
{
f(i);
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;在-c-中调用-c-成员函数&#34;&gt;在 C 中调用 C++ 成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果需要在 C 中调用成员函数(包括虚函数)，需要提供一个简单的封装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class C {
//...
virtual double f(int);
};

//封装函数
extern &amp;quot;C&amp;quot; double call_C_f(C* p, int i)
{
return p-&amp;gt;f(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct C
{
//...
};
double call_C_f(struct C*, int);

void ccode(struct C* p, int i)
{
double d = call_C_f(p, i);
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;在-c-中调用-c-重载函数&#34;&gt;在 C 中调用 C++ 重载函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果需要在 C 中调用重载函数，必须为 C 语言提供不同名称的封装函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void f(int);
void f(double)

extern &amp;quot;C&amp;quot; void f_i(int);
extern &amp;quot;C&amp;quot; void f_d(double);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f_i(int);
void f_d(double);

void ccode(int i, double d)
{
f_i(i);
f_d(d);
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这种方式适用于在 C 中调用 C++ 库，即使不能修改 C++ 的头文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-名称重整&#34;&gt;C++ 名称重整&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;C++ 支持函数重载。比如可以有多个函数名称相同，但参数不同。当生成目标代码时，C++ 编译器通过添加参数信息修改名称来区分不同的函数。这个添加额外信息到函数名的技术叫做名称重整(name mangling)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ 标准没有对名称重整指定任何详细的技术，因此不同编译器可能添加不同信息到函数名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int f(void) {return 1;}
int f(int) {return 0;}
void g(void) (int i=f(), j=f(0);)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上述代码可能被 C++ 编译器改成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int __f_v(void) {return 1;}
int __f_i(int) {return 0;}
void __g_v(void) (int i=__f_v(), j=__f_i(0);)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-链接器处理-c-符号&#34;&gt;C++ 链接器处理 C 符号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;C 不支持函数重载，名称不会被重整。当把代码放到 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 块时，C++ 编译器确保函数名不会被重整，即编译器生成一个二进制文件，且没有修改函数名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 在 C++ 调用 C 时：告诉 g++ 预期得到 gcc 生成的未重整的符号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 在 C 调用 C++ 时：告诉 g++ 生成未重整的符号给 gcc 使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反编译一个 g++ 生成的二进制代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void f() {}
void g();

extern &amp;quot;C&amp;quot; {
void ef() {}
void eg();
}

void h() { g(); eg();}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 g++ 编译 &lt;code&gt;g++ -c main.cpp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;反编译符号表 &lt;code&gt;readelf -s main.o&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Symbol table &#39;.symtab&#39; contains 13 entries:
Num:    Value          Size Type    Bind   Vis      Ndx Name
 0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
 1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS cppcode.cpp
 2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
 3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
 4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
 5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
 6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
 7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
 8: 0000000000000000     7 FUNC    GLOBAL DEFAULT    1 _Z1fv
 9: 0000000000000007     7 FUNC    GLOBAL DEFAULT    1 ef
10: 000000000000000e    17 FUNC    GLOBAL DEFAULT    1 _Z1hv
11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z1gv
12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND eg
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以看到：&lt;code&gt;ef&lt;/code&gt; 和 &lt;code&gt;eg&lt;/code&gt; 在符号表存储的名字和代码中的名字相同；其他的名称被重整过&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解开(unmangle)这些名字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kiki@ubuntu:/tmp/test$ c++filt _Z1fv
f()
kiki@ubuntu:/tmp/test$ c++filt _Z1hv
h()
kiki@ubuntu:/tmp/test$ c++filt _Z1gv
g()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中包含一个标准的-c-头文件&#34;&gt;在 C++ 中包含一个标准的 C 头文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接使用 &lt;code&gt;#include&lt;/code&gt; 包含所需头文件，比如 &lt;code&gt;#include &amp;lt;cstdio&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cstdio&amp;gt;

int main()
{
printf(&amp;quot;Hello!\n&amp;quot;);// or std::printf
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果使用 C++ 编译器编译 C 代码，又不希望将类似 &lt;code&gt;printf&lt;/code&gt; 改成 &lt;code&gt;std::printf&lt;/code&gt;，可以在 C 代码中使用旧风格的头文件 &lt;code&gt;stdio.h&lt;/code&gt; 替换新风格的头文件 &lt;code&gt;cstdio&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
printf(&amp;quot;Hello!\n&amp;quot;);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中包含一个非系统的-c-头文件&#34;&gt;在 C++ 中包含一个非系统的 C 头文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果在 C++ 中包含一个非系统提供的 C 头文件，需要使用 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt; 结构包裹 &lt;code&gt;#include&lt;/code&gt; 语句，这个告诉 C++ 编译器此头文件声明的函数是 C 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; {
//get declaration for void sum(int, int)
#include &amp;quot;my-c-code.h&amp;quot;
}

int main()
{
sum(1, 2);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;修改自己的-c-头文件以便-c-容易使用-include-语句包含&#34;&gt;修改自己的 C 头文件以便 C++ 容易使用 include 语句包含&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果在 C++ 中包含一个非系统提供的 C 头文件，且 C 头文件可以修改，强烈建议在头文件添加 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt; 语句使得 C++ 开发者更加容易使用 &lt;code&gt;#include&lt;/code&gt; 包含此头文件到 C++ 代码&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为 C 编译器不理解 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt; 结构，必须使用 &lt;code&gt;#ifdef&lt;/code&gt; 包裹 &lt;code&gt;extern &amp;quot;C&amp;quot; {&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt;，以便 C 编译器看不到这个结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//my-c-code.h
//有且只有 C++ 编译器会定义 __cplusplus 符号
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

//c code

#ifdef __cplusplus
}
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;my-c-code.h&amp;quot;

int main()
{
sum(1, 2);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中调用非系统的-c-函数-f-int-char-float&#34;&gt;在 C++ 中调用非系统的 C 函数 f(int,char,float)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果需要调用一个 C 函数，但是不需要或者不想包含声明此函数的 C 头文件，可以在 C++ 代码中使用 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 语法声明这一个 C 函数。一般需要使用完整的函数原型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int,char,float);

int main()
{
int i=1;
char c=&#39;c&#39;;
float ff=2;
f(i, c, ff);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多个 C 函数可以使用 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建一个可被-c-调用的-c-函数-f-int-char-float&#34;&gt;创建一个可被 C 调用的 C++ 函数 f(int,char,float)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C++ 编译器必须通过 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 知道 &lt;code&gt;f(int,char,float)&lt;/code&gt; 会被 C 编译器调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int,char,float);

//define f(int,char,float) in some c++ module
void f(int i, char c, float ff)
[
//...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 告诉编译器发送给链接器的外部信息应该使用 C 的调用管理和名称重整(name-mangling)(比如前置一个下划线)。因为 C 不支持名称重载，你不能在 C 程序中同时调用多个重载的函数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;链接器在-c-c-调用-c-c-函数时报错的原因&#34;&gt;链接器在 C/C++ 调用 C++/C 函数时报错的原因&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果 `extern &amp;ldquo;C&amp;rdquo; 语法不正确，会有一些链接错误而不是编译器错误。因为 C++ 编译器通常会重整(mangle) 函数名称(比如为了支持函数重载)而跟 C 编译器不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;传递一个-c-类的对象给-从-c-函数&#34;&gt;传递一个 C++ 类的对象给/从 C 函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// fred.h: this header can be read by c/c++ compilers
#ifndef FRED_H
#define FRED_H

#ifdef __cplusplus
class Fred {
public:
  Fred();
  void wilma(int);

private:
  int a_;
};
#else
typedef struct Fred Fred;
#endif

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

#if defined(__STDC__) || defined(__cplusplus)
  extern void c_function(Fred*);///* ANSI C prototypes */
  extern Fred* cplusplus_callback_function(Fred*);
#else
  extern void c_function();///* K&amp;amp;R style */
  extern Fred* cplusplus_callback_function();
#endif

#ifdef __cplusplus
}
#endif

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// fred.cpp
#include &amp;quot;fred.h&amp;quot;

#include &amp;lt;stdio.h&amp;gt;

Fred::Fred() : a_(0)
{

}

void Fred::wilma(int a)
{
  a_ = a;
  printf(&amp;quot;a=%d\n&amp;quot;, a);
}

Fred* cplusplus_callback_function(Fred* fred)
{
  fred-&amp;gt;wilma(123);
  return fred;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// ccode.c
#include &amp;quot;fred.h&amp;quot;

void c_function(Fred* fred)
{
  cplusplus_callback_function(fred);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// cppcode.cpp
#include &amp;quot;fred.h&amp;quot;

int main()
{
  Fred fred;
  c_function(&amp;amp;fred);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;编译命令 &lt;code&gt;gcc fred.h fred.cpp ccode.c cppcode.cpp&lt;/code&gt; 或 &lt;code&gt;gcc fred.h fred.cpp ccode.c cppcode.cpp&lt;/code&gt;，输出 &lt;code&gt;a=123&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和 C++ 代码不同，C 代码不能识别统一对象的两个指针，除非这两个指针完全是同一类型。比如，C++中容易检查指向同一对象的衍生类指针 dp 和基类指针 bp&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;判断 &lt;code&gt;if(dp == bp)&lt;/code&gt;，C++ 编译器会自动转化两个指针到同一类型，这种情况下到基类指针，然后进行比较。这取决于 C++ 编译器的具体实现，有时候这种转化会改动一个指针值的比特位&lt;/li&gt;
&lt;li&gt;技术层面上，大部分 C++ 编译器使用一个二进制对象格式以便多继承和/或虚继承的转换。但是 C++ 语言不会暴露对象格式，因此从原则上说，一个转化也会发生在非虚单继承&lt;/li&gt;
&lt;li&gt;关键点是 C 编译器不知道如何做指针转换，所以从衍生类到基类指针的转换必须发生在 C++ 编译器编译的代码，而不是 C 编译器编译的代码&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;当转换衍生类和基类指针到 void* 时必须要小心，因为这个不支持 C/C++ 编译器做适合的指针调整&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(Base* bp, Derived *dp)
{
if(bp ==dp) //valid to compare a Base* to Derived*
{
//...
}
void* xp = bp;
void* yp = dp;
if(x == y) //bad form! do not use this!
{
//...
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如上所述，上述指针转换会发生在多继承和/或虚继承&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 void* 指针的安全方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(Base* bp, Derived *dp)
{
void* xp = bp;
// If conversion is needed, it will happen in the static_cast&amp;lt;&amp;gt;
void* yp = static_cast&amp;lt;Base*&amp;gt;(dp);
if(x == y)//valid to compare a Base* to Derived*
{
//....
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c-函数是否可以直接访问-c-类对象的数据&#34;&gt;C 函数是否可以直接访问 C++ 类对象的数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果一个 C++ 类满足下面的条件，C 函数可以安全访问 C++ 对象的数据

&lt;ul&gt;
&lt;li&gt;没有虚函数(包括继承的虚函数)&lt;/li&gt;
&lt;li&gt;所有数据的访问权限相同(private/protected/public)&lt;/li&gt;
&lt;li&gt;不含带有虚函数的完全包含的子对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果 C++ 类由任何基类(或者其完全包含的子对象有基类)，对这些数据的访问都是不可移植的。因为语言不会暴露带有继承的类格式。但实际上，所以的 C++ 编译器的处理方式相同：基类对象在前面(多重继承时按照从左至右的顺序)，然后是成员对象&lt;/li&gt;
&lt;li&gt;此外，如果该类(或任何基类)包含虚函数，几乎所有 C++ 编译器会在对象内放置一个 void*，或者是在第一个虚函数的位置，或者是在对象最开始的位置。这一点也不是语言要求的，但是每个语言都这样处理&lt;/li&gt;
&lt;li&gt;如果类包含需基类，情况更加复杂且更难移植。一个通用的实现技术是在对象最后包含一个虚基类的对象(不管虚基类在继承中的层次结构)。对象的其他部分还是正常的顺序。每个衍生的类实际上有一个指向虚基类的指针？？？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用-c-比-c-更觉得远离机器代码&#34;&gt;使用 C++ 比 C 更觉得远离机器代码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作为面向对象(OO)的编程语言，C++ 支持模型化问题域，这支持在问题域的语言进行编程而不是使用解决方案域的语言编程&lt;/li&gt;
&lt;li&gt;C 的一个很大优势是没有隐藏机制：看到的就是得到的。可以阅读一个 C 程序并看到每一个时钟周期。但 C++ 不支持。虽然 C++ 为编程者隐藏了一些机制，它也提供了一个抽象层和表达上的经济，以便降低维护成本且不会破坏运行时性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/mixing-c-and-cpp&#34; target=&#34;_blank&#34;&gt;mixing c and cpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&#34; target=&#34;_blank&#34;&gt;What is the effect of extern “C” in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>表驱动测试</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/table_driven_tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/table_driven_tests/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95%e7%9a%84%e4%be%8b%e5%ad%90&#34;&gt;表驱动测试的例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34; target=&#34;_blank&#34;&gt;Go 维基官网——表驱动测试&lt;/a&gt;学习。&lt;/p&gt;

&lt;p&gt;原网页由 Martin Tournoij 在 2018/4/11 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests/_history&#34; target=&#34;_blank&#34;&gt;第 3 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;编写好的测试不是烦琐的，在很多情况下大量领域可以使用表驱动测试覆盖：每个表条目是一个包含输入和预期结果的测试用例，而且有时候包含一些额外的信息，比如测试名称，使得测试输出易于阅读。如果你曾经发现自己在编写测试时使用拷贝和粘贴，考虑是否重构为表驱动测试，或者把拷贝的代码放在一个辅助函数可能是一个更好的选择。&lt;/p&gt;

&lt;p&gt;给定一个测试用例表，真正的测试简单地迭代遍历所有表条目，且未每个条目执行必要的测试。测试代码只编写一次且被分摊到所有的表条目，因此精心编写一个带有好的错误消息的测试是有意义的。&lt;/p&gt;

&lt;h2 id=&#34;表驱动测试的例子&#34;&gt;表驱动测试的例子&lt;/h2&gt;

&lt;p&gt;这里是一个来自 &lt;a href=&#34;http://golang.org/pkg/fmt/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;fmt&lt;/code&gt; 包&lt;/a&gt;测试代码的好例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var flagtests = []struct {
  in  string
  out string
}{
  {&amp;quot;%a&amp;quot;, &amp;quot;[%a]&amp;quot;},
  {&amp;quot;%-a&amp;quot;, &amp;quot;[%-a]&amp;quot;},
  {&amp;quot;%+a&amp;quot;, &amp;quot;[%+a]&amp;quot;},
  {&amp;quot;%#a&amp;quot;, &amp;quot;[%#a]&amp;quot;},
  {&amp;quot;% a&amp;quot;, &amp;quot;[% a]&amp;quot;},
  {&amp;quot;%0a&amp;quot;, &amp;quot;[%0a]&amp;quot;},
  {&amp;quot;%1.2a&amp;quot;, &amp;quot;[%1.2a]&amp;quot;},
  {&amp;quot;%-1.2a&amp;quot;, &amp;quot;[%-1.2a]&amp;quot;},
  {&amp;quot;%+1.2a&amp;quot;, &amp;quot;[%+1.2a]&amp;quot;},
  {&amp;quot;%-+1.2a&amp;quot;, &amp;quot;[%+-1.2a]&amp;quot;},
  {&amp;quot;%-+1.2abc&amp;quot;, &amp;quot;[%+-1.2a]bc&amp;quot;},
  {&amp;quot;%-1.2abc&amp;quot;, &amp;quot;[%-1.2a]bc&amp;quot;},
}
func TestFlagParser(t *testing.T) {
  var flagprinter flagPrinter
  for _, tt := range flagtests {
    t.Run(tt.in, func(t *testing.T) {
      s := Sprintf(tt.in, &amp;amp;flagprinter)
      if s != tt.out {
        t.Errorf(&amp;quot;got %q, want %q&amp;quot;, s, tt.out)
      }
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意使用 &lt;code&gt;t.Errorf&lt;/code&gt; 提供的详细的错误消息：提供了函数结果和预期结果；输入是子测试的名字。当测试失败时，哪个错误失败以及为什么失败是显然的，甚至不用阅读测试代码。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;t.Errorf&lt;/code&gt; 调用不是一个断言。即使打印一个错误日志，测试仍会继续。比如，当使用整数输入测试一些代码时，知道函数对所有输入失败，还是只对奇数失败，或者是对 2 的幂失败是有意义的。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;golangdoc/code.md#测试&#34; target=&#34;_blank&#34;&gt;如何编写 Go 代码——测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;golangdoc/faq.md#为什么-Go-没有断言&#34; target=&#34;_blank&#34;&gt;常见问题解答——断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;golangdoc/faq.md#我最喜欢的测试辅助函数在哪里&#34; target=&#34;_blank&#34;&gt;常见问题解答——测试框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;golangpkg/testing.md&#34; target=&#34;_blank&#34;&gt;testing 包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>设置 GOPATH</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/set_gopath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/set_gopath/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#unix-%e7%b3%bb%e7%bb%9f&#34;&gt;Unix 系统&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-113&#34;&gt;Go 1.13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bash&#34;&gt;Bash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#zsh&#34;&gt;Zsh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fish&#34;&gt;fish&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#windows&#34;&gt;Windows&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-113-%e5%91%bd%e4%bb%a4%e8%a1%8c&#34;&gt;Go 1.13 (命令行)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#windows-10-%e5%9b%be%e5%bd%a2%e7%94%a8%e6%88%b7%e7%95%8c%e9%9d%a2&#34;&gt;Windows 10 (图形用户界面)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#windows-10-%e5%91%bd%e4%bb%a4%e8%a1%8c&#34;&gt;Windows 10 (命令行)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考&lt;a href=&#34;https://github.com/golang/go/wiki/SettingGOPATH&#34; target=&#34;_blank&#34;&gt;设置 GOPATH 维基&lt;/a&gt;学习。&lt;/p&gt;

&lt;p&gt;原网页由 Bryan C. Mills 在 2019/9/27 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/SettingGOPATH/_history&#34; target=&#34;_blank&#34;&gt;第 55 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GOPATH&lt;/code&gt; 环境变量指定你的工作区的位置。如果没有设置 &lt;code&gt;GOPATH&lt;/code&gt;，则认为 Unix 系统上是 &lt;code&gt;$HOME/go&lt;/code&gt; 且 Windows 上是 &lt;code&gt;%USERPROFILE%\go&lt;/code&gt;。如果你想要使用自定义位置作为你的工作区，你可以设置 &lt;code&gt;GOPATH&lt;/code&gt; 环境变量。此页解释如何在不同的平台上设置这个变量。&lt;/p&gt;

&lt;h2 id=&#34;unix-系统&#34;&gt;Unix 系统&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;GOPATH&lt;/code&gt; 可以是你系统上的任一目录。在 Unix 系统上，我们将设置其为 &lt;code&gt;$HOME/go&lt;/code&gt; (从 Go 1.8 其的默认值)。注意 &lt;code&gt;GOPATH&lt;/code&gt; 一定不能和 Go 安装路径相同。另外一个常见的设置是设置 &lt;code&gt;GOPATH=$HOME&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;go-1-13&#34;&gt;Go 1.13&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go env -w GOPATH=$HOME/go&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;bash&#34;&gt;Bash&lt;/h3&gt;

&lt;p&gt;编辑 &lt;code&gt;~/.bash_profile&lt;/code&gt;，添加下面的行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GOPATH=$HOME/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并退出编辑器。然后使 &lt;code&gt;~/.bash_profile&lt;/code&gt; 修改生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh&#34;&gt;Zsh&lt;/h3&gt;

&lt;p&gt;编辑 &lt;code&gt;~/.zshrc&lt;/code&gt;，添加下面的行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GOPATH=$HOME/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并退出编辑器。然后使 &lt;code&gt;~/.zshrc&lt;/code&gt; 修改生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;source ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fish&#34;&gt;fish&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;set -x -U GOPATH $HOME/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-x&lt;/code&gt; 用于指定这个变量应被导出，且 &lt;code&gt;-U&lt;/code&gt; 使其成为一个全局变量，对所有会话可用且是持久的。&lt;/p&gt;

&lt;h2 id=&#34;windows&#34;&gt;Windows&lt;/h2&gt;

&lt;p&gt;你的工作区可位于任何你喜欢的地方，但是我们在这个例子中使用 &lt;code&gt;C:\go-work&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;GOPATH&lt;/code&gt; 一定不能和 Go 安装路径相同。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;C:\go-work&lt;/code&gt; 新建文件夹。&lt;/li&gt;
&lt;li&gt;右击“开始”，并点击“控制面板”。选择“系统和安全”，然后点击“系统”。&lt;/li&gt;
&lt;li&gt;从左边的菜单栏，选中“高级系统设置”。&lt;/li&gt;
&lt;li&gt;点击底部的“环境变量”按钮。&lt;/li&gt;
&lt;li&gt;从“用户变量”区域点击“新建”。&lt;/li&gt;
&lt;li&gt;在“变量名”输入 &lt;code&gt;GOPATH&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在“变量值”输入 &lt;code&gt;C:\go-work&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;点击“确定”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-1-13-命令行&#34;&gt;Go 1.13 (命令行)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;打开一个命令提示符(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;r&lt;/code&gt; 然后输入 &lt;code&gt;cmd&lt;/code&gt;) 或者 powershell 窗口(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;i&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;go env -w GOPATH=c:\go-work&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;windows-10-图形用户界面&#34;&gt;Windows 10 (图形用户界面)&lt;/h3&gt;

&lt;p&gt;有一个通过搜索编辑 &lt;code&gt;环境变量&lt;/code&gt; 的快速方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;左击“搜索”并输入 &lt;code&gt;env&lt;/code&gt; 或 &lt;code&gt;environment&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择&lt;code&gt;编辑账户的环境变量&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;和上述步骤相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;windows-10-命令行&#34;&gt;Windows 10 (命令行)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;打开一个命令提示符(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;r&lt;/code&gt; 然后输入 &lt;code&gt;cmd&lt;/code&gt;) 或者 powershell 窗口(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;i&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;setx GOPATH %USERPROFILE%\go&lt;/code&gt;。(这将会设置 &lt;code&gt;GOPATH&lt;/code&gt; 为你的 &lt;code&gt;[home folder]\go&lt;/code&gt;，比如 &lt;code&gt;C:\Users\yourusername\go&lt;/code&gt;。)&lt;/li&gt;
&lt;li&gt;关闭命令提示符或 powershell 窗口。(环境变量只对新的命令提示符或 powershell 窗口生效，当前窗口不生效。)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>远程导入路径</title>
      <link>https://xueqing.github.io/translation/go-doc/command/remote_import_path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/remote_import_path/</guid>
      <description>&lt;p&gt;一些导入路径也描述了如何使用版本控制系统获取包的源码。&lt;/p&gt;

&lt;p&gt;一些常见的代码托管网站有一些特殊的语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Bitbucket (Git, Mercurial)

  import &amp;quot;bitbucket.org/user/project&amp;quot;
  import &amp;quot;bitbucket.org/user/project/sub/directory&amp;quot;

GitHub (Git)

  import &amp;quot;github.com/user/project&amp;quot;
  import &amp;quot;github.com/user/project/sub/directory&amp;quot;

Launchpad (Bazaar)

  import &amp;quot;launchpad.net/project&amp;quot;
  import &amp;quot;launchpad.net/project/series&amp;quot;
  import &amp;quot;launchpad.net/project/series/sub/directory&amp;quot;

  import &amp;quot;launchpad.net/~user/project/branch&amp;quot;
  import &amp;quot;launchpad.net/~user/project/branch/sub/directory&amp;quot;

IBM DevOps Services (Git)

  import &amp;quot;hub.jazz.net/git/user/project&amp;quot;
  import &amp;quot;hub.jazz.net/git/user/project/sub/directory&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于托管在其他服务商的代码，导入路径或者具备版本控制类型，或者 go 工具可以通过 https/http 动态拉取导入路径，然后从 HTML 的 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 标签代码位置。&lt;/p&gt;

&lt;p&gt;为了声明代码位置，具有形式 &lt;code&gt;repository.vcs/path&lt;/code&gt; 的导入路径指定了给定的仓库(使用或不使用 .vcs 后缀，使用命名的版本控制系统)和该仓库内的路径。支持的版本控制系统是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Bazaar      .bzr
Fossil      .fossil
Git         .git
Mercurial   .hg
Subversion  .svn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如，&lt;code&gt;import &amp;quot;example.org/user/foo.hg&amp;quot;&lt;/code&gt; 表示根目录在 Mercurial 仓库的 example.org/user/foo 或 foo.hg，且 &lt;code&gt;import &amp;quot;example.org/repo.git/foo/bar&amp;quot;&lt;/code&gt; 表示 Git 仓库的 foo/bar 目录在 example.org/repo 或 repo.git。&lt;/p&gt;

&lt;p&gt;当一个版本控制系统支持多个协议时，下载时轮流尝试每个协议。比如，一个 Git 下载尝试 &lt;code&gt;https://&lt;/code&gt;，然后是 &lt;code&gt;git+ssh://&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;默认的，下载受限于已知的安全协议(比如，https 和 ssh)。要覆盖 Git 下载的这个设置，可以设置 GIT_ALLOW_PROTOCOL 环境变量(查看 &lt;code&gt;go help environment&lt;/code&gt; 获取更多信息)。&lt;/p&gt;

&lt;p&gt;如果导入路径不是已知的代码托管网站，且缺少版本控制限定符，go 工具尝试通过 https/http 查找 HTML  &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 标签来拉取导入。&lt;/p&gt;

&lt;p&gt;meta 标签有这样的形式 &lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;import-prefix vcs repo-root&amp;quot;&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;import-prefix 是对应 repo-root 的导入路径。它必须是一个前缀，或者是借助 &lt;code&gt;go get&lt;/code&gt; 拉取包的一个精确匹配。如果不是一个精确匹配，生成另外一个 http 请求来验证 meta 标签。&lt;/p&gt;

&lt;p&gt;meta 标签应该尽早出现在文件中。特别地，它应该出现在任何原始的 JavaScript 或 CSS 之前，避免使 go 命令受限的解释器不能理解。&lt;/p&gt;

&lt;p&gt;vcs 是 bzr/fossil/git/hg/svn 中的一个。&lt;/p&gt;

&lt;p&gt;repo-root 是版本控制系统的根，包含了一个体系，但是不包含 .vcs 限定符。&lt;/p&gt;

&lt;p&gt;比如，&lt;code&gt;import &amp;quot;example.org/pkg/foo&amp;quot;&lt;/code&gt; 会导致下面的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;https://example.org/pkg/foo?go-get=1 (preferred)
http://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果页面包含 meta 标签 &lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;example.org git https://code.org/r/p/exproj&amp;quot;&amp;gt;&lt;/code&gt;，那么 go 工具会验证 &lt;code&gt;https://example.org/pkg/foo?go-get=1&lt;/code&gt; 包含相同的 meta 标签，然后使用 &lt;code&gt;git clone https://code.org/r/p/exproj&lt;/code&gt; 克隆源码到 &lt;code&gt;GOPATH/src/example.org&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当使用 GOPATH 时，下载的包被写到 GOPATH 环境变量列举的第一个目录。(查看 &lt;code&gt;go help gopath-get&lt;/code&gt; 和 &lt;code&gt;go help gopath&lt;/code&gt;。)&lt;/p&gt;

&lt;p&gt;当使用模块时，下载的包存储在模块缓存。(查看 &lt;code&gt;go help module-get&lt;/code&gt; 和 &lt;code&gt;go help goproxy&lt;/code&gt;。)&lt;/p&gt;

&lt;p&gt;当使用模块时，go-import meta 标签的额外的变量被识别且更倾向于通过这些列举的版本控制系统。比如，在 &lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;example.org mod https://code.org/moduleproxy&amp;quot;&amp;gt;&lt;/code&gt; 中，该变量使用 “mod” 作为 vcs 内容的值。&lt;/p&gt;

&lt;p&gt;这个标签意味着使用以 example.org 开始的路径从 &lt;code&gt;https://code.org/moduleproxy&lt;/code&gt; 可用的模块代理拉取模块。查看 &lt;code&gt;go help goproxy&lt;/code&gt; 获取更多关于代理的信息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>重写分支</title>
      <link>https://xueqing.github.io/blog/git/git_filter_branch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_filter_branch/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#git-filter-branch&#34;&gt;git filter-branch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-filter-branch&#34;&gt;git filter-branch&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 从所有提交中删除文件 filename
# 当提交中不包含此文件时，`rm filename`会失败提交，可使用`rm -f filename`
git filter-branch --tree-filter &#39;rm filename&#39; HEAD
# 比 --tree-filter 更快
git filter-branch --index-filter &#39;git rm --cached --ignore-unmatch filename&#39; HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://git-scm.com/docs/git-filter-branch&#34; target=&#34;_blank&#34;&gt;git filter-branch doc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>重设状态</title>
      <link>https://xueqing.github.io/blog/git/git_reset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/git/git_reset/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;将当前分支的 HEAD 重设到指定的状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git reset [&amp;lt;mode&amp;gt;] [-q] [&amp;lt;commit&amp;gt;]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;mode 包括&lt;code&gt;--soft | --mixed [N] | --hard | --merge | --keep&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置当前分支的 HEAD 到 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;mixed 是默认模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;reset&lt;/code&gt; 之前，git 会保存原本的 &lt;code&gt;HEAD&lt;/code&gt; 到 &lt;code&gt;ORIG_HEAD&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;git reset &amp;lt;commit&amp;gt;&lt;/code&gt; 之后可通过 &lt;code&gt;git reset ORIG_HEAD&lt;/code&gt; 回到原来的地方&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 重设暂存区和工作区, 丢弃所有改变, 把 HEAD 指向 commit
git reset --hard
# 暂存区和工作区内容不做任何改变, 仅把 HEAD 指向 commit, 可用于删除提交历史记录, 只生成一次提交
git reset --soft
# 仅重设暂存区, 不改变工作区
git reset --mixed
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;git-reset-soft-合并提交&#34;&gt;git reset &amp;ndash;soft 合并提交&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 合并最近 3 次提交
git reset --soft HEAD~3
# 使用这 3 次提交的信息
git commit --edit -m&amp;quot;$(git log --format=%B --reverse HEAD..HEAD@{1})&amp;quot;
# 重新编写提交信息
git add . &amp;amp;&amp;amp; git commit -m &amp;quot;new commit message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>镜像仓库命令</title>
      <link>https://xueqing.github.io/blog/docker/image_rep_cmd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/docker/image_rep_cmd/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%99%bb%e5%bd%95%e9%80%80%e5%87%ba&#34;&gt;登录/退出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8b%89%e5%8f%96%e9%95%9c%e5%83%8f&#34;&gt;拉取镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8a%e4%bc%a0%e9%95%9c%e5%83%8f&#34;&gt;上传镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;登录-退出&#34;&gt;登录/退出&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 登陆到一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub
docker login [OPTIONS] [SERVER]
# 登出一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub
docker logout [OPTIONS] [SERVER]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-u: 登陆的用户名&lt;/li&gt;
&lt;li&gt;-p: 登陆的密码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;登陆到 Docker Hub。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker login -u username -p password
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登出 Docker Hub。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker logout
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;拉取镜像&#34;&gt;拉取镜像&lt;/h2&gt;

&lt;p&gt;从镜像仓库中拉取或者更新指定镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull [OPTIONS] NAME[:TAG|@DIGEST]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-a: 拉取所有 tagged 镜像&lt;/li&gt;
&lt;li&gt;&amp;ndash;disable-content-trust: 忽略镜像的校验,默认开启&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从 Docker Hub 下载 java 最新版镜像。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker pull -a java
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;上传镜像&#34;&gt;上传镜像&lt;/h2&gt;

&lt;p&gt;将本地的镜像上传到镜像仓库,要先登陆到镜像仓库。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker push [OPTIONS] NAME[:TAG]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;OPTIONS 说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ndash;disable-content-trust: 忽略镜像的校验,默认开启&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上传本地镜像 myapache:v1 到镜像仓库中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;docker push myapache:v1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
