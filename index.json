[{"authors":["admin"],"categories":null,"content":"hi，欢迎来到我的主页。\n一枚毕业于计算机专业的程序媛。喜欢阅读、电影、音乐和运动。\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"zh","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://xueqing.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"hi，欢迎来到我的主页。 一枚毕业于计算机专业的程序媛。喜欢阅读、电影、音乐和运动。","tags":null,"title":"kiki","type":"authors"},{"authors":["kiki"],"categories":["blog"],"content":"  1 概览 2 什么是 Memcached 3 什么是 Redis 4 Memcached 和 Redis 的相似点 5 Memcached 和 Redis 的不同 6 选择 Memcached 还是 Redis  6.1 选择 Memcached 6.2 选择 Redis 6.3 总结  7 参考  1 概览  关系型数据库是常见的数据库类型，但是不适合存储大量的数据。因此，引入了 NoSQL。它表示非关系型或非 SQL。Memcached 和 Redis 归类为 NoSQL Memcached 和 Redis 最大的区别在于  Memcached 是开源的，高性能，分布式内存缓存系统，可通过最小化数据加载代价而加速 web 应用 Redis 是开源的，key-value 存储，用于建设可扩展的 web 应用   2 什么是 Memcached  Memcached 是开源的，高性能，分布式内存缓存系统。它是持久化数据存储 Memcached 主要的优势在于它降低了数据库加载代价，因此对于大量数据库加载的网站是非常有效且快速的 Memcached 有存储命令、检索命令、统计命令  存储命令 set：为一个新的或已有的键设置新值 add：为一个新键设置值 replace：替换已有的键的值 append：为已有键增加一些数据 检索命令 get：获取键中保存的值 delete：删除已有键   3 什么是 Redis  Redis 是开源的，内存型数据结构存储，用作数据库、缓存和消息代理 Redis 代表远程字典服务器(remote dictionary server)。以 key-value 格式存储数据 用户在 Redis 命令行界面(command line interfacem, CLI)，使用命令和数据库通信  SET：写数据到 Redis 数据存储 GET：从 Redis 数据存储读数据  Redis 简单易用。它归类为 NoSQL 数据库。和像 MySQL，Oracle 的关系型数据库不同，Redis 不使用表存储数据  Redis 不使用常规的 SQL 命令，例如 select、delete、create、update 等 Redis 使用数据结构存储数据。主要的数据结构是 string，list，set，sorted set，hash，bitmap 等  Redis 使用 C 语言编写，是开源的，跨平台的系统 Redis 主要的优势在于它保存数据在内存中。这使得 Redis 非常快速。它也可以写数据到磁盘。Redis 可用作一个缓存系统或是全面的数据库 Redis 另外一个优势是它可以和其他数据库一起使用。Redis 可以存储频繁访问的数据，而不访问主要的数据库，并且可以从主要的数据库获取其它的数据 Redis 遵循 master-slave 架构。它提供性能、可扩展性且易用  4 Memcached 和 Redis 的相似点  都归类为 NoSQL 都以 key-value 格式存储数据：Redis 更准确的描述是作为数据结构存储 都将存储数据到内存(毫秒级延迟) 二者都是轻量级，和易失缓存一样快  Memcached 易失内存型的 key-value 存储 Redis 不限于此，是一个数据结构服务  易用性、支持多种编程语言(Java/Python/PHP/C/C++/C#/JavaScript/NodeJS/Ruby/Go) 支持数据分割：允许分布数据到多个节点，以便随着需求增长扩展数据处理能力  5 Memcached 和 Redis 的不同    不同点 Memcached Redis     描述 开源的，高性能，分布式内存缓存系统，可通过最小化数据加载代价而加速 web 应用 开源的，key-value 存储，可作为数据库、缓存和消息代理   易安装 N Y   高级数据结构 N(字符串和整型) Y(string/list/set/sorted set/hash)   多线程架构 Y(充分利用多核) N   快照 N Y(时间快照存储数据到磁盘，用于归档或恢复)   复制 N Y(支持 master-slave 复制)   事务 N Y   pub/sub N Y   Lua 脚本 N Y   地理空间支持 N Y(可查找两个元素之间的距离，或者查找给定范围的所有元素)   速度 读写速度更快 读写速度快，但是取决于开发的应用    6 选择 Memcached 还是 Redis 6.1 选择 Memcached  当缓存相当小的静态数据，比如 HTML 代码段：Memcached 内部的内存管理系统在最简单的应用场景下是更加高效，因为只占用相当小的内存资源用于元数据 当数据大小动态变化，Memcached 的内存管理效率快速下降，有时内存会碎片化  同时，大数据集经常牵涉到序列化数据，需要更多空间存储 如果使用Memcached，当重启时数据会丢失，而且重建缓存代价很好  Memcached 在伸缩性方面比 Redis 好： Memcached 是多线程，很方便增加计算资源；Redis 大多数是单线程，在不丢失数据的情况下只能通过集群水平增长  集群是有效的扩展方案，但是在设置和操作方面很复杂 Memcached 不支持复制  Memcached 在处理高流量网站方面更好：可以一次读大量信息，而且响应时间快。  6.2 选择 Redis  Redis 支持更多数据类型，所以作为缓存可以提供更更好的性能和效率 数据回收(data eviction)：缓存使用数据回收机制，从内存删除旧数据为新数据分配空间  Memcached 使用 LRU(least recently used, 最近最少使用)算法，有时随机回收大小类似的数据 Redis 支持细粒度控制回收，提供 6 种不同的回收策 Redis 支持 lazy 和 active 的回收，即需要更多空间或主动地(proactively) Memcached 值支持 lazy 回收  Redis 作为数据结构的一些特性  丰富的数据类型和使用命令 默认持久化到磁盘 锁事务(WATCH/MULTI/EXEC) 发布订阅(pub/sub)非常快 值可达 512MB(Memcached 限制每个键 1MB) 支持 Lua 脚本(2.6 开始) 内嵌集群(3.0 开始) 在各方面非常快  Redis 丰富的数据类型非常重要。它支持 Redis 提供共享队列(lists)，消息机制(pub/sub)，存储会话(hash)，高评分跟踪(sorted set)  6.3 总结  Memcached 和 Redis 归类为 NoSQL。它们不使用结构化化查询语言(structed query language)来存储、检索和操作数据 不同点在于 Memcached 是开源、高性能分布式内存缓存系统，Redis 是开源、key-value 存储用于构建可扩展 web 应用 使用 Memcached 还是 Redis 取决于应用：需要高级数据结构时可使用 Redis；降低数据库加载代价，加速 web 应用可使用 Memcached  7 参考  Difference Between Memcached and Redis Memcached vs Redis, Which One to Pick Choosing between Redis and Memcached  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e8296b26da0a1b08fb1a7d75911a3763","permalink":"https://xueqing.github.io/blog/database/redis_vs_memcached/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/redis_vs_memcached/","section":"blog","summary":"1 概览 2 什么是 Memcached 3 什么是 Redis 4 Memcached 和 Redis 的相似点 5 Memcached 和 Redis 的不同 6 选择 Memcached 还是 Redis 6.1 选择 Memcached 6.2 选择 Redis 6.3 总结 7 参考 1 概览 关系型数据库是常见的数据库类型，但是","tags":["database"],"title":"Redis vs Memcached","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  目录 参考  目录  1 Memcached 简介 2 Memcached 存储命令 3 Memcached 查找命令 4 Memcached 统计命令 5 Memcached 实例  参考  Memcached 教程 Redis 命令  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"aaa24d2340de2affef3f3d35b559b7d5","permalink":"https://xueqing.github.io/blog/database/memcached/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/memcached/readme/","section":"blog","summary":"目录 参考 目录 1 Memcached 简介 2 Memcached 存储命令 3 Memcached 查找命令 4 Memcached 统计命令 5 Memcached 实例 参考 Memcached 教程 Redis 命令","tags":["database"],"title":"前言","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  概念 目录 参考  概念  BSD 协议：可自由的使用，修改源代码，也可将修改后的代码作为开源或专有软件再发布 守护进程(Daemon Process)：Linux 的后台服务进程。生存期较长，通常独立于控制终端且周期性地执行某种任务或等待处理某些发生的事件。脱离终端是为了避免进程被任何终端产生的信息打断，其执行过程中的信息也不显示在任何终端  目录  1 Redis 简介 2 Redis 命令 3 Redis 进阶 4 Redis VM 技术  参考  Redis 教程 Redis 命令  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"072dd9e2bb5a63b0b5d6313ec90c991c","permalink":"https://xueqing.github.io/blog/database/redis/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/redis/readme/","section":"blog","summary":"概念 目录 参考 概念 BSD 协议：可自由的使用，修改源代码，也可将修改后的代码作为开源或专有软件再发布 守护进程(Daemon Process)：Linu","tags":["database"],"title":"前言","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"参考官网学习。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d476876840cf4d771b9f86398be205dd","permalink":"https://xueqing.github.io/blog/django_cms/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/django_cms/readme/","section":"blog","summary":"参考官网学习。","tags":["django"],"title":"前言","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  git 安装 git 配置 git 帮助 git 基础  git 仓库、工作目录、暂存区域、文件状态 初始化版本库 新建版本库 克隆版本库 版本库目录 .git blob 对象 tree 对象 commit 对象 常用 git 命令  git 服务器 参考网站 好玩的网站  git 安装  Linux\n# Fedora sudo yum install git # Debian sudo apt-get install git sudo apt-get install gitk git-gui # 源码安装,[下载地址](http://git-scm.com/download) sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext libz-dev libssl-dev export GIT_VER=2.0.0 wget https://www.kernel.org/pub/software/scm/git/git-$GIT_VER.tar.gz tar -zxf git-$GIT_VER.tar.gz pushd git-$GIT_VER make prefix=/usr/local all sudo make prefix=/usr/local install popd  Windows\n msysgit Git 图形化操作程序, TortoiseGit GitHub for Windows  Mac\n 安装 Xcode 后自动装上 Git 使用图形化的Git 安装工具Git OS X   git 配置  参考git_config  git 帮助  有三种命令可以找到 git 命令的使用手册  git help \u0026lt;verb\u0026gt; git \u0026lt;verb\u0026gt; --help man git-\u0026lt;verb\u0026gt; git help config # 查看 config 命令的手册   git 基础 git 仓库、工作目录、暂存区域、文件状态  git仓库：git 用来保存项目的元数据和对象数据库的地方 工作目录：对项目的某个版本独立提取出来的内容. 是从 git 仓库的压缩数据库中提取出来的文件, 放在磁盘上使用或修改 暂存区域(索引)：一个文件, 保存了下次将提交的文件列表信息, 一般在 Git 仓库目录中 基本的 Git 工作流程如下：  在工作目录中修改文件 暂存文件, 将文件的快照放入暂存区域 提交更新, 找到暂存区域的文件, 将快照永久性存储到 git 仓库目录  文件状态： 已提交状态(commited)：git 目录中保存着的特定版本文件 已暂存状态(staged)：作了修改并已放入暂存区域 工作目录下的每一个文件都属于已跟踪(tracked)或未跟踪(untracked),已跟踪的文件状态可处于未修改(unmodified)、已修改(modified)或已放入暂存区(staged)   初始化版本库 新建版本库 # 确定版本库目录 mkdir dirname pushd dirname # 生成 .git 目录以及其下的版本历史记录文件, push 时易出现冲突 git init # 创建一个裸仓库, 只保存git历史提交的版本信息, 不允许用户在上面进行各种 git 操作 git init --bare  克隆版本库  自动将其添加为远程仓库并默认以 “origin” 为简写 自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支\n# 1 使用 ssh 协议克隆 # 1.1 默认本地仓库名字和远程仓库相同 git clone git@github.com:tensorflow/tensorflow.git # 在当前目录下创建 tensorflow 目录, 并在这个目录下初始化一个 .git 文件夹, # 从远程仓库拉取下所有数据放入 .git 文件夹, 然后从中读取最新版本的文件的拷贝 # 1.2 自定义本地仓库的名字克隆 git clone git@github.com:tensorflow/tensorflow.git MyTensorflow # 2 使用 HTTPS 协议克隆 git clone https://github.com/tensorflow/tensorflow.git   版本库目录 .git    文件(夹)名 描述     HEAD 指向最新提交   config 项目的配置信息, git config 命令会改动它   description 项目的描述信息   hooks 系统默认钩子脚本目录   index 索引文件，记录统计版本库的每个文件，如大小、创建时间和最后修改时间，对比当前统计信息和索引确定文件是否被修改   logs 各个 refs 的历史信息   objects git 本地仓库的所有对象(commits, trees, blobs, tags)   refs 标识项目里的每个分支指向了哪个提交(commit)    blob 对象  git 基于“内容寻址”：文件不是按照文件名存储，而是按照包含内容的哈希值，存在一个叫“blob 对象”的文件中 可以把文件内容的哈希值看做一个唯一 ID blob 对象存储文件内容，与文件名无关  tree 对象  tree 对象：一组包含文件类型、文件名和哈希值的数据 tree 对象存储文件名  commit 对象  commit 对象存储提交信息及其创建的日期和时间 commit 对象是原子性的，即一个提交不会部分地记录变更  常用 git 命令  添加文件参考git_add 防止文件误添加  修改 .gitignore 修改 .git/info/exclude 格式规范参考git_ignore  提交更新参考git_commit 跟踪状态参考git_status 提交日志参考git_log 移除文件参考git_rm 移动文件参考git_mv 远程仓库参考git_remote 推送数据参考git_push 标签参考git_tag 分支参考git_branch 变基参考git_rebase 版本比较参考git_diff 撤消操作  git commit --amend # 尝试重新提交 git reset HEAD f1 # 取消暂存文件 f1 git checkout -- f1 # 撤消之前对文件 f1 所做的修改 参考git_reset   git 服务器  协议  本地协议: 远程版本库就是硬盘内的另一个目录. 常见于团队每一个成员都对一个共享的文件系统(例如一个挂载的 NFS)拥有访问权, 或者比较少见的多人共用同一台电脑的情况 git clone /opt/git/project.git # Git 会尝试使用硬链接（hard link）或直接复制所需要的文件 git clone file:///opt/git/project.git   参考网站  Git Magic git-scm  好玩的网站  github blog  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"32d636117ee774d0a491e011e6a22874","permalink":"https://xueqing.github.io/blog/git/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/readme/","section":"blog","summary":"git 安装 git 配置 git 帮助 git 基础 git 仓库、工作目录、暂存区域、文件状态 初始化版本库 新建版本库 克隆版本库 版本库目录 .git blob 对象 tree 对象 commit 对象 常用 git 命令 git 服务器","tags":["git"],"title":"前言","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 安装 结构 基础语法 数据类型 变量 常量 运算符 条件语句 循环语句 函数 变量作用域 数组 指针 结构 切片 范围 散列表 递归函数 类型转换 方法 接口 错误处理 补充笔记  异常处理 包 结构体 goroutine 通道 WaitGroup 和 worker pool 锁 模块   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5cb186cdb38e3e0d882f8fc1b1ec29cd","permalink":"https://xueqing.github.io/blog/go/basic/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/readme/","section":"blog","summary":"安装 结构 基础语法 数据类型 变量 常量 运算符 条件语句 循环语句 函数 变量作用域 数组 指针 结构 切片 范围 散列表 递归函数 类型转换 方法 接口 错误处理 补充笔记 异常处","tags":["go"],"title":"前言","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" Go 基础学习 Go 开发遇到的坑  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a3f9d526c43b044f5cb6b10bfefc4d17","permalink":"https://xueqing.github.io/blog/go/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/readme/","section":"blog","summary":"Go 基础学习 Go 开发遇到的坑","tags":["go"],"title":"前言","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"记录 go 开发遇到的坑\n 不使用短变量声明 := json 解析成结构体 module 不要在 vscode 工作区打开工程 同一包不同源文件变量声明时不要带包名\n 有时候新定义的变量或者函数不能跳转，需要重启 vscode，相关插件长时间运行可能崩溃\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3784c01eec751c38ca6878b6dc149950","permalink":"https://xueqing.github.io/blog/go/traps/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/traps/readme/","section":"blog","summary":"记录 go 开发遇到的坑 不使用短变量声明 := json 解析成结构体 module 不要在 vscode 工作区打开工程 同一包不同源文件变量声明时不要带包名 有时候新定义的变量或者函数不能","tags":["go"],"title":"前言","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  敏捷：一种用于增量创建软件的软件开发方法，使用 1-4 周的短期迭代以保证开发和一直改变的业务需求一致\n 1 入门\n 1.1 敏捷中的角色 1.2 跨职能团队 1.3 敏捷团队如何计划工作 1.4 用户故事 user story 1.5 故事何时完成  2 宣言\n 2.1 软件开发价值观 2.2 敏捷宣言的 12 个原则  3 特点\n 3.1 迭代/增量和准备进化 3.2 面对面沟通 3.3 反馈回路  4 每日站会\n 4.1 每日站会的概念 4.2 每日站会的重要性 4.3 每日站会的参与人 4.4 物理分散的团队  5 完成标准\n 5.1 用户故事 5.2 迭代 5.3 发布  6 发布计划\n 6.1 参与者 6.2 计划的先决条件 6.3 需要的材料 6.4 计划数据 6.5 输出 6.6 日程  7 迭代计划\n 7.1 参与者 7.2 计划的先决条件 7.3 计划流程 7.4 速度计算 7.5 任务容量 7.6 计划步骤  8 产品需求列表\n 8.1 产品需求列表的重要性 8.2 产品需求列表的特点  9 有用的术语\n  有用的书  Scrum: a Breathtakingly Brief and Agile Introduction Learning Agile: Understanding Scrum, XP, Lean, and Kanban Agile Project Management For Dummies Agile Project Management QuickStart Guide: A Simplified Beginners Guide To Agile Project Management Agile!: The Half-Assed Guide To Creating Anything You Want From Scratch. No Experts Required! Understanding the Agile Manifesto: A Brief \u0026amp; Bold Guide to Agile  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"581d870636aadd8b46eb5ff9f6addeba","permalink":"https://xueqing.github.io/translation/agile/tutorial/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/readme/","section":"translation","summary":"敏捷：一种用于增量创建软件的软件开发方法，使用 1-4 周的短期迭代以保证开发和一直改变的业务需求一致 1 入门 1.1 敏捷中的角色 1.2 跨职能团队 1.3 敏捷团队如何","tags":["agile"],"title":"前言","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":" 参考 Go 命令官网 学习。\n用法 Go 是一个用于管理 Go 源码的工具。\n用法：go \u0026lt;command\u0026gt; [arguments]\n命令有:\n   命令 描述     bug 开启一个缺陷报告   build 编译包及其依赖   clean 删除目标文件和缓存文件   doc 查看包或者符号的文档   env 打印 Go 环境变量信息   fix 更新包以使用新的 API   fmt gofmt(reformat) 包的源文件   generate 通过处理源生成 Go 文件   get 为当前模块添加依赖并且安装依赖   install 编译和安装包及其依赖   list 列举包或模块   mod 模块维护   run 编译和运行 Go 程序   test 测试包   tool 运行指定的 go 工具   version 打印 Go 版本   vet 打印包中可能的错误    使用 go help \u0026lt;command\u0026gt; 查看命令的更多信息。\n其他的帮助话题：\n   帮助 描述     buildmode 编译模式   c 在 Go 和 C 直接调用   cache 编译和测试缓存   environment 环境变量   filetype 文件类型   go.mod go.mod 文件   gopath GOPATH 环境变量   gopath-get 传统 GOPATH 的 go get   goproxy 模块 proxy 协议   importpath 模块路径语法   modules 模块，模块版本等   module-get 明白模块的 go get   module-auth 使用 go.sum 的模块认证   module-private 对于非公共模块的模块配置   packages 包列表和模式   testflag 测试标识   testfunc 测试函数    使用 go help \u0026lt;topic\u0026gt; 查看话题的更多信息。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"feac5dbbc6dcdb9768f0c6bf3e0d3ed8","permalink":"https://xueqing.github.io/translation/go-doc/command/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/readme/","section":"translation","summary":"参考 Go 命令官网 学习。 用法 Go 是一个用于管理 Go 源码的工具。 用法：go \u0026lt;command\u0026gt; [arguments] 命令有: 命令 描述 bug 开启一个缺陷报告 build 编译包及其依赖 clean 删除目标文件和缓存文","tags":["go-command"],"title":"前言","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  安装 Go 学习 Go 参考 文章 非英文文章  参考 Golang 官网文档 学习。\n安装 Go 学习 Go 参考 文章 代码漫步：Go 程序的指导之旅。 Go 的一级函数 生成任意文本：一个 Markov 链算法 通过共享内存 编写 Web 应用——构建一个简单的 web 应用。  工具 关于 Go 命令——为什么我们编写它？它是什么？它不是什么？如何使用它？ 使用 GDB 调试 Go 代码 数据竞争检测器——关于数据竞争检测器的手册 快速入门 Go 的汇编器——介绍了 Go 使用的汇编器  更多 查看维基的文章页面获取更多 Go 的文章   非英文文章 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9eb740e1016fe4df123b01d9fe361c80","permalink":"https://xueqing.github.io/translation/go-doc/golangdoc/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangdoc/readme/","section":"translation","summary":"安装 Go 学习 Go 参考 文章 非英文文章 参考 Golang 官网文档 学习。 安装 Go 学习 Go 参考 文章 代码漫步：Go 程序的指导之旅。 Go 的一级函数 生成任意文本：一个 Markov 链算法 通","tags":["golang-doc"],"title":"前言","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  标准库 其他包  子仓库 社区   参考 Golang 官网文档 学习。\n标准库    名字 概述     testing 支持对 Go 包的自动测试   ——iotest 实现了主要用于 testing 的 Reader 和 Writer   ——quick 实现了帮助黑盒测试的工具函数    其他包 子仓库 社区 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fb9ede3d85eb0a102bc87f6142d9de24","permalink":"https://xueqing.github.io/translation/go-doc/golangpkg/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangpkg/readme/","section":"translation","summary":"标准库 其他包 子仓库 社区 参考 Golang 官网文档 学习。 标准库 名字 概述 testing 支持对 Go 包的自动测试 ——iotest 实现了主要用于 testing 的 Reader 和 Writer ——quick 实现了帮","tags":["golang-pkg"],"title":"前言","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"关于 Go 语言之旅 的练习题\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fd33b8efbf7c5f1502956c6d192e2fe3","permalink":"https://xueqing.github.io/translation/go-doc/gotour/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/readme/","section":"translation","summary":"关于 Go 语言之旅 的练习题","tags":["go-tour"],"title":"前言","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  Go 之家 贡献 内容列表  Go 入门 用 Go 工作 更多关于 Go 的学习 Go 社区 使用 go 工具链 其他的 Go 编程维基 网上用 Go 的服务 生产环境的 Go 程序疑难解答 为 Go 项目做贡献 平台特定的信息 发布特定的信息 问题   参考 Go 维基官网 学习。\n原网页由 HunterQ 在 2019/4/12 编辑。第 99 次修订。\nGo 之家 欢迎来到 Go 维基，集中了关于 Go 编程语言的信息。Awesome Go 是另外一个给 Go 编程人员的丰富的资源，由 Go 社区管理。\n贡献  这个维基可被拥有 Github 账号的 Go 社区的任意成员编辑。 如果你想要新增一个页面，请首先在 Go issue 跟踪页面 打开一个 issue，以前缀 “wiki” 开头来提议新增的内容。清楚地说明为什么这个内容不适用任何现有的页面。 因为维基页面的重命名会破坏外部链接，请在重命名或删除任何维基页面之前打开一个 issue。  内容列表 Go 入门 Go 语言之旅是入门最好的地方。 实效 Go 编程将会帮助学习如何编写惯用的 Go 代码。 Go 标准库文档使你熟悉标准库。 使用 Go Playground 用于在你的浏览器测试 Go 程序。 仍然不确信？查看这份 Go 使用者清单以及他们的一些成功案例。我们也收集了一份长长的原因清单，关于你为什么应该尝试 Go。 了解更多已经从其他语言转到 Go 的公司。 这里是一些帮助你入门的链接。  用 Go 工作 准备好自己写一些 Go 代码了吗？这里是一些帮助你入门的链接。\n安装和设置你的环境 由此开始：官方安装文档 如果你更喜欢源码安装，先阅读此文档 从源码安装——其他关于源码安装的建议 Windows 用户？为 Windows 安装和配置 Go、Git和 Atom Mac 用户？如何开始-Go——安装 Go 和编译你的以第一个 web 服务的分步指南 安装遇到问题？安装疑难解答 确保你已经正确设置了 $GOPATH 环境变量 如果需要其他关于使用 $GOPATH 的建议，浏览这里 多个 GOROOT——更多高级信息关于在安装多个 go 以及 $GOROOT 变量的环境工作  Go 集成开发环境和编辑器——一些关于如何使用你最喜欢的编辑器开发 Go 的信息 为开发 Go 代码的工具——格式化、语言分析、代码检查、代码重构、代码导航和可视化 查找 Go 库和包 由此开始：Go 开源工程 查找 Go 包：go 文档官网 Go 开源包图的可视化  管理你的依赖——一个你可以用来管理第三方包 (vendoring) 的工具纵览 发布开源的 Go 包 准备好发布你的包了？由此开始 Go 检查清单——发布一个项目的完全指南 如何设计你的 Github 仓库 以便其他 Go 编程人员更容易使用 go get 命令 Go 包——一些使得 Go 包更易用的建议   更多关于 Go 的学习 当你对这门语言有一个概览之后，这里有一些资源供你使用学习更多关于 Go：\n学习 Go—— Go 入门到高级的资料集合 Go 新手开发人员的最佳实践——来自 Go 社区成员的见解 服务器编程——构建 web、移动端和 API 服务器 并发 错误处理 测试 移动端——安卓和 iOS  书籍——一份已经出版的(电子书，论文)关于 Go 的的书籍清单 博客——关于 Go 的博客 [播客]——描写 Go 特色的播客和故事  视频、谈话和演示 GopherVids 是一个关于 Go 的视频的搜索目录 GoTalks——来自 Go 会议和聚会的谈话集合 Screencasts  文章——帮助你学习 Go 的文章集合 培训——免费的、商业的、在线的 Go 课堂培训 大学课程——一个使用 Go 的 CS 编程和课程列表 非英语人士的资源  Go 社区 有一些地方，你可以找到在线的 Gophers。要了解成为 Go 社区一名成员意味着什么，阅读 Damian Gryski 在 2015 年 GolankUK 会议上的主题演讲或者观看 Andrew Gerrand 在 2015 年 GopherCon 上的闭幕演讲。\n Gophers 在线聚会场所：  Go 论坛——Go 社区的万能讨论论坛 Gophers Slack Channel——针对实时聊天(要求成员) Golang 新闻——关于 Go 编程的链接 r/golang——sub-reddit 在 Twitter 上，follow @golang 账户，并且   使用 go 工具链 其他的 Go 编程维基 网上用 Go 的服务 生产环境的 Go 程序疑难解答 为 Go 项目做贡献 平台特定的信息 发布特定的信息 问题 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5653abcd37e2517d287a5b345e1ea437","permalink":"https://xueqing.github.io/translation/go-doc/wiki/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/wiki/readme/","section":"translation","summary":"Go 之家 贡献 内容列表 Go 入门 用 Go 工作 更多关于 Go 的学习 Go 社区 使用 go 工具链 其他的 Go 编程维基 网上用 Go 的服务 生产环境的 Go 程序疑难解答 为 Go 项目做贡献 平台特","tags":["go-doc-wiki"],"title":"前言","type":"translation"},{"authors":["kiki"],"categories":["reading"],"content":" 文艺  高山上的小邮局 步履不停 我不【大冰】 好吗，好的 乖，摸摸头 查令十字街 84 号 相约星期二 信【东野圭吾】 沉睡的人鱼之家 远大前程 山茶文具店 闪闪发光的人生 樱风堂书店  人生  步履不停 莫斯科绅士 我们仨 给青年的十二封信 兔子屋的秘密  经典  穆斯林的葬礼 四世同堂 京华烟云 我与地坛  英文  怦然心动 杀死一只知更鸟 荆棘鸟 了不起的盖茨比 追风筝的人 无声告白  独立  一间自己的房间 醒来的女性 我的孤单，我的自我 依恋：为什么我们爱的如此卑微 一个人的好天气 一个人住的每一天 清单人生 爱的艺术  压抑  一九八四 挪威的森林 人间失格 边城 这些人，那些事 许三观卖血记 活着 平凡的世界 看见  漫画  你会不会喜欢我 十万次相亲 我可以咬一口吗 你今天真好看 这是你的星星，请签收 睡了吗？摘颗星星给你 回答不了 一见你就好心情 我很好啊你怎么样  诗歌  向着明亮那方  学习  刻意练习：如何从新手到大师 微习惯：简单到不可能失败的自我管理法则 怦然心动的人生整理魔法·实践解惑  鸡汤  我决定活的有趣 我喜欢人生快活的样子  艺术  谈美【朱光潜】   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"429d9581843d6bc4ff59aef6450ad14c","permalink":"https://xueqing.github.io/reading/%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B9%A6/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/reading/%E6%8E%A8%E8%8D%90%E7%9A%84%E4%B9%A6/","section":"reading","summary":"文艺 高山上的小邮局 步履不停 我不【大冰】 好吗，好的 乖，摸摸头 查令十字街 84 号 相约星期二 信【东野圭吾】 沉睡的人鱼之家 远大前程 山茶文具店 闪闪发光的人","tags":["booklist"],"title":"推荐的书[不定期更新]","type":"reading"},{"authors":["kiki"],"categories":["blog"],"content":" 目录  基本概念和入门 渠道侧处理 电商侧处理 账户和账务处理  参考  支付清结算之基本概念和入门 支付清结算之渠道侧处理 支付清结算之电商侧处理 支付清结算之账户和账务处理  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5a92480d2d0c7db0a22abbf006b507b3","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/readme/","section":"blog","summary":"目录 基本概念和入门 渠道侧处理 电商侧处理 账户和账务处理 参考 支付清结算之基本概念和入门 支付清结算之渠道侧处理 支付清结算之电商侧处理 支付清结算之账","tags":["o2o"],"title":"支付清结算","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  支付系统设计  目录 参考   目录  支付系统的账户模型 对账处理 银行卡支付 绑卡、签约和身份验证 应用内支付 支付产品服务设计 支付系统的整体架构  参考  支付系统设计：支付系统的账户模型（一） 支付系统设计：对账处理（二） 支付系统设计：银行卡支付（三） 支付系统设计：绑卡、签约和身份验证（四） 支付系统设计：应用内支付（五） 从产品分类、模块功能和业务流程，了解支付产品服务的设计 浅析支付系统的整体架构 其他  支付网关设计概述 支付网关的设计：核心模块的功能需求、软件架构设计以及注意要点 支付手续费设计思路   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ef527d03e6f0ac773a6093295b036595","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/readme/","section":"blog","summary":"支付系统设计 目录 参考 目录 支付系统的账户模型 对账处理 银行卡支付 绑卡、签约和身份验证 应用内支付 支付产品服务设计 支付系统的整体架构 参考 支付系统设计","tags":["o2o"],"title":"支付系统设计","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  硬件历史变化 多道程序（Multiprogramming）设计 内存 线程（Thread）\n 线程调度（Thread Schedule） Linux 多线程 线程安全 线程模型  计算机硬件三个关键部件：中央处理器 CPU，内存和 I/O 控制芯片\n  硬件历史变化  早期的计算机硬件：每个设备的 I/O 控制器和 CPU 以及内存连同一总线 CPU 核心频率提升，产生了与内存频率一致的系统总线 为了些协调 CPU、内存和高速的图形设备，设计高速的北桥芯片，以便其高速地交换数据 设计南桥芯片，专门处理低速设备（磁盘、USB、键盘、鼠标等），由南桥汇总连到北桥  系统总线用 PCI 结构，低速设备用 ISA 总线  CPU 频率到达 4GHz 的极限，通过增加 CPU 的数量来增加 CPU 的速度  对称多处理器（SMP，Symmetrical Multi-Processing），每个 CPU 在系统中所处的地位和发挥的功能一样，是相互对称的 应用场合是商用的服务器和需要处理大量计算的环境 多核处理器（Multi-core Processor），多个处理器“被打包”，共享比较昂贵的缓存部件  系统软件：管理计算机本身的软件  平台性的：操作系统内核/驱动程序/运行库和其他系统工具 用于程序开发的：编译器/汇编器/链接器等开发工具和开发库  计算机软件体系结构：硬件——硬件规格——操作系统内核——系统调用接口——运行时库——操作系统 API——应用软件  硬件规格（Hardware Specification），由硬件生产厂商负责提供 系统调用接口（System Call API），往往以软件中断（Software Interrupt）的方式提供 操作系统应用程序编程接口（API，Application Programming Interface）   多道程序（Multiprogramming）设计  充分利用 CPU 资源 当某个程序暂时不适用 CPU 时，监控程序把正在等待 CPU 资源的程序启动 缺点：调度时不能满足需要即时响应的需求 分时系统（Time-Sharing System）：每个程序运行一段时间以后都主动让出 CPU 给其他程序  缺点：当某个程序进入死循环，整个系统无法响应交互式需求  多任务系统（Multi-tasking System）：操作系统管理所有硬件资源，所有应用程序以进程的方式运行在比操作系统权限更低的级别  每个进程拥有独立的地址空间，进程之间的地址空间互相隔离 操作系统统一分配 CPU，根据每个进程的优先级分配 进程运行时间超出一定阈值，操作系统会暂停该进程，将 CPU 资源分配给其他等待运行的进程，即抢占式（Preemptive），操作系统可以强制剥夺 CPU 资源并且分配给它认为目前最需要的进程 硬件驱动（Device Driver）程序：和操作系统内核一起运行在特权级，但与操作系统内核直接有一定的独立性。将硬件抽象成一系列概念，提供统一的硬件访问模式。 驱动程序的开发工作通常由硬件生产厂商完成。 操作系统开发者提供一系列接口和框架，硬件生产厂商安装该接口和框架开发的驱动程序都可以在操作系统上使用。   内存  早期计算机的程序运行在物理内存，即使用物理地址空间（Physical Address Space）  问题：地址空间不隔离；内存使用效率低；程序运行的地址不确定  虚拟地址空间（Virtual Address Space）：每个进程都挺自己独立的虚拟空间，且只能访问自己的虚拟地址空间  分段（Segmentation）：分段对内存区域的映射仍以程序为单位，内存不足时内存的切换以程序为单位，会影响速度 分页（Paging）：把地址空间等分成固定大小的页，每页大小由硬件决定，或硬件支持多种大小的页，由操作系统选择决定页的大小。 虚拟页（VP，Virtual Page） 物理页（PP，Physical Page） 磁盘页（DP，Disk Page） 页错误（Page Fault），进程需要的虚拟页不在内存中 内存管理单元（MMU，Memory Management Unit）进行页映射，将虚拟地址映射到物理地址   线程（Thread）  程序执行流的最小单元，也被称为轻量级进程（LWP，Lightweight Process） 线程包含线程 ID，当前指令指针 PC，寄存器集合和堆栈 进程由一到多个线程组成，各个线程共享程序的内存空间（代码段、数据段、堆等）及一些进程级的资源（如打开文件和信号）  线程调度（Thread Schedule）  三种状态：  运行 Running：线程正在执行 就绪 Ready：线程可以执行，等待 CPU 调度 等待 Waiting：线程正在等待某一事件（I/O或同步），无法执行  时间片（Time Slice）  优先级调度（Priority Schedule）：线程有各自的优先级，优先级高的线程会更早地执行 IO 密集型线程（IO Bound Thread）比 CPU 密集型线程（CPU Bound Thread）更容易得到优先级的提升  IO 密集型：频繁等待 CPU 密集型：频繁进行大量计算  系统会提升等待过长时间而未被调度执行的线程的优先级，避免饿死（Starvation） 改变线程优先级的三种方式  用户指定优先级 根据进入等待状态的频繁程度提升或降低优先级 长时间得不到执行而被提升优先级  轮转法（Round Robin）：让各个线程轮流执行一小段时间  抢占（Preemption）  Linux 多线程  创建线程的三种方式：  fork 复制当前进程，子进程和父进程共享内存空间，执行相同代码，内存空间是写时复制（COW，Copy On Wright） exec 使用新的可执行映像覆盖当前可执行映像 clone 创建一个线程并从指定位置开始执行   线程安全  原子（Atomic）操作：单指令操作，不会被调度系统打断 同步（Synchronization）：一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问  锁（Lock）：线程在访问数据或资源之前先试图获得（Acquire）锁，访问结束之后释放（Release）锁 信号量（Semaphore）：一个初始值为 N 的信号量允许 N 个线程并发访问 二元信号量（Binary Semaphore）：只有占用和非占用两种状态，适合只能被一个线程独占访问的资源 访问资源过程：获取信号量；信号量值减 1；信号量值小于 0，则等待，否则继续执行 访问之后释放资源过程：获取信号量；信号量值加 1；信号量值小于 1，则唤醒一个等待线程 互斥量（Mutex）：只允许一个线程独占访问资源 信号量可以被任意线程获取并释放，即获取和释放线程可以不同 互斥量只能由获取的线程释放锁 临界区(Critical Section)：获取临界区的锁即进入临界区，释放锁则离开临界区 互斥量和信号量在系统的任何进程都是可见的 临界区的作用范围仅限于本进程，其他进程无法获取该锁 读写锁（Read-Write Lock）：允许多个线程读，一个线程写 共享的（Shared）：处于共享状态获取的锁，允许其他线程以共享方式获取，此时该锁被分配给多个线程 独占的（Exclusive）：处于独占状态获取的锁，其他线程不能获得该锁 条件变量（Condition Variable） 线程可以等待条件变量，一个条件变量允许多个线程等待 线程可以唤醒条件变量，此时某个或者所有等待此条件变量的线程都会被唤醒并继续执行  可重入（Reentrant）  函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行 多个线程同时执行该函数 函数自身调用自身 函数可重入：函数被重入之后不会产生任何不良后果 不使用（局部）静态或全局的非 const 变量 不使用（局部）静态或全局的非 const 变量的指针 仅依赖调用者提供的参数 不依赖单个资源的锁（mutex 等） 不调用不可重入的函数  过度优化：编译器会保存变量到寄存器，执行程序时可能会交换指令的顺序  volatile 关键字阻止过度优化 防止编译器为了提高速度将一个变量缓存到寄存器而不写回 防止编译器跳转操作 volatile 变量的指令顺序 barrier 指令：阻止 CPU 将该指令之前的指令交换到该指令之后   线程模型  一对一：一个用户线程对应一个内核线程  真正意义的线程并发 对内核线程的数量限制会限制用户线程的数量 内核线程上下文切换开销大，导致用户线程的执行效率下降  多对一：多个用户线程对应一个内核线程  高效的上下文切换 不限制用户线程数量 一个用户线程阻塞，所有线程无法执行  多对多：多个用户线程对应多个内核线程  一个用户线程阻塞不会阻塞所有用户线程 不限制用户线程数量   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d59c04791e7e393745014f12bc6a2338","permalink":"https://xueqing.github.io/blog/link_load_lib/1_%E7%AE%80%E4%BB%8B/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/link_load_lib/1_%E7%AE%80%E4%BB%8B/","section":"blog","summary":"硬件历史变化 多道程序（Multiprogramming）设计 内存 线程（Thread） 线程调度（Thread Schedule） Linux 多线程 线程安全","tags":["develop","link","lib"],"title":"第一章  温故而知新","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"书籍\n 一 软件工程导论  1 概述 2 软件过程 3 敏捷软件开发 4 需求工程 5 系统建模 6 体系结构设计 7 设计与实现 8 软件测试 9 软件进化  二 可依赖性和信息安全性 三 高级软件工程 四 软件管理  22 项目管理 23 项目规划 24 质量管理 25 配置管理   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ebb05415a3ad4c8a71854396a3b5379b","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/readme/","section":"blog","summary":"书籍 一 软件工程导论 1 概述 2 软件过程 3 敏捷软件开发 4 需求工程 5 系统建模 6 体系结构设计 7 设计与实现 8 软件测试 9 软件进化 二 可依赖性和信息安全性 三 高","tags":["sa","engineer"],"title":"软件工程第九版","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":" 原网站\n 软件架构：指软件系统较大的结构，处理的是多个软件进程合作执行任务 软件设计：指较小的结构，处理的是一个软件进程内部的设计  有用的书  Software Architecture in Practice (3rd Edition) (SEI Series in Software Engineering) Beyond Software Architecture: Creating and Sustaining Winning Solutions Software Systems Architecture: Working With Stakeholders Using Viewpoints and Perspectives (2nd Edition) Software Architecture: Foundations, Theory, and Practice Software Architecture in Practice (2nd Edition)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"26c8bd43cb540daaf7b60cbbef9d0380","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/readme/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/readme/","section":"translation","summary":"原网站 软件架构：指软件系统较大的结构，处理的是多个软件进程合作执行任务 软件设计：指较小的结构，处理的是一个软件进程内部的设计 有用的书 Software Architecture in Practice","tags":["sa"],"title":"软件架构和设计教程","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  1.1 软件架构 1.2 软件设计 1.3 架构目标 1.4 软件架构的角色 1.5 质量参数 1.6 质量情景  软件架构和设计有关的元素如下图 1.1 软件架构  软件架构描述了一个系统的蓝图 定义了一个结构化的解决方案来满足所有的技术和操作需求，同时优化一些常见的质量参数(比如性能、安全性) 包含一系列和软件开发组织有关的重要决策，而且每个决定对于最终产品的质量、可维护性、性能有重要的影响。决策包括  组成系统的结构化元素和元素接口的选取 上述元素之间合作的行为 将上述结构化、指定行为的元素组成一个大的子系统 和商业目标一致的架构决策 指导组织的架构风格   1.2 软件设计  软件设计提供了一个设计计划，此计划描述了一个系统的元素，以及元素之间如何组合并一起工作来满足系统的需求 设计计划的目标包括  商定系统需求，设置对客户、市场和管理人事的期望 作为开发过程中的一个蓝图 指导执行任务，包括详细设计、编码、集成、测试  软件设计在详细设计、编码、继承和测试之前，在领域分析、需求分析和风险分析之后   1.3 架构目标  架构目标  主要目标是识别影响应用结构的需求 降低和创建技术解决方案有关的商业风险，并且连接商业和技术需求 展示系统结构，但是隐藏实现细节 实现所有的用例(use-case)和情景 设法满足不同利益共享者的需求 简化所有者的目标，改善组织的市场定位 改善系统提供的质量和功能 改善外部对于组织或系统的信心  软件架构仍然是软件工程领域刚出现的准则。因此有一些限制  缺少工具和标准化的方式呈现架构 缺少分析方法来预测架构是否会落实实现需求 缺少对从架构设计到软件设计重要性的认知 缺少对软件架角色和利益共享者之间缺乏沟通的理解 缺少对设计流程、设计经验和设计评估的理解   1.4 软件架构的角色  软件架构提供了解决方案，技术团队可以用来创建和设计整个应用 相关的专业知识包括  设计：软件设计的知识、方法和途径；领导开发团队；审查和权衡设计建议 领域：帮助确认需求，确保完整性和一致性 技术：熟悉已有技术，整合选择编程语言、框架、平台和数据库等 方法论：在软件开发生命周期可采用的软件开发方法，选择合适的方法帮助整个团队 隐藏的角色：促进团队成员间的技术工作，强化团队的信任关系；分享知识，有很多经验的信息专家；保护团队免受外界干预和分心 交付的产品： 一个清楚、完整、一致且可达到的功能目标 对于系统的一个功能性描述，至少有两个层面的分解 对于该系统的一些概念 系统的设计层面，至少有两层分解 对于时间、操作人员属性、实现和操作计划的标注 一个文件或流程，用于确保功能性的分解，以及接口的形式   1.5 质量参数  质量参数可分为  静态质量参数：反映了系统和组织的结构，与架构、设计和源码直接相关 对终端用户不可见，但是影响了开发和维护成本 比如模块化性、可测试性、可维护性 动态质量参数：反映了系统执行期间的行为 与系统的架构、设计、源码、配置、部署参数、环境和平台直接相关 对于终端用户可见，且存在于运行时 比如吞吐率、健壮性、可伸缩性   1.6 质量情景 一个软件架构必须有的公共的质量参数\n 设计质量  概念完整性：定义整个设计的一致性和条理性，包括组件或模块的设计方式 可维护性：在一定程度上可修改 可复用性：组件或紫刺探对其他应用可用  运行时质量  互用性：一个或多个系统与外部系统通过通信和交换信息正确操作，外部系统由外部组成来写或运行 易管理性：系统管理员容易管理系统 可靠性：系统维持操作的时间 可伸缩性：可以不影响系统性能时解决负载增加的问题，或是易于扩大规模 安全性：可以阻止设计之外的恶意或者偶然的使用 性能：表明在给定的时间间隔，系统对于所有动作的反应 可用性：定义系统正常工作的时间比例  系统质量  可支持性：当工作不正确时，可以提供有用的信息便于定位和解决问题 可测试性：容易为系统和系统组件创建测试标准  用户质量  易用性：定义应用如何较好地满足用户和消费者的需求  架构质量  正确性：系统满足所有需求  非运行时质量  可移植性：使得系统可以在不同的电脑环境运行 完整性：使得单独开发的系统组件一起正常工作 易修改性：软件系统易修改  商业质量参数  花费和日程表：系统的花费，考虑市场时间、期望的工程时间、已有项目的利用 市场性：系统的使用，考虑到市场竞争   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"24e0b2a00599ff3ad96f658e36e52fba","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/1-introduction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/1-introduction/","section":"translation","summary":"1.1 软件架构 1.2 软件设计 1.3 架构目标 1.4 软件架构的角色 1.5 质量参数 1.6 质量情景 软件架构和设计有关的元素如下图 1.1 软件架构 软件架构描述了一个系统的蓝图 定义了","tags":["sa"],"title":"1 介绍","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  深入理解gcc hello.c的过程  预处理 Prepressing 编译 Compilation 汇编 Assembly 链接 Linking  编译器 编译过程  扫描，词法分析 语法分析 语义分析 源代码优化 代码生成 目标代码优化 链接器 静态链接   构建（Build）：集成开发环境（IDE，Integrated Development Environment）通常将编译和链接合并到一起\n深入理解gcc hello.c的过程 预处理 Prepressing  C++ 程序的源代码文件扩展名是.cpp或.cxx，头文件扩展名是.h或.hpp，预编译后文件扩展名是.ii 只执行预编译gcc -E hello.c -o hello.i 预编译主要处理源码中以#开头的预编译指令，比如#define，#include等，处理规则如下  删除#define，展开宏定义 处理条件预编译指令，比如#if，#ifdef#else#endif 处理#include预编译指令，将被包含的头文件插入到该预编译指令的位置，此过程是归队执行的 删除注释//和/**/ 添加行号和文件名标识，比如 #2 \u0026quot;hello.c\u0026quot; 2，便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时可以显示行号 保留#pragma编译器指令  经过预编译后的.i文件不包含任何宏定义，且包含的头文件被插入到.i文件。所以当无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题  编译 Compilation  编译是对预处理之后的文件进行词法分析、语法分析、语义分析及优化后产生响应的汇编代码文件 执行编译/usr/lib/gcc/x86_64-linux-gnu/4.8/ccl hello.i，查看分析流程  C++ 代码的预编译和编译程序shicclplus gcc -S hello.i -o hello.s gcc -S hello.c -o hello.s   汇编 Assembly  汇编器将汇编代码转变成机器可执行的指令，每一个汇编语句对应一条机器指令 执行汇编gcc -c hello.s -o hello.o，生成目标文件（Object File）  as -c hello.s -o hello.o gcc -c hello.c -o hello.o   链接 Linking  调用ld产生一个可以正常运行的程序  编译器  编译器将高级语言翻译成机器语言。  使用机器语言或汇编语言编写程序十分麻烦 使用机器语言或汇编语言编写程序依赖特定的机器 高级语言更加关注程序逻辑的本身，而尽量少的考虑计算机本身的限制，如字长、内存大小、通信方式、存储方式等 高级语言大大提高了程序开发效率 高级语言的可移植性   编译过程 Source Code \u0026gt;\u0026gt; Scanner \u0026gt;\u0026gt; Tokens \u0026gt;\u0026gt; Grammar Parser \u0026gt;\u0026gt; Syntax Tree \u0026gt;\u0026gt; Scemantic Analyzer \u0026gt;\u0026gt; Commented Syntax Tree \u0026gt;\u0026gt; Source Code Optimizer \u0026gt;\u0026gt; Intermediate Representation \u0026gt;\u0026gt; Code Generator \u0026gt;\u0026gt; Target Code \u0026gt;\u0026gt; Code Optimizer \u0026gt;\u0026gt; Final Target Code\n扫描，词法分析  扫描器（Scanner），进行词法分析，运用类似于有限状态机（Finite State Machine）的算法将源代码的字符序列分割成一系列的记号（Token）  记号一般分为：关键字、标识符、字面量（数字、字符串等）和特殊符号（加号、等号等） 扫描器同时将标识符放到符号表，将数字、字符串常量放到文字表 程序 lex 可以实现词法扫描，按照用户之前描述好的词法规则将输入的字符串分割成一个个记号，这样编译器的开发者只需要根据需要改变词法规则就可以解析不同的语言 对于有预处理的语言，比如 C 语言的宏替换和头文件包含等工作交给单独的预处理器处理   语法分析  语法分析器（Grammar Parser）：语法分析器对记号进行语法分析，生成语法树  采用上下文无关语法（Context-free Grammar）的分析手段 语法树是以表达式（Expression）为节点的树 符号和数字是最小的表达式，通常作为语法树的叶节点 语法树已经确定了运算符号的优先级和含义 出现了表达式不合法，如括号不匹配、表达式缺少操作符等，编译器会报告语法分析阶段的错误 程序 yacc（Yet Another Compiler Compiler）可以根据用户给定的语法规则对输入的记号序列进行解析，从而构造出语法树 编译器的开发者只需要高边语法规则就可以编写语法分析器，所以被称为编译器编译器（Compiler Compiler）   语义分析  语义分析（Semantic Analyzer）：判断语句是否真正有意义  编译器分析的语义是静态语义（Static Semantic），是在编译期可以确定的语义，动态语义（Dynamic Semantic）是在运行期才能确定的语义 静态语义通常包括声明和类型的匹配、类型的转换 动态语义是在运行期出现的语义相关的问题，比如 将 0 作为除数 经过语义分析，正哥语法树的表达式被标识了类型，如果有些类型需要做隐式转换，语义分析程序会在语法树种插入响应的转换节点   源代码优化  源代码优化器（Source Code Optimizer）：在源代码级别进行优化  源代码优化器往往将整个语法树转换成中间代码（Intermediate Code），是语法树的顺序表示。和目标机器和运行时环境无关 中间代码常见的形式：三地址码（Three-address Code）和 P-代码（P-Code） 中间代码使得编译器分为前端和后端：前端负责产生机器无关的中间代码，后端负责将中间代码转换成目标机器代码 对于可以跨平台的编译器，可以针对不同的平台使用同一个前端和针对不同机器平台的数个后端   代码生成  代码生成器（Code Generator），属于编译器后端，将中间代码转换成目标机器代码  此过程依赖于目标机器，不同的机器有不同的字长、寄存器、整数数据类型和浮点数数据类型等   目标代码优化  目标代码优化器（Code Optimizer），属于编译器后端，优化目标代码  比如选择合适的寻址方式、使用位移代替乘法运算、删除多余的指令等   链接器  现代的编译器将一个源代码文件编译成一个未链接的目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。 重定位（Relocation）：重新计算各个目标的地址过程 程序设计的模块化：将代码安装功能或性质划分，分别形成不同的功能模块，不同的模块之间按照层次结构或其他结构来组织。  静态链接  链接（Linking）的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。 链接主要包括地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等  符号决议有时也叫做符号绑定（Symbol Binding）、名称绑定（Name Binding）、名称决议（Name Resolution），或地址绑定（Address Binding）、指令绑定（Instruction Binding）。“决议”倾向于静态链接，而“绑定”倾向于动态链接，二者使用的范围不同。在静态链接，统称为符号决议。  静态链接将目标文件（Object File，扩展名一般是.o或.obj）和库（Library）一起链接形成最终可执行文件。  库其实是一组目标文件的包，是将一些最常用的代码编译成目标文件后打包存放 常见的是运行时库（Runtime Library）  重定位就是链接器在链接目标文件的时候，将定义在其他目标文件中的函数调用或变量的地址进行修正  重定位入口（Relocation Entry），指的是地址要被修正的地方   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f45edfe4cd94ae8657b685ea5da7f1bb","permalink":"https://xueqing.github.io/blog/link_load_lib/2_%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/link_load_lib/2_%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/","section":"blog","summary":"深入理解gcc hello.c的过程 预处理 Prepressing 编译 Compilation 汇编 Assembly 链接 Linking 编译器 编译过程 扫描，词法分析 语法分析 语义分析 源代码优化 代码生成 目标代码优化 链接器","tags":["develop","link","lib"],"title":"第二章 编译和链接","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  2.1 架构风格 2.2 公共的架构设计 2.3 架构类型 2.4 架构设计流程 2.5 重要的架构原则 2.6 重要的设计原则  2.1 架构风格  架构风格(architectural style)，也叫架构模式(architectural pattern)，为一组系统定义了抽象的框架 架构风格内容包括  提供组件和连接者的词汇表，以及它们如何联合的规则 通过给出常见问题的解决方案改善划分，允许设计重用 描述一种特别的方式来配置一组组件(一个具有定义良好的接口、可重用、可替换的模块)和连接者(模块之间的通信链接)  每种风格描述了一个系统分类，包括  一组组件类型，用来执行系统要求的功能 一组连接者(子例程调用，远程过程调用，数据流和套接字)使得不同的组件通信、协调、合作 语义限制，定义组件如何整合成系统 组件的布局拓扑图，表明它们运行时的相互关系   2.2 公共的架构设计 架构风格根据主要的聚焦点可以分为\n 通信  消息总线：规定软件系统的使用，通过一个或多个通信通道可以接受和发送消息 服务导向架构：定义应用服务使用约定和消息暴露和消费功能  部署  客户端/服务端：将系统分为客户端和服务端，客户端向服务端发送请求 3/N 层式：将功能分为独立的部分，每个部分成为一层，分布在不同的物理机上  领域  领域驱动设计：聚焦于模块化一个业务领域，基于该领域的实体定义领域目标  结构  基于组件：将应用设计成可复用的功能或逻辑组件，组件具有定义良好的通信接口 分层：将应用的问题分成重叠的组(层) 面向对象：基于应用或系统的责任分成对象，每个对象包含数据以及和该对象有关的行为   2.3 架构类型 从企业的角度来看有一下几种架构\n 业务架构：定义企业内业务、管理、组织和主要业务流程的策略，集中于业务流程的分析和设计 应用(软件)架构：作为单个应用系统的蓝图,系统的相互作用和系统对组织业务流程的的关系 信息架构：定义逻辑和物理的数据资源和数据管理资源 信息技术(IT)架构：定义硬件和软件的基石，它们组成了组织的整个信息系统  2.4 架构设计流程  架构设计流程致力于分解系统为不同的组件，以及组件直接相互作用以满足功能性和非功能性的需求 架构设计的输入是  通过分析人物得到的需求 硬件架构(系统架构配置硬件架构，软件架构反过来为系统架构提供需求)  架构设计的输出是一个架构描述 架构设计流程包括  理解问题：许多软件项目和产品是失败的，因为它们没有真正解决一个有效的商业问题，或者说对于投资没有一个可识别的回报 确认设计元素和它们的关系 为定义系统的边界上下文设定一个基线 基于功能将系统分解成主要的组件。分解可以模型化，使用设计结构矩阵(DSM, Design structure matrix)，它展示了设计元素之间的依赖，不指定元素的粒度 评估架构设计 评估每个质量参数收集定量的数据和测量，从而评估设计 如果满足每个质量参数的标准，则软件设计流程完成 否则进入下个阶段，即转换架构设计 转换架构设计 修改架构直到满足质量参数需求   2.5 重要的架构原则  为了改变而构建，而不是为了持续而构建：随着时间发展应用可能需要改变来满足新需求或挑战 降低风险和模型以便于分析：使用决策工具，可视化、模型化系统来捕获需求，设计决策 使用模型和可视化作为通信和协作工具：和利益共享者高效的沟通和共享设计 使用增量迭代的方法：以基本架构开始，然后通过迭代测试逐步形成候选的架构，改善架构  2.6 重要的设计原则  关注点分类：确保组件功能之间没有重叠；高内聚，低耦合 单一责任原则：系统的每个模块有专门的功能 最少知识原则：每个组件或对象不应知道其他组件的内部细节，可以避免依赖性，提高可维护性 最小化提前大型设计：当应用需求不明确时，尽量减少大型设计。如果可能需要修改需求，那么避免为整个系统添加大的设计  BDUF(Big Design Up front)，一种软件开发方法，即程序实现开始之前，程序设计时完全的、完美的、常应用域瀑布模型  不要重复功能：重复功能的代码不易修改，清晰度降低，且增加了潜在的不一致性 重用功能时使用复合而不是继承：继承增加了父类和子类的依赖性，不利于单独使用子类 确定组件并且整合到逻辑层：将某个关注点相关的组件组合到一个逻辑层 定义层之间的通信协议 定义层的数据格式：不同的组件通过数据格式交互，确保层内的数据格式是一样的 系统服务组件应是抽象的：有关安全性、通信或系统服务(比如日志、分析和配置)的代码再各个组件应该是抽象的。不要将其与业务逻辑混合 设计异常和异常处理机制：提前定义异常，帮助组件管理错误和不希望的情形 命名规范：提前定义命名规范。以便用户理解系统，也便于团队成员检验其他人的代码，增强可维护性  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b543a409603b74badcfed81ecff1dfe4","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/2-key-principles/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/2-key-principles/","section":"translation","summary":"2.1 架构风格 2.2 公共的架构设计 2.3 架构类型 2.4 架构设计流程 2.5 重要的架构原则 2.6 重要的设计原则 2.1 架构风格 架构风格(architectural style)","tags":["sa"],"title":"2 重要原则","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" 可执行文件格式（Executable）主要是 PE（Windows 下，Portable Executable）和 ELF（Linux 下，Executable Linkable Format），都是 COFF（Common file format）格式。 目标文件是源代码编译后但未进行链接的中间文件（Windows 下的 .obj 和 Linux 下的 .o），与可执行文件的内容和结构相似  Windows 下广义地把目标文件与可执行文件的格式统称为 PE-COFF 文件格式 Linux 下统称为 ELF 文件  可执行文件（Windows 的 .exe 和 Linux 的 ELF 可执行文件），动态链接库（DLL，Dynamic Linking Library）（Windows 的 .dll 和 Linux 的 .so），静态链接库（Static Linking Library）（Windows 的 .lib 和 Linux 的 .a）文件都按照可执行文件格式存储  静态链接库是把很多目标文件捆绑在一起形成一个文件，在加上一些索引   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d28139e219df559729342841d6183730","permalink":"https://xueqing.github.io/blog/link_load_lib/3_%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/link_load_lib/3_%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6/","section":"blog","summary":"可执行文件格式（Executable）主要是 PE（Windows 下，Portable Executable）和 ELF（Linux 下，Execu","tags":["develop","link","lib"],"title":"第三章 目标文件","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  3 架构模型\n 3.1 统一建模语言 3.2 架构视图模型 3.3 架构描述语言  定义一个软件架构的方式包括\n 统一建模语言(UML, unified modeling language)：面向对象的解决方案，用于软件建模和设计 架构视图模型(architecture view model)，也叫 4+1 视图模型(4+1 view model)：展示软件应用的功能性和非功能性需求 架构描述语言(ADL, architecture description language)：正式地从语义上定义软件架构   3.1 统一建模语言  作为软件需求分析和设计文档的标准，是开发软件的基础 有两种示意图  结构图：描述系统的静态特点。静态部分可用类、接口、对象、组件和节点表示。结构图可分为 类图：表示类之间的静态关系 对象图：表示一组对象运行时关系，也描述了系统的静态视图 组件图：描述系统所有组件，组件的相互关系、交互和接口 部署图：一组节点和节点的关系。这些节点是部署组件的物理实体 包图：描述包的结构和组织。包括一个包内的类和包内的包 复合结构图：描述组件内部的结构，包括所有的类、组件的接口 动作/行为图：捕获系统的动态特点，包括系统改变/移动的部分。动作图分为 用例图：描述功能之间的关系，以及它们内部/外部的控制器/行动者 序列图：可视化系统内完成专门功能的调用顺序 通信图：和序列图一样，区别在于通信图关注对象角色 状态图：表示系统的时间驱动状态变化。主要是类、接口的状态变化 活动图：描述系统的控制流，包括活动和连接。流可以是顺序的、并发的、分支的 交互图：包含活动图和序列图，提供系统和业务流程的控制流的总览 时序图：描述状态、条件和事件消息的变化   3.2 架构视图模型  模型：对软件架构完整的、基础的、简化的描述，包括从一个角度或视角的多个视图 视图：表示一组相关的关注点的整个系统。用于从不同的利益共享者(比如终端用户、开发者、项目管理者和测试者)描述系统 4+1 视图模型：是一个强调系统不同的特点和关注点的多视图模型。标准化软件设计文档，使得设计被所有的利益共享者更好理解 提供 4 个基本的视图  逻辑/概念视图：描述设计的对象模型 进程视图：描述系统的活动，捕获设计的并发和同步特点 物理视图：描述软件到硬件的映射，也反映了分布式特点 开发视图：描述软件在开发环境下的静态组织或结构  1 个额外视图：场景视图/用例视图  为软件系统的终端用户和客户设计 和其他 4 个视图一起展现架构   4+1 视图的关系如下 3.3 架构描述语言  一种正式的规范语言，描述了软件特点(比如进程、线程、数据、子程序)和硬件组件(比如处理器、设备、总线和内存)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"147c80d99e893bbe071c1cda5c524488","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/3-architecture-models/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/3-architecture-models/","section":"translation","summary":"3 架构模型 3.1 统一建模语言 3.2 架构视图模型 3.3 架构描述语言 定义一个软件架构的方式包括 统一建模语言(UML, unified modeling language)：面向对象的解决方","tags":["sa"],"title":"3 架构模型","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  4 面向对象泛型  4.1 面向对象泛型介绍 4.2 面向对象分析 4.3 面向对象设计   4.1 面向对象泛型介绍 面向对象系统的基础概念和术语包括\n 对象：在面向对象环境中，对象是真实的元素，在物理(比如一个客户、一辆车)或概念(比如一个项目、一个进程)上是存在的  每个对象都有 身份：与系统中其他对象区分 状态：决定一个对象的特点属性，已经持有的属性的值 行为：表示一个对象执行的外部可见的行为，和对象的状态变化相关 对象可以根据应用的需求被模型化  类：类表示拥有相同的特点属性(表现相同的行为)的一组对象  创建一个类的一个对象作为成员称作实例化。因此，对象是类的一个实例 一个类包括 一组属性：对象从类实例化得到的属性  一般来说，一个类的不同对象在这些属性上有一些不同 属性常表示成类的数据  一组操作：描绘该类的对象的行为  操作常表示成类的函数或方法   封装：封装是在类中将属性和方法绑定在一起的过程  通过封装，类可以向外部隐藏内部的细节 类只允许外部通过接口访问类内的元素  多态：多态暗示操作的方式不同，取决于操作针对的实例  多态使得内部结构不同的对象可以向外部提供统一的接口 多态主要通过继承实现 关系：系统包括动态(行为)指标和静态(逻辑)指标 动态指标描述对象之间的关系(比如消息传递) 静态指标描述类之间的关系(比如聚合、关联、继承)  消息传递：系统内的对象彼此使用消息传递通信  一个对象如果想要另一个对象执行一个方法，必须给该对象发送一个消息  复合或聚合：复合或聚合表示类间的关系，指一个类可以通过其他类对象的组合生成  聚合指的是 part-of 或 has-a 关系 一个聚合类由一个或多个其他的对象组成  关联：关联是拥有共同的结构和行为的一组链接(link)。关联描述了一个或多个类的对象之间的关系  一个链接(link)可以定义成一个关联的一个实体 关联的度表示参与到一个连接的类的数目。度可以是单元、二元或三元的 一个单元关系连接同一个类内的对象 一个二元关系连接两个类的对象 一个三元关系连接三个或多个类的对象  继承：继承机制允许基于已有的类创建类，创建的类可以扩展或重定义能力  已有的类称作基类/父类/超类(super-class)，新类成为衍生类/子类/亚类(subclass) 亚类可以继承或衍生超类提供的属性和方法 亚类也可以添加自己的属性和方法，且方法可能会改变超类的方法 继承定义了 is-a 的关系   4.2 面向对象分析  OO(object-oriented，面向对象)分析的目的是理解系统的应用领域和特定的需求 OO 分析的输出是系统的需求规格文档、逻辑结构的初始分析和可行性 OO 分析常用的分析技术包括  对象建模：开发软件系统对象的静态结构。对象建模的步骤 标识对象，组合成类 标识对象间的关系 创建一个用户对象模型图 定义一个用户对象的属性 定义类上应该执行的操作 动态建模：动态建模的目的是检验系统的时间和外部变化 动态建模可以定义为“描述一个单独的对象如何响应事件的一种方式，事件可以是其他对象触发的内部事件，或者外部世界触发的外部事件” 动态建模的步骤  标识每个对象的状态 标识事件，分析行为的适用性 构建动态模型图，包括状态转换图 表示对象属性的每个状态 验证画的状态转换图  功能建模：功能模型展示了对象内部执行的流程，以及对象在方法之间移动时数据如何变化 功能建模详细说明了对象建模操作和动态建模行为的意义 功能建模和传统的结构化分析的数据流图对应 功能建模的步骤  标识所有的输入和输出 构建数据流图，展示功能依赖性 说明每个函数的目的 标识约束 具体说明优化标准    4.3 面向对象设计  面向对象设计(OOD, object-oriented design)阶段，面向对象分析中的技术独立性概念被映射到实现类，约束被标识，接口被设计，生成解决方案域的模型 OOD 的主要目的是开发系统的结构化架构 OOD 的步骤  定义系统的上下文 设计系统架构 标识系统的对象 构造设计模型 规范对象接口  OOD 总结为两个步骤  概要设计：也叫高层设计，定义系统所需所有类，详细描述每个类的功能 使用类图描述类间的关系 交互图展示事件流 详细设计：也叫低层设计，基于交互图给每个类赋予属性和操作 状态图描述设计进一步的细节  需要遵循下面的设计原则  解耦原理：低耦合，可以通过引入新的类或继承消除耦合 确保内聚：高内聚，一个内聚的类执行一组紧密相关的功能 开放封闭原则：系统应该可以扩展满足新的需求 系统已有的实现和代码不应该被修改以扩展系统 下面是指导方针  对于每一个具体类，应该维护独立的接口和实现 在多线程环境，保持属性是私有的 最小化全局变量和类变量    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7bdf90f324a72c261aa63b3eaee04f95","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/4-object-oriented-paradigm/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/4-object-oriented-paradigm/","section":"translation","summary":"4 面向对象泛型 4.1 面向对象泛型介绍 4.2 面向对象分析 4.3 面向对象设计 4.1 面向对象泛型介绍 面向对象系统的基础概念和术语包括 对象：在面向对象环境中，对象是","tags":["sa"],"title":"4 面向对象泛型","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"模型之间的执行有三种类型\n 批量顺序  数据流携带批量的数据作为一个整体，从一个子系统到另外一个子系统 模块之间的通信可通过临时文件执行，并由后续的子系统删除 对于数据是批量的应用可行，每个子系统读相关的输入文件，然后写相关的输出文件 此架构典型的应用包括业务数据处理，比如银行和公用事业账单 优点：提供子系统简单的分割，每个子系统可以是一个独立的程序，作用于输入数据，生成输出数据 缺点：高延迟，低吞吐；不停并发和交互接口；需要外部控制实现  管道和过滤或非顺序的流水线模式  过滤器：一个过滤器是一个独立的数据流转换器或流传感器。在内部转换输入数据流，然后通过管道写转换的数据流传给下一个过滤器处理 主动过滤器：让连接的管道拉入数据，然后推出转换的数据 被动过滤器：让连接的管道推入数据，然后拉出转换的数据，必须提供读写机制 优点：并行，高吞吐；可复用，简化系统维护；易修改，低耦合；灵活度，支持顺序和并行执行 缺点：对动态交互不合适；过滤器直接数据转换的负载；不支持过滤器合作交互解决问题；难以动态配置 管道：无状态，存在于过滤器之间，可以携带二进制或字符流  流程控制  处理单元：改变处理控制变量 控制单元：计算改变数量。必须包含以下元素 控制变量、输入变量、操纵变量、处理定义、敏感元件、设定点、控制算法   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"44eae339b122fb633aef662b3b623e7e","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/5-data-flow-architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/5-data-flow-architecture/","section":"translation","summary":"模型之间的执行有三种类型 批量顺序 数据流携带批量的数据作为一个整体，从一个子系统到另外一个子系统 模块之间的通信可通过临时文件执行，并由后续的子","tags":["sa"],"title":"5 数据流结构","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":" 组件包括  中心数据结构/数据存储器/数据仓库：负责提供长久的数据存储，表示当前的状态 数据访问器/一系列独立的组件：操作中心数据结构存储，执行计算，存回结果   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fbd802077926234a7b0cdb4b525c6833","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/6-data-centered-architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/6-data-centered-architecture/","section":"translation","summary":"组件包括 中心数据结构/数据存储器/数据仓库：负责提供长久的数据存储，表示当前的状态 数据访问器/一系列独立的组件：操作中心数据结构存储，执行计","tags":["sa"],"title":"6 以数据为中心的架构","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  7.1 主子例程架构 7.2 主从式架构 7.3 虚拟机架构 7.4 分层式架构\n 将整个系统视为层次结构，即将软件系统分为不同层次的逻辑模块或子系统\n 分类：主-子例程、主从式、虚拟机、分层式\n  7.1 主子例程架构  目的是复用模块，自由开发各自的模块或子例程 将数据作为参数传递给子例程：值传递/引用传递 如图 优点：易基于层次改进分解系统；可用于 OOD 的子系统 缺点：因包含全局共享数据而易受攻击；高耦合导致不易修改  7.2 主从式架构  应用分治的思想，提供系统稳定系和容错性 架构向主设备提供相同的服务，主设备根据选择策略从架构选取结果 如图 实现步骤：  指定计算任务如何分解成一系列等价的子任务，然后指定所需子服务处理子任务 指定如何根据所得子任务的结果计算整个系统最后的结果 为第一个阶段的子服务定义接口。将由从设备实现，由主设备分配子任务 根据上述接口实现子服务 根据前三步实现主服务  应用：适用于可靠性比较重要的软件，广泛应用于并行和分布式计算领域 优点：快速计算，方便扩展；从设备可重复，提供了稳健性；从设备实现可不同以最小化语义错误 缺点：通信负载；不是所有问题可分割；难以实现，不易跨平台  7.3 虚拟机架构  一个虚拟机基于已有系统创建，提供一个虚拟的抽象、一系列属性和操作 在虚拟机架构中，主设备使用从设备相同的子服务，执行例如划分工作、调用从设备、联合结果等工作 如图 应用：适用于以下领域  如果没有直接的解决方案，通过仿真或翻译解决问题 样例程序，包括微程序解释，XML 处理，脚本命令语言执行，基于规则系统的执行，Smalltalk 和 Java 解释器类型的编程语言 常见的例子包括解释器、基于规则的系统、句法 shell、命令语言处理器  优点：可移植性，机器平台独立性；简化软件开发；灵活性；仿真灾难性的工作模型；引入运行时修改 缺点：解释器执行慢；性能代价，因为执行中有多余的计算  7.4 分层式架构  每一层在系统中有自己单独的责任  每一层包含一组相关的类，被封装成一个包，一个部署组件，或者作为一组子例程 每一层为上层提供服务，并作为下层的客户端，即调用下一层的服务  应用：  适用于包含明显的服务类的应用，可以分成层级式 应用可被分成特定应用和特定平台的部分 应用可清晰地分成内核服务、关键服务、用户接口服务等  优点：基于高层次的抽象；一层修改至多影响相邻两层；接口和实现分类；基于组件技术开发，支持即插即用；每一层可单独部署，可移植；基于任务自上而下分解；相同层的不同实现可互换 缺点：许多应用或系统不易分解成层级式；多层传递会降低运行时性能；数据在每层传递的负载会降低性能；层内通信可能会死锁，到底高耦合；异常和错误不易传送到所有的调用层  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"dc75882f62b82b3427fbe53be368e28d","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/7-hierarchical-architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/7-hierarchical-architecture/","section":"translation","summary":"7.1 主子例程架构 7.2 主从式架构 7.3 虚拟机架构 7.4 分层式架构 将整个系统视为层次结构，即将软件系统分为不同层次的逻辑模块或子系统 分类：主-子例程、主从式","tags":["sa"],"title":"7 层次化架构","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  8.1 MVC 8.2 PAC\n 目的：将数据层、业务数据处理和用户操作分离\n 包括三个部分：\n 数据模块：提供数据抽象和业务逻辑 控制模块：识别控制流和系统配置行为 视图展示模块：负责输出数据的视觉和听觉展示，也为用户输入提供接口  包括两种：模型-视图-控制器(MVC, model-view-control)和显示-抽象-控制器(PAC, presentation-abstraction-control)\n  8.1 MVC  模型：封装底层数据和业务逻辑 控制器：响应用户操作，指导应用流程  接收输入并转换成给模型或视图的命令 作为相关命令、视图和输入设备的接口 可发送命令给模型，更新模型的状态 也可发送命令给相关的视图，改变视图的展示  视图：格式化模型的数据并展示给用户 如图 可分为  MVC-I 如图 模型模块通知控制器-视图模块数据的变化，随之改变对应的图形化数据展示 模型模块提供所有的数据和域服务 二者的连接可以是订阅-通知式的，即控制器视图订阅模型，模型将变化通知给控制器-视图 MVC-II 如图 视图层展示数据 控制器接收输入请求，验证输入数据，初始化模型、视图以及二者的连接，分发任务  应用：适用于交互式应用 优点  有很多 MVC 的开发框架包 用同一个数据模型去同步多个视图 容易添加和修改接口视图 应用开发分为图像专家、编程专家、数据库开发专家  缺点  不适用面向代理的应用 多个控制器和视图操作统一数据模型，导致数据修改代价增大 视图和控制器在某些情况下不易划分   8.2 PAC  PAC 将系统划分成多个合作代理的层级。每个代理包含三个组件  展示组件：格式化数据并展示给用户 抽象组件：取回并处理数据 控制器组件：处理组件之间的控制流或通信等任务  如图 展示组件和抽象组件只能通过控制器组件通信 多代理的 PAC  如图 每个代理有自己特别指定的工作 顶层代理提供核心数据和业务逻辑 底层代理定义特定的数据和展示 中间代理作为底层代理的协调者 某些中间代理不需要交互展示，不需要展示组件 每个代理需要控制器组件与其他代理通信 应用 交互系统中，系统可分成层级的合作代理时，较有效 代理直接的耦合松散，因为代理修改不影响其他代理时，较有效 分布式系统，每个代理有自己的数据和交互接口处理函数时，较有效 有大量 GUI 组件，每个 GUI 组件保存自己当前的数据和交互接口，与其他组件进行通信时，较有效  优点：支持多任务，多视图；支持代理复用，延伸线好；易添加和修改已有的代理；支持并发，多个代理可在不同的线程或设备或机器上并发运行 缺点：展示组件和抽象组件的控制桥的负载，代理控制器控制组件之间的通信负载；不易确定代理数目；每个代理完全划分展示和抽闲组件会增加开发复杂性  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"253bcec5f36fe67e1ad841e921463dac","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/8-interaction-oriented-architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/8-interaction-oriented-architecture/","section":"translation","summary":"8.1 MVC 8.2 PAC 目的：将数据层、业务数据处理和用户操作分离 包括三个部分： 数据模块：提供数据抽象和业务逻辑 控制模块：识别控制流和系统配置行为 视图展示模","tags":["sa"],"title":"8 面向交互的架构","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  9.1 客户端服务端架构 9.2 多层架构 9.3 代理(Broker)架构 9.4 面向服务的架构\n 中间件是分布式架构的基础结构。如图 分布式架构侧重于透明性、可靠性、可用性\n 关于透明性\n 访问：隐藏访问资源的方式和数据平台的差异 位置：隐藏资源的位置 技术：对用户隐藏不同的技术，比如编程语言，操作系统 迁移/重定位：隐藏使用时可能被移动到另一个位置的资源 重复：隐藏可能复制在其他地方的资源 并发：隐藏可能与其他用户共享的资源 错误：对用户隐藏资源的错误和复原 一致性：隐藏资源或软件是在内存或磁盘  优点：资源共享、开放性、并发、易扩展、容错性\n 缺点：复杂度、安全性降低、不易管理、不可预测\n  9.1 客户端服务端架构  如图 服务端提供服务，客户端使用这些服务 服务端不需要知道客户端，客户端需要知道服务端的身份 优点：分离用户接口展示和业务逻辑处理；服务组件复用，可能并发；简化设计和开发；易迁移或整合已有应用到分布式环境；多客户端访问一个高性能的服务可充分利用资源 缺点：缺少异构架构处理需求改变；安全问题；服务的可用性和扩展性降低  9.2 多层架构  如图 一般分为三层：展示层、应用层(也叫业务逻辑层、逻辑层、中间层)和数据层  如图  优点：易管理、性能好；可复用，易扩展；多线程支持，降低网络负载；易维护，灵活性高 缺点：不易测试，缺少测试工具；可靠性和可用性对服务要求更高  9.3 代理(Broker)架构  中间件架构，在分布式计算中使用，协调注册的服务端和客户端之间的通信 对象之间通信使用中间件系统，叫做对象请求代理(系统总线)  客户端和服务端不会直接交互。它们各自直接连接自己的代理，和 mediator-broker 通信 服务端通过注册和发布接口到 broker 提供服务，客户端可以通过 broker 静态或动态查找请求服务 通用对象请求代理架构CORBA(CORBA, Common Object Request Broker Architecture)是一个实现的较好的例子  组件包括  broker：负责协调通信，比如转发和分发结果和异常 协商服务请求，定位一个合适的服务端并发送请求，发送回复给客户端 维护服务端的注册信息，包括它们的功能、服务和定位信息 给客户端发送请求和服务端发送回复提供 API stub：静态编译阶段生成，部署在客户端，作为客户端的代理 作为客户端和 broker 的协调者 在协议层隐藏进程间通信(IPC, inter-process communication) 整合参数值，分割服务端返回的结果 skeleton：服务端接口编译生成，部署在服务端，作为服务端的代理 封装了底层特定系统的网络函数，提供高级的 API 来协调服务端和 broker 接收请求，解包请求，分割方法参数，调用合适的服务，发送结果，发送给客户端 bridge：基于不同的通信协议连接两个不同的网络，协调不同的 broker 可选组件，隐藏两个 broker 互相操作的实现细节  如图 CORBA 是针对对象请求代理的国际化标准——一个管理分布式对象通信的中间件  如图   9.4 面向服务的架构  如图 面向服务的架构(SOA, service-oriented architecture)是一个客户端/服务端设计，支持业务驱动  应用包含软件服务端和软件服务消费者 服务之间的连接通过通用的基于消息的协议(比如 SOAP 网络服务协议)，可以在服务之间发送请求和回复  特点：分布式部署；可组合性；互用性；复用性 SOA 操作如图 优点：  低耦合，可以充分利用已有的服务资源，无关平台和技术限制 无状态，每个服务组件和其他服务相互独立 只要不改变接口，修改服务的实现不影响其他服务 客户端和服务端可以访问其他服务，无关平台、技术、生产商、语言实现 资产和服务的复用性，只要知道公共接口就可以使用 在时间和花费上更有效 提高了可扩展性，为系统提高标准连接 易整合，改善了内部互操作性   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5b815aca84b92a295a2c2ec95e169da7","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/9-distributed-architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/9-distributed-architecture/","section":"translation","summary":"9.1 客户端服务端架构 9.2 多层架构 9.3 代理(Broker)架构 9.4 面向服务的架构 中间件是分布式架构的基础结构。如图 分布式架构侧重于透明性、可靠性、可用","tags":["sa"],"title":"9 分布式架构","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":" 目标：确保组件复用性 致力于分解设计成单个功能或逻辑组件，表示定义良好的通信接口，包括方法、时间和属性 提高更高级别的抽象，将问题分解成子问题，每个子问题一个组件 特点：复用性、可替换、没有特定上下文、易扩展、封装性、独立性 优点：易部署、减少花费、易开发、复用性、降低技术复杂度、可靠性、系统易维护、易升级、独立性  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1b0729b273dcbcaef83d619e20205916","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/10-component-based-architecture/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/10-component-based-architecture/","section":"translation","summary":"目标：确保组件复用性 致力于分解设计成单个功能或逻辑组件，表示定义良好的通信接口，包括方法、时间和属性 提高更高级别的抽象，将问题分解成子问题，","tags":["sa"],"title":"10 基于组件的架构","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":" 图形化用户界面，也叫 WIMP 界面。因为使用了  window：窗口，屏幕上的一个矩形区域 icon：图标，一个图片或符号用于表示软件应用或硬件设备 menu：菜单，用户可选择的一系列选项 pointer：指示物，一个符号(比如箭头)，当用户移动鼠标时在屏幕上移动，帮助用户选择对象  用户界面设计  分析用户界面，了解 4 个元素：用户、任务、内容、工作环境 从用户而不是机器的能力和局限设计 将任务分成用户和机器级别的 一般分成以下几步 定义用户界面对象和行为/操作 定义事件(用户行为)导致用户界面改变的状态 详细说明用户如何根据界面提供的信息解释系统状态 描述终端中户看到每个界面状态  开发流程：  接口分析：分析用户、任务、内容、工作环境，定义需要做的任务 接口设计：定义一系列接口对象、行为、屏幕表示 接口构造：先有产品原型支持评估使用情形，然后使用开发工具完善 接口验证：致力于验证以下方面 接口的能力 执行每个用户任务的正确性 满足所有任务的改变 满足所有通用的需求 接口的易用性和易学性   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d4085eafcb979d8176be38b9600b7124","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/11-user-interface/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/11-user-interface/","section":"translation","summary":"图形化用户界面，也叫 WIMP 界面。因为使用了 window：窗口，屏幕上的一个矩形区域 icon：图标，一个图片或符号用于表示软件应用或硬件设备 men","tags":["sa"],"title":"11 用户界面","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":" 迭代增量式方法：通过一次或多次重复生成候选的解决方案。分为 5 步  确认架构目标：确认一开始的架构目标，确认架构消费者的目标，确认限制 关键情节 一个情节是一个扩展性的，覆盖描述用户和系统的一个交互 给每个情节确定优先级，在用户、商业和系统目标之间权衡 应用概述：将架构与现实世界的限制和决定关联，包括下面的活动 确认应用类型：移动端、web 端、互联网应用等 确认部署限制：选择合适的部署拓扑，解决应用和基础设施之间的冲突 确认重要的架构设计类型：客户端/服务端、分层、消息-总线、领域驱动等 确认相关的技术：根据开发的应用类型、倾向的应用部署拓扑和架构类型确认相关技术 关键问题或关键热点：关键热点是经常制造错误的区域 候选的解决方案：根据应用概述和关键问题创建和细化架构 候选的架构包括：应用类型、部署架构、架构类型、技术选型、指令参数和横切关注点 根据架构目标和关键情节验证候选的解决方案  架构概况：  在项目的关键阶段经常检查架构，响应其他重要架构的改变 主要目的是确定基础架构和候选架构的灵活性 将功能需求和之类属性与建议的技术方案关联  交流架构设计  完成架构设计之后，必须和其他的利益共享者交流设计，包括开发团队、系统管理员、操作员、商业所有者，及其他利益集团 有下面几个方法向其他人描述架构 统一建模语言：功能需求视图、静态结构视图、动态行为视图 4+1 模型：逻辑视图、进程视图、物理视图、开发视图、场景视图/用例视图 架构描述语言 敏捷建模  模型足够简单，易于理解，足够准确、详细和已知  IEEE 1471：是体系结构描述的推荐规范，用于软件密集型系统，保证架构描述的内容   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b285e0a2de3e98560449d154318aaf97","permalink":"https://xueqing.github.io/translation/software_architecture_tutorial/12-architecture-techniques/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/software_architecture_tutorial/12-architecture-techniques/","section":"translation","summary":"迭代增量式方法：通过一次或多次重复生成候选的解决方案。分为 5 步 确认架构目标：确认一开始的架构目标，确认架构消费者的目标，确认限制 关键情节 一个","tags":["sa"],"title":"12 架构技术","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  编辑器 基本技巧  标题 代码 粗斜体 换行 链接 列表 普通无序列表 普通有序列表 列表嵌套 表格 引用 普通引用 引用嵌套引用 引用嵌套列表 引用嵌套代码块 图片 分隔符  高级技巧  行内 HTML 元素 符号转义 公式 脚注  文档规范  编辑器  Mac  Mou  Windows  MarkdownPad MarkPad  Linux  ReText Vim+Vimwiki  在线编辑器  markable dillinger  浏览器插件  MaDe(chrome) 马克飞象  高级应用  Sublime Text 2 + MarkdownEditing / 教程   基本技巧 标题 Markdown 支持两种标题的语法，类 Setext 和类 atx 形式\n类 atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶(可以在行尾加上 #)\n# 一级标题 # ## 二级标题 ## ### 三级标题 ### #### 四级标题 ####  类 Setext 形式是用底线的形式，利用 = (最高阶标题)和 - (第二阶标题)(任何数量的 = 和 - 都可以有效果)\n一级标题 ============ 二级标题 ------------  代码  行内代码：用反引号标记行内代码，如  function_name() 包含反引号`的代码  代码段，通常编辑器根据代码片段适配合适的高亮方法\n 可以用[三个`]包裹一段代码，并指定一种语言\nint test() { return 0; }  也可以使用 4 空格或是 1 个制表符缩进，再贴上代码，实现相同的的效果\n  int test() { return 0; }\n 如果不需要代码高亮，可以用下面的语法禁用\nint test() { return 0; }    粗斜体 Markdown 使用星号和底线作为标记强调字词的符号\n斜体 斜体\n粗体 粗体\n粗斜体 粗斜体\n换行 另起一行，只需要在当前结尾加2个空格\n这样就会另起一行\n空出一行，即可新起一个段落\n行尾加斜线，\n也可实现换行\n链接  行内式链接  文字链接：方括号(链接名称)+圆括号(链接地址) 链接名称 google gmail 自动链接：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，尖括号+(链接地址) https://translate.google.com/ https://mail.google.com/mail/u/0/  参考式链接：在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记，然后在文件的任意处为标记变量赋值(网址)  隐式链接标记：可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字 这个链接用 Google 作为网址变量 Google 这个链接用 yahoo 作为网址变量 Yahoo! 链接标记的内容定义的形式为： 方括号(前面可以选择性地加上至多三个空格来缩进)，里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的网址(链接网址也可以用尖括号包起来) 选择性地接着 title 内容，可以用单引号、双引号或是括弧包着   列表 普通无序列表 - 无序列表，文本前使用[减号+空格] + 无序列表，文本前使用[加号+空格] * 无序列表，文本前使用[星号+空格]  普通有序列表  列表前使用[数字+英文句点+空格] 可以自动添加数字 数字不对显示的时候回自动调整 文档开始如果出现‘1986. blabla’要写成‘1986. blabla’  5) 列表前使用[数字+)+空格] 6) 可以自动添加数字 7) 数字不对显示的时候回自动调整 8) 文档开始如果出现‘1986. blabla’要写成‘1986. blabla’\n列表嵌套  列出所有元素：  无序列表元素 A  元素 A 的有序子列表  前面加 4 个空格或 1 个制表符  列表里的多段换行：\n前面必须加 4 个空格或 1 个制表符，\n这样换行，整体的格式不会乱 列表里引用：\n 前面空一行\n仍然需要在 \u0026gt; 前面加 4 个空格或 1 个制表符\n 列表里代码段：\n前面 4 个空格或 1 个制表符，之后按三个`代码语法\n或者直接空 8 个空格或 2 个制表符， 引入代码块   表格 默认：左对齐(col1)\n   col1 col2 col3     col1 col2 col3   col1,col1 col2,col2 col3,col3   col1,col1,col1 col2,col2,col2 col3,col3,col3    引用 普通引用  引用前使用[大于号+空格]\n换行可以不加\n空行和新起一行需要加上\n 引用嵌套引用  最外层引用 \u0026gt; 多一个[大于号+空格]嵌套一层引用 \u0026gt; \u0026gt; 可以嵌套很多层\n 引用嵌套列表   这是引用里嵌套的一个列表 还可以有子列表  子列表需要从[减号、加号、星号]之后延后 4 个空格或 1 个制表符开始    引用嵌套代码块  同样的，在前面加 4 个空格或 1 个制表符形成代码块   或者使用三个`形成代码块  图片  跟链接的方法区别在于前面加了个感叹号。行内式的图片语法 感叹号+方括号(图片名称)+圆括号(图片链接地址/图片相对路径)：\n  分隔符 在新起一行输入三个减号、星号、底线，即可实现分割线。当前后都有段落时，请空出一行。\n段落1\n段落2\n段落3\n高级技巧 行内 HTML 元素 目前只支持段内 HTML 元素效果，包括 kbd/b/i/em/sup/sub/br 等。现不建议使用 HTML 元素\n 键位显示： 使用 \u0026lt;kbd\u0026gt;Ctrl\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Alt\u0026lt;/kbd\u0026gt;+\u0026lt;kbd\u0026gt;Del\u0026lt;/kbd\u0026gt; 重启电脑 代码块：使用 pre/code 标签 粗斜体：\u0026lt;b\u0026gt;粗体\u0026lt;/b\u0026gt;  符号转义 在符号前加反斜杠可以避免被转义。如：\n\\_不想这里的文本变斜体\\_ \\*\\*不想这里的文本被加粗\\*\\*  Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\\ 反斜线\n` 反引号\n* 星号\n_ 底线\n{} 花括号\n[] 方括号\n() 括弧\n# 井字号\n+ 加号\n- 减号\n. 英文句点\n! 惊叹号\n公式 当需要在编辑器中插入数学公式时，可以使用两个美元符包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$\n$$ x \\href{why-equal.html}{=} y^2 + 1 $$\n脚注 Markdown 官网1\n文档规范  标题用#，右边的#可不加 行内代码  三个反引号 制表符 code 标签  代码段  三个反引号 制表符 pre/code 标签    https://daringfireball.net/projects/markdown/ ^   ","date":1573374150,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":1573374150,"objectID":"ec9b794cab92402479acc18c8fc224e0","permalink":"https://xueqing.github.io/blog/markdown/markdown_%E8%A7%84%E8%8C%83/","publishdate":"2019-11-10T16:22:30+08:00","relpermalink":"/blog/markdown/markdown_%E8%A7%84%E8%8C%83/","section":"blog","summary":"编辑器 基本技巧 标题 代码 粗斜体 换行 链接 列表 普通无序列表 普通有序列表 列表嵌套 表格 引用 普通引用 引用嵌套引用 引用嵌套列表 引用嵌套代码块 图片 分隔符 高级","tags":["md"],"title":"Markdown 规范","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  0.1 dd 命令安装  0.1.1 无人值守安装 0.1.2 使用 dd 命令实现硬盘复制 0.1.2.1 dd 命令 0.1.2.2 dd 命令安装步骤  0.2 Linux LiveCD：从 CD 光盘运行 Linux 0.3 远程管理协议  0.3.1 RDP vs RFB 0.3.2 Telnet vs SSH   0.1 dd 命令安装 0.1.1 无人值守安装  面对大批量服务器的安装，人们往往热衷于选择“无人值守安装”的方式，而此方式需要对服务器进行过多配置 无人值守安装(Kickstart)，又称全自动安装，其工作原理是，创建一个名为 ks.cfg 的文件记录 Linux 系统在安装过程中需要人工干预填写的各种参数  当安装过程中出现要填写参数时，安装程序会自行去 ks.cfg 文件中查找合适的参数，如果没找到，还是需要手工干预 在 ks.cfg 文件涵盖安装过程所有可能需要填写的参数的前提下，安装者只需要告诉安装程序 ks.cfg 文件的位置，就可实现全自动安装   0.1.2 使用 dd 命令实现硬盘复制  用 dd 命令实现硬盘复制，间接实现安装 Linux 系统的方法，类似 Windows 下用 GHOST 软件进行硬盘克隆  0.1.2.1 dd 命令  dd 命令用于复制文件。它可以用指定大小的数据块复制一个文件，并在复制的同时进行指定的转换 简单地理解，dd 命令可用于进行两块硬盘之间的复制(完整复制出一块和原系统盘一样的硬盘) 格式 dd if=输入文件 of=输出文件 bs=字节数 count=个数 选项\n if=输入文件：指定源文件或源设备 of=输出文件：指定目标文件或目标设备 bs=字节数：指定一次输入/输出多少字节，即把这些字节看作一个数据块 count=个数：指定输入/输出多少个数据块\n# 创建一个 100MB 大小的文件 testfile # /dev/zero是一个输入设备，可以使用它来初始化文件，该设备无穷尽地输出 0 # 可以理解为向 testfile 中不停地写 0，直到写满 100MB [root@localhost ~]# dd if=/dev/zero of=/root/testfile bs=1k count=100000 # 把第一块硬盘中的数据复制到第二块硬盘中 [root@localhost ~]# dd if=/dev/sda of=/dev/sdb # 把第一块硬盘中的数据复制到 image 文件中 [root@localhost ~]# dd if=/dev/hda of=/root/image   使用 dd 命令复制硬盘，需满足以下两个前提条件\n 需要批量复制的服务器硬件配置一致。通常，采购服务器都是批量采购的，服务器的配置都是一样的 复制硬盘的时候，需要手工更换被复制盘。服务器上一般都是 SCSI 硬盘，SCSI 硬盘支持热插拔，而且不需要拆卸机箱，更换被复制盘非常方便   0.1.2.2 dd 命令安装步骤  使用 dd 命令安装 Linux，实际上就是硬盘之间的完整拷贝，其实现过程如下  把母盘插入服务器的第一个硬盘插口，把被复制盘插入服务器的第二个硬盘插口，注意不要插反 执行复制命令dd if=/dev/sda of=/dev/sdb /dev/sda 代表第一块 SCSI 盘，/dev/sdb 代表第二块 SCSI 盘 这条命令会把第一块硬盘中的数据完整地复制到第二块硬盘中  经过以上两步，即可实现将服务器之间的复制 此方法的效率：由于复制的速度和服务器的配置及安装软件的多少相关，因此每台服务器的复制时间约为15〜25分钟。选择无人值守安装的方式，也要受到服务器端配置和网络带宽的影响 硬盘复制也可以多台服务器同时操作  0.2 Linux LiveCD：从 CD 光盘运行 Linux  一些 Linux 发行版创建了含有 Linux 样本系统的可引导 CD，称为 Linux LiveCD 由于单张 CD 容量的限制，这个样本并非完整的 Linux 系统，不过可以自己加入各种软件。结果就是，可以通过 CD 来启动 PC，并且无需在硬盘安装任何东西就能运行 Linux 发行版 这是一个不弄乱 PC 就体验各种 Linux 发行版的绝妙方法。只需插入 CD 就能引导。所有的 Linux 软件都将直接从 CD 上运行。可以从互联网上下载各种 Linux LiveCD，刻录，体验 Linux LiveCD 也有一些不足之处  由于要从 CD 上访问所有东西，应用程序会运行得更慢，而如果再搭配上陈旧缓慢的 PC 和光驱，那更是慢上加慢 由于无法向 CD 写入数据，对 Linux 系统作的任何修改都会在重启后失效   0.3 远程管理协议  远程管理，通常指远程管理服务器，而非个人计算机。个人计算机可以随时拿来用，服务器通常放置在机房中，用户无法直接接触到服务器硬件，只能采用远程管理的方式 远程管理，实际上就是计算机(服务器)之间通过网络进行数据传输(信息交换)的过程，与浏览器需要 HTTP 协议(超文本传输协议)浏览网页一样，远程管理同样需要远程管理协议的支持 目前，常用的远程管理协议有 4 种     协议 描述 特点 举例     RDP(remote desktop protocol)协议 远程桌面协议，大部分 Windows 系统都默认支持此协议 - Windows 系统中的远程桌面管理就基于该协议   RFB(Remote FrameBuffer)协议 图形化远程管理协议 - VNC 远程管理工具就基于此协议   Telnet 命令行界面远程管理协议，几乎所有操作系统都默认支持此协议 在进行数据传送时使用明文传输的方式，也就是不对数据进行加密 -   SSH(Secure Shell)协议 命令行界面远程管理协议，几乎所有操作系统都默认支持此协议 和 Telnet 不同，该协议在数据传输时会对数据进行加密并压缩，因此使用此协议传输数据既安全速度又快 -    0.3.1 RDP vs RFB  都允许用户通过图形用户界面访问远程系统 RFB 协议倾向于传输图像，RDP 协议倾向于传输指令  RFB 协议会在服务器端将窗口在显存中画好，然后将图像传给客户端，客户端只需将得到的图像解码显示 RDP 会将画图的工作交给客户端，服务器端需要根据客户端的显示能力做适当的调整  因此，完成相同的操作，使用 RFB 协议传输的数据量会比 RDP 大，而 RDP 对客户端的要求比 RFB 更苛刻，RFB 适用于瘦客户端，而 RDP 适用于低速网络  瘦客户端是相对于胖客户端而言的，比如，人们使用 QQ 需要下载客户端，这属于“胖客户” 反之，通过浏览器就可查阅网络上各种资料，无需再下载其他任何软件，这属于“瘦客户” 简单理解，瘦客户端指的是最大可能减轻客户端的负担，多数工作由服务器端完成；胖客户端则相反   0.3.2 Telnet vs SSH  都是命令行远程管理协议，有共同的应用领域，常用于远程访问服务器 相比 Telnet 协议，SSH 协议在发送数据时会对数据进行加密操作，数据传输更安全 因此 SSH 协议几乎在所有应用领域代替了 Telnet 协议 在一些测试、无需加密的场合（如局域网），Telnet协议仍常被使用  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6fed377053083a71fc8a3b1980dc5e7e","permalink":"https://xueqing.github.io/blog/linux/0_%E5%AE%89%E8%A3%85/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/0_%E5%AE%89%E8%A3%85/","section":"blog","summary":"0.1 dd 命令安装 0.1.1 无人值守安装 0.1.2 使用 dd 命令实现硬盘复制 0.1.2.1 dd 命令 0.1.2.2 dd 命令安装步骤 0.2 Linux LiveCD：从 CD 光盘运行 Linux 0.3 远程管理协议 0.3.1 RDP vs RFB 0.3.2 Telnet vs SSH 0.1 dd","tags":["linux"],"title":"0 安装","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 Linux Vim 三种工作模式  前言 命令模式 输入模式 编辑模式   前言  Vim 有三种工作模式：命令模式、输入模式和编辑模式。三种模式可随意切换 不论处于什么模式，都可以按一次 Esc 键返回命令模式。如果多按几次 Esc 键后听到\u0026rdquo;嘀————\u0026rdquo;的声音，则代表已经处于命令模式了  命令模式  使用 Vim 编辑文件时，默认处于命令模式 此模式下，可使用方向键（上、下、左、右键）或 k、j、h、l 移动光标的位置，还可以对文件内容进行复制、粘贴、替换、删除等操作  输入模式  在输入模式下，Vim 可以对文件执行写操作，类似于在 Windows 系统的文档中输入内容 在命令模式状态下输入 i、I、a、A、o、O 等插入命令（各指令的具体功能如表所示）进行输入模式，当编辑文件完成后按 Esc 键即可返回命令模式     快捷键 功能描述     i 在当前光标所在位置插入随后输入的文本，光标后的文本相应向右移动   I 在光标所在行的行首插入随后输入的文本，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令   o 在光标所在行的下面插入新的一行。光标停在空行首，等待输入文本   O 在光标所在行的上面插入新的一行。光标停在空行的行首，等待输入文本   a 在当前光标所在位置之后插入随后输入的文本   A 在光标所在行的行尾插入随后输入的文本，相当于光标移动到行尾再执行a命令    编辑模式  编辑模式用于对文件中的指定内容执行保存、查找或替换等操作 在命令模式状态下按“：”键切换到编辑模式，此时 Vim 窗口的左下方出现一个“：”符号，这时就可以输入相关指令进行操作 指令执行后 Vim 会自动返回命令模式。如想直接返回命令模式，按 Esc 即可  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"92b4be0aec82cc045c9afebd397c5537","permalink":"https://xueqing.github.io/blog/vim/1_%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/1_%E4%B8%89%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F/","section":"blog","summary":"1 Linux Vim 三种工作模式 前言 命令模式 输入模式 编辑模式 前言 Vim 有三种工作模式：命令模式、输入模式和编辑模式。三种模式可随意切换 不论处于什么模式，都可以","tags":["vim"],"title":"1 Linux Vim 三种工作模式","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1.1 前言 1.2 特点 1.3 支持的语言 1.4 Memcached 用户  1.1 前言  Memcached 是一个自由开源、高性能、分布式内存对象缓存系统 基于内存的 key-value 存储，用于存储小块的任意数据(字符串、对象)。这些数据可以是数据库调用、API 调用或页面渲染的结果 设计简洁：便于快速开发，减轻开发难度，解决了大数据量缓存的问题。API 兼容大部分流行的开发语言 本质上是一个简洁的 key-value 存储系统 一般的使用目的：通过缓存数据库查询结果，减少数据库访问次数，以提高动态 web 应用的速度，提高可扩展性  1.2 特点  协议简单 基于 libevent 的事件处理  libevent 是一个基于事件触发的网络库 libevent API 提供一种机制：当一个文件描述符的特定时间发生(可读、可写、出错)，或一个定时时间发生，libevent 自动执行用户指定的回调函数，来处理事件 libevent 也支持信号或常规超时的回调 libevent 用于取代网络服务器中的事件循环检查框架  内置内存存储方式 分布式不互相通信  1.3 支持的语言  许多语言实现了连接 Memcached 的客户端，以 Perl、PHP 为主 其他语言包括：Python/Ruby/C#/C/C++/Lua  1.4 Memcached 用户 LiveJournal/Wikipedia/Flickr/Bebo/Twitter/Typepad/Yellowbot/Youtube/WordPress.com/Craigslist/Mixi\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0858eabe515ca89f4c58a2f4b1528cad","permalink":"https://xueqing.github.io/blog/database/memcached/1_intro/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/memcached/1_intro/","section":"blog","summary":"1.1 前言 1.2 特点 1.3 支持的语言 1.4 Memcached 用户 1.1 前言 Memcached 是一个自由开源、高性能、分布式内存对象缓存系统 基于内存的 key-value 存储，用于存储小块的任意数据(字符串、对象","tags":["database"],"title":"1 Memcached 简介","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1.1 key-value 缓存产品特点 1.2 Redis 优点 1.3 Redis 配置 1.4 Redis 数据类型 1.5 Redis 数据库  1.1 key-value 缓存产品特点  支持数据持久化：可将内存数据保存到磁盘，重启的时候再次加载使用 支持简单的 key-value 类型，也支持 list/set/zset/hash 数据的存储 支持数据备份：master-slave 模式的数据备份  1.2 Redis 优点  性能极高：读写速度快 数据类型丰富：支持 string/list/hash/set/zset(sorted set) 原子性：单个操作是原子性的。多个操作支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来 特性丰富：支持 publish/subscribe，通知，key 过期等  1.3 Redis 配置  配置文件位于安装目录，文件名 redis.conf(Windows 下是 redis.windows.conf) 查看配置项 CONFIG GET CONFIG_STRING_NAME  CONFIG_STRING_NAME 为 * 表示获取所有配置项  设置配置项 CONFIG GET CONFIG_STRING_NAME NEW_CONFIG_VALUE  1.4 Redis 数据类型    类型 简介 特性 命令 场景     string key-value 二进制安全，即 string 可包含任何数据(jpg 对象或序列化的对象等) SET key val/GET key -   hash key-value 对集合，即编程中的 Map 适合存储对象，可像数据库只修改某一属性值 HMSET hash_name key1 val1 [key2 val2...]/HGET hash_name key 存储/读取/修改用户属性   list string 列表(双向链表)，按插入顺序排序，下标从 0 开始 增删快，可操作某一段元素 lpush list_key value/lrange list_key start_index end_index 消息队列；最新消息排行等(如朋友圈时间线)   set string 无序集合，不允许 member 重复，hash 表实现 增删查的复杂度都是 O(1)；为集合提供交并差运算 sadd set_key member：添加 member 到 set_key 对应的集合，成功返回 1，已存在返回 0，set_key 对应集合不存在返回错误；smembers set_key 共同好友；利用唯一性，统计访问网站的所有独立 IP；根据 tag 求交集，大于某阈值可推荐好友   zset string 集合，member 唯一，score 可重复。score是 double 类型，根据 score 为 member 从小到大排序 数据插入时已排序 zadd zset_key score member/ZEANGEBYSCORE zset_key score1 score2 排行榜；带权重的消息队列    1.5 Redis 数据库  一个 Redis 示例提供了多个字典用于存储数据。客户端可指定存储的字典。每个字典可理解成一个独立的数据库。每个数据库数据隔离不共享 Redis 不支持自定义数据名字，每个数据库以编号(0 开始)命名。默认支持 16 个数据库，可通过配置文件修改 客户端连接 Redis 之后，默认选择 0 号数据库，可使用 SELECT db_no 更换数据库 局限性  开发者需要自己记录每个数据库存储的数据 不支持为每个数据库单独设置密码。所以所有数据库的权限是绑定的 多个数据库不是完全隔离，如 FLUSHALL 可清除一个 Redis 示例所有数据库的数据。所以不建议多个应用程序使用一个 Redis 实例的不同数据库存储数据。且 Redis 是轻量级的，一个空的实例占用内存很小   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c96afabef38b567d9b590086f4c85b73","permalink":"https://xueqing.github.io/blog/database/redis/1_intro/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/redis/1_intro/","section":"blog","summary":"1.1 key-value 缓存产品特点 1.2 Redis 优点 1.3 Redis 配置 1.4 Redis 数据类型 1.5 Redis 数据库 1.1 key-value 缓存产品特点 支持数据持久化：可将内存数据保存到磁盘，重启的时候再次加载使用 支持简单","tags":["database"],"title":"1 Redis 简介","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  1.1 敏捷中的角色  1.1.1 Scrum Master 流程管理员 1.1.2 Product Owner 产品负责人  1.2 跨职能团队 1.3 敏捷团队如何计划工作 1.4 用户故事 user story  1.4.1 用户故事和任务的关系  1.5 故事何时完成  1.5.1 验收标准(acceptance criteria) 1.5.2 如何定义需求   1.1 敏捷中的角色 1.1.1 Scrum Master 流程管理员  流程管理员是团队领导，帮助团队成员实现敏捷计划。责任包括  保证所有角色和机能之间的紧密合作 移除阻碍 保护团队免受打扰 和组织一起跟踪公司的进度和流程 保证敏捷的检查与调整   1.1.2 Product Owner 产品负责人  从业务角度推动产品。责任包括  定义需求，评估需求的优先级 确定发布的实际和内容 在迭代计划和发布计划会议中承担积极的角色 确保团队致力于最有价值的需求 接受满足完成标准和定义好的验收标准(acceptance criteria)用户故事(user story)   1.2 跨职能团队  每个敏捷团队应当是一个自满足的团队，成员是 5-9 人，平均经验是 6-10 年 典型的敏捷团队包括 3-4 位开发者，1 位测试，1 位技术领导， 1 位产品负责人和 1 位流程管理员  产品负责人和流程管理员作为团队接口，其他成员是技术接口   1.3 敏捷团队如何计划工作  迭代实现用户故事，每个迭代周期是 10-15 天 point 点：定义一个团队可以提交完成。一般是 8 个小时。每个故事用点评估 capacity 能力：定义一个人可以提交完成。用小时评估  1.4 用户故事 user story  一个用户故事是一个需求，定义用户所需作为功能  在发布计划中，使用相对范围的点数粗略的评估一个用户故事 在迭代计划中，将用户故事分解成任务(task)   1.4.1 用户故事和任务的关系  用户故事描述要完成什么，定义了用户所需；任务描述如何完成它，定义了要实现的功能 故事是通过任务实现，每个故事是任务的一个集合 当把用户固执放在当前迭代计划时，用户故事被分解成任务 任务用小时评估，一般是 2-12 个小时 故事通过验收测试进行验证  1.5 故事何时完成  团队定义完成的含义。标准可能是  所有的任务(开发和测试)被完成 所有的验收测试在运行并通过 没有开放的缺陷(defect) 产品负责人已经接受了故事 可交付给终端用户   1.5.1 验收标准(acceptance criteria)  标准定义一个特性需要的功能、行为和性能，以便产品负责人可以接受 它定义了要完成什么以便开发者知道一个用户故事何时完成  1.5.2 如何定义需求  需求可以定义为  一个用户故事 包含验收标准 包含完成这个故事的任务   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ba4d99d4171a3d0bea1e6a5d742bb867","permalink":"https://xueqing.github.io/translation/agile/tutorial/1-primer/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/1-primer/","section":"translation","summary":"1.1 敏捷中的角色 1.1.1 Scrum Master 流程管理员 1.1.2 Product Owner 产品负责人 1.2 跨职能团队 1.3 敏捷团队如何计划工作 1.4 用户故事 user story 1.4.1 用户故事和任务的关系 1.5 故事何时完成 1.5.1 验收标准","tags":["agile"],"title":"1 入门","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  1.1 支付流程 1.2 交易流水 1.3 会计主体 1.4 会计要素 1.5 会计科目 1.6 会计账户 1.7 记账凭证 1.8 会计分录和记账 1.9 更多问题  1.1 支付流程  先说个比较简单的支付场景，用户(小明)用绑定的银行卡(工行)购买某电商公司(老熊公司)的产品。小明需要先在老熊公司网站上完成银行卡绑定的操作。绑卡以后，就可使用这个卡来购买商品。首先是挑选商品和下单，其后是执行支付。下单之前的流程不做介绍，从支付开始说明支付过程中的清结算问题 为了简化，先从比较简单的同渠道、公司内购买的场景开始。商品也先假定为虚拟产品(如会员卡)。为了实现这个流程，有一些前置的操作需要完成：  老熊公司已对接工行的快捷支付接口。通过这个接口，可实现绑卡(签约)、支付、退款、查单等操作 老熊公司已按照工行要求，在工行开了备付金账户。老熊公司通过工行接口的所有收款、退款等资金往来，都发生在这个账户 小明在老熊公司的应用中绑定了自己的一张卡，为了简化处理，小明绑定的也是工行的卡，先省略跨行结算的步骤  用户小明在手机或 PC Web 上购买了 100 元的虚拟产品(如会员卡)。这里先从虚拟物品入手，因为实体物品情况会复杂一点，供应链和物流也是一个大课题，购买实体物品就需要考虑这个问题，而虚拟产品就可暂不考虑。然后小明在网站上执行下单、支付操作 老熊公司的支付系统收到小明的支付操作请求后，系统首先会校验订单是否有问题，然后调用工行快捷支付接口，从用户的工行卡上扣除 100 元  用户的工行卡的扣款是实时进行的，也就是说，这个操作完成后，小明查看他的工行余额和流水，会有一笔 100 元的交易，并且账户余额也减少了 100 元 但是这个钱并不是直接进入老熊公司的(结算)账户。工行在第二天凌晨会对前天的交易进行清算和结算。在计算收入的同时，也从中扣除掉通道费用，得到最终应该划拨到结算账户上的金额。在这个例子中假定手续费按支付金额收费，比例为 0.1%。这一笔交易，支付给工行 0.10 元，公司收入 99.9 元 这里需要注意。有些银行是在扣除手续费后，将前一天的余额全部划拨到结算账户上；有些银行是先全额划拨所有收入到结算账户上，然后扣除手续费   1.2 交易流水  用户执行支付后，系统首先需要记录交易流水，流水的内容包括：  交易主体：即发起本次交易的出款的用户，一般是记录 ID、姓名等信息 交易账户：即用户购买时使用的出款账户，这是用户在工行的卡，实际账户是建立在工行，但在电商系统中，为了便于结算，为这个账户建立一个代理。这个账户在系统中的 ID 是 10001(数据本身无其他含义) 交易对手：即出卖虚拟产品的业务部门，一般记录部门的 ID、名称等信息 结算收益：交易对手能够拿到的金额。这里是支付金额-渠道费用，即 99.9 元 对手账户：即虚拟产品的收款账户，为了便于结算，公司一般会对每项业务设置独立的结算账户。这个账户在系统中的 ID 是 20001(数据本身无其他含义) 交易渠道：即工行的快捷支付，还需要记录渠道的 ID，名称等 渠道结算账号：这也是个代理账号，记录在渠道侧的交易流水。注册在电商侧，是电商自己的账户 渠道提交时间：请求渠道执行支付的时间 渠道支付时间：渠道一般会在返回的报文中说明本次交易的执行时间。如果没有，则使用渠道的支付接口返回时间 渠道费率：渠道的手续费，这里假定工行是按支付金额收费，比例为支付金额的 0.1% 渠道费用：这里是支付金额*手续费率，即 0.1 元 发起交易日期：2016年12月12日 13:00:10，即用户提交订单后，虚拟产品业务调用支付系统接口执行支付的时间 执行交易日期：2016年12月12日 13:00:11，即支付系统接口调用时间 支付截止日期：必须在此日期前完成支付 订单信息：在本例子中是会员卡，一般需要记录业务方订单 ID、名称、内容等信息 订单金额：提交过来的原始订单的金额 100 元 支付金额：用户实际支付的金额，由于没有使用优惠券、打折卡等，这里支付金额等于订单金额，是 100元  没有使用卡券、没有和合作方分成，这两块内容暂不记录 交易流水是在完成支付时实时生成的。这个流水信息是后续记账的依据，所以务必在流水中真实记录能收集到的所有的现场信息。这里从下面几个角度来多方位全角度的描述这笔交易  交易主体，即掏钱的小明 交易对手，即收钱的业务方 交易渠道，即工行快捷 交易商品，即会员卡  这里有不少冗余信息。实际上对交易涉及到所有可能会被修改的信息，如用户姓名、商品名称、商品价格，都需要在这里留一个快照，以便后续回溯和审核  1.3 会计主体  这一笔账是老熊公司的账务，不是工行的账务，也不是小明家的账务。虽然这里会有工行和小明的信息，但记账的目的是为了了解和改进老熊公司的经营状况服务 老熊公司不是某个大公司的分公司或子公司，它是一家独立核算的、具有独立的资金和经营业务的单位，从会计学角度来说，他是一个独立的会计实体  1.4 会计要素  从概念上说，所有和钱有关的活动，买会员、用户充值、支付手续费等，都需要记账，这些活动，称之为会计对象 每个公司都有不同的会计对象，有时候同一类活动，叫法不一样。如果直接用这些活动内容来记账，那就没法比较每个公司的情况。需要有一个记账的标准，让大家分门别类的做记录 对会计对象做规范化的管理，这就引入会计要素的概念  会计要素是对会计对象进行的基本分类，是会计核算对象的具体化。如果说会计对象是个 Object，则会计要素是定义这个 Object 的 Class 不同的国家对会计要素有不同的规定 国际会计准则委员会(IASC)在《编制和呈报财务报表的结构》将会计要素其归类为资产、负债、权益、收益和费用五个要素 美国财务会计准则委员会(FASB)在《财务会计概念公告》中将会计要素归类为资产、负债、所有者权益(净资产)、业主投资、派给业主款、综合收益、营业收入、费用、利润、损失十个要素 我国《会计准则》将会计要素归类为资产、负债、所有者权益、收入、费用和利润六个要素。其中资产、负债和所有者权益，是反应公司的财务状况的。它满足如下恒等式： \u0026gt; 资产=负债+所有者权益   1.5 会计科目  六大会计要素指明了需要记账的 scope，但毕竟粒度还是太大了。为了更详细地了解公司财务情况，引入会计科目来对会计对象进行第二层次的划分 使用 IT 的语言来说，会计科目其实就是一个分类体系，用来分门别类地记账 在实现上，是一个编号+名称，IT 俗称字典表 从定义上说，会计科目是指一个涵义明确、概念清楚、简明扼要、通俗易懂的标准名称 会计科目按照经济内容的性质不同，可分为资产类科目、负债类科目、所有者权益类科目、损益类科目，成本类科目，有些金融企业还有资产负债共同类科目。在每一类会计科目下，还可继续细分，详细内容可参考2016年财政部发布的新会计准则。会计科目和要素之间的关系如下   | 会计要素 | 所属会计科目 | | \u0026mdash; | \u0026mdash; | | 资产 | 资产 | | 负债 | 负债 | | 所有者权益 | 所有者权益 | | 收入 | 损益 | | 费用 | 损益、成本 | | 利润 | 损益 | | - | 共同 |\n 会计科目还分为总账科目和明细科目。从IT角度，可认为总账科目是一级分类，而明细科目则是这个一级分类下的二级、三级，甚至更多级别的详细的科目。记账时，会同时记录到总账、明细科目。在电商的支付系统中，一般会设置如下科目  | 会计科目编号 | 会计科目名称 | | \u0026mdash; | \u0026mdash; | | 1002 | 银行存款(资产类) | | 100201 | 业务收款 | | 100201001 | 支付宝收款 | | 100201002 | 工行收款 | | 100201003 | 建行收款 | | 1004 | 服务成本(成本类) | | 100401001 | 支付宝手续费 | | 100401002 | 工行手续费 | | 100401003 | 建行手续费 | | 6001 | 主营业务收入(损益类) | | 6001001 | 会员卡业务 | | 6001002 | 游戏业务 |\n1.6 会计账户  账户：指对会计要素的具体内容所作的科学的分类，包括两方面：账户的名称、账户的用途与结构 会计科目是设置账户的依据，也是账户的名称。如对银行存款这个会计科目，也会设置一个对应的银行存款账户，用来跟踪公司在银行存款的变动 在这个案例中，将设置的账户同会计科目。  1.7 记账凭证  在以前没有电脑的时候，去买公交卡，公交公司阿姨会认真地记录你买的卡的卡号、买卡人的姓名、卡的面值等信息，运气好的时候还会给个发票。一般来说，阿姨会将购买记录登记到一个账册上，形成记账凭证，并在这里会登记发票号码 在现在高科技时代，这个凭证还是少不了了。先说明细账，记录内容如下  这里详细记录每一条交易信息，当然，通过计算机系统，可记录更多详情，包括时间、地点等  1.8 会计分录和记账  大家经常看到的记录应该是这样的  银行存款、服务成本、主营业务收入，属于总账科目 工行收款、会员卡、工行手续费，属于明细科目 这里采用的是复式记账法中借贷记账法。对应的账户结构如下：  借贷复式记账法的特点是\n 采用借、贷作为记账符号，建立在会计恒等式基础上，遵循有借必有贷，借贷必相等的原则 账户基本结构是： 左侧为借，右侧为贷 一般采用如上图所示的 T 行账户的形式来描述 借贷所代表的增加、减少的含义并不固定，和账户的性质有关     借方 贷方     资产增加 资产减少   权益减少 权益增加   成本增加 成本减少   收入减少 收入增加   费用及支出增加 费用及支出减少     1.9 更多问题  作为清结算的入门介绍，这里介绍的是最简单的场景，以此来解释清结算相关的概念，特别是会计学一些从IT角度不容易理解的名词。实际上，这个场景还有很多问题：  严格的说，会员卡的收入，还不能立即作为公司主营业务收入。会员卡是预付款项，用户开始使用会员卡，公司需要为这个使用提供服务；用户结束使用会员卡之后，这一笔开支才算是真正落入公司主营业务收入中 会员卡在使用期间，公司针对会员业务的各种开销，要分摊到这一段期间的会员上。将开销分摊到每张会员卡上，计算其使用成本，最终才能够计算出收益 用户会员卡购买的款项是立即反映到备付金账户的，但并不是立即到结算账户的，一般是 T+1 结算，也就是第二天银行才会将清算好的资金打到公司结算账户上，这种情况应该如何记账？ 如果支付过程中使用了代金券和优惠券，那又应该如何考虑？  此外，还有退款、充值等场景的清结算，这些问题都将在本系列的文章中详细介绍。本文仅介绍一些相关的概念  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6db0901b17a9168d4f31fe6dfb1ff4b6","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/1_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%85%A5%E9%97%A8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/1_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%85%A5%E9%97%A8/","section":"blog","summary":"1.1 支付流程 1.2 交易流水 1.3 会计主体 1.4 会计要素 1.5 会计科目 1.6 会计账户 1.7 记账凭证 1.8 会计分录和记账 1.9 更多问题 1.1 支付流程 先说个比较简单的支付场景，用户(小","tags":["o2o"],"title":"1 基本概念和入门","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1.1 环境要求 1.2 配置 Python 环境  1.2.1 配置 Python 1.2.2 配置 pip 1.2.3 配置 python3-venv  1.2 创建和激活虚拟环境 1.3 使用 django CMS installer 1.4 启动 runserver  1.1 环境要求 django CMS 要求 Django \u0026gt;=1.11，Python 2.7/\u0026gt;=3.3。下面使用 Python3。\n1.2 配置 Python 环境 1.2.1 配置 Python 本地环境是 ubuntu 16.04。\n# 查看本地的 Python 版本 python # python python2 python2.7 python3 python3.5 python3.5m python3m # 配置 python2.7 和 python3 sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 100 # update-alternatives: using /usr/bin/python2.7 to provide /usr/bin/python (python) in auto mode sudo update-alternatives --install /usr/bin/python python /usr/bin/python3 2 # 配置使用 python3，选择 2，即 /usr/bin/python3 sudo update-alternatives --config python  1.2.2 配置 pip pip 是 Python 包管理工具。\nsudo apt-get install python-pip python3-pip # 可能会有 warning: not replacing /usr/bin/pip with a link 错误， ll /usr/bin/pip* 查看可知道 /usr/bin/pip 不是一个软链接，可以删除 /usr/bin/pip，再重新执行 --install 命令 sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip2 100 sudo update-alternatives --install /usr/bin/pip pip /usr/bin/pip3 2 # 配置使用 pip3，选择 2，即 /usr/bin/pip3 sudo update-alternatives --config pip  1.2.3 配置 python3-venv 在 Debian/Ubuntu系统，需要使用 apt-get install python3-venv 命令安装 python3-venv 包。\n1.2 创建和激活虚拟环境 # 创建虚拟环境，遇到 The virtual environment was not created successfully because ensurepip is not availabl ... 错误，参考上述教程安装 python3-venv python -m venv env # 激活虚拟环境 source env/bin/activate # 升级虚拟环境的 pip pip install --upgrade pip  1.3 使用 django CMS installer django CMS installer 是一个帮助设置一个新项目的脚本。\n# 安装 django CMS installer，安装之后可使用 djangocms 命令 (env) kiki@ubuntu:~$ pip install djangocms-installer # 新建目录并切换到该目录 (env) kiki@ubuntu:~$ mkdir mydjango \u0026amp;\u0026amp; cd mydjango # 新建一个 django 项目 (env) kiki@ubuntu:~/mydjango$ djangocms -f -p . mysite  关于 djangocms -f -p . mysite 命令：\n djangocms 表示运行 django CMS installer -f 表示安装 django Filer，是用于 django 的一个文件管理应用 -p . 表示使用当前目录作为新项目目录的父目录 mysite 指定新项目目录的名字  installer 会创建一个管理员用户，用户名/密码 是 admin/admin。\n1.4 启动 runserver (env) kiki@ubuntu:~/mydjango$ python manage.py runserver  在浏览器打开 http://localhost:8000/ 或 http://127.0.0.1:8000/，可以看到登录页面，然后可以新建页面。\n当需要登录时，在 URL 后面添加 ?edit，会启动工具栏，可以输入用户名和密码重新登录并管理网站。\n当前的 Django 版本是 1.11.25，django CMS 版本是 3.6.0。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b5b0722a4c76f4a9731d3d5a02a01ae2","permalink":"https://xueqing.github.io/blog/django_cms/tutorial/1_install/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/django_cms/tutorial/1_install/","section":"blog","summary":"1.1 环境要求 1.2 配置 Python 环境 1.2.1 配置 Python 1.2.2 配置 pip 1.2.3 配置 python3-venv 1.2 创建和激活虚拟环境 1.3 使用 django CMS installer 1.4 启动 runserver 1.1 环境要求 django CMS 要求 Django \u0026gt;=1.11，Python 2","tags":["django"],"title":"1 安装","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1.1 前言 1.2 支付账户和登录账号 1.3 账户的设计需求  1.3.1 交易与账户  1.4 记账与账户  1.4.1 内部账户和外部账户 1.4.2 收款账户和收单账户  1.5 账户建模  1.5.1 实体模型 1.5.2 账户模型 1.5.3 交易模型   1.1 前言  账户体系是支付系统的基础，它的设计直接影响整个系统的特性。这里探讨如何针对电子商务系统的支付账户体系设计  1.2 支付账户和登录账号  支付账户：指用户在支付系统中用于交易的资金所有者权益的凭证 登录账号：指用户在系统中的登录的凭证和个人信息 关系  一个用户可有多个登录账户，一个登录账户可有多个支付账户，如零钱账户，储值卡账户等 一般来说，支付账户不会在多个登录账户之间共用。如没有特殊说明，下文中的账户，都默认指支付账户   1.3 账户的设计需求  在支付系统中，账户的设置，主要考虑的方面  交易需求：如检查账户是否被锁定、余额是否足够、是否有效等 记账需求：按照公司会计需求记录账户上的所有行为，包括支出、充值、转账等 对账需求：包括和支付渠道、商户、个人的对账需求，核对交易和账户余额是否正确 风控需求：如反洗钱、反欺诈等，都需要依赖于账户体系来提供核心数据 信用需求：对用户、资产、商户等主体进行信用评估时，也需要依赖账户体系来提供的核心数据  这五个需求，按照其设计的优先级，也是从支付、记账、对账、风控来进行。支付系统根据其发展所处的阶段，逐步将新增需求纳入设计中  1.3.1 交易与账户  账户设置，一般从交易开始。交易的实现必须有账户的支持，账户是交易的基本构成元素 从支付系统的角度，交易中涉及到的资金流是资金从一个账户流向另一个账户  交易主体：发起交易的一方。可以是个人或机构。资金从该主体所拥有的账户中流出 交易对手：接收交易的一方。可以是个人或机构 渠道：由于电商系统本身并无清结算的资质，所有资金从交易主体到交易对手的账户的流动，在大部分情况下，并没有经过电商系统，而是由电商系统调用支付渠道提供的接口，由它来完成真正的支付过程。在此过程中，渠道要收取费用  所以，在电商系统中，一次交易会涉及到三个账户： 交易主体账户、交易对手账户及支付渠道账户  1.4 记账与账户  记账：公司的会计需要对每一笔交易都要做详细的记录 会计科目：公司每天都产生大量的交易行为，为了方便管理和统计，一个简单的方法是对交易进行分类，比如食品、带宽、办公用品等等。这个分类按照公司的规模和业务复杂度，可以有一级、二级、三级或更多级的结构，这被称之为会计科目 记账时，除了交易明细，还需要在每个级别上对交易额进行汇总  一般来说，一级科目上汇总称为总帐科目，而详细记录称为明细科目 电商系统中，涉及到的参与方较多，记账也相对复杂，但基本方法类似。电商的参与者可以分为商户、买家和渠道，对这三类参与者，都需要分别建立总帐账户和明细账户   1.4.1 内部账户和外部账户  外部账户：支付系统只能记录账户在本系统的明细以及累计消费额，无法得知账户真正余额  用户使用银行卡支付时，电商支付系统需要和银行对接，从用户银行卡所代表的账户上扣除资金 对接了银行、第三方支付等机构的电商支付系统，需要连接到用户在这些机构的账户来执行扣款或者充值操作，这些账户称为外部账户  内部账号：可以知道账号的全部消费明细和余额  零钱：也就是让用户充值到零钱，使用的时候就直接从零钱中扣除。这就需要零钱账号。这是电商系统中自己设立的账号，所以也叫内部账号 除了零钱账号，也可以有储值卡账号，信用账号等   1.4.2 收款账户和收单账户  收款账户：当电商要对接银行时，往往都会被要求开设一个收款账户  用户通过这个银行来支付时，钱就被转到这个账户上。对第三方支付也是一样 收款账户是开设在银行或者第三方支付这边的，即渠道侧。一般来说，渠道每天都可以提供这个账户的交易流水供电商对账用。这样在电商这边，渠道就成为一个收单机构  收单账号：在电商这边，建立这个收款账户对应的对账用的收单账号，用来记录通过这个渠道进行的各项交易流水  开设一个账号，绑定这个收款账户，就可以查这个账户在渠道侧的流水   1.5 账户建模  账户模型和公司业务密切相关，不同规模、发展阶段不同的公司需要不同的模型 账户建模本身包括三大核心模型：实体模型、账户模型和交易模型 明细模型：从交易模型中可以衍生出针对各个角色的账户流水，用于支持对账  1.5.1 实体模型  实体模型：和用户、商户模型有重叠的地方，这里专门针对支付而设置的各个实体属性 一般来说，支付相关的实体模型需要包括如下属性  用户 ID：一般直接映射到登录账户的 ID 是否允许执行支付 支付密码 手机号：用于设置或者重置支付密码 邮箱：用于设置或者重置支付密码 用户的安全等级：根据业务需要来设置   1.5.2 账户模型  根据业务需要，可设置多种账户，如支付账户、预付卡账户、代扣账户、零钱账户、结算账户等 从类别上来说，这里的账户一般指总账账户 一般来说电商系统中涉及的账户类型有：  虚拟币账号：用户和使用奇点奇豆的商户都需要建立虚拟币账户 关于虚拟币：商家先接受虚拟币，如何结算需要和商家定协议 代扣账号：用来支持订阅类型的定期代扣 零钱账号：即电商的内部账号.用户、商户、清算单位需要建立零钱账户 第三方支付账号：用户在第三方支付机构建立的账户 银行卡账号：用户的银行卡信息，每个卡对应一个账户 结算账号：用来支持和第三方支付公司、银行进行结算用。第三方支付需要为每个商户号建立结算账号；银行需要为借记卡、贷记卡分别建立结算账号(有必要吗？银行卡直连时使用) 代扣代缴账户：用来支持代扣税款业务  对这些账户，需要设置如下属性  基本属性 账户号(账户 ID)：一般是系统自动生成。特别注意，要事先约定好账户 ID 的规则。如头三位用来表示账户类型，后几位用来表示账户编号等。务必保证根据账号号能快速确定账户类型，且保证账户号不重复 账户名称：一般由用户自己设置的，显示用 账户使用的货币类型：注意虽然一张银行卡可以支持多个币种，实际在内部，还是针对每个币种建立独立的子账户。涉及到多币种的账户，也可以采用类似的建模方案 会计科目代码：一般是一级会计科目的代码 账户控制相关 是否允许充值 是否允许提现 是否允许透支 是否允许支付 是否允许转账进入 是否允许转账转出 是否有安全保障 是否激活 是否冻结 资金相关 当前账户余额：等于可用余额+冻结余额 当前账户可用余额 当前账户冻结余额：指账户上暂不能使用的额度。在支付的时候，往往是先冻结，商品出库后，再实际执行扣款 银行卡、第三方支付信息 第三方实体 ID 第三方账号：如银行卡号或在第三方支付的 open_id 等 第三方 app_id 账号失效日期：该账号什么时候失效  注意  有些第三方信息不能保存(如用户的账号密码、信用卡的 CV 号) 为了避免账户信息被爬库或者数据库信息意外泄露，一般还需要对敏感字段(如密码)进行加密保存，甚至保存到另外的表中 更进一步，为了避免账户信息被意外修改，还可增加一个校验字段，在写入数据时设置该字段，在读取数据时做校验，一旦发现数据有问题，则关闭该账号   1.5.3 交易模型  考虑到交易记录将被用于风控和信用分析，能收集到的信息是越全面越好  流水号：每一笔交易的流水号不同。需要根据业务情况详细设计流水号。流水号往往也是对交易表做分表分库的依据 交易记录创建时间 交易记录最后修改时间 会计科目代码 关联的订单号，由商户提供 订单名称、描述、关联的地址等信息 费用信息：包括结算货币类型、原始费用、实际费用等 交易主体信息：记录主体 ID、类型、名字、账号、账号类型、使用的 IP 地址、手机号、平台、通知邮箱、当前位置等。这些信息虽可以从主体表中获取，但考虑主体表信息随时会被修改，所以这里需要记录详细的各原始信息 交易对手信息：记录对手主体 ID、类型、名字、账号、账号类型、手机号、平台、通知邮箱等 交易渠道信息：记录所使用的交易渠道的实体 id、渠道账户、渠道执行支付的时间、渠道侧返回的订单号等。如有错误发生，还需要记录从渠道接收到的错误信息和错误码   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"111ae3d9aa5489a6cc9f0a6a9cffb769","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/1_%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/1_%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%B4%A6%E6%88%B7%E6%A8%A1%E5%9E%8B/","section":"blog","summary":"1.1 前言 1.2 支付账户和登录账号 1.3 账户的设计需求 1.3.1 交易与账户 1.4 记账与账户 1.4.1 内部账户和外部账户 1.4.2 收款账户和收单账户 1.5 账户建模 1.5.1 实体模型 1.5.2 账户模型 1.5.3 交","tags":["o2o"],"title":"1 支付系统的账户模型","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"264e7cd04e368625c1c97ad20382d7e6","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/1-introduction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/1-introduction/","section":"blog","summary":"","tags":["sa","engineer"],"title":"1 概述","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1.1 操作系统概述  1.1.1 操作系统  1.2 UNIX vs Linux  1.2.1 UNIX/Linux 系统结构  1.3 Linux 系统的优缺点 1.4 Linux 的发行版  1.4.1 Linux 发行版及特点汇总 1.4.2 Linux 发行版本的选择  1.5 Linux 应用领域  1.5.1 服务器 1.5.2 电影工业 1.5.3 嵌入式应用  1.6 开源软件 1.7 开源协议  1.7.1 Apache 许可证版本(Apache License Version)协议 1.7.2 BSD(Berkeley Software Distribution，伯克利软件发布版)协议 1.7.3 GNU GPL(GNU General Public License，GNU 通用公共许可证) 1.7.4 GUN LGPL(GNU Lesser General Public License，GNU 宽通用公共许可证) 1.7.5 MIT(Massachusetts Institute of Technology)协议 1.7.6 如何选择开源协议  1.3 Linux vs Windows  1.1 操作系统概述  计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。计算机由硬件和软件组成  硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等 软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序   1.1.1 操作系统  操作系统(Operating System，OS)是软件的一部分，是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等) 操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能。如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如\n 文件系统：提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式 设备驱动程序：提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节 用户接口：操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式 系统服务程序：当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作   目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等，手机操作系统有 Android、iOS、Windows Phone(简称 WP)，嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等\n  1.2 UNIX vs Linux  区别  UNIX 系统大多是与硬件配套的，即大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上 UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码  联系  Linux 是一套免费使用和自由传播的类 Unix 操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化 Linux 是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统 Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件 Linux 继承了 UNIX 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统   1.2.1 UNIX/Linux 系统结构  UNIX/Linux 系统可以粗糙地抽象为 3 个层次，如图所示。底层是 UNIX/Linux 操作系统，即系统内核(Kernel)；中间层是 Shell 层，即命令解释层；高层则是应用层    内核层：UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源(硬件资源和软件资源)，有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境 Shell 层：与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作 应用层：提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能(就如同 TCP/IP 是一个协议，定义软件所应具备的功能)，系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window  1.3 Linux 系统的优缺点  Linux 不可比拟的优势  大量的可用软件及免费软件：比如 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义 良好的可移植性及灵活注：几乎支持所有的 CPU 平台，使得它便于裁剪和定制。可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用 如果希望不进行安装就体验 Linux 系统，可在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS/BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统 优良的稳定性和安全性：Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注 支持几乎所有的网络协议及开发语言：UNIX 系统是与 C 语言、TCP/IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而网络协议都与 TCP/IP 有关。所以，Linux 对网络协议和开发语言的支持很好  Linux 的缺点：桌面应用还有待完善(Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏)、Linux 的标准统一还需要推广、开源软件的盈利模式与发展还有待考验等  1.4 Linux 的发行版  从技术上来说，李纳斯•托瓦兹开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心 Linux 的发行版：一些组织或厂商将 Linux 内核与各种软件和文档包做一个打包，并提供系统安装界面和系统配置、设定与管理工具 Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层(由发行商整合开发的应用)才有所体现   Linux 的发行版本可以大体分为两类  商业公司维护的发行版本，以著名的 Red Hat 为代表 社区组织维护的发行版本，以 Debian 为代表  知名的发行版  Ubuntu：基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供 Red Hat：公司的产品主要包括 RHEL(Red Hat Enterprise Linux，收费版本)和 CentOS(RHEL 的社区克隆版本，免费版本)、Fedora Core(由 Red Hat 桌面版发展而来，免费版本) CentOS 是基于 Red Hat Enterprise Linux 源代码重新编译、去除 Red Hat 商标的产物，各种操作使用和付费版本没有区别，且完全免费。缺点是不向用户提供技术支持，也不负任何商业责任 SuSE Linux：可以非常方便地实现与 Windows 的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便 Gentoo Linux：所有 Linux 发行版本里安装最复杂的，到目前为止仍采用源码包编译安装操作系统。不过，它是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。具有高度的自定制性(基于源代码的发行版)。尽管安装时可以选择预先编译好的软件包，但是大部分使用 Gentoo 的用户都选择自己手动编译，因此适合比较有 Linux 使用经验的用户使用   1.4.1 Linux 发行版及特点汇总    版本名称 网址 特点 软件包管理器     Debian Linux www.debian.org 开放的开发模式，且易于进行软件包升级 apt   Ubuntu www.ubuntu.com 优秀易用的桌面环境，基于 Debian 构建 apt   Fedora Core www.redhat.com 拥有数量庞人的用户，优秀的社区技术支持。并且有许多创新 up2date(rpm)，yum (rpm)   CentOS www.centos.org CentOS 就是将商业的 Linux 操作系统 RHEL 进行源代码再编译后分发，并在 RHEL 的基础上修正了不少已知的漏洞 rpm   SuSE Linux www.suse.com 专业的操作系统，易用的 YaST 软件包管理系统 YaST(rpm)，第三方 apt (rpm)软件库(repository)   Gentoo Linux www.gentoo.org 高度的可定制性，使用手册完整 portage    1.4.2 Linux 发行版本的选择  Linux 的发行版本众多，选择 Linux 发行版本的建议  如果只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu 如果需要一个服务器系统，且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议选择 CentOS 或 RHEL 如果需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE 如果想深入摸索一下 Linux 各个方面的知识，而且想非常灵活地定制自己的 Linux 系统，选择 Gentoo   1.5 Linux 应用领域 1.5.1 服务器  通常服务器使用 LAMP(Linux + Apache + MySQL + PHP)或 LNMP(Linux + Nginx+ MySQL + PHP)组合 服务器使用 Linux 而不使用 UNIX 或 Windows：使用 Linux 成本较低，而 UNIX 和 Windows 都是商业软件；而且 Linux 服务器非常高效和稳定  1.5.2 电影工业  Linux 作为开源软件，可以节省大量成本 Linux 具有商业软件不具备的功能定制化特点，各家电影厂商都可依据自己的制片需要铺设相关平台  1.5.3 嵌入式应用  嵌入式系统是以应用为中心，以计算机技术为基础，并且软硬件可定制，适用于各种应用场合，对功能、可靠注、成本、体积、功耗有严格要求的专用计算机系统。它一般由嵌入式微处理器、外围硬件设备、嵌入式操作系统及用户的应用程序 4 部分组成，用于实现对其他设备的控制、监视或管理等 安卓是基于 Linux 的开源系统，主要适用于便携设备，如智能手机和平板电脑等，是Google公司为移动终端打造的真正开放和完整的移动软件  1.6 开源软件  Linux 是一款开源软件，我们可以随意浏览和修改它的源代码 开源软件就是把软件程序与源代码文件一起打包提供给用户，用户既可以不受限制地使用该软件的全部功能，也可以根据自己的需求修改源代码，甚至编制成衍生产品再次发布出去 开源软件的优点  | 优点 | 说明 | | \u0026mdash; | \u0026mdash; | | 低风险 | 一旦封闭的源代码没有人来维护，你将进退维谷；而且相较于商业软件公司，开源社区很少存在倒闭的问题 | | 高品质 | 相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的 bug 还没有等爆发就已经被修补 | | 低成本 | 开源工作者都是在幕后默默且无偿地付出劳动成果，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力 | | 更透明 | 没有人会把木马、后门等放到开放的源代码中，这样无疑是把自己的罪行暴露在阳光之下 |\n 典型的开源软件  | 软件 | 说明 | | \u0026mdash; | \u0026mdash; | | Linux | Linux 是一款开源的操作系统，它的内核由多名极客共同维护。Linux 是开源软件的经典之作、代表之作、巅峰之作 | | Apache | 世界使用排名第一的 Web 服务器软件 | | MySQL | 世界上最流行的关系型数据库，适合中小型网站 | | Firefox | 火狐浏览器。在 Chrome 推出之前，Firefox 几乎是最快速的浏览器，直到现在也是 Web 开发人员的调试利器 | | OpenOffice | 一套跨平台的办公软件套件，类似 Microsoft Office | | GCC | C语言/C++编译器 | | Java、PHP、Python | 开源的编程语言 |\n 国内外开源社区推荐：开源中国、ChinaUnix、GitHub、Apache、SourceForge  1.7 开源协议  开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织(Open Source Initiative)认可的开源许可协议来保证开源工作者的权益 开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么 开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一  1.7.1 Apache 许可证版本(Apache License Version)协议  Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由 现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件  该软件及其衍生品必须继续使用 Apache 许可协议 如果修改了程序源代码，需要在文档中进行声明 若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息 如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议   1.7.2 BSD(Berkeley Software Distribution，伯克利软件发布版)协议  BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件  如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议 不允许用原始软件的名字、作者名字或机构名称进行市场推广  BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发  1.7.3 GNU GPL(GNU General Public License，GNU 通用公共许可证)  只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件 遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的 GPL 开源协议的主要特点  | 特点 | 说明 | | \u0026mdash; | \u0026mdash; | | 复制自由 | 允许把软件复制到任何人的电脑中，并且不限制复制的数量 | | 传播自由 | 允许软件以各种形式进行传播 | | 收费传播 | 允许在各种媒介上出售该软件，但必须提前让买家知道这个软件可以免费获得；因此，开源软件一般是通过为用户提供有偿服务的形式盈利 | | 修改自由 | 允许开发人员增加或删除软件的功能，但软件修改后必须依然基于 GPL 许可协议授权 |\n1.7.4 GUN LGPL(GNU Lesser General Public License，GNU 宽通用公共许可证)  LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议 LGPL 允许商业软件通过类库引用(link)的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售 但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议 因此 LGPL 协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用  1.7.5 MIT(Massachusetts Institute of Technology)协议  目前限制最少的开源许可协议之一(比 BSD 和 Apache 的限制都少)，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用 使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等  1.7.6 如何选择开源协议 1.3 Linux vs Windows  目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下     比较 Windows Linux     界面 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致   驱动程序 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题(是否存在和安装方法)会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解   使用 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利 图形界面使用简单，容易入门。文字界面，需要学习才能掌握   学习 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易   软件 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权 大部分软件都可以自由获取，同样功能的软件选择较少   大小写 不区分 区分   扩展名 依赖以区分文件类型 不区分。通过权限位标识确定文件类型     Linux 中的一些特殊文件要求写\u0026rdquo;扩展名\u0026rdquo;，但并不是 Linux 一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有  压缩包：Linux 下常见的压缩文件名有 gz/bz2/zip/tar.gz/tar.bz2/tgz 等。就算没写扩展名，在 Linux 中一样可以解压缩，不影响使用 二进制软件包：CentOS 中所使用的二进制安装包是 RPM 包，所有 RPM 包用 rpm 扩展名结尾，目的同样是让管理员一目了然 程序文件：Shell 脚本一般用 sh 扩展名结尾，其他还有用 c 扩展名结尾的 C 语言文件等 网页文件：网页文件一般使用 php 等结尾，不过这是网页服务器的要求，而不是 Linux 的要求   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a5d1aa1255daee9b059d5c0bd5b718f7","permalink":"https://xueqing.github.io/blog/linux/1_%E7%AE%80%E4%BB%8B/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/1_%E7%AE%80%E4%BB%8B/","section":"blog","summary":"1.1 操作系统概述 1.1.1 操作系统 1.2 UNIX vs Linux 1.2.1 UNIX/Linux 系统结构 1.3 Linux 系统的优缺点 1.4 Linux 的发行版 1.4.1 Linux 发行版及特点汇总 1.4.2 Linux 发行版本的选择 1.5 Linux 应用领域 1.5.1 服务器 1.5.2 电影工业","tags":["linux"],"title":"1 简介","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  2.1 内核引导 2.2 运行init  2.2.1 运行级别  2.3 系统初始化 2.4 建立终端 2.5 用户登录系统 2.5.1 图形模式与文字模式的切换方式 2.6 Linux 关机\n Linux 系统的启动过程可以分为 5 个阶段\n 内核的引导 运行 init 系统初始化 建立终端 用户登录系统  init 程序的类型\n SysV: init，CentOS 5之前，配置文件：/etc/inittab Upstart: init，CentOS 6，配置文件：/etc/inittab，/etc/init/*.conf Systemd： systemd，CentOS 7，配置文件：/usr/lib/systemd/system，/etc/systemd/system   2.1 内核引导  当计算机打开电源后，首先是 BIOS 开机自检，按照 BIOS 中设置的启动设备(通常是硬盘)来启动 操作系统接管硬件以后，首先读入/boot目录下的内核文件  2.2 运行init  init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动 init 程序首先是需要读取配置文件/etc/inittab  2.2.1 运行级别  许多程序需要开机启动。它们在 Windows 叫做\u0026rdquo;服务\u0026rdquo;(service)，在Linux就叫做\u0026rdquo;守护进程\u0026rdquo;(daemon) init 进程的一大任务，就是去运行这些开机启动的程序 但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要 Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做\u0026rdquo;运行级别\u0026rdquo;(runlevel)。也就是说，启动时根据\u0026rdquo;运行级别\u0026rdquo;，确定要运行哪些程序。Linux 系统有 7 个运行级别(runlevel)  运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动 运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆 运行级别 2：多用户状态(没有NFS) 运行级别 3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式 运行级别 4：系统未使用，保留 运行级别 5：X11 控制台，登陆后进入图形 GUI 模式 运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动   2.3 系统初始化  在 init 的配置文件中有这么一行：si::sysinit:/etc/rc.d/rc.sysinit  它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作 rc.sysinit是每一个运行级别都要首先运行的重要脚本 它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务  l5:5:wait:/etc/rc.d/rc 5这一行表示以 5 为参数运行/etc/rc.d/rc  /etc/rc.d/rc是一个 Shell 脚本，它接受 5 作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的 rc 启动脚本 /etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际上都是放在/etc/rc.d/init.d/目录下 而这些 rc 启动脚本有着类似的用法，它们一般能接受 start、stop、restart、status 等参数。 /etc/rc.d/rc5.d/中的 rc 启动脚本通常是 K 或 S 开头的链接文件 对于以 S 开头的启动脚本，将以 start 参数来运行 而如果发现存在相应的脚本也存在 K 打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以 stop 为参数停止这些已经启动了的守护进程，然后再重新运行 这样做是为了保证是当 init 改变运行级别时，所有相关的守护进程都将重启  至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的\u0026rdquo;System Services\u0026rdquo;来自行设定  2.4 建立终端  rc 执行完毕后，返回 init。这时基本系统环境已经设置好了，各种守护进程也已经启动了 init 接下来会打开 6 个终端，以便用户登录系统。在inittab中的以下 6 行就是定义了 6 个终端\n1:2345:respawn:/sbin/mingetty tty1 2:2345:respawn:/sbin/mingetty tty2 3:2345:respawn:/sbin/mingetty tty3 4:2345:respawn:/sbin/mingetty tty4 5:2345:respawn:/sbin/mingetty tty5 6:2345:respawn:/sbin/mingetty tty6  从上面可以看出在 2、3、4、5 的运行级别中都将以respawn方式运行mingetty程序\n mingetty程序能打开终端、设置模式 同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给 login 程序来验证用户的身份   2.5 用户登录系统  一般来说，用户的登录方式有三种  命令行登录 ssh 登录 图形界面登录  对于运行级别为 5 的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器 文本方式登录：当我们看到 mingetty 的登录界面时，我们就可以输入用户名和密码来登录系统了 Linux 的账号验证程序是 login  login 会接收 mingetty 传来的用户名作为用户名参数 然后 login 会对用户名进行分析：如果用户名不是 root，且存在/etc/nologin文件，login 将输出 nologin 文件的内容，然后退出 这通常用来系统维护时防止非 root 用户登录。只有/etc/securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录 /etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制   2.5.1 图形模式与文字模式的切换方式  Linux 预设提供了六个命令窗口终端机让我们来登录 默认我们登录的就是第一个窗口，也就是 tty1，这个六个窗口分别为 tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。 如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面 当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7就回来了 如果你用的 vmware 虚拟机，命令窗口切换的快捷键为Alt + Space + F1~F6。如果你在图形界面下请按Alt + Shift + Ctrl + F1~F6切换至命令窗口  2.6 Linux 关机  在 Linux 领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情-况下，不得已才会关机  | 命令 | 功能 | 备注 | 命令示例 | | sync | 将数据由内存同步到硬盘中 | 重启或关闭系统前运行sync命令，把内存数据写到磁盘 | - | | shutdown | 给系统计划一个时间关机 | 如果使用了时间参数，系统关机前 5 分钟会创建/run/nologin文件。以确保没有人可以再登录 | shutdown [-h|-r] now 现在停止(默认)/关闭/重启机器 | | halt | 关闭系统，通知硬件来停止所有的 CPU 功能，但仍然保持通电。你可以用它使系统处于低层维护状态。一般需要手动重启或关机。注意在有些情况会它会完全关闭系统(某些Linux 发布版的微调) | 等同于shutdown –h now和 poweroff | halt -p 关闭系统后关闭电源 | | poweroff | 会发送一个 ACPI 信号来通知系统关机(关闭计算机操作系统并切断系统电源) | 等同于shutdown now| poweroff -h 关闭操作系统之前将系统中所有的硬件设置为备用模式 | | reboot | 重新启动正在运行的操作系统 | 等同于shutdown –r now | reboot |\n 正确的关机流程为：sync \u0026gt; shutdown \u0026gt; reboot \u0026gt; halt  最好在重启前执行几次sync命令，可以让暂时保存在内存中的数据同步到硬盘上 建议使用shutdown –r now重启。在重启时会正常保存和中止服务器中正在运行的程序，是安全命令  可以运行如下命令关机\nshutdown shutdown now shutdown 20:25 # 10 分钟后关机 shutdown –h +10 # 10 分钟后关机，并且会显示在登陆用户的当前屏幕中 shutdown –h 10 # 在 20:25 关机 shutdown –h 20:25 # 10 分钟后重启 shutdown –r +10 # 要取消即将进行的关机 shutdown -c  关机的命令有shutdown –h now/halt/poweroff/init 0\n 重启系统的命令有shutdown –r now/reboot/init 6\n 注意\n 远程服务器在重启前，要中止正在执行的服务。计算机的硬盘最怕在高速存储时断电或重启，非常容易造成硬盘损坏。所以，在重启前先中止服务，甚至可以考虑暂时断开对外提供服务的网络   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"73aebfdeb27b3692460da527dd85eb75","permalink":"https://xueqing.github.io/blog/linux/2_%E5%90%AF%E5%8A%A8/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/2_%E5%90%AF%E5%8A%A8/","section":"blog","summary":"2.1 内核引导 2.2 运行init 2.2.1 运行级别 2.3 系统初始化 2.4 建立终端 2.5 用户登录系统 2.5.1 图形模式与文字模式的切换方式 2.6 Linux 关机 Linux 系统的启动过程可以分为 5 个阶段","tags":["linux"],"title":"2 Linux 系统启动过程","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  2.1 命令 2.2 键命令 2.3 字符串命令 2.4 哈希命令 2.5 列表命令 2.6 集合命令 2.7 有序集合命令 2.8 Redis HyperLogLog 命令 2.9 Redis 发布订阅命令 2.10 Redis 事务命令 2.11 Redis 脚本命令 2.12 Redis 连接命令 2.13 Redis 服务器命令  2.1 命令 通过 Redis 客户端再 Redis 服务上执行 Redis 命令\n# 启动客户端，连接本地 redis 服务 redis-cli # 检查 redis 服务是否启动 PING # 连接远程 redis 服务 redis-cli -h host -p port -a password   避免中文乱码 redis-cli --raw  2.2 键命令 用于管理 redis 的 key：COMMAND key_name\n   命令 描述     DEL key key 存在时删除 key   DUMP key 序列化 key，返回被序列化的值   EXISTS key 检查 key 是否存在   EXPIRE key seconds 为给定 key 设置过期时间，以秒计   EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)   PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计   PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计   KEYS pattern 查找所有符合给定模式(pattern)的 key   MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中   PERSIST key 移除 key 的过期时间，key 将持久保持   PTTL key 以毫秒为单位返回 key 的剩余的过期时间   TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)   RANDOMKEY 从当前数据库中随机返回一个 key   RENAME key newkey 修改 key 的名称   RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey   TYPE key 返回 key 所储存的值的类型    2.3 字符串命令 用于管理字符串值：COMMAND key_name\n   命令 描述     SET key value 设置 key 的值   GET key 获取 key 的值   GETRANGE key start end 返回 key 中字符串值的子字符   GETSET key value 将 key 的值设为 value ，并返回 key 的旧值(old value)   GETBIT key offset 对 key 所储存的字符串值，获取指定偏移量上的位(bit)   MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值   SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)   SETEX key seconds value 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (秒)   SETNX key value 只有在 key 不存在时设置 key 的值   SETRANGE key offset value 用 value 覆写给定 key 所储存的字符串值，从偏移量 offset 开始   STRLEN key 返回 key 所储存的字符串值的长度   MSET key value [key value \u0026hellip;] 同时设置一个或多个 key-value 对   MSETNX key value [key value \u0026hellip;] 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在   PSETEX key milliseconds value 和 SETEX 命令相似，以毫秒为单位设置 key 的生存时间   INCR key 将 key 中储存的数字值增一   INCRBY key increment 将 key 所储存的值加上给定的增量值(increment)   INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值(increment)   DECR key 将 key 中储存的数字值减 1   DECRBY key decrement key 所储存的值减去给定的减量值(decrement)   APPEND key value 如果 key 已经存在并且是一个字符串， 将 value 追加到该 key 原来值的末尾    2.4 哈希命令    命令 描述     HDEL key field1 [field2] 删除一个或多个哈希表字段   HEXISTS key field 查看哈希表 key 中，指定的字段是否存在   HGET key field 获取存储在哈希表中指定字段的值   HGETALL key 获取在哈希表中指定 key 的所有字段和值   HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment   HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment   HKEYS key 获取所有哈希表中的字段   HLEN key 获取哈希表中字段的数量   HMGET key field1 [field2] 获取所有给定字段的值   HMSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中   HSET key field value 将哈希表 key 中的字段 field 的值设为 value   HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值   HVALS key 获取哈希表中所有值   HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对    2.5 列表命令    命令 描述     BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止   BRPOP key1 [key2 ] timeout 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止   BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止   LINDEX key index 通过索引获取列表中的元   LINSERT key BEFORE AFTER pivot value   LLEN key 获取列表长   LPOP key 移出并获取列表的第一个元   LPUSH key value1 [value2] 将一个或多个值插入到列表头   LPUSHX key value 将一个值插入到已存在的列表头   LRANGE key start stop 获取列表指定范围内的元   LREM key count value 移除列表元   LSET key index value 通过索引设置列表元素的   LTRIM key start stop 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除   RPOP key 移除列表的最后一个元素，返回值为移除的元素   RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返   RPUSH key value1 [value2] 在列表中添加一个或多个   RPUSHX key value 为已存在的列表添加    2.6 集合命令    命令 描述     SADD key member1 [member2] 向集合添加一个或多个成员   SCARD key 获取集合的成员数   SDIFF key1 [key2] 返回给定所有集合的差集   SDIFFSTORE destination key1 [key2] 返回给定所有集合的差集并存储在 destination 中   SINTER key1 [key2] 返回给定所有集合的交集   SINTERSTORE destination key1 [key2] 返回给定所有集合的交集并存储在 destination 中   SISMEMBER key member 判断 member 元素是否是集合 key 的成员   SMEMBERS key 返回集合中的所有成员   SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合   SPOP key 移除并返回集合中的一个随机元素   SRANDMEMBER key [count] 返回集合中一个或多个随机数   SREM key member1 [member2] 移除集合中一个或多个成员   SUNION key1 [key2] 返回所有给定集合的并集   SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中   SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素    2.7 有序集合命令    命令 描述     ZADD key score1 member1 [score2 member2] 向有序集合添加一个或多个成员，或者更新已存在成员的分数   ZCARD key 获取有序集合的成员数   ZCOUNT key min max 计算在有序集合中指定区间分数的成员数   ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 increment   ZINTERSTORE destination numkeys key [key \u0026hellip;] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中   ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量   ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合成指定区间内的成员   ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员   ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员   ZRANK key member 返回有序集合中指定成员的索引   ZREM key member [member \u0026hellip;] 移除有序集合中的一个或多个成员   ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员   ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员   ZREMRANGEBYSCORE key min max 移除有序集合中给定的分数区间的所有成员   ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到底   ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序   ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序   ZSCORE key member 返回有序集中，成员的分数值   ZUNIONSTORE destination numkeys key [key \u0026hellip;] 计算给定的一个或多个有序集的并集，并存储在新的 key 中   ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素(包括元素成员和元素分值)     集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)其实不太准确\n在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知：\n 添加和删除都需要修改skiplist，所以复杂度为O(log(n))。但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1)。 其他的range操作复杂度一般为O(log(n))。\n 当然如果是小于64的时候，因为是采用了ziplist的设计，其时间复杂度为O(n)\n 2.8 Redis HyperLogLog 命令  Redis 2.8.9 版本添加 HyperLogLog 结构，用于做基数统计 优点：输入元素的数量或提交非常大时，计算基数所需空间小且固定 原因：HyperLogLog 只根据输入元素计算基数，不会存储元素本身。所以也不能返回输入的各个元素 基数估计：在误差可接受范围内，快速计算基数     命令 描述     PFADD key element [element \u0026hellip;] 添加指定元素到 HyperLogLog 中   PFCOUNT key [key \u0026hellip;] 返回给定 HyperLogLog 的基数估算值   PFMERGE destkey sourcekey [sourcekey \u0026hellip;] 将多个 HyperLogLog 合并为一个 HyperLogLog    2.9 Redis 发布订阅命令  Redis 发布订阅(pub/sub)是一种消息通信模式：发送者发送消息，订阅者接收消息  Redis 客户端可以订阅任意数量的频道      命令 描述     PSUBSCRIBE pattern [pattern \u0026hellip;] 订阅一个或多个符合给定模式的频道   PUBSUB subcommand [argument [argument \u0026hellip;]] 查看订阅与发布系统状态   PUBLISH channel message 将信息发送到指定的频道   PUNSUBSCRIBE [pattern [pattern \u0026hellip;]] 退订所有给定模式的频道   SUBSCRIBE channel [channel \u0026hellip;] 订阅给定的一个或多个频道的信息   UNSUBSCRIBE [channel [channel \u0026hellip;]] 退订给定的频道    2.10 Redis 事务命令  Redis 事务可一次执行多个命令，且保证  批量操作在发送 EXEC 命令前被放入缓存队列 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余命令仍旧执行 事务执行过程中，其他客户端提交的命令请求不会插入到事务执行命令序列  一个事务从开始到执行有三个阶段：开始事务、命令入列、执行事务 注意：单个 Redis 命令的执行是原子性的。但 Redis 未在事务上增加维护原子性的机制，所以 Redis 事务的执行不是原子性的  事务可理解为一个打包的批量执行脚本，但批量指令不是原子化的，中间指令的失败不会回滚前面已做指令，也不会停止执行后续指令  事务的原子性是指：事务要么完整的被执行，要么完全不执行     命令 描述     DISCARD 取消事务，放弃执行事务块内的所有命令   EXEC 执行所有事务块内的命令   MULTI 标记一个事务块的开始   UNWATCH 取消 WATCH 命令对所有 key 的监视   WATCH key [key \u0026hellip;] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断    2.11 Redis 脚本命令  Redis 脚本使用 Lua 解释器执行脚本。Redis 2.6 内嵌支持 Lua 环境     命令 描述     EVAL script numkeys key [key \u0026hellip;] arg [arg \u0026hellip;] 执行 Lua 脚本   EVALSHA sha1 numkeys key [key \u0026hellip;] arg [arg \u0026hellip;] 执行 Lua 脚本   SCRIPT EXISTS script [script \u0026hellip;] 查看指定的脚本是否已经被保存在缓存当中   SCRIPT FLUSH 从脚本缓存中移除所有脚本   SCRIPT KILL 杀死当前正在运行的 Lua 脚本   SCRIPT LOAD script 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本    2.12 Redis 连接命令    命令 描述     AUTH password 验证密码是否正确   ECHO message 打印字符串   PING 查看服务是否运行   QUIT 关闭当前连接   SELECT index 切换到指定的数据库    2.13 Redis 服务器命令  INFO 命令获取 Redis 服务器的统计信息     命令 描述     BGREWRITEAOF 异步执行一个 AOF(AppendOnly File) 文件重写操作   BGSAVE 在后台异步保存当前数据库的数据到磁盘   CLIENT KILL [ip:port] [ID client-id] 关闭客户端连接   CLIENT LIST 获取连接到服务器的客户端连接列表   CLIENT GETNAME 获取连接的名称   CLIENT PAUSE timeout 在指定时间内终止运行来自客户端的命令   CLIENT SETNAME connection-name 设置当前连接的名称   CLUSTER SLOTS 获取集群节点的映射数组   COMMAND 获取 Redis 命令详情数组   COMMAND COUNT 获取 Redis 命令总数   COMMAND GETKEYS 获取给定命令的所有键   TIME 返回当前服务器时间   COMMAND INFO command-name [command-name \u0026hellip;] 获取指定 Redis 命令描述的数组   CONFIG GET parameter 获取指定配置参数的值   CONFIG REWRITE 对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写   CONFIG SET parameter value 修改 redis 配置参数，无需重启   CONFIG RESETSTAT 重置 INFO 命令中的某些统计数据   DBSIZE 返回当前数据库的 key 的数量   DEBUG OBJECT key 获取 key 的调试信息   DEBUG SEGFAULT 让 Redis 服务崩溃   FLUSHALL 删除所有数据库的所有key   FLUSHDB 删除当前数据库的所有key   INFO [section] 获取 Redis 服务器的各种信息和统计数值   LASTSAVE 返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示   MONITOR 实时打印出 Redis 服务器接收到的命令，调试用   ROLE 返回主从实例所属的角色   SAVE 同步保存数据到硬盘   SHUTDOWN [NOSAVE] [SAVE] 异步保存数据到硬盘，并关闭服务器   SLAVEOF host port 将当前服务器转变为指定服务器的从属服务器(slave server)   SLOWLOG subcommand [argument] 管理 redis 的慢日志   SYNC 用于复制功能(replication)的内部命令    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"289a5b1cbb2cfa07a06ffa32a5239679","permalink":"https://xueqing.github.io/blog/database/redis/2_command/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/redis/2_command/","section":"blog","summary":"2.1 命令 2.2 键命令 2.3 字符串命令 2.4 哈希命令 2.5 列表命令 2.6 集合命令 2.7 有序集合命令 2.8 Redis HyperLogLog 命令 2.9 Redis 发布订阅命令 2.10 Redis 事务命令 2.11 Redis 脚本命令 2.12 Redis 连接命令 2.13 Redis 服务","tags":["database"],"title":"2 Redis 命令","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  2.1 软件开发价值观 2.2 敏捷宣言的 12 个原则  2.1 软件开发价值观  个体和互动：高于流程和工具 可工作的软件：高于详尽的文档 客户合作：高于合同谈判 响应变化：高于遵循计划  2.2 敏捷宣言的 12 个原则  满足客户需求：最重要的是通过尽早和不断交付有价值的软件满足客户需求 欢迎变化：软件开发过程中变化不可避免。应该欢迎需求的变化，即使在开发后期。敏捷过程应保持客户的竞争优势 交付可工作软件：经常交付可以工作的软件，从几周到几个月，时间尺度越短越好 合作：业务人员和开发者在整个项目过程中必须在一起工作 动力：应该围绕斗志高昂的人进行软件开发。给开发者提供环境，相信他们一边使他们感觉对完成工作负责 面对面对话：面对面对话是在开发小组中最有效率也最有效果的信息传达方式 按照可工作的软件度量进度：可工作的软件是关键，它应当是进度的主要度量标准 维持不变的节奏：敏捷过程提倡可持续开发。业务、开发人员和用户应能维持项目不变的节奏 监察：定期关注技术的完美型和好的设计来提高敏捷性 简单性：保持事情简单，使用简单的术语来度量未完成的工作 自我组织的团队：一个敏捷团队应该是自我组织的，不应严重依赖其他团队，因为最好的架构、需求和设计源自自我组织的团队 定期评审工作：每隔一段时间评审工作，以便团队可以离开如何变得更有效率，并相应地调整自己的行为  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"048e0a7c5146decf8ed804d5fd24f451","permalink":"https://xueqing.github.io/translation/agile/tutorial/2-manifesto/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/2-manifesto/","section":"translation","summary":"2.1 软件开发价值观 2.2 敏捷宣言的 12 个原则 2.1 软件开发价值观 个体和互动：高于流程和工具 可工作的软件：高于详尽的文档 客户合作：高于合同谈判 响应变化：高","tags":["agile"],"title":"2 宣言","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  2.1 前言 2.2 对账处理流程  2.2.1 渠道对账单下载 2.2.1.1 第三方支付的对账单情况 2.2.1.2 银行直连的对账情况 2.2.2 渠道对账单标准化 2.2.3 本地交易记录准备 2.2.4 轧帐 2.2.5 平帐   2.1 前言  轧帐：对账系统的工作，是发现有差异的记录 平帐：通过人工或者自动的方式，解决上述差异 对电商系统来说，每一笔交易，在所有相关主体侧都要能对得上  交易主体：如发起人是个人，必须能够从个人交易历史记录中找到这笔交易。但大部分人不会保留电子记录，所以一般是提供可以下载的账单或交易记录，让用户自己对去 交易对手：一般是商户。商户侧对账处理同用户侧，也仅仅提供对账单 交易渠道侧：这是对账的重点，一是核实交易流水，二是核实交易佣金，毕竟是租用人家通道做结算的  需要对账的记录主要是交易记录和退款记录  2.2 对账处理流程 一般来说，对账流程涉及到如下步骤：渠道对账单下载、本地交易记录准备、轧账、平账\n2.2.1 渠道对账单下载  银行、第三方支付、银联等，基本都会提供对账单下载的功能。不过也有少数工作做不到位或者太到位的银行，只提供账单查询后台，不提供对账单下载功能 对开发人员来说，这里有几个坑  对账单格式不一：txt、xml、csv 的都有。为了后续能够统一处理，在账单下载完成后，需要进行标准化处理 下载方式不一：HTTP、HTTPS、FTP 的都有。下载程序需要按照渠道的协议来处理 下载时间不一：一般是凌晨 1 点后，到中午 12 才能用的也有。如果在预定的时间取不到数据，需要注意重试读取 稳定性差：FTP 服务器出问题是常有的事。渠道侧解决方案往往就是重启。所以重试机制是必要的  技术方面  HTTP(S)：用 apache http client 即可实现连接池和断点续传 FTP：可使用 Apache Commons Net API 不管是哪一个，都需设置重试次数和连接超时。重试次数和间隔的设置需要小心，重试太频繁，容易把服务器打死；时间间隔太大，又会阻塞后续处理步骤。5～10 分钟是一个合适的重试间隔区间 连接超时：指在服务器出现问题时，连接在指定时间内获取不到数据即自动断开   2.2.1.1 第三方支付的对账单情况    渠道 对账周期 账单提供方式 账单文件格式     支付宝 每天 2:10 HTTPS xml   支付宝退款 每天 3:10 HTTPS xml   百付宝 每天 7:00 FTP txt   百付宝退款 每天 7:00 FTP txt   微信支付 每天 10:30 HTTPS txt   微信退款 每天 10:30 HTTPS txt    2.2.1.2 银行直连的对账情况    银行 对账形式 对账周期 打款周期     交行 接口/商户对账系统 日对账 日结(T+1)   建行 接口 日对账 日结(T+1)   工行 登录网银的方式手动下载 日对账 日结(T+1)   浦发 信用卡-登录自助平台；借记卡-接口 日对账 日结(T+1)   农行 银行定时推送对账文件 日对账 日结(T+0)   中行 银行定时推送对账文件 日对账 日结(T+1)   招行 银行定时推送对账文件 日对账 日结(T+1)    2.2.2 渠道对账单标准化  微信的对账单：csv 格式，逗号隔开。包括字段  交易时间：在微信侧的支付完成的时间。这个时间会成为一个陷阱 公众账号ID、商户号、子商户号、设备号：这些信息需要做验证，确保是自己的单子 微信订单号、商户订单号：对单的核心 微信订单号：微信侧产生的订单号，在微信支付接口返回值中有。但是万一收不到这个返回值，那在本地记录中可能就空了 商户订单号：我们发送给微信的订单号，一般用这个来做对单依据。两边的数据中都会有这个值 用户标识、交易类型、交易状态、付款银行、货币种类、总金额、企业红包金额：对单的核心字段，必须确保双方是一致的 商品名称、商户数据包、手续费、费率：可选验证  某宝的账单：txt 格式，空格隔开。包括字段  商户订单号、交易流水号、交易时间、支付时间、付款方、交易金额、交易类型、交易状态  每个渠道的账单格式不尽相同，在得到账单后，下一步是对账单做标准化处理，这样轧帐以及后续工作可统一处理 标准化后的账单数据可以放在文件系统或者数据库中。这取决于交易数据量  每天百万以上的量，使用文件系统比较合适。如 hdfs 数据库操作相对比较慢，也浪费资源  基于文件系统的标准化涉及如下内容  文件格式标准化：统一使用 csv、json 或 xml 格式。如使用 hadoop 或者 spark 对账，使用 csv 是个不错的选择 文件存储统一化：文件目录、文件名都需要遵循统一命名规范   2.2.3 本地交易记录准备  本地交易记录的准备，总的来说有如下方法  直接用原始数据：鉴于大部分系统使用的是 MySQL，也意味着在 MySQL 上做对账 对账时需要大量的数据查找工作，必然会影响线上业务 在数据规模较大(如超过 100 万)时不太合适 使用备库执行对账：既简单，也不影响线上业务。是典型的空间换时间的做法 如果业务大到需要分表分库才能处理，那对账数据准备也不一样 使用分库不现实，因为分库一般是按照主体 id，而不是渠道 id 来分库，这样对账需要在多个库上进行，会降低效率 对分表分库建立从库非常耗费资源。这种情况下，需要同步一份数据到文件系统(hdfs)，或 NoSQL 数据库  交易记录是支付系统核心数据，有大量的应用(如信用、风控)都需要交易记录数据。这些应用对交易记录的需求还不完全一致，为了提升性能，交易记录会使用异步的方式来将数据投递给使用方  交易记录在入库时，投递消息到消息系统中 使用方监听这个消息，一旦收到新消息，则从交易记录库中查询数据，获取数据并更新到库中   2.2.4 轧帐  轧帐：按照客户订单号来比较本地交易记录和渠道交易记录是否一致  从算法角度，是计算两个数组的差异 在单机运行时，可采用的算法不少。 推荐采用 mapreduce 来轧帐，优势是可以按照订单号将渠道提供的记录和本地记录 shuffle 到同一个reduce 处理上，这样就可以很容易进行数据比对  轧帐中最大的坑，莫过于切分点的问题  如以整 0 点为切分点，那存在一个问题，本地 23:59 发起的交易，到了渠道侧，可能会在 00:01 处理，这一笔交易变成第二天的帐了 实际处理中，一笔交易在渠道侧处理，花上几分钟都有可能 对于切分点附近无法确认的帐，做一个时间窗，在时间窗内的数据，留待第二天对账时继续处理   2.2.5 平帐  发现两边不一致的数据，  数据量不大时：记录起来，人工甄别 数据量很大：人工处理成本太高。这个没有统一的处理方法，需要对有问题的数据分析，然后做自动处理。  针对交易记录的对账的处理，主要有如下情况  本地未支付，支付渠道已支付：这主要是本地未正确接收到渠道下发的异步通知导致。一般处理是将本地状态修改为已支付，并做响应的后续处理，比如通知业务方等 本地已支付，支付渠道已支付，但金额不同：需要人工核查 本地已支付，但支付渠道中无记录；或本地无记录，支付渠道有记录：在排除跨日因素外，这种情况非常少见，需要了解具体原因后做处理  针对退款的对账处理，主要有如下情况  本地未退款，支付渠道已退款：以支付渠道为准，修改本地为已退款状态，并触发后续处理 本地已退款、支付渠道已退款，但金额不同：需要人工核查 本地已退款，但支付渠道无记录；或本地无记录，支付渠道有记录：在排除跨日因素外，这种情况非常少见，需要了解具体原因后做处理   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f47143924e0d3602e5cee32aac8fb61e","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/2_%E5%AF%B9%E8%B4%A6%E5%A4%84%E7%90%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/2_%E5%AF%B9%E8%B4%A6%E5%A4%84%E7%90%86/","section":"blog","summary":"2.1 前言 2.2 对账处理流程 2.2.1 渠道对账单下载 2.2.1.1 第三方支付的对账单情况 2.2.1.2 银行直连的对账情况 2.2.2 渠道对账单标准化 2.2.3 本地交易记录准备 2.2.4 轧帐 2.2.5 平帐 2.1 前言 轧帐：","tags":["o2o"],"title":"2 对账处理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  2.1 模板 2.2 占位符 2.3 静态占位符 2.4 渲染菜单  2.1 模板 可以使用 HTML 模板来定制网站外观、定义占位符标记要管理的内容，以及使用特殊标签生成菜单等。\n可以使用不同的格式或内置组件定义多个模板，然后根据需要为每个页面选择模板。一个页面的模板总是可被其他页面使用。\n网站模板位于 mysite/templates。\n默认的，网站页面使用 fullwidth.html 模板，即列举在项目 settings.py 的 CMS_TEMPLATES 元组的第一个。\nCMS_TEMPLATES = ( ## Customize this ('fullwidth.html', 'Fullwidth'), ('sidebar_left.html', 'Sidebar Left'), ('sidebar_right.html', 'Sidebar Right') )  2.2 占位符 占位符定义 HTML 模板的一部分，然后在渲染网页的时候使用数据库的内容填充它。通过使用 django CMS 的前端的编辑机制(使用 Django 的模板标签)编辑网页内容。\nfullwidth.html 包含一个占位符 {% placeholder \u0026quot;content\u0026quot; %}。\nfullwidth.html 还有一个占位符 {% load cms_tags %}。cms_tags 是需要的模板标签库。\n可以参考 Django 文档 查看更多关于 Django 的模板标签。\n给 fullwidth.html 的 {% block content %} 部分增加一些占位符。比如：\n{% block content %} {% placeholder \u0026quot;feature\u0026quot; %} {% placeholder \u0026quot;content\u0026quot; %} {% placeholder \u0026quot;splashbox\u0026quot; %} {% endblock content %}  如果切换到结构模式，看以看到新的可用的占位符：Feature 和 Splashbox。\n2.3 静态占位符 静态占位符可以在网站的多个位置展示相同的内容。静态占位符大多数行为类似普通占位符，但是当创建一个静态占位符并增加内容，它会在全局保存。即使从一个模板删除这个静态占位符，也可以之后重用。\n比如，增加一个 footer 到所有的页面。因为我们想要 footer 出现在每个页面，应该增加到基础模板(mysite/templates/base.html)。放置在 HTML \u0026lt;body\u0026gt; 元素的末尾：\n\u0026lt;footer\u0026gt; {% static_placeholder 'footer' %} \u0026lt;/footer\u0026gt; {% render_block \u0026quot;js\u0026quot; %} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  保存模板文件，返回到浏览器。刷新任一页面，在结构模式可以看到新的静态占位符。\n注意：为了减少界面的凌乱，静态占位符的插件默认会被隐藏。可点击展开。\n如果按照正常方式增加内容到新的占位符，你会看到它出现在网站的其他页面。\n2.4 渲染菜单 使用 show_menu 渲染模板中的菜单。\n使用 show_menu 的模板必须首先加载 CMS 的 menu_tags 库：\n{% load menu_tags %}  我们在 mysite/templates/base.html 使用的菜单：\n\u0026lt;ul class=\u0026quot;nav\u0026quot;\u0026gt; {% show_menu 0 100 100 100 %} \u0026lt;/ul\u0026gt;  这个选项控制展示在菜单树的网站层级。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d44f94fd4e8306cf6e5c61944aca4e88","permalink":"https://xueqing.github.io/blog/django_cms/tutorial/2_template_palceholder/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/django_cms/tutorial/2_template_palceholder/","section":"blog","summary":"2.1 模板 2.2 占位符 2.3 静态占位符 2.4 渲染菜单 2.1 模板 可以使用 HTML 模板来定制网站外观、定义占位符标记要管理的内容，以及使用特殊标签生成菜单等。 可以使用不同","tags":["django"],"title":"2 模板和占位符","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  2.1 支付  2.1.1 银行直连 2.1.2 第三方支付平台 2.1.2.1 备付金  2.2 充值 2.3 提现  2.3.1 银企直连 2.3.2 企业网银 2.3.3 第三方支付渠道   2.1 支付  这里的渠道侧，包括银行、第三方支付以及银联 举例：小明通过工行在老熊公司买了一张 100 元的会员卡，工行按照支付金额的 0.1% 收取手续费，产生了如下会计分录\n借：银行存款-工行收款 100 贷：主营业务收入-会员卡 100 借：服务成本-工行手续费 0.1 贷：银行存款-工行收款 0.1\n 这里详细介绍在支付时的清结算过程，分别从银行直连、第三方支付的角度来说明。\n  2.1.1 银行直连  用户通过工行支付的款项，在银行侧并不是直接落地到老熊公司的结算账户上，而是先到一个中间账户上。这就需要了解银行侧的账户和资金处理流程。针对第三方支付和电商直连银行，在银行侧的账户和资金处理流程是不一样的\n 电商公司直连银行，不需要复杂的备付金管理 当电商公司(第三方支付公司类似)和工行签约开通支付接口后，工行会为这个接口开设一个结算账户。通过这个接口流转的资金最终会结算到这个账户上。这也是电商公司可以提现的一个账户 另外，为了方便资金清算，工行还会为电商公司开设一个收付账户，这个账户是直接对接线上资金处理的，这是工行内部账户，电商公司无法操作这个账户，但是可以看到这个账户的收付情况  支付时，资金在工行侧的流转流程\n 用户提交支付请求，支付系统调用工行快捷支付接口执行支付 工行服务器检查用户账户余额和状态，如果余额不足或者状态异常，则停止支付。继续检查电商公司的收款账户的状态。如果状态正常，开始执行支付。资金从用户账户转到收付账户上 工行采用 T+1 的结算，将 T 日用户支付的所有款项，扣除退款，扣除手续费等费用后，将剩余资金打入电商结算账户上  在商户侧，需要调整前期所述的记账流程。用户付费不能直接进入公司存款账户，而是记在应收账款下。需等待银行完成清结算后，才能将商家在该银行所有的收款转到存款中\n 用户付费时，会计分录\n借：应收账款-工行收款 99.9 服务成本-工行手续费 0.1 贷：主营业务收入-会员卡 100\n  在电商侧执行日切，将当前的应收账款归集到存款上，在接收到工行对账单后，对这个日切结果也要对账。假定当前收入为 200 万元，手续费为 2 千元，对应的会计分录为\n借：银行存款-工行 1,998,000 贷：应收账款-工行收款 1,998,000\n 通过这个会计分录，怎么知道这一笔手续费是谁付的？要知道这只是从会计角度做的记录，在具体存储库的设计时，还需要添加更多的信息，包括交易发生的时间、会员卡号等信息\n 对工行来说，这些资金都是行内流转，不涉及到跨行转账的问题。因此在银行内部的处理也比较简单，一般就是一个内部的信息流，分别将商家账户和用户账户的资金做了增减，并无实际的资金流转\n  2.1.2 第三方支付平台  对于没有直连的银行，可以通过第三方支付来收款。第三方支付侧的资金处理和银行的类似 以支付宝为例，当商家在支付宝开通支付接口后，支付宝为商家建立账户以及商户号。每个业务对应一个商户号。用户提交支付后，支付宝完成收款后，直接进行分润，扣除手续费，将剩余资金转移到商户号上\n借：应收账款-支付宝会员账户收款 99.9 服务成本-支付宝会员手续费 0.1 贷：主营业务收入-会员卡 100\n 这里记为应收账款，因为 T+1 后，支付宝还要将资金按照商户的要求，转移到指定银行账户上。假定这个银行账户为建行的账户，当天的收入为 200 万元，手续费为 2 千元，对应的会计分录为\n借：银行存款-建行 1,998,000 贷：应收账款-支付宝会员账户收款 1,998,000\n 那对于这一笔收款，支付宝是如何处理？这就涉及到备付金的问题了\n  2.1.2.1 备付金  关于备付金，建议大家详细阅读《支付机构客户备付金存管办法》全文，对备付金的使用和管理有详细的介绍  当用户在电商网站(如淘宝网)购买商品，下单后，资金并不是立即进入商家的账户上，而是暂存在第三方支付公司 当用户确认接收到商品后，资金从第三方支付公司转到商家账户上 这个资金被称为备付金，“指支付机构为办理客户委托的支付业务而实际收到的预收待付货币资金” 备付金由银行托管，备付金银行分为存管银行和合作银行 存管银行只能有一家，负责处理备付金跨行收付，并对支付机构存放在各银行的备付金信息做归集、合并与监督 合作银行可以有多家，可以办理针对本银行的备付金存取和监管  和备付金相关的账户有三类：  存管账户：可以以现金形式接收客户备付金、以银行转账方式办理客户备付金收取和支取业务的专用存款账户。针对备付金存管银行，可以一个省开设一个存管账户。只有存管账户才能够支持跨行付款 收付账户：可以以现金形式或以银行转账方式接收客户备付金、以银行资金内部划转方式办理客户备付金支取业务的专用存款账户。在同一个备付金合作银行只能开设一个收付账户 汇缴账户：仅支持同行收款以及退款时原路退回。在备付金存管和合作银行都可以开设。备付金银行应当于每日营业终了前，将备付金汇缴账户内的资金全额划转至支付机构的备付金存管账户或在同一备付金合作银行开立备付金收付账户  有了收付账户，还有必要开设汇缴账户吗？这要看交易规模了，如果规模大，那是有必要的，因为有些地方银行可以给非常低的手续费用，可以省一大笔钱 这几个账户都是备付金专用的活期存款账户。汇缴账户到收付账户的划拨，是通过银行自己行内转账进行；收付账户到存管账户，就走人行的大小额、超级网银或者同城系统进行划拨。当然，这些接口一般第三方支付是不能直接访问的，但可以通过银行提供的接口来进行 这样在第三方支付公司，用户支付的资金首先进入汇缴账户或者收付账户，日终后，汇缴账户的资金全部汇总到收付账户上 在上述小明的例子中，如果小明使用的卡是招行的卡，在有备付金支持的情况下，小明支付的100元是通过招行的内部转账直接进入了支付宝在招行的备付金收付账户或者汇缴账户。这样将跨行转账变成行内资金划拨，可以减少通道费的支出，也使得资金到账更为迅捷。第三方支付备付金的使用和调拨是个专门的话题。这里不再详细展开  2.2 充值  资金沉淀成为电商公司孜孜以求的目标。用户充值既有利于提升支付体验，特别是对高频小额支付而言；由此也可以形成可观的资金沉淀，这对电商公司来说是个一举多得的好事。但此举是迈向违规的危险第一步 接之前的场景，老熊公司在工行开设了一个对公账户，用于收款，这个账户可以用结算账户。先考虑用户小明使用工行卡充值的场景。公司需要为每个用户开设一个账户，用来跟踪账户余额。这个账户有两种处理方式，所谓的虚户和实户  虚户：指客户和商户的资金都存放在电商公司开设的对公账户上，老熊公司内部为每个实体维护一个虚拟账户。当客户给商家支付时，资金直接在虚拟账户上划拨，没有实际的资金流转，只有信息流。由于虚户是开设在电商平台上，所以也叫支付账户。大部分电商公司用的都是这种模式 实户：指在银行侧为每个客户和商户在对公账户下开设二级账户。每个账户都是相互独立的。对于少数服务大客户的电商公司来说，使用这种模式也比较方便。相对支付账户，这被称为银行账户  这里介绍虚户的情况。使用虚户时，电商需要为客户和商户建立内部账户。这个内部账户，对电商公司来说，需要记录在负债上 回到充值的案例：用户使用工行的卡，给自己的账户充值 100 块钱，不考虑手续费【手续费处理方法支付】，会计分录：\n借：应收账款-工行收款 100 贷：客户 A 账户 100\n 资金先进入应收账款，因为充值和支付一样，资金也是在清结算完成后才到账的。用户在其他行充值情况应该如何处理？如果电商公司和这个银行有开通支付通道，那就会有对应的对公结算账户，充值款项就会在结算完成后，进入这个账户。如果电商和这个银行没有对接，需要通过其他第三方渠道，如支付宝、微信支付等来完成充值，对应的，资金也会进入第三方渠道。这和支付情况也是类似的。不管用户用哪个卡充值，最终的钱都记录在客户 A 的虚拟账户上\n 第三方支付在处理充值时流程和上述是类似的。但是当电商调用第三方支付接口来完成充值时，和银行不一样地方在于，这个充值是实时入账的。虽然银行并不是实时把充值的金额结算到第三方支付的银行账户上的，而是到T+1 完成结算后才会到账。但对第三方支付而言，在银行接口确认成功后，就可以假定 T+1 银行肯定可以把钱结算给自己。因此可以实时把电商在第三方支付的账户的金额增加，也即实时到账\n  2.3 提现  有充值，一般都需要提现。可提现是一个危险的业务，提供资金逃离电商的途径 对充值和支付来说，就算出问题了，钱还在。而提现就麻烦了，一旦出问题，钱都没了。对提现的账户和账务处理尤其谨慎 电商提现的主要途径是银企直联、企业网银和第三方支付代付  2.3.1 银企直连  对于商户和客户规模不大的公司，通过将公司内部的 ERP、财务系统等业务系统和银行接口对接，实现银企直连，可以让财务人员直接通过内部业务系统来打款  2.3.2 企业网银  一般银行都提供的企业网银接口，支持同行批量打款(代付)功能。银行将企业对公账户扣款，打到对应的个人账户上。对于个人跨行取现，本质上来说，是将对公账户的资金转账到对私账户上 目前银行侧转账需要通过人行的大小额系统和超级网银来进行。人行系统并不直接对企业开放，银行通过企业网银来封装这些接口，批发或者零售给企业使用  行内清算系统：银行内部转账一般通过此系统来进行，不限金额，实时到账，手续费低。对于同行提现，如上述案例，小明需要将零钱提现到工行账户上，老熊公司在工行也开设了用于收付的对公账户，则可以通过工行的行内清算系统，直接 100 元支付给小明 小额支付系统：大小额支付系统同属于央行的中国现代化支付系统(CNAPS)。5 万以内的普通贷记业务可以通过央行的小额批量支付系统(BEPS)来进行，这是 7*24 小时运行，批量运行，收集到若干交易后统一打包处理，所以是非实时到账的，费用相对大额来说也比较低。此外，小额支付需要提供联行号，即支行信息，一般绑卡流程不会要求用户提供此类信息 大额支付系统：大额实时支付系统(HVPS)每笔交易都实时发送，实时清算的，所以基本上能实时到账，跨行资金零在途。但大额系统运行的时间，仅限于工作日的 8:30~17:00 运行，节假日也不运行。目前对使用大额支付系统进行转账并没有设置最低资金量的要求，也就是一块钱也会给你转过去。但是费用较高，另外大额支付系统也需要支行信息(联行号) 超级网银：全称是网上支付跨行清算系统，2013 年 10 月份正式投产运行。超级网银是对大小额支付系统的一个补充，接入机构不再限于银行，第三方支付也可以接入，所以有的第三方支付给商户提供的提现代发功能就是基于超级网银做的。7*24 小时实时到账，单笔上限 5 万元。超级网银并不是所有的银行都支持，目前至少支持172 家主要银行。此外，超级网银交易可以不需要联行号  对电商来说，由于不能直接访问央行的这些接口，对接银行，通过银行来访问央行的接口，是主要的提现方式。但不同的银行，针对不同的提现场景，收费不一样。所以在具体实现提现的时候，还需要有提现路由(打款路由)，从费率、支持的额度、到账时间等多个维度来评估和选择提现渠道  2.3.3 第三方支付渠道  支付宝、微信等第三方支付公司一般也都提供代付服务，可以是通过文件来实现批量代付，也可以通过接口来实现提现  第三方支付与用户提现的银行有合作关系且银行提供实时到账接口，此类银行支持实时到账的提现操作；如果只提供准实时到账接口(例如 2 小时到账)，则此类合作银行只支持准实时到账提现操作(支付宝为 2 小时到账) 第三方支付与用户提现的银行无合作关系，只能通过银行小额支付系统定时跑批，此类只支持 2 天内到账。  不管通过哪个途径来实现，提现的会计分录和充值相反，借记用户的虚拟账户，贷记对公账户存款\n借：客户 A 账户 100 贷：银行存款-工行 100\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c63f73c8e0b0f00f9b1d3abfcbd0ef5e","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/2_%E6%B8%A0%E9%81%93%E4%BE%A7%E5%A4%84%E7%90%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/2_%E6%B8%A0%E9%81%93%E4%BE%A7%E5%A4%84%E7%90%86/","section":"blog","summary":"2.1 支付 2.1.1 银行直连 2.1.2 第三方支付平台 2.1.2.1 备付金 2.2 充值 2.3 提现 2.3.1 银企直连 2.3.2 企业网银 2.3.3 第三方支付渠道 2.1 支付 这里的渠道侧，包括银行、第三方支付以及银联 举例","tags":["o2o"],"title":"2 渠道侧处理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  2.1 软件过程模型 2.2 过程活动 2.3 应对变更 2.4 Rational 统一过程\n 软件过程分类\n 计划驱动：提前计划好所有的过程活动，庵后按计划去考核过程的执行 敏捷过程：计划是增量式的，而且很容易根据不断变化的客户需求变更过程  过程标准化的重要性：减少在一个机构中多样的软件过程的出现，可以改善沟通、缩短培训时间、使自动化的过程支持更经济\n  2.1 软件过程模型  常用的过程模型(也叫过程泛型)     名称 描述 适用场景 优点 不足     瀑布模型 计划驱动，开始工作之前，必须对所有过程活动制定计划并给出进度安排 完全了解需求，且系统开发过程中不太可能发生重大改变 每个阶段生成文档，过程可见，易于根据项目计划监控项目进度 不易响应用户的需求变更   增量式开发 敏捷方法，系统每个增量或版本包括用户需要的一部分功能 商务、电子商务和个人系统 降低了适应用户需求变更的成本，易得到用户反馈，更快地交付和部署 过程不可见，新的增量导致系统结构被破坏   面向复用的软件过程 根据需求复用现存软件进行开发 已存在大量可复用的软件组件，以及组合组件的集成框架 减少需要开发的软件数量，降低开发成本和风险，可快速交付 需求妥协，可能不符合用户真正的需求，且组件新版本不受机构控制    2.2 过程活动  包括 4 个基本活动  软件描述：必须定义软件的功能以及软件操作上的约束。其中的关键阶段是需求工程 软件设计和实现：对实现软件的结构、系统的数据、系统组件间的接口以及所用算法的描述 软件有效性验证：软件必须得到有效性验证，即确保软件是客户所想要的 软件进化：软件必须进化以满足不断变化的客户需要   2.3 应对变更  返工：变更增加了软件开发的成本，通常意味着已完成的工作要重做 降低返工成本的方法  变更避免：在重大返工发生之前预测变更。比如开发原型，客户试用原型，重新定义需求 变更容忍：通常需要增量开发，提出的变更可能是在还没有开发的增量上实现，或者修改单个增量来适应变更  应对变更系统需求的方法：  系统原型：快速开发一个系统版本或系统的一部分，以检验客户需求和某些设计决定的可行性。支持变更避免 原型：一个软件系统的最初版本，用于验证概念、试用设计选型、发现更多的问题和可能的解决方案 增量交付：系统增量地交付给客户，给用户评审和试用。支持变更避免和变更容忍   2.4 Rational 统一过程  6 个基本且最好的实践  1 迭代地开发软件：根据客户的轻重缓急来规划系统的增量，在开发过程中先开发和交付最高优先权的系统特性 2 对需求的管理：明确地记录客户的需求并跟踪这些需求的变更。在接受之前分析系统变更带来的影响 3 使用基于组件的体系结构：将系统体系结构组织成组件的形态 4 可视化地建模软件：使用图形 UML 模型表现软件的静态和动态视图 5 检验软件质量：保证软件满足了机构质量标准 6 控制对软件的变更：使用变更管理系统、配置管理程序和工具来管理软件的变更   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e8d42b8c98da44de3cb5e946199ba3d8","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/2-software-process/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/2-software-process/","section":"blog","summary":"2.1 软件过程模型 2.2 过程活动 2.3 应对变更 2.4 Rational 统一过程 软件过程分类 计划驱动：提前计划好所有的过程活动，庵后按计划去考核过程的执行 敏捷过程：计划是增量","tags":["sa","engineer"],"title":"2 软件过程","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  22.1 风险管理 22.2 人员管理 22.3 团队协作\n 软件项目管理者的任务是确保软件项目满足和服从这些约束，并确保交付高质量的软件产品\n 项目管理的目标：\n 在约定的时间将软件产品交付给客户 将全部成本控制在预算之内 交付的软件产品满足客户的要求 保持一个愉悦且运作良好的开发团队  软件工程管理的不同之处：\n 软件产品是无形的 大型软件项目常常是“一次性的”项目 软件开发过程是可变的和机构特定的   22.1 风险管理    风险种类 描述 举例     项目风险 影响项目进度或项目资源的风险 职员跳槽、管理层变更、硬件缺乏、需求变更、描述延迟、低估了系统规模   产品风险 影响开发中软件的质量或性能的风险 需求变更、描述延迟、低估了系统规模、CASE 工具性能较差   业务风险 影响软件开发机构或软件产品购买机构的风险 技术变更、产品竞争    22.2 人员管理    关键因素 描述     一致性 对项目组的每个人应该同等对待   尊重 尊重每个人有不同的技能，所有成员都应该有机会做出贡献   包容 能够倾听并采纳团队成员的建议   诚实 对项目组中好的情况和不好的情况保持诚实的态度。诚实地对待自己的技术知识水平，并在必要的时候乐于服从更博学的员工       工作动力 描述 措施     生理的需求 较低层次，如事物和睡眠 软件开发人员一般没有饥渴问题   安全的需求 环境对身体的威胁 一般没有   社会的需求 给员工提供与同事交往的时间和场所 建议面对面交流，而不是电子会议   受尊重的需求 让员工感受在他们在开发机构中很受尊重 对员工做出的成绩给予认可，让员工感觉到为他们所支付的报酬能够反映出他们的能力和经验的价值   自我实现的需求 让员工对自己的工作负责人，分配给他们较难(但是可以完成)的任务，并提供培训计划以提高他们的技能 员工喜欢学习新知识和技能，培训是一项重要的激励方式       职业人士分类 描述 特点     面向任务型 动力来自所从事的工作。在软件工程中，软件开发智力上的挑战激发了他们的工作热情 喜欢独自工作，技术可能更出色   面向自我型 动力来自个人成功和得到认可。他们更乐于把软件开发视为达到自己目标的手段 喜欢独自工作。团队协调好，可变成面向交互型。可能善于推动整个工作的完成   面向交互型 动力来自同事们的存在和协作 喜欢小组作业。更利于小组内部的交流沟通    22.3 团队协作  小组具有凝聚力的好处     好处 描述     能够建立小组自己的质量标准 小组一致同意的标准与强加的标准相比，更容易被小组遵守   成员互相学习，互相帮助 鼓励互相学习可消除互相不了解引起的隔阂   知识分享 一旦有成员离开小组也可保持工作的连续性。其他成员可接手关键的任务，不会过度影响项目   鼓励重构以及不断改善 小组成员集体工作交付高质量的产品并解决出现的问题     如何增强小组凝聚力\n 为小组成员及其家庭组织一些社会活动 通过给小组命名确立小组的特性和地位，尝试建立小组的认同感 开展有鲜明小组特色的小组建设活动，如运动和游戏 把组员当做自己人 必须认为小组成员是负责人的、可信赖的，保障小组成员的知情权 坦诚的信息交流，可使小组成员感觉自己是小组的一部分 开发新产品时，负责产品描述和设计的小组成员都参与会议，是每个成员能够关心产品的描述和设计 午餐会：项目组所有成员互相认识并谈论彼此所关心的问题，比如新产品构想等 放松日：每个小组成员准备一项相关技术的最新内容并介绍给小组中其他成员，提高小组的技术水平  影响团队工作的普遍因素\n 小组的人员：项目小组需要不同类型的成员。因为软件开发包括很多活动——和客户谈判，编码，测试，编写文档等 团队的组织：组织团队使得小组成员都能尽其所能，所承担的各项任务都能按时完成 技术和管理上的沟通：小组成员之间、软件开发团队和其他项目信息持有者之间的良好沟通必不可少  挑选成员\n 创建一个在技术技能和人格各项之间平衡的小组：挑选不同类型(面向任务、面向自我、面向交互)的成员 组织成员一起有效的工作：实行民主、集体决策，且需要权威来指导工作。双向沟通，避免较多的会议和冗长的文件   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"71dd0ef8d12d589f90fba68c6b58cd36","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/22-project-management/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/22-project-management/","section":"blog","summary":"22.1 风险管理 22.2 人员管理 22.3 团队协作 软件项目管理者的任务是确保软件项目满足和服从这些约束，并确保交付高质量的软件产品 项目管理的目标： 在约定的时间将","tags":["sa","engineer"],"title":"22 项目管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  23.1 软件报价 23.2 计划驱动的开发 23.3 项目进度安排 23.4 敏捷规划 23.5 估算技术\n 项目计划：在项目开始建立，用于向项目开发团队和客户说明工作如何开展，以及帮助估计项目进展\n 软件开发项目总成本包括\n 工作量成本(支付给软件开发人员的费用) 包括维护在内的硬件和软件费用 差旅费和培训费用  开发过程中，为每个软件版本制定一个非正式的项目计划和工作量成本估计，应该让团队所有成员都参与到规划过程中\n  23.1 软件报价 影响软件报价的因素\n   因素 描述     市场机遇 开发机构可能为进入一个新的软件市场而提出一个低的报价。在一个项目上的低回报可能会换来今今后更大收益的机会，而且获得的经验可有助于开发新产品   成本估算的不确定性 如果机构对成本估算不太确定，可能增加应急开支项，使得提出的报价超出了一般收益   合同条款 客户可能愿意开发者保留对源代码的版权，并在其他项目中使用。这样付出的价钱会比将软件源代码交给客户时少些   需求易变性 如果需求可能会发生改变，机构会降低它的价格以得到合同，在合同签订后，需求的改变将带来高的要价   财务状况 处于财务困难中的开发者可能会降低报价来得到一份合同。比正常情况下少赚一些甚至亏一点也比没有项目好。在困难时期现金流比利润更重要    23.2 计划驱动的开发  计划驱动的开发，或者叫做基于计划的开发，是一种给开发过程制定详细的计划的软件工程方法 项目计划完整地记录：要完成的工作，谁将执行此项工作，开发进度安排，以及项目的成果是什么 计划驱动开发基于工程项目管理技术，可看做管理大型软件开发项目的传统方法\n 项目计划书应包括的部分\n     内容 描述     引言 简要论述项目的目标，并列出影响项目管理的种种约束条件，如预算、时间的限制等   项目组织 阐述开发团队的组织方式、人员构成及其分工   风险分析 分析项目可能存在的风险，以及这些风险发生的可能性，并提出降低风险的策略   硬件和软件资源需求 介绍完成开发所需的硬件和支持软件。如果需要购买硬件，应注明估算的价格和交付的时间   工作分解 把项目分解成一系列的活动，指定项目里程碑和可交付的文档。里程碑是项目的关键阶段，借此可以评估过程，可交付文档是能够交付给客户的工作产品   项目进度安排 描述项目中各活动之间的依赖关系。到达每个里程碑预期所需的时间以及人员在活动中的分配   监控和报告机制 说明要提交哪些管理报告、什么时候提交，以及使用什么样的项目监控机制     项目辅助计划的例子     计划 描述     质量计划 描述在项目中所要使用的质量过程和标准   有效性验证计划 描述系统有效性验证所采用的方法、资源和进度安排   配置管理计划 描述所要采用的配置管理过程和结果   维护计划 预测维护需求、成本以及工作量   员工发展计划 描述如何发展项目人员的技能和经验    23.3 项目进度安排  项目进度安排：决定如何组织工作，将其分割成单独的一个个任务，并且何时以何种方式完成各项任务  估算需要用于完成每个任务的时间、需要的成本以及完成这些既定任务的人员 估算完成每项任务所需的资源，比如服务器所需磁盘资源、需在专门硬件上占用的时间以及项目人员的差旅费预算  项目启动阶段创建一个初始项目进度安排，在后续的开发规划过程中修改完善  初始进度安排计划如何给项目分配人员，检查项目进展是否符合合同承诺 计划驱动开发：开始阶段创建完整的进度安排，随着项目进行而修改 敏捷过程：必须有一个总的进度安排，确定何时完成项目的各个主要阶段。再使用迭代的方法规划各个阶段  注意并行的任务：不同的员工研发不同的不见 进度安排表示方法  条形图：基于日历时间，表示每项活动的负责人，预计所用时间，以及该项活动预计的开始和结束时间。也叫甘特图 活动网络图：表示构成项目的不同活动之间的依赖关系  项目活动是基本的规划单元，包括  以天或者月计算的工期 工作量估计，反映完成工作所需的人日或人月数 活动完成的期限 定义好的终点，表示完成一项活动的明确结果。可以是一份文档，举行评审会，或是所有测试的成功完成等   23.4 敏捷规划 极限编程的规划过程\n   步骤 描述     情节识别 用户情节反映了系统应包含的特征。项目启动时，开发团队和客户尝试定义一系列情景，使其可以覆盖最终系统的所有功能   初始估计 项目组阅读并讨论情景，按照实现这些情景所需时间将情形排序。此过程也会将大情景拆分成小情景   版本规划 包括选择和完善上述情景。这些情景反映出了在系统的发布版本中应实现的功能以及实现这些情景的顺序。然后选择发布日期，检查情景以判断工作量估计是否满足发布日期。不满足的话，增加或删除清单上的一些情景   迭代规划 迭代开发第一步。选择迭代过程要实现的情景，情景个数反映了交付一次迭代的时间和项目组的进度   任务规划 迭代开发第二步。是一个更详细的规划阶段，将情景拆分成各个开发任务。每项任务大概是 4-16 小时。列出本次迭代所有的任务，开发者申请自己要完成的任务   迭代完成 迭代交付日期到达时，即使未实现所有情景，也宣告完成迭代。迭代完成，考虑已实现的情景，增加工作量，重新规划下一个系统版本。即重复迭代规划和任务规划过程     注意  每个开发者根据自己的速度申请任务，申请的任务量不能多于其在规定时间内能完成的任务量 如果不能按时完成工作，减少工作量，而不是延长进度安排  上述分配任务方法的好处  整个项目组对迭代过程中要完成的任务有一个整体认识。因此他们能够理解项目组其他成员的工作内容已经确定任务依赖关系后应和谁交流 每个开发者选择要完成的任务，而不是由项目管理者分配任务。这样开发者对自己选择的任务有一种拥有感，可能激发他们更好地完成任务   23.5 估算技术    类型 描述     基于经验的技术 使用管理者之前项目和应用领域的经验估算要求的未来工作量，即管理者主观给出所需要的工作量的一个估计   算法成本建模 使用一个公式方法计算项目的工作量，它基于对产品属性(如规模)和过程特点(如参与员工的经验)的估计    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4103dd8a7ee1a09d0d09c038c9b3af54","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/23-project-planning/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/23-project-planning/","section":"blog","summary":"23.1 软件报价 23.2 计划驱动的开发 23.3 项目进度安排 23.4 敏捷规划 23.5 估算技术 项目计划：在项目开始建立，用于向项目开发团队和客户说明工作如何开展，以及帮助估计","tags":["sa","engineer"],"title":"23 项目规划","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  24.1软件质量 24.2 软件标准 24.3 复查与审查 24.4 软件度量和量度\n 质量保证团队：在大多数公司负责管理版本测试过程，即负责软件的测试，检查系统是否满足需求，以及维护测试过程记录\n 质量规划：为项目制定一个质量计划的过程。应当列出要达到的软件质量，并且描述怎么评估这些质量\n 质量文档：记录项目中的每个子小组所做的工作的文件\n 帮助检查，以避免遗忘重要的任务，或避免团队的一部分会对其他团队所做的工作做出错误的假设 贯穿一个系统生命周期的沟通手段 允许对系统进化负责的小组追踪测试以及开发团队所做的工作   24.1软件质量  软件质量管理的一个通用假设：按照需求测试系统。根据测试结果判断是否实现了要求的功能 系统的主观质量很大部分依赖于非功能特性：安全性、可理解性、可移植性、信息安全性、可测试性、可用性、可靠性、可调节性、可复用性、适应力、模块化、效率、鲁棒性、复杂度、学习能力 开发过程对于软件质量有明显的影响：好的过程更有可能得到好的软件。过程质量的管理和改进能够减少软件开发过程中产生的缺陷  24.2 软件标准    重要性 描述     智慧的结晶 软件标准封装了对于机构来说最成功的或最恰当的软件开发实践。制定为标准可避免重犯错误   为定义特定环境中的“质量”含义提供了一个框架 通过使用标准，为判断软件是否达到要求的质量水平建立基础   有助于工作的连续性 由一个人着手进行的工作别人可以接着做。软件标准确保一个机构中所有的工程人员采用相同的做法       类型 描述     产品标准 用于开发的软件产品。包括文档标准，如需求文档格式，文档编写标准，编码标准   过程标准 定义了软件开发必须遵循的过程。应将良好的开发方法封装其中。过程标准包括对描述、设计和有效性验证过程、过程支持工具以及对在这些过程中产生的文档的描述的定义     为了减少不满情绪，设定标准的质量管理人员要采取以下步骤  让软件工程人员参与产品标准的选择 定期评审和修改标准，以反映技术的变化 尽可能提供支持软件标准的软件工具   24.3 复查与审查  质量复查：检查文档和代码的一致性和完整性，确保遵循质量标准  用来发现软件和项目文档的问题和遗漏 复查的结果应当作为质量管理过程的一部分被正式记录  过程复查：将软件工程的实际过程和计划过程对比。关注点是工程是否能够按时并在预算范围内发布有用的软件 复查和审查的目的是提升软件的质量，不是评估开发团队成员的表现  项目管理人员必须对个人的关注保持敏感。必须营造一种文化，发现错误时不责备当事人  复查过程  1 复查前活动：复查前工作关心复查的计划和复查的准备工作 复查计划：包括建立一个复查团队，安排复查的时间地点，分发要被复查的文档 复查准备工作：复查团队见到要复查的软件的一个综述  部分复查团队成员需要阅读并理解软件、文档及相关标准 他们独立工作，依靠标准找出错误、遗漏和违背的地方 不能参加会议的复查人员，可以提供书面的软件意见  2 复查会议：会议期间，被复查文档或程序的作者和复查团队一起把文档从头到尾浏览一遍 复查时间不超过两个小时 包含一个复查主席，负责保证所有的书面意见被考虑在内。在复查期间写西安一个达成共识的意见和行动的记录 包含一个成员正式记录所有复查决议和要采取的行动 3 复查后活动：会议结束后，必须解决在复查期间提出的问题 比如修复软件漏洞，重构软件以使它和质量标准一致，重写文档  敏捷过程的复查  Scrum：每次迭代完成后，会有一个复查会议(冲刺复查)，讨论质量问题 极限编程：配对编程确保另一个团队成员经常检查和复查代码。极限编程依赖于个人主动性来提升和重构代码  程序审查：同行评审，团队成员合作发现开发程序中的漏洞  不同背景的团队成员，对程序源码进行精心、一行一行的复查 寻找错误和问题(逻辑错误，代码异常等)，并在审查会议中描述出来 审查时，经常使用一份常见编程错误的检查表。且不同的语言有不同的检查表 每个机构应当根据部门标准和实践开发自己的检查表，并经常更新检查表   24.4 软件度量和量度    中文 英文 描述 目标     软件度量 measurement 对软件组织、系统或过程的某种属性进行量化 长期目标是利用度量代替复查，评判软件质量。度量之后达到所需质量阈值就可以不通过复查而被接受   软件量度 metric 能被客观度量的软件系统、系统文档或开发过程有关的特性 软件量度影响管理决策的制度       软件量度分类 描述 举例 影响     控制量度 支持过程管理，常与软件过程相关 修复发现的缺陷所需平均工作量和时间 决定是否做出过程改变   预言者量度(产品量度) 与软件本身相关 模块的回路复杂性，程序中标识符的平均长度，在设计中与对象有关的属性和操作的数量 用来估计软件变更所需的成本     软件产品量度可能用到的方法：\n 给系统质量属性赋值：通过度量系统组件的特性(如回路复杂性)，并综合这些量度，评估系统质量属性(如可维护性) 找出质量低于标准的系统组件：度量能识别哪些特性背离某些规范的个别组件。比如找出有着高复杂性的问题组件，因为复杂度高难于理解，组件更可能包含错误  CK 面向对象的量度套件\n     面向对象量度 描述     每个类加权后的方法 每个类的方法数，是对每个方法根据复杂度进行加权后计算所得。度量值越大，对象类越复杂   继承树的深度(DIT) 在继承树中的具体层数。继承树越深，设计越复杂   孩子数(NOC) 度量类的直接子类数，NOC 度量类层次结构的宽度，DIT 代表它的深度。NOC 高意味着更多的复用   对象类间耦合度(CBO) 当一个类中的方法使用在另一个类中定义的方法或实例时，类间就是耦合的。CBO 意味着类是高度依赖的   对类的响应(RFC) 当类的对象接收到消息时潜在可能的对此做出相应的方法数的度量。RFC 越高，类的复杂度越高   方法追你个缺乏内聚力(LCOM) 通过计算类中各对方法而得。LCOM 是两个数的差，一个数是方法间没有共享属性的方法对数，一个数是方法间共享属性的方法对数。此亮度值的意义有争议     软件组件分析的关键阶段  选择要做的度量 选择要评估的组件 度量组件特性 识别异常度量 分析异常组件   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4281bd3587890d7b7acc51e331ee7638","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/24-quality-management/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/24-quality-management/","section":"blog","summary":"24.1软件质量 24.2 软件标准 24.3 复查与审查 24.4 软件度量和量度 质量保证团队：在大多数公司负责管理版本测试过程，即负责软件的测试，检查系统是否满足需求","tags":["sa","engineer"],"title":"24 质量管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  25.1 变更管理 25.2 版本管理 25.3 系统构建 25.4 发布版本管理  软件系统产品的配置管理活动包括\n   名称 描述     变更管理 跟踪来自客户和开发者的软件变更请求，计算做出这些变更的花费并估计其影响，决定是否变更、何时完成变更   版本管理 跟踪系统组件的多个版本，确保由不同开发者对组件做出的变更不会彼此干涉   系统构建 一个组装程序组件、数据和库的过程，然后把这些组件编译链接成一个可执行系统   发布管理 包括准备对外发布的软件，持续跟踪已经发布以供客户使用的系统版本       配置管理术语 解释     配置项或软件配置项(SCI) 与配置管理控制下的软件项目有关的人格事物(设计、代码、测试数据、文档等)。配置项会存在多个不同的版本。每个配置项有唯一的名字   配置控制 确保系统和组件的版本得到记录和维护的过程。这样变更可以得到管理，所有的组件的版本都能在整个系统生命周期中识别和存储   版本 配置项的一个实例，区别于其他配置项的实例。版本总是有一个唯一标识符，通常由配置项名字加上版本号组成   基线 用于组成系统的组件版本的集合。基线是受控的，意味着构成系统的组件的版本是不能改变的，总是可以从它的组成组件中重新创建一个基线   代码线 是软件组件以及组件所依赖的其他配置项的集合   主线 代表系统不同版本的基线的序列   发布版本 发布给客户(或其他机构中用户)使用的系统版本   工作空间 一个私有的工作空间，在其中软件可以修改而不至于影响其他会使用或修改软件的开发者   分支 从现存的代码线的版本中创建一个新的代码线。然后新的代码线和已存在的代码线可独立开发   合并 通过合并在不同代码线中的单独版本创建软件组件的新版本。这些代码线可能是由某个代码线的先前存在的分支所创建的   系统构建 通过耦合和链接组件和库的适当版本创建一个可执行的系统版本    25.1 变更管理  变更管理过程  提交变更请求：客户(非开发团队)完成并提交一个描述对系统的变更的变更请求 变更请求可能是描述错误症状的错误报告，也可能是增加系统附加功能的请求 变更请求：可通过填写变更请求表(CRF)来提交 变更请求表包含的内容：提议、估算成本、请求、核准、实现和有效性验证日期、开发人员实现变更的概述 检查变更请求：检查以确保是否有效 检查者可来自客户、应用支持团队或开发团队的一个成员(内部请求时) 评估和成本估算：处理有效的变更请求 通常是开发团队或维护团队的任务 开发团队检查所有因变更而受到影响的组件 评估系统请求变更的模块 产品开发小组或变更控制委员会估算实现成本以及其他系统组件可能要相应发生变更的成本 决定是否同意变更请求时需要考虑的因素  不做变更会引起的后果 变更的益处：哪些用户收益 变更影响的用户数：影响用户越多，优先级越低，甚至不可取 变更所需花费 产品发布循环：刚发布版本，可推迟需求到下一个版本  影响到单个组件或模块的变更，不需要单独评估，可直接交给开发团队 实现变更：开发团队变更软件组件时，应维护每个组件的变更记录，也成为组建的导出历史 最佳方式是将其放在组件源代码开头的标准化的注释部分 注释应该索引到引起系统变更的请求 每个版本的变更记录经常放到一个独立页中，一般放在文档的前面   25.2 版本管理  版本管理(VM, version management)：跟踪软件组件或配置信息以及使用这些组件系统的不同版本的过程  版本管理确保由不同开发者做出的变更不会彼此影响 版本管理过程可看做是管理代码线和基线的过程  版本管理系统的特征     特征 描述 优点     版本和发布版本识别 被管理版本提交给系统时给它们分配标识符。标识符通常基于配置项的名字，后跟一位或几位数字 简化了定义配置的问题，是快速索引更简单   存储管理 版本管理系统通常会提供存储管理工具。系统只存储每个版本不同之处的列表而不是每个版本的副本 减少了只有轻微差异的不同版本所占存储空间。通过把版本的不同之处列表应用到源版本(通常是最近的版本)，就能够重建目标版本   变更历史记录 记录并列出所有对系统或组件做出的变更 在一些系统中，这些变更可以用来选择一个特殊的系统版本   独立开发 不同的开发者可能在同一时间正在相同的组件上工作 版本管理系统跟踪检出的组件，确保不同开发者对组件做出的变更不会彼此影响   项目支持 一个版本管理系统可能支持共享组件的几个项目的开发 ——    25.3 系统构建  系统构建是把软件组织、外部的库、配置文件等编译和链接成一个完整的、可执行的程序的过程 构建过程可能有三种不同的系统平台  开发系统：包括开发工具，比如编译器、源码编译器等 开发系统对应的是私有工作空间 开发人员将代码从版本管理系统下载到私有空间，再做修改 构建服务器：用于构建确定的、可执行的系统版本 构建服务器和版本管理系统紧密交互 系统构建可能依赖外部库，但这些库未包含在版本管理系统 目标环境：对应目标平台，是系统运行的平台 可能是和用于开发和构建系统相同类型的电脑  构建系统的特征     特征 描述     构建脚本生成 在必要情况下，构建系统应该分析待构建的程序，识别依赖的组件，并自动生成一个构建脚本(有时叫配置文件)。系统也应支持手工创建和编辑构建脚本   版本管理系统集成 构建系统应从版本管理系统中检出需要的组件版本   最小化再编译 构建系统应分析出哪些源代码需要进行再编译，再对需要的代码进行编译   可执行系统创建 构建系统应将编译后的各个目标代码文件以及其他需要的文件(如库文件、配置文件等)链接起来，创建可执行的系统   测试自动化 有的构建系统能使用自动化工具，如 JUnit，自动运行自动测试。可以检查构建是否被变更破坏   报告 构建系统应提供关于运行的构建或测试成功与否的报告   文档生成 构建系统可能能生成关于构建和系统帮助页面的版本注释     持续集成的步骤     步骤 描述     检出主线 将主线系统从版本管理系统中检出到开发人员的私有工作空间   构建和测试系统 构建系统并允许自动测试，以确保所构建的系统能通过所有测试。不能则构建终止。这时应通知最后提交主线系统的开发人员。他们负责修复这个问题   做相应变更 完成系统组件的变更   构建和测试系统 在私有工作空间构建系统并重新运行测试。测试失败则继续编辑   检入到构建服务器 系统通过测试，将它检入到构建系统，但是不要作为新系统基线提交   构建和测试系统 在构建服务器上构建系统并运行测试。如果有人修改了组件，检出失败的组件并进行编辑，使测试在私有工作空间通过   加入版本管理系统 如果系统在构建系统上通过测试，将作出的变更作为系统主线中的一个新的系统基线    25.4 发布版本管理  系统的发布版本：分发给客户的版本  主要发布：交付重要的新功能 小型发布：修复漏洞和用户报告的问题  发布版本应包括  系统的可执行代码 配置文件：定义对于特定安装，发布版本应该如何配置 数据文件：比如错误信息的文件，是成功进行系统操作必需的 安装程序：用来帮助在目标硬件上安装系统 电子和书面文档：用于系统说明 包装和相关的宣传：为发布版本所做的工作   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"751b2ef80b7e8a06d3e2e17aed72d0f5","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/25-configuration-management/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/25-configuration-management/","section":"blog","summary":"25.1 变更管理 25.2 版本管理 25.3 系统构建 25.4 发布版本管理 软件系统产品的配置管理活动包括 名称 描述 变更管理 跟踪来自客户和开发者的软件变更请求，计算做出这些变","tags":["sa","engineer"],"title":"25 配置管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  3.1 Redis 数据备份与恢复 3.2 Redis 安全 3.3 Redis 性能测试 3.4 Redis 客户端命令 3.5 Redis 管道技术 3.6 Redis 分区  3.1 Redis 数据备份与恢复    命令 描述     SAVE 创建当前数据库的备份，在 Redis 安装目录创建 dump.rdb 文件   CONFIG GET dir 获取 Redis 安装目录。将备份文件 dump.rdb 移动到安装目录并启动服务即可   BGSAVE 在后台执行命令，创建 Redis 备份文件    3.2 Redis 安全  通过配置文件设置密码，使得客户端连接到 Redis 服务需要密码验证     命令 描述     CONFIG get requirepass 查看是否设置了密码验证。默认 requirepass 参数为空，即无需密码   CONFIG set requirepass password 设置密码。之后客户端连接 Redis 服务需要密码验证   AUTH password 输入密码验证    3.3 Redis 性能测试  通过同时执行多个命令实现性能测试 基本命令 redis-benchmark [option] [option value]  在 Redis 安装目录下执行 不是 Redis 客户端的内部命令      可选参数 描述 默认值     -h 指定服务器主机名 127.0.0.1   -p 指定服务器端口 6379   -s 指定服务器 socket -   -c 指定并发连接数 50   -n 指定请求数 10000   -d 以字节的形式指定 SET/GET 值的数据大小 2   -k 1=keep alive 0=reconnect 1   -r SET/GET/INCR 使用随机 key, SADD 使用随机值 -   -P 通过管道传输 numreq 请求 1   -q 强制退出 redis。仅显示 query/sec 值 -   \u0026ndash;csv 以 CSV 格式输出 -   -l 生成循环，永久执行测试 -   -t 仅运行以逗号分隔的测试命令列表 -   -I Idle 模式。仅打开 N 个 idle 连接并等待 -    3.4 Redis 客户端命令  Redis 通过监听一个 TCP 端口或 Unix socket 方式接收来自客户端的连接。建立一个连接后，Redis 内部会进行  客户端 socket 被设置为非阻塞模式，因为 Redis 在网络事件处理上采用的是非阻塞多路复用模型 为该 socket 设置 TCP_NODELAY 属性，禁用 Nagle 算法 创建一个可读的文件事件用于监听该客户端 socket 的数据发送  最大连接数： Redis 2.4 中，最大连接数被硬编码到代码内部。2.6 之后可配置  CONFIG get maxclients 查看最大连接数 CONFIG set maxclients 1000 修改最大连接数 redis-server --maxclients 10000 在服务启动时设置最大连接数      命令 描述     CLIENT LIST 返回连接到 Redis 服务的客户端列表   CLIENT SETNAME 设置当前连接的名称   CLIENT GETNAME 获取通过 CLIENT SETNAME 命令设置的服务名称   CLIENT PAUSE 挂起客户端连接，指定挂起的时间以毫秒计   CLIENT KILL 关闭    3.5 Redis 管道技术  Redis 是一种基于客户端-服务端模型以及请求/响应协议的 TCP 服务。一般步骤  客户端向服务端发送一个查询请求，并监听 socket 返回。通常以阻塞模式，等待服务端响应 服务端处理命令，将结果返回给客户端  Redis 管道技术可在服务端未响应时，客户端可继续向服务端发送请求，并最终一次性读取所有服务端的响应 管道技术提高了 Redis 服务的性能  3.6 Redis 分区  分区是分割数据到多个 Redis 实例的处理过程。每个实例只保存 key 的一个子集 优势  通过利用多台计算机内存的和值，使得可以构造更大的数据库 通过多核和多台计算机，支持扩展计算能力；通过多台计算机和网络适配器，支持扩展网络带宽  不足  通常不支持涉及多个 key 的操作。如，当两个 set 映射到不同的 Redis 实例上时，不能对两个 set 做交集操作 不能使用涉及多个 key 的 Redis 事务 数据处理复杂。如，需要处理多个 rdb/aof 文件，并且从多个实例和主机备份持久化文件 增删容量复杂。Redis 集群大多支持在运行时增删节点的透明数据平衡能力。类似于客户端分区、代理等其他系统则不支持此特性。可参考 presharding 技术  分区类型  范围分区：映射一定范围的对象到特定的 Redis 实例 不足：要有一个区间范围到实例的映射表，要管理表和各种对象的映射表 哈希分区：对任何 key 都适用。操作方法 用一个 hash 函数将 key 转换为一个数字 对整数取模(按照 Redis 实例数目)，从而映射到其中一个 Redis 实例   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a54809f5ddaf067aaecd1f7babc169ad","permalink":"https://xueqing.github.io/blog/database/redis/3_advanced/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/redis/3_advanced/","section":"blog","summary":"3.1 Redis 数据备份与恢复 3.2 Redis 安全 3.3 Redis 性能测试 3.4 Redis 客户端命令 3.5 Redis 管道技术 3.6 Redis 分区 3.1 Redis 数据备份与恢复 命令 描述 SAVE 创建当前数据库的备份，在 Redis 安装目录创建 dump.rdb","tags":["database"],"title":"3 Redis 进阶","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  3.1 敏捷方法 3.2 计划驱动开发和敏捷开发 3.3 极限编程 3.4 敏捷项目管理 3.5 可扩展的敏捷方法  敏捷方法是增量式开发方法，每个增量一般较小，通常两到三周会提供新版本给用户使用\n3.1 敏捷方法 敏捷方法的基本原则\n   原则 描述     客户参与 客户在开发过程中始终紧密参与。作用是提供新系统的需求、对需求进行排序，并评估系统的迭代   增量式交付 软件以增量方式开发，客户指定在每个增量的内容   人非过程 开发团队的技术应得到承认和发扬，团队成员应保持自己的工作风格   接受变更 预料系统需求的变更，设计系统使其适应变更   保持简单性 致力于所开发软件和开发过程的简单性    3.2 计划驱动开发和敏捷开发 计划驱动开发和敏捷开发的对比\n   区别 计划驱动开发 敏捷开发     过程 需求工程-\u0026gt;需求描述-\u0026gt;设计和实现，阶段之间用正式文件沟通 需求工程-\u0026gt;设计和实现   开始实现之前，详细和描述和设计很重要 是 否   软件交付并快速取得反馈可行 否 是   开发系统的规模 大的开发团队，大型系统 小的、处于同一地点的开发团队   开发系统的类型 实施之前需要大量分析和设计 ——   预期的系统寿命 长寿命，需要更多设计文档 文档更新不及时，且长期维护不需要   支持系统开发的技术 使用 IDE，且没有好的可视化编程和开发工具 依赖好的工具以跟踪设计进化   组织开发团队 分散或外包，需要文档进行沟通 ——   设计和编码人员的能力 水平较低，需要更好的设计人员 需要更高的技术水平    3.3 极限编程    实践或原则 描述     增量式规划 需求记录在脚本/场景/情景卡片，包含在版本中的故事情节可以决定可用的时间和相对优先级。开发者将脚本分解成任务   小版本发布 先开发能提供业务价值的一个最小有用集合。增量式地王第一个版本添加新功能   简单设计 只进行有限的能满足当前需求的设计，不追求太多   测试优先的开发 实现功能钱，采用一个自动单元测试框架编写对新功能的测试   重构 期待所有开发人员连续地重构代码，只要有能改善的代码就做，保持代码的简单性和可维护性   结对编程 开发人员成对工作，检查彼此的工作并提供支持   集体所有 配对的开发人员参与系统的所有方面的工作，共享代码。任何人可以修改任何代码   连续集成 任务一完成，将它继承到大系统。每次集成后，必须通过系统所有的单元测试   可持续的节奏 大量超时不能接受，因为这通常会降低代码质量和平均生产率   在场客户 系统最终用户的代表(客户)应全程配合 XP 团队。客户有责任将系统需求带给开发团队    3.4 敏捷项目管理 Scrum 方法是一个通用的敏捷方法，主要是注重迭代开发的管理。\n   序号 阶段 描述     1 规划纲要 建立大致的项目目标，设计软件体系结构   2 冲刺循环 每个循环开发一个系统增量   3 项目结束 总结项目，完善需要的文档(如系统帮助和用户手册)，总结经验    冲刺循环的流程：评估，特征的选择和开发，软件实现。特点包括\n 冲刺长度固定：一般是 2~4 周对应一个版本 规划起点：积压的任务，即项目中要完成的工作清单 2.1 评估阶段审查这些积压的任务，进行优先级排序并进行风险的指派 2.2 在此过程中，用户在每个循环开始时提出新的需求或任务的建议 选择阶段：项目团队的人员都参加，和用户角色相同 软件开发：每天，团队成员参加短时会议，回顾开发过程，科能会重新安排工作 冲刺循环结束：对已做工作复查并交付用户。开始下一个循环  3.5 可扩展的敏捷方法 将敏捷的一些重要内涵应用域大型工程：弹性计划、频繁发布、持续集成、测试驱动开发、良好的团队沟通\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a1057499d09b005597749ec0c7a23519","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/3-agile-software-development/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/3-agile-software-development/","section":"blog","summary":"3.1 敏捷方法 3.2 计划驱动开发和敏捷开发 3.3 极限编程 3.4 敏捷项目管理 3.5 可扩展的敏捷方法 敏捷方法是增量式开发方法，每个增量一般较小，通常两到三周会提供新","tags":["sa","engineer"],"title":"3 敏捷软件开发","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  3.1 迭代/增量和准备进化 3.2 面对面沟通 3.3 反馈回路  3.1 迭代/增量和准备进化  大多数敏捷开发方法将一个问题分解成小任务。对于所有的需求没有直接长期的计划。通常，迭代是短时间的规划，例如一到四周。 每个迭代都有一个跨职能的团队，工作内容包含软件开发的所有功能，包括规划、需求分析、设计、编码、单元测试和验收测试 迭代结束的产物是一个可工作的产品，并在迭代结束后向利益相关者展示 演示之后，采纳评审意见，并根据需求计划包含进可工作的软件  3.2 面对面沟通  每个敏捷团队应该有一个客户代表(类似Scrum 中的产品负责人)。这个代表被授权代表利益相关者，且能够回答开发者在迭代中的问题 通常会在办公室的显著位置放一个消息辐射体(实体显示器)，以便路人可以看到敏捷团队的进度。消息辐射体展示了最新的项目状态总结  3.3 反馈回路  每日站会是所有敏捷开发的一个共同文化，也称为日常 Scrum。它是一个简短的会议，每个团队成员相互报告自己已经完成的、接下来要做的以及面对的所有问题状态  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"18066a3c2979d3d12e696951be0c575b","permalink":"https://xueqing.github.io/translation/agile/tutorial/3-characteristics/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/3-characteristics/","section":"translation","summary":"3.1 迭代/增量和准备进化 3.2 面对面沟通 3.3 反馈回路 3.1 迭代/增量和准备进化 大多数敏捷开发方法将一个问题分解成小任务。对于所有的需求没有直接长期的计划","tags":["agile"],"title":"3 特点","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  3.1 支付 3.2 外部结算 3.3 促销  3.3.1 代金券 3.3.2 打折销售 3.3.3 买赠 3.3.4 满减 3.3.5 实物购买以及税务问题 3.3.6 退换货  3.4 充值与提现  本文描绘一堆业务对应的会计分录\n3.1 支付  继续小明的案例，小明通过工行在老熊公司买了一张 100 元的会员卡，工行按照支付金额的 0.1% 收取手续费，产生了如下会计分录\n借：应收账款-工行收款 100-100*0.1% = 99.9 服务成本-工行手续费 100*0.1% = 0.1 贷：主营业务收入-会员卡 100\n 在电商侧执行日切，将当前的应收账款归集到存款上，在接收到工行对账单后，对这个日切结果也要对账。假定当前收入为 200 万元，手续费为 2 千元，对应的会计分录为\n借：银行存款-工行 2,000,000-2,000= 1,998,000 贷：应收账款-工行收款 1,998,000\n  3.2 外部结算  如果小明买的是其他公司(凤凰公司)的会员卡，该卡由老熊公司代理销售，代理价格是 90 元。这个流程会更复杂。买断式的代理，和仅仅支付手续费的代理在记账上略有区别。这里仅提供供参考的版本，具体记账的会计科目需要按照公司的情况来具体处理 老熊公司接收到凤凰公司发送过来的 100 张会员卡，每张卡售价是 100 元。这些卡作为预售的代销商品入库，记录到代销商品中。其会计分录如下\n借：代销商品-凤凰会员卡 90*100 = 9,000 贷：代销商品款-凤凰会员卡 90*100 = 9,000\n 对应的会员卡信息，每张卡的卡号、价格等信息，可以记录到明细表中\n 老熊公司销售出一张会员卡给小明，产生的会计分录如下\n借：应收账款-工行收款 99.9 服务成本-工行手续费 0.1 贷：主营业务收入-会员卡 100\n借：主营业务成本-会员卡 90 贷：代销商品-凤凰会员卡 90\n借：代销商品款-凤凰会员卡 90 贷：应付账款-凤凰会员卡 90\n 这里是将收入记录到主营业务收入的科目下，实际情况应该按照公司的会计要求来进行\n 老熊公司当天销售了 10 张卡，银行将当天的收入结算给老熊公司。这个可以单独分录，也可以和银行的其他结算一起分录\n借：银行存款-工行 9,990 贷：应收账款-工行收款 9,990\n 老熊公司当天将卡收入结算给凤凰公司，未考虑税费的问题，会计分录如下\n借：应付账款-凤凰会员卡 9,000 贷：银行存款 9,000\n  3.3 促销 常用促销方式包括代金券、折扣券、买赠、满减等，以下简单介绍各个方式的记账\n3.3.1 代金券  对代金券的财务处理目前没有统一的标准，会计处理方法因公司核算方式不同会有多种，有营销费用、销售折扣、主营业务成本等方式 在这个案例中，我们假定老熊公司发放了 100 张优惠券，每张价值 10 元。会计分录\n借：营销成本-通用优惠券 1000 贷：预计负债-通用优惠券 1000\n 当用户使用优惠券购买商品时，10 元的优惠券，用户实际付款是 90 元，手续费按照 90*0.1% 来计算。会计分录\n借：应收账款-工行收款 89.91 服务成本-工行手续费 0.09 预计负债-通用优惠券 10 贷：主营业务收入-会员卡 100\n 这批优惠券到期后，实际发放了 80 张，还有 20 张需要回收，每张价值还是 10 元，回收时会计分录\n借：预计负债-通用优惠券 200 贷：营销成本.通用优惠券 200\n 这种方式处理优惠券，是按照使用优惠券之前的价格，也就是 100 元来计算增值税，公司所得税会相应扣减，但处理起来也比较麻烦。还有一种简单的方式是直接在用户消费的时候记账\n借：应收账款-工行收款 89.91 服务成本-工行手续费 0.09 贷：主营业务收入-会员卡 90\n 可以在明细账中记录用户使用的优惠券\n  3.3.2 打折销售  折扣销售时，和普通销售一样处理，金额按照打折后的来计算 老熊公司促销，8 折优惠，小明用 80 块钱买了张会员卡，会计分录如下\n借：应收账款-工行收款 80-0.08 = 79.92 服务成本-工行手续费 80*0.1% = 0.08 贷：主营业务收入-会员卡 80\n  3.3.3 买赠  买赠和打折销售类似，需要按照比例来分摊 老熊公司推出买一增一活动，买一张 100 元的会员卡，赠送一张价值 50 元的点播卡。会计分录如下\n借：应收账款-工行收款 100-0.1 = 99.9 服务成本-工行手续费 100*0.1% = 0.1 贷：主营业务收入-会员卡 100*100/(100+50) = 66.67 主营业务收入-点播卡 50*100/(100+50) = 33.33\n  3.3.4 满减  满减活动的处理和买赠类似，需要按比例来分摊 老熊公司推出满 200 减 50 的活动，小明买了一张 100 元会员卡，1 张 50 元点播卡，1 张 50 元游戏卡。也就是 150 元买了 3 张卡，每张卡的收入按比例来分摊，会计分录如下\n借：应收账款-工行收款 200-0.2 = 199.8 服务成本-工行手续费 2000.1% = 0.2 贷：主营业务收入-会员卡 100(200-50)/200 = 75 主营业务收入-点播卡 50(200-50)/200 = 37.5 主营业务收入-游戏卡 50(200-50)/200 = 37.5\n  3.3.5 实物购买以及税务问题  实物购买涉及到送货费用、税费等。送货费用每个公司处理起来差异较大，这里不介绍 在税费处理上，一般是在计算业务收入时扣除。实物按照 17% 的增值税来扣减 如小明在老熊公司买了 100 块钱的卡通熊玩偶，记账如下：\n借：应收账款-工行收款 99.9 服务成本-工行手续费 0.1 贷：主营业务收入-卡通熊 100\u0026frasl;1.17 = 85.47元 应交税费–应交增值税 100\u0026frasl;1.17*17%=14.53元\n  3.3.6 退换货  退货根据销售的不同阶段，采取相应的冲销。在货款到对公账户前退货，则对冲应收账款；如果是货款已经到公司银行账户了，则对冲银行存款 换货可以按先退货再购买的方式来记账  3.4 充值与提现  和支付类似，用户充值也分为两个步骤\n 第一步是执行充值操作，充值到公司对公账户上，但是资金并不是立即到账的，这个过程的会计分录如下\n借：应收账款-工行收款 99.9 服务成本-工行手续费 0.1 贷：客户账户-小明 100\n 在第二天资金到账后，应收账款变为公司的存款，这个过程同支付\n  提现流程和充值相反，会计分录如下\n借：客户账户-小明 100 服务成本-工行手续费 0.1 贷：应付账款-工行 100.1\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"27cb0518ba9eee03ff93c8c4c62c4123","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/3_%E7%94%B5%E5%95%86%E4%BE%A7%E5%A4%84%E7%90%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/3_%E7%94%B5%E5%95%86%E4%BE%A7%E5%A4%84%E7%90%86/","section":"blog","summary":"3.1 支付 3.2 外部结算 3.3 促销 3.3.1 代金券 3.3.2 打折销售 3.3.3 买赠 3.3.4 满减 3.3.5 实物购买以及税务问题 3.3.6 退换货 3.4 充值与提现 本文描绘一堆业务对应的会计分录 3.1 支付 继续小明的","tags":["o2o"],"title":"3 电商侧处理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  3.1 FHS 标准 3.2 Linux 根目录  3.2.1 系统启动相关 3.2.2 命令集合 3.2.2.1 /usr 目录 3.2.2.2 Linux 命令  3.2.2.2.1 命令提示符 3.2.2.2.2 命令的基本格式 3.2.2.2.3 命令分类  3.2.3 外部文件和设备管理 3.2.4 临时文件 3.2.5 账户相关 3.2.6 运行过程相关 3.2.6.1 /var 目录 3.2.7 扩展所需  3.3 注意  3.1 FHS 标准  为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准 FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件  3.2 Linux 根目录  FHS 认为，Linux 系统的根目录（/）最为重要（没有之一），其原因有以下 2 点  所有目录都是由根目录衍生出来的 根目录与系统的开机、修复、还原密切相关  在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构  文件系统的最顶层由根目录开始的，系统使用/表示根目录 根目录之下的既可以是目录(一级目录)，也可以是文件，而每一个目录中又可以包含子目录(二级目录)和文件。如此反复就可以构成一个庞大的文件系统  两个特殊的目录  用户所在的工作目录，也叫当前目录，可使用一个点.或./表示 当前目录的上一级目录，也叫父目录，可使用两个点..或../表示  如果一个目录或文件名以一个点.开始，表示这个目录或文件是一个隐藏目录或文件(.bashrc)。即以默认方式查找时，不显示该目录或文件  3.2.1 系统启动相关    目录 描述     /boot 存放启动 Linux 时使用的一些核心文件，包括一些链接文件以及镜像文件   /etc 存放所有系统管理所需要的配置文件和子目录，更改目录下的文件可能导致系统不能启动。系统内所有默认安装（rpm 安装）的服务配置文件全部保存在此目录，如用户信息、服务启动脚本、常用服务的配置文件等   /lib 存放系统最基本的动态链接共享库，作用类似 Windows 的 DLL 文件。几乎所有的应用程序都需要用到这些共享库   /sys 虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息。这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建    3.2.2 命令集合    目录 描述     /bin Binary 的缩写，存放最常使用的命令(如 ls 在 /bin/ls 目录)，普通用户和 root 都可执行。在单用户模式下也可以执行   /sbin s(Super User)，保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看   /usr/bin 系统用户使用的应用程序，普通用户和超级用户都可执行。这些命令和系统启动无关，在单用户模式下不能执行   /usr/sbin 超级用户使用的比较高级的管理程序和系统守护程序     /bin, /sbin, /usr/bin, /usr/sbin: 系统预设的执行文件的放置目录  /sbin, /usr/sbin 是给 root 使用的指令 /bin, /usr/bin 是给系统用户使用的指令(除root外的通用户)   3.2.2.1 /usr 目录  usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录 Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\\Windows\\ + C:\\Program files\\ 两个目录的综合体     目录 描述     /usr/include C/C++ 等编程语言头文件的放置目录   /usr/lib 应用程序调用的函数库保存位置   /usr/local 手工安装的软件保存位置。一般建议源码包软件安装在这个位置   /usr/src 内核源代码默认的放置目录。手工下载的源码包和内核源码包都可以保存到这里   /usr/XllR6 图形界面系统保存位置    3.2.2.2 Linux 命令 3.2.2.2.1 命令提示符  登录系统后，第一眼看到的内容是：\n[root@localhost ~]#  这就是 Linux 系统的命令提示符\n []：这是提示符的分隔符号，没有特殊含义 root：显示的是当前的登录用户 @：分隔符号，没有特殊含义 localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain） ~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录 #：命令提示符，Linux 用这个符号标识登录的用户权限等级 超级用户，提示符是 # 普通用户，提示符是 $  用户在自己的家目录中拥有完整权限，所以建议操作实验可以放在家目录中进行\n[root@localhost ~]# cd /usr/local # 切换用户所在目录，命令提示符中的 ~ 会变成用户当前所在目录的最后一个目录（不显示完整的所在目录 /usr/local，只显示最后一个目录 local) [root@localhost local]#   3.2.2.2.2 命令的基本格式  基本格式 命令[选项][参数]  [] 代表可选项，也就是有些命令可以不写选项或参数，也能执行  用 Linux 中最常见的 ls 命令来解释一下命令的格式\n 如果按照命令的分类，那么 ls 命令应该属于目录操作命令\n# ls 命令之后不加选项和参数也能执行，但只能执行最基本的功能，即显示当前目录下的文件名 [root@localhost ~]# ls anaconda-ks.cfg install.log install.log.syslog # 如果加\u0026quot;-l\u0026quot;选项，可以看到显示的内容明显增多了 # \u0026quot;-l\u0026quot;是长格式（long list）的意思，也就是显示文件的详细信息 [root@localhost ~]# Is -l 总用量44 -rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg -rw-r--r--.1 root root 24772 1 月 14 18:17 install.log -rw-r--r--.1 root root 7690 1 月 14 18:17 install.log.syslog   选项的作用：调整命令功能。如果没有选项，命令只能执行最基本的功能；而选项可以显示更加丰富的数据\n 短格式选项（-l）：是英文的简写，用一个减号调用，如 [root@localhost ~]# ls -l 长格式选项（\u0026ndash;all）：是英文完整单词，一般用两个减号调用，如 [root@localhost ~]# ls --all 一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项 当然也有例外，比如 ls 命令的短格式选项 -l 就没有对应的长格式选项 具体的命令选项可以通过帮助命令来进行査询  参数的作用\n 参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作 命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数\n[root@localhost ~]# ls -l anaconda-ks.cfg -rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg # ls 默认参数是当前所在位置，显示当前目录下的文件名 [root@localhost ~]# ls anaconda-ks.cfg install.log install.log.syslog    3.2.2.2.3 命令分类  Linux 命令按照来源方式，可分为两种  Shell 内置命令：Shell 自带的命令，这些命令没有执行文件，也没有执行文件所在路径 外部命令：外部命令是由程序员单独开发的，是命令，会有命令的执行文件  Linux 中的绝大多数命令是外部命令  3.2.3 外部文件和设备管理    目录 描述     /dev Device(设备)的缩写, 存放 Linux 的外部设备，在 Linux 中访问设备和访问文件的方式相同   /media Linux 系统会自动识别一些媒体设备(U 盘/光驱)，识别后把识别的设备挂载到这个目录   /mnt 为了让用户临时挂载别的文件系统。可以将光驱挂载在/mnt/上，然后进入该目录查看光驱里的内容   /misc 挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是哪个目录挂载什么设备可由管理员自己决定    3.2.4 临时文件    目录 描述     /lost+found 一般情况下为空，当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录   /run 一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果系统上有 /var/run 目录，应该让它指向 run   /tmp 用来存放一些临时文件    3.2.5 账户相关    目录 描述     /home 用户主目录(也称家目录)。创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录   /root 系统管理员，也称作超级权限者的用户主目录    3.2.6 运行过程相关    目录 描述     /proc 虚拟文件系统。是一个虚拟目录，是系统内存的映射，可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘而在内存，主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的。也可直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all   /var 存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等    3.2.6.1 /var 目录  /var：这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里     目录 描述     /var/lib 程序运行中需要调用或改变的数据保存位置。如 MySQL 数据库保存在 /var/lib/mysql/   /var/log 登陆文件放置的目录，其中包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等   /var/nis和/var/yp NIS 服务机制使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 NIS 服务的日志文件存放的目录   /var/run 一些服务和程序运行后，它们的 PID（进程 ID）保存位置   /var/spool 主要是一些临时存放，随时会被用户调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务   /var/tmp 一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除   /var/www RPM 包安装的 Apache 的网页主目录    3.2.7 扩展所需    目录 描述     /opt 第三方安装的软件保存位置。是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录。如安装一个ORACLE数据库就可以放到这个目录下。默认是空。/usr/local/ 目录也可以用来安装软件   /selinux Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的   /srv 服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据    3.3 注意  /proc/fn/sys/ 保存在内存，如果在这里写入数据，那么内存会越来越小，直至死机 /boot/ 不能保存额外数据，因为会单独分区作为启动分区，如果没有空闲空间，会导致系统不能正常启动  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"10db8ee603132003d0f836d40acf9f55","permalink":"https://xueqing.github.io/blog/linux/3_%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/3_%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","section":"blog","summary":"3.1 FHS 标准 3.2 Linux 根目录 3.2.1 系统启动相关 3.2.2 命令集合 3.2.2.1 /usr 目录 3.2.2.2 Linux 命令 3.2.2.2.1 命令提示符 3.2.2.2.2 命令的基本格式 3.2.2.2.3 命令分类 3.2.3 外部文件和设备管理 3.2.4 临时文件 3.2.5 账户相关 3.2.6 运","tags":["linux"],"title":"3 系统目录结构","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  3.1 支付和交易  3.1.1 银行卡支付 3.1.1.1 认证支付 3.1.1.2 网银支付 3.1.1.3 快捷支付  3.2 支付流程 3.3 资金流 3.4 银行 Token 支付  3.4.1 对接银行 3.4.1.1 专线问题 3.4.1.2 加密问题 3.4.2 对接银联   3.1 支付和交易  支付和交易，这两个概念在不同公司不一样 此处的定义  交易是生成订单；支付是对订单进行付款  就支付行为来说，大部分都是单次支付，其次还有转账和退款 单次支付是用的最多的支付方式，即一次结清所有款项。把单次支付走通了，其他支付方式也容易处理  3.1.1 银行卡支付  银行卡支付：分为线上支付和线下支付  线下支付：通常说的 POS 收单，这里不介绍 线上支付 按照卡的类别，分为贷记卡支付，也叫motopay、ePOS，即信用卡支付；和借记卡支付 按照支付形态，分为认证支付、网银支付、快捷支付  银行卡网银支付要求银行卡必须开通在线支付功能 快捷支付不需要开通在线支付功能  主要利用支付验证要素(卡号、密码、手机号、CVN2、CVV2 等)，结合安全认证(例如短信验证码)，让持卡人完成互联网支付   3.1.1.1 认证支付  指用户在绑卡时，将卡信息提供给电商。由电商在服务器侧保留用户的账户信息，如身份证号、卡号、手机号。在用户支付时，无需再输入这些内容，最多提供密码或者校验码，就可以完成支付 认证支付基本不会打断用户的使用体验，所以也是电商喜欢的支付方式 认证支付最大问题是安全性  需要向电商暴露个人信息，一旦被窃取，资金就容易被盗走 在手机上执行支付，一旦手机丢失，窃取者就可以轻而易举的使用或者转移资金   3.1.1.2 网银支付  网银支付更安全 网银支付是由银联或者银行提供支付界面，用户必须在页面上输入卡号、密码等验证信息才可以执行支付 大部分银行还要求用户使用 U 盾或其它安全硬件 安全和易用永远是个矛盾  网银使用会打断用户体验，增加用户使用难度 对使用硬件加密的支付，不可能天天带着 U 盘跑 网银主要用在 web 端，在手机端嵌入网银页面，还比较难看   3.1.1.3 快捷支付  快捷支付和认证支付类似，不同点在于绑卡之后，有些银行接口会返回 token，后续使用 token 作为支付凭证，无需提供卡号信息，电商也不需要本地保留卡号 目前主要是银联有提供 token 接口  3.2 支付流程  举例：比如用户在电商系统中买了 200 块钱的东西，然后通过浦发银行卡做结算，用的是快捷支付。这个过程是  1 用户在交易界面上，提交订单到交易系统中；交易系统确认订单无误后，请求支付系统进行结算。这是在交易系统做的，后面工作就进入支付系统 2 用户被引导到收银台页面，让用户确认交易金额，选择支付方式，调用支付系统接口 3 支付系统接收到支付请求，验证请求的各个字段是否有问题，确认无误后，调用支付网关执行支付 4 支付网关请求浦发银行的快捷支付接口执行支付 5 支付网关接收到支付结果报文后，对结果报文做解析，获取结果，并将结果告知交易系统。这可以通过 URL 或 RPC 调用实现 6 商城系统收到支付结果后，开始执行后续操作。如果是支付成功，则开始准备出库。这一步在交易系统中处理，这里不做介绍  上述过程的差异  网银支付在第 4 步插入一个步骤：将用户导航到网银页面输入支付信息，后续步骤一样 在资金流上也是相同 在第 5 步获取返回结果上，一般银行直接同步返回，银联是分为同步和异步返回 同步告知操作成功或者失败，异步告知扣款成功或者失败 同步操作和异步操作都需要调用方提供一个回调的 URL 地址，银联会将参数附加在这个地址上。通过解析这些参数可以得到执行结果 异步操作一般有 2-3 秒的延迟，取决于网络以及该交易处理的复杂度   3.3 资金流  上述支付流程中第 3 步，会触发资金流：资金从用户个人账户上转移到电商公司的账户 当然，这一笔交易银行要收手续费。资金是实时到账的，手续费一般是按月结算。有按交易笔数计费的，但大部分按照交易金额来收费 同行快捷支付比较简单。如果支付系统没有对接浦发银行，那对浦发卡，就得走其它支付方式：银联或者第三方支付  银联快捷：银联提供的多种接入方式，常说的快捷支付，在银联文档中叫商户侧开通 token 接口。通过这个接口，可以实现同行和跨行资金结算。不管收款行是浦发还是其它行，都可以完成结算。对本地和用户来说体验是一样的。而在银联侧，后台资金流处理不一样。了解这个资金流，有助于在异常情况下，了解资金去向 收款行也是浦发银行，银联发报文给浦发，浦发使用内部系统完成两个账户间的转帐，即时完成 收款行是他行，比如工行。银联发指令给浦发和工行，分别完成各自账户上资金余额的增减，对个人和电商来说，这笔资金算是落地了。但实际资金流并不是立即发生。银联会在半夜做清结算后处理这笔资金。这个过程是金融机构之间的清结算，一般不需要关注 第三方支付：对用户来说，处理的流程和银联一样。但资金流会不一样 第三方支付在浦发和工行一般都会有落地的托管资金。发生交易后，一般来说不会产生跨行资金流动。用户在浦发行的钱会被结算到第三方支付在浦发行的托管账户，而在工行的钱，会由第三方支付在工行的账户打到客户账户上。这就降低了跨行资金流动成本  目前国内主要银行都提供快捷和直联的接口。对电商来说，需要考虑对接哪些银行、怎么对接银行、渠道和第三方支付  3.4 银行 Token 支付  一般来说，大部分银行提供直联和网银接口，但不需要直接对接所有银行 银联和第三方支付也提供直联接口，可以直接对接国内主要银行 不是所有银行都被银联支持，这和银联签约的接口有关，需要在对接时咨询银联。如浦发借记卡、邮储银行卡不支持。另外交行、平安(含原深发)、上海银行、浦发、北京银行，上述银行卡需开通银联在线支付业务  3.4.1 对接银行  大部分银行提供的银行卡支付接口，借记卡支付和贷记卡支付是不一样的。但也有银行(工行和建行)可以用一套接口同时开通借记卡和贷记卡。 作为国内最保守的软件团队，和银行对接时务必做好足够的准备。在商务谈判完成、拿到银行的接口文档后，需要考虑两个问题：专线问题、加密问题  3.4.1.1 专线问题  大部分银行对接需要专线。与银行沟通的时候，注意收集如下信息  专线类型：MSTP 类型或 SDH 类型 专线接入点：目前国内主要是联通、电信 封装类型：HDLC 或 PPP 专线代宽：默认是 2M  前置机 IP，需要在银行侧和电商侧进行配置。专线其实是在银行和电商之间建立一个局域网，需要双方分配通讯 IP  这两组 IP 都是 NAT 后的 IP 银行分配给我们的是电商真实的前置机 IP 经过最外端的网络防火墙转换后的 IP 段 后者也是对方的真实前置机 IP 经过转换后的 IP 段 出于安全考虑，双方都不会将真实 IP 暴露出去，所以要 NAT  接入地址：即电商这边机房的地址 从可靠性角度考虑，一般建议从联通、电信各拉一条线路出来。一旦有一个线路出问题了，也不会导致所有交易被终止 不需要专线的银行接口有：浦发、工行、交行信用卡等 需要专线的有中行、农行、建行等 一般专线需要 1 个月左右的时间，包括银行侧的申请、施工时间  3.4.1.2 加密问题  部分银行(如中行)前置要求使用加密机。此处加密机的常用功能有三方面  MAC加密(完整性) 支付会话/密码加密(安全性) 密钥交换加密(防截取)  对开发来说，加密机的主要作用，是让黑客都无法从内存中看到密码 国内对接银行一般就用江南天安的加密机  3.4.2 对接银联  对接银联比对接银行简单，不需要专线，不需要加密机 需要获取 ADSS 认证。银联最近在推 Token 接口，有两套接口  一套是银联侧开通，一套是商户侧开通 前者类似网银支付，后者类似快捷支付 务必要求接入后者接口   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"81b38936a68cb27226f7d4726045506b","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/3_%E9%93%B6%E8%A1%8C%E5%8D%A1%E6%94%AF%E4%BB%98/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/3_%E9%93%B6%E8%A1%8C%E5%8D%A1%E6%94%AF%E4%BB%98/","section":"blog","summary":"3.1 支付和交易 3.1.1 银行卡支付 3.1.1.1 认证支付 3.1.1.2 网银支付 3.1.1.3 快捷支付 3.2 支付流程 3.3 资金流 3.4 银行 Token 支付 3.4.1 对接银行 3.4.1.1 专线问题 3.4.1.2 加密问题 3.4.2 对接银联 3.1 支付和交易 支付","tags":["o2o"],"title":"3 银行卡支付","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4e91f4db63eaefdd8180f140a565d498","permalink":"https://xueqing.github.io/blog/django_cms/tutorial/3_integrate_app/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/django_cms/tutorial/3_integrate_app/","section":"blog","summary":"","tags":["django"],"title":"3 集成应用","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  4.1 前言 4.2 简单解释 VM 4.3 何时使用 VM 是个好主意 4.4 VM 配置 4.5 设置 vm-max-memory 4.6 配置 swap 文件 4.7 线程式 VM vs 阻塞式 VM 4.8 需要知道的一些事  4.8.1 swap 文件的好位置 4.8.2 监视 VM 4.8.3 开启 VM 的 Redis：.rdb 文件 和 只能追加的文件哪个好 4.8.4 尽可能少的使用内存  4.9 VM 稳定性 4.10 参考 4.11 其他内容  4.11.1 Redis 对象和 VM pointer 4.11.2 交换过程   4.1 前言  重要提示：Redis VM(virtual memory) 现在已经弃用。2.4 是最新支持 VM 的版本(但警告不鼓励使用 VM)。我们发现使用 VM 有一些劣势和问题。在将来的 Redis，我们希望简单提供最好的内存数据库(但像往常一样持久化到磁盘)，至少现在不用考虑支持大于 RAM 大小的数据库。我们将来致力于提供脚本化、集群和更好的持久化 Redis VM 特性第一次出现在稳定的 Redis 2.0 发布版本。然而，VM 在 git 的不稳定分支上仍然可以获取，且稳定可测试  4.2 简单解释 VM  Redis 遵循 key-value 模型。键和一些值关联。通常，Redis 将键和相关的值保存在内存。有时这不是最好的选项，所以在设计上必须把键放在内存(为了保证快速查找)，但是可以把较少使用的值交换到磁盘 在实际中，这意味着如果你在内存有 100 000 个键的数据集，但是只有 10% 的键经常使用，支持 VM 的 Redis 会尝试将较少使用的键关联的值转移到磁盘。当客户端的命令请求这些值时，这些值从 swap 文件加载到主存  4.3 何时使用 VM 是个好主意  在使用 VM 之前，你应该问自己你是否真的需要它。Redis 是磁盘备份，内存型数据库。正确使用 Redis 几乎总是有足够的 RAM 保存所有数据到内存。仍然有一些场景是不可能实现的  数据访问非常不均匀。只有小部分的键(比如网站上相关的活跃用户)被大量访问。同时每个键有大量的数据在内存中 不管数据访问模式和大量的值，只是没有足够的内存存放所有的数据。这种配置下，Redis 可当作磁盘型数据库，而键保存在内存，因此键查找很快，但是访问实际的值需要访问磁盘(较慢)  需要记住一个重要的概念Redis 不能交换键，因此如果内存问题的事实是键太多而对应的值很小，VM 不是解决方案 然而，如果因为值很大(比如大量的字符串、列表、集合或者有太多元素的哈希)而占用大量内存，VM 是一个好主意 有时候，可以通过哈希将相关的数据组合在一个键中，从而将“键很多，值很小”的问题转换成“键很少，值很大”的问题。比如，不要为对象的每个属性设置一个键，而是每个对象一个键，用哈希表示不同的属性  4.4 VM 配置  配置 VM 不难，但是需要根据需求仔细设置最好的参数 通过编辑 redis.conf 开启和配置 VM：vm-enabled yes 其他一些配置选项可以改变 VM 行为。规则就是不想使用默认配置运行 Redis，因为每个问题和数据集需要一些微调以达到最好的优势  4.5 设置 vm-max-memory  vm-max-memory 指定 Redis 在交换值到磁盘之前可以自由使用的内存大小 基本上，如果没有达到这个内存限制，Redis 不会交换对象，所有对象在内存中。一旦达到这个限制，Redis 会交换足够的对象以使内存降到限制以下 交换的对象主要是“年纪最大”(即未被使用的实际最长)，但是一个对象的“可交换性”与它在内存中大小的对数是成比例的。因此，虽然偏向更旧的对象，当“年纪”相同时首先交换更大的对象 警告：因为不能交换键，在键使用空间大于内存时，Redis 不会考虑 vm-max-memory 设置 vm-max-memory 最好的值是足够的 RAM 来保持数据工作集。在实际中，只要给 Redis 尽可能多的空间，交换过程更好  4.6 配置 swap 文件  Redis 使用交换文件将数据从内存转移到磁盘。交换文件和数据持久性无关，而且当一个 Redis 示例终止时可以被删除。但是，Redis 运行时，不应移动、删除或改变交换文件 因为在随机访问方式中经常使用 Redis 交换文件，把交换文件放在 SSD(solid state disk)会达到更好的性能 交换文件被分成页。一个值可以被交换到一个或多个页，但是一个页不能保存超过一个值 没有直接方式告诉 Redis 应该使用多大的交换文件。而是配置两个不同的值，二者相乘得到使用的字节数。可通过 redis.conf 配置两个参数  vm-pages：交换文件的页数 vm-page-size：页的大小，以字节为单位  比如页大小是 32 bytes，总页数是 10 000 000，交换文件可以保存 320 MB 的数据 因为一个页不能保存超过一个值(但是一个值可以保存在多个页)，必须仔细设置这些参数。通常，最好的注意是设置页大小以便大部分值可以使用较少的页交换  4.7 线程式 VM vs 阻塞式 VM  另一个很重要的配置参数是 vm-max-threads。默认值是 4 表示为了执行交换文件的 I/O 操作所用的线程数量最大值。一个好的值只要和系统的核数匹配即可 0 会开启阻塞式 VM。当配置成阻塞式 VM 时，Redis 会以同步阻塞方式执行 I/O  客户端访问交换出去的值，从磁盘读时会阻塞其他客户端，因此客户端经历的延迟会变大，尤其当磁盘慢或者忙，或者磁盘有大的交换的值 阻塞式 VM 的性能总的来说较好，因为没有同步、线程创建、恢复等待值的阻塞客户端的时间损失。因此，如果愿意接受较高的延迟，阻塞式 VM 是个好的选择。尤其是交换很少发生，且大部分访问的数据都在内存时  相反，如果有大量的交换操作，且有许多核想要利用，而且通常不希望处理交换值的客户端阻塞其他客户端几毫秒(交换值很大的时候时间更长)，最好使用线程式 VM 鼓励使用不同的配置对数据集做实验。。。  4.8 需要知道的一些事 4.8.1 swap 文件的好位置  在很多配置中，交换文件可以很大，达到 40GB 甚至更大。不是所有类型的文件系统可以较好的处理大文件，尤其是 Mac OS X 文件系统在处理大文件方面比较差 建议使用 Linux ext3 文件系统，或者其他较好支持稀疏文件(sparse files)的文件系统。什么是稀疏文件呢？  稀疏文件大部分内容是空白的。高级的文件系统如 ext2，ext3，ext4，ReiserFS，Reiser4 等可以更有效地编码这些文件，并且在需要的时候为文件分配更多的空间，即文件更多的实际块被使用  交换文件显然是非常稀疏的，尤其是当服务运行时间较短，或者相比交换出去的数据更大时。一个不支持稀疏文件的文件系统创建一个大文件时，有时会阻塞 Redis 流程  4.8.2 监视 VM  当有一个开启 VM 的 Redis 系统允许时，可能对它如何工作感兴趣：总共交换了多少对象，每秒交换和加载的对象数目等 有一个工具方便检查 VM 如何允许，是 Redis 工具的一部分。这个工具叫做 redis-stat，使用方式很直接：./redis-stat vmstat\n./redis-stat vmstat --------------- objects --------------- ------ pages ------ ----- memory ----- load-in swap-out swapped delta used delta used delta 138837 1078936 800402 +800402 807620 +807620 209.50M +209.50M 4277 38011 829802 +29400 837441 +29821 206.47M -3.03M 3347 39508 862619 +32817 870340 +32899 202.96M -3.51M 4445 36943 890646 +28027 897925 +27585 199.92M -3.04M 10391 16902 886783 -3863 894104 -3821 200.22M +309.56K 8888 19507 888371 +1588 895678 +1574 200.05M -171.81K 8377 20082 891664 +3293 899850 +4172 200.10M +53.55K 9671 20210 892586 +922 899917 +67 199.82M -285.30K 10861 16723 887638 -4948 895003 -4914 200.13M +312.35K 9541 21945 890618 +2980 898004 +3001 199.94M -197.11K 9689 17257 888345 -2273 896405 -1599 200.27M +337.77K 10087 18784 886771 -1574 894577 -1828 200.36M +91.60K 9330 19350 887411 +640 894817 +240 200.17M -189.72K  上述输出的 redis 服务开启了 VM，大约有 1 百万键，且有大量的同步加载使用 redis-load 工具\n 可以从输出中看到，每秒都发生一些 load-in 和 swap-out 操作。注意第一行表示服务启动后实际的值，后续的行和前面的不一样\n 如果分配足够的内存来保存数据工作集，可能应该看到更少的交换发送，因为 redis-stat 是一个很有价值的工具来理解是否需要去商店购买 RAM\n  4.8.3 开启 VM 的 Redis：.rdb 文件 和 只能追加的文件哪个好  当开启 VM 时，保存和加载数据库是相当慢的操作。如果服务配置成使用最小的内存(即 vm-max-memory 设置成 0)，在开启 VM 后，在 2 秒内加载的数据库通常需要 13 秒时间加载 因此，你可能想要切换配置使用只能追加的文件(Append Only File)来持久化，以便于你可以一直执行 BGREWRITEAOF 需要注意当一个 BGSAVE 或 BGREWRITEAOF 在处理时，Redis 不会在磁盘上交换新的值。当有一个子进程访问 VM 时 VM 是只读的。因此如果一个工作的子进程有大量的写操作时，内存使用会增长  子进程在读 VM 时，主进程不能进行值交换操作。因为通常读完一次值，“年龄”变小，可能从 VM 取出，而交换新的值   4.8.4 尽可能少的使用内存  将 Redis 设置成磁盘型数据库，而只保存键在内存的一个有趣的设置是设置 vm-max-memory 为 0。如果不介意更多延迟和较差的性能，但是想要非常大的值使用更少的内存，这个是好的设置 这种设置情况，应该首先尝试设置 VM 是阻塞式的(vm-max-threads 为 0)，因为大业务量会导致很多交换操作，且和简单的阻塞式实现相比，线程会消耗大量的资源  4.9 VM 稳定性  VM 仍然是实验性代码，但是在过去的几周，在开发环境下用各种方式测试了 VM，甚至在一些生产环境。在测试阶段没有注意到 bug。但是在一些未控制的环境，且出于某些原因无法复现这些设置，会出现更加模糊的 bug 在这个阶段，鼓励在开发环境尝试 VM，甚至是生产环境下，当数据库不是关键型任务，比如大量持久化数据可以小时而不会有任何问题  4.10 参考  官方文档  4.11 其他内容 4.11.1 Redis 对象和 VM pointer  键值都是 Redis 的对象，但是当值被移到 VM 时，会变成 VM pointer。主要记录值在磁盘的信息，如记录对象在交换文件第几页、共使用几页等内容 Redis 对象和 VM pointer 都有一个字段 storage，用于判断值的位置  redis_vm_memory：在内存 redis_vm_swapped：在磁盘 redis_vm_loading：在磁盘，但目前正有进程将其加载到内存 redis_vm_swapping：在内存，但目前正有进程将其写入磁盘   4.11.2 交换过程  将对象交换到交换文件  计算保存此对象需要占用多少页 在交换文件中寻找一段连续空间保存此对象 把对象写入交换文件  将对象从交换文件取出到内存  VM pointer 记录了对象在文件的起始页和占用页数，直接加载到内存即可  阻塞式 VM 在内存使用超过设定的 vm-max-memory 时，会循环找到候选对象进行交换直到内存使用下降到设定值以下  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1f3f8ed623dcc9e137e80f27f931bb29","permalink":"https://xueqing.github.io/blog/database/redis/4_vm/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/database/redis/4_vm/","section":"blog","summary":"4.1 前言 4.2 简单解释 VM 4.3 何时使用 VM 是个好主意 4.4 VM 配置 4.5 设置 vm-max-memory 4.6 配置 swap 文件 4.7 线程式 VM vs 阻塞式 VM 4.8 需要知道的一些事 4.8.1 swap 文件的好位置 4.8.2 监视 VM 4.8.3 开启 VM 的","tags":["database"],"title":"4 Redis VM 技术","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  4.1 Linux 文件属性  4.1.1 Linux 一切皆文件 4.1.1.1 挂载 4.1.2 Linux/UNIX 文件类型  4.2 Linux 文件属主和属组  4.2.1 更改文件属性 4.2.1.1 chgrp 更改文件属组 4.2.1.2 chown 更改文件属主，也可以同时更改文件属组 4.2.1.3 chmod 更改文件9个属性  4.2.1.3.1 chmod 用数字更改文件9个属性 4.2.1.3.1 chmod 用符号更改文件9个属性   4.3 Linux 文件时间属性  4.1 Linux 文件属性  Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限 为了保护系统的安全性，Linux系统对不同的用户访问同一文件(包括目录文件)的权限做了不同的规定 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如\n 实例中，bin文件的第一个属性用\u0026rdquo;d\u0026rdquo;表示，在Linux中代表该文件是一个目录文件\n[root@www /]# ls -l total 64 dr-xr-xr-x 2 root root 4096 Dec 14 2012 bin dr-xr-xr-x 4 root root 4096 Apr 19 2012 boot   在Linux中第一个字符代表这个文件是目录、文件或链接文件等等\n d 目录 - 文件 l 链接文档(link file) b 可供储存的接口设备(可随机存取装置) c 串行端口设备，如键盘、鼠标(一次性读取装置)  接下来的字符中，以三个为一组，且均为rwx的三个参数的组合\n r代表可读(read) w代表可写(write) x代表可执行(execute) 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号-  每个文件的属性由左边第一部分的10个字符来确定，从左至右用0-9这些数字来表示\n 0位：确定文件类型 1-3位：确定属主(该文件的所有者 owner)拥有该文件的权限 4-6位：确定属组(所有者的同组用户 group)拥有该文件的权限 7-9位：确定其他用户(others)拥有该文件的权限 1、4、7位：表示读权限，\u0026rdquo;r\u0026rdquo;字符表示有读权限；\u0026rdquo;-\u0026ldquo;字符表示没有读权限 2、5、8位：表示写权限，\u0026rdquo;w\u0026rdquo;字符表示有写权限；\u0026rdquo;-\u0026ldquo;字符表示没有写权限 3、6、9位：表示可执行权限，\u0026rdquo;x\u0026rdquo;字符表示有执行权限；\u0026rdquo;-\u0026ldquo;字符表示没有执行权限   4.1.1 Linux 一切皆文件  Linux 中所有内容都是以文件的形式保存和管理的，即一切皆文件。包括普通文件、目录(Windows 下称为文件夹)、硬件设备(键盘、监视器、硬盘、打印机)、套接字(socket)、网络通信等资源 好处  开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源 比如，Linux 中几乎所有读（文件、系统状态、socket、pipe）的操作都可以用 read 函数；几乎所有更改（改文件、改系统参数、写 socket、写 pipe）的操作都可以用 write 函数  坏处  使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用 如果想通过 Linux 上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义 如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到   4.1.1.1 挂载  挂载：指将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件 误区：并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录 根目录下的 /dev/ 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统会给 U 盘分配一个目录文件（比如 sdb1），就位于 /dev/ 目录下（/dev/sdb1），但无法通过 /dev/sdb1/ 直接访问 U 盘数据，访问此目录只会提供此设备的一些基本信息（比如容量）  4.1.2 Linux/UNIX 文件类型  Linux系统中，文件具体可分为以下几种类型     文件类型 权限位表示 描述     普通文件 \u0026rsquo;-\u0026rsquo; 类似 mp4、pdf、html 这样，可直接拿来使用的文件。Linux 用户根据访问权限不同可对这些文件进行查看、删除和更改操作   目录文件 \u0026rsquo;d\u0026rsquo; 包含了此目录中各个文件的文件名以及指向这些文件的指针。打开目录等同于打开目录文件，只要有权限，可以随意访问目录中的任何文件   特殊文件-块文件(block) \u0026lsquo;b\u0026rsquo; 通常隐藏在 /dev/ 目录下，当进行设备读取或外设交互时才会被使用。如磁盘光驱   特殊文件-字符设备文件(character) \u0026lsquo;c\u0026rsquo; 通常隐藏在 /dev/ 目录下，当进行设备读取或外设交互时才会被使用。如串口设备   特殊文件-符号链接文件(symbolic link) \u0026lsquo;l\u0026rsquo; 类似与 Windows 中的快捷方式，是指向另一文件的简介指针(软链接)   特殊文件-管道文件(pipe) \u0026lsquo;p\u0026rsquo; 主要用于进程间通信。例如，使用 mkfifo 命令创建一个 FIFO 文件，与此同时，启用进程 A 从 FIFO 文件读数据，启用进程 B 从 FIFO 文件中写数据，随写随读   特殊文件-套接字文件(socket) \u0026rsquo;s\u0026rsquo; 一般隐藏在 /var/run/ 目录下，用于进程间的网络通信     目录文件的访问权限，同普通文件的执行权限，是一个意思  4.2 Linux 文件属主和属组  对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户 在Linux系统中，用户是按组分类的，一个用户属于一个或多个组 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户 Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限\n[root@www /]# ls -l total 64 drwxr-xr-x 2 root root 4096 Feb 15 14:46 cron drwxr-xr-x 3 mysql mysql 4096 Apr 21 2014 mysql  在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限\n 对于 root 用户来说，一般情况下，文件的权限对其不起作用\n  4.2.1 更改文件属性 4.2.1.1 chgrp 更改文件属组  语法：chgrp [-R] 属组名 文件名 参数选项  -R：递归更改文件属组，即在更改某个目录文件的属组时加上 -R，则该目录下所有文件的属组都会更改   4.2.1.2 chown 更改文件属主，也可以同时更改文件属组  语法：chown [–R] 属主名 文件名或chown [-R] 属主名:属组名 文件名 进入/root目录(~)将install.log的拥有者改为bin这个账号\n[root@www ~] cd ~ [root@www ~]# chown bin install.log [root@www ~]# ls -l -rw-r--r-- 1 bin users 68495 Jun 25 08:53 install.log  将install.log的拥有者与群组改回root\n[root@www ~]# chown root:root install.log [root@www ~]# ls -l -rw-r--r-- 1 root root 68495 Jun 25 08:53 install.log   4.2.1.3 chmod 更改文件9个属性  Linux文件属性有两种设置方法，一种是数字，一种是符号  4.2.1.3.1 chmod 用数字更改文件9个属性  Linux文件的基本权限有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。\n 文件的权限字符为：-rwxrwxrwx， 这九个权限是三个三个一组的 可以使用数字来代表各个权限，各权限的分数对照表如下 r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数需要累加，如权限为-rwxrwx---分数是 owner： rwx = 4+2+1 = 7 group： rwx = 4+2+1 = 7 others：\u0026mdash; = 0+0+0 = 0 设定权限的变更时，该文件的权限数字就是 770 变更权限的指令 chmod 的语法：chmod [-R] xyz 文件或目录 选项与参数  xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加 -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更  举例，如果要将.bashrc这个文件所有的权限都设定启用，那么命令如下\n[root@www ~]# ls -al .bashrc -rw-r--r-- 1 root root 395 Jul 4 11:45 .bashrc [root@www ~]# chmod 777 .bashrc [root@www ~]# ls -al .bashrc -rwxrwxrwx 1 root root 395 Jul 4 11:45 .bashrc   如果要将权限变成-rwxr-xr--，那么权限的分数就成为[4+2+1][4+0+1][4+0+0]=754    4.2.1.3.1 chmod 用符号更改文件9个属性  九个权限分别是  (1)user (2)group (3)others  使用 u, g, o 来代表三种身份的权限 a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用：chmod u|g|o|a +(加入)|-(除去)|=(设定) r|w|x 文件或目录 如果需要将文件权限设置为-rwxr-xr--，可以使用chmod u=rwx,g=rx,o=r 文件名\n# 创建 test1 文件 touch test1 # 查看 test1 默认权限 ls -al test1 # -rw-r--r-- 1 root root 0 Nov 15 10:32 test1 # 修改 test1 权限 chmod u=rwx,g=rx,o=r test1 ls -al test1 # -rwxr-xr-- 1 root root 0 Nov 15 10:32 test1 # 如果是要将权限去掉而不改变其他已存在的权限。如要拿掉全部人的可执行权限 chmod a-x test1 ls -al test1 #-rw-r--r-- 1 root root 0 Nov 15 10:32 test1   4.3 Linux 文件时间属性  Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间  访问时间(Access Time, atime)：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变 数据修改时间(Modify Time, mtime)：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变 状态修改时间(Change Time, ctime)：当文件的状态发生变化，就会相应改变这个时间。比如，如果文件的权限或者属性发生改变，此时间就会相应改变   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c549bf42b2e929d2d9ce24688713ca66","permalink":"https://xueqing.github.io/blog/linux/4_%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/4_%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7/","section":"blog","summary":"4.1 Linux 文件属性 4.1.1 Linux 一切皆文件 4.1.1.1 挂载 4.1.2 Linux/UNIX 文件类型 4.2 Linux 文件属主和属组 4.2.1 更改文件属性 4.2.1.1 chgrp 更改文件属组 4.2.1.2 chown 更改文件属主，也可以同时更改文件属组 4.2.1.3 chmod 更改","tags":["linux"],"title":"4 文件基本属性","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  4.1 每日站会的概念 4.2 每日站会的重要性 4.3 每日站会的参与人 4.4 物理分散的团队\n 每日站会，顾名思义，是敏捷团队所有成员媒体的状态会议。它不仅为定期的更新提供论坛，也将团队成员的问题作为关注点以便可以被快速处理\n 每日站会是一个必须的实践，不管一个敏捷团队建立的办公室位置\n  4.1 每日站会的概念  每日站会是所有成员间的一个每日状态会议，大概举行 15 分钟 每个成员必须回答三个重要的问题  昨天做了什么 今天要做什么 正面临的问题或阻碍  每日站会用于更新状态，而不是讨论。讨论的成员应当安排其他时间 参与者应当站着而不是坐着以便快速结束  4.2 每日站会的重要性  每日站会在敏捷中的益处  团队可以评估每日进度，查看每个迭代计划是否可以交付 每个团队成员通知自己每天的完成量 为团队的所有延期和障碍提供可视化性   4.3 每日站会的参与人  流程管理员、产品负责人和交付团队应当参与每日站会 利益相关者和客户鼓励出席会议，并可以作为观察者，但是不应该参与站会 流程管理员应该记录每个团队成员的疑问和面临的问题  4.4 物理分散的团队  站会可以有多种方式，以便敏捷团队的成员分布在不同的时区  轮流选择一名成员，可以出席不同时区的站会 每个团队有单独的站会，在一个工具(如 Rally，SharePoint，Wikis等)更新站会的状态 准备多种沟通工具(如电话会议、视频会议、即时通讯工具或其他第三方认可的知识共享工具)   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ef9df5a6a4bb9947ff27297876b6a147","permalink":"https://xueqing.github.io/translation/agile/tutorial/4-daily-standup/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/4-daily-standup/","section":"translation","summary":"4.1 每日站会的概念 4.2 每日站会的重要性 4.3 每日站会的参与人 4.4 物理分散的团队 每日站会，顾名思义，是敏捷团队所有成员媒体的状态会议。它不仅为定期的更新","tags":["agile"],"title":"4 每日站会","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  4.1 前言 4.2 绑卡场景 4.3 绑卡流程 4.4 卡 bin 4.5 短信和身份验证 4.6 绑卡接口 4.7 银联绑卡 4.8 实名认证  4.1 前言  用户绑卡和快捷支付有关  绑卡是将用户卡信息提供给电商，以后电商就用这个信息去银行完成支付 绑卡实际上是一个授权，让用户允许商家自动从他的账户上扣除资金。所以绑卡也叫签约，用户和银行、商家的三方签订的支付合约  绑卡对用户和商户来说都存在巨大风险 用户绑卡是为了提升用户体验，让用户花钱更容易。其次，提升支付成功率  使用网银支付成功率在 20% 左右，银联直联成功率一般在 50% 左右，银行卡直联可以提升到 70% 左右  我们知道对接银行包括直接对接银行接口和通过银联来间接对接。这两种情况下绑卡处理也不同  4.2 绑卡场景  直观的，电商网站会在用户后台提供一个绑卡的入口，让用户直接绑卡 要点  只能绑自己的卡，这主要从安全角度考虑 需要用户在银行侧预留的手机号进行短信验证。但不是所有银行都需要。这个时候，为了统一处理，可以考虑自己发验证短信  更多的场景是用户在支付中绑卡。也就是提交订单后，发现没有银行卡了，就开始绑卡。和纯绑卡流程不同的是，最后一步绑卡成功后，一般都同时完成支付。有些渠道会提供绑卡并支付的接口，减少交互次数  4.3 绑卡流程  比较简单的银联直联绑卡。为了保证卡的安全，绑卡有这些前置需求  用户必须已经绑定了手机号。该手机号用于修改支付密码 用户需设置了支付密码。支付密码不同于登录密码  针对用户不同状态，绑卡流程上有区别。绑卡是安全操作，要求用户必须登录到系统中。为了避免和服务器端的交互被劫持，所有操作必须在安全链接中进行，即使用 HTTPS。当用户开始绑卡时，执行如下流程  1 检查用户是否有手机号。没有则进入设置手机号流程 2 检查用户是否设置支付密码。如果已经设置，则需要用户输入密码。确认后开始绑卡。否则，也是先进去绑卡后设置密码 3 用户输入卡号，系统根据卡号判断卡的发卡行，并显示给用户。有些实现，如微信支付，会提供扫卡识码功能 4 用户输入银行预留手机。对于没有绑过卡的用户，需要用户提供真实姓名和身份证号。对于信用卡，还需要输入 cv 码和有效期。这一步，卡的信息都收集全了 5 调用银行绑卡验证接口进行绑卡。这里有一个四要素验证的概念。由于国内要求实名制，所有银行卡都是实名办理的，所以银行可以验证姓名、身份证号、银行卡号和手机号是不是一致的，如果没问题，则会发短信到手机上 6 用户输入短信验证码并确认绑卡，服务器端将用户实名信息以及短信验证码组合形成报文，发送给银行执行签约操作。银行侧签约成功后，返回签约号给商户   4.4 卡 bin  根据卡号判断发卡行需要卡 bin  BIN 号即银行标识代码的英文缩写 BIN 由 6 位数字表示，出现在卡号的前 6 位，由国际标准化组织(ISO)分配给各从事跨行转接交换的银行卡组织 银行卡的卡号是标识发卡机构和持卡人信息的号码，由以下三部分组成：发卡行标识代码(BIN号)、发卡行自定义位、校验码  目前，国内的银行卡按照数字打头的不同分别归属于不同的银行卡组织  以 4 字打头的银行卡属于 VISA 卡组织 以 5 字打头的属于 MASTER CARD 卡组织 以 9/62/60 打头的属于中国银联，而 62\u0026frasl;60 打头的银联卡是符合国际标准的银联标准卡，可在国外使用，这也是中国银联近几年来主要发行的银行卡片  大部分银行卡号前 6 位即可确定发卡行和卡类型，但也有非标卡需要 6-10 位才可判断出来 需要维护一个卡 bin 库  4.5 短信和身份验证  一般绑卡操作第 5 步需要银行下发短信验证码。短信验证的接口，不同银行不一样。有些银行是短信和身份验证一起做了；有些银行是可以配置身份验证是否同时发短信 此类接口一般包含如下内容：  版本号：当前接口的版本号 编码方式：默认都是 UTF-8，指传输的内容的编码方式 签名和签名方法：生成报文的签名。不是所有的字段都需要放到签名中，文档中会说明哪些字段需要签名 签名算法：生成签名的算法，RSA、RSA128、MD5 等 商户代码：在渠道侧注册的商户号 商户订单号：即发送给渠道的订单号 发送时间：该请求送出的时间 账号和账号类型：银行卡、存折、IC 卡等支持的账号类型以及对应的账号 卡的加密信息：如信用卡的 CVN2、有效期等 开户行信息：开户行所在地以及名称。大部分不需要 身份证件类型和身份证号：可用于实名验证的证件，指身份证、军官证、护照、回乡证、台胞证、警官证、士兵证等。不同银行可以支持的证件类型不一样，这也不是问题。大部分是身份证 姓名：真实姓名，必须和身份证一致 手机号：在所在银行注册的手机号  系统会返回上述数据的验证结果。如果验证通过，则会发短信。但这不是所有的渠道都是这样。哪些字段会参与验证、需不需要发短信，需要注意看接口文档  4.6 绑卡接口  绑卡接口和发短信接口类似，还需要将用户的卡号、身份证等信息传递过去 绑卡成功后，会返回一个签约号。这个签约号是后续调用支付、解约等接口所必须的 银行都不支持重复绑卡：大部分银行(如农业、浦发、建行)对绑卡签约接口调用，会首先验证身份信息，如果验证不通过，则不执行后续操作。验证通过后，再检查这个卡在该商户下是否已经绑过了，如果没有绑过，则执行绑卡，否则会提示卡已经绑定过了，不能重复签约。但工行首先验证这个卡是不是已经绑过了，如果已经绑卡，则不继续验证身份信息  4.7 银联绑卡  银联直联绑卡：和银行绑卡类似，但是得注意验证接口，仅验证卡号和姓名，不验证身份证号和手机号。这导致第 5 步无法正常进行。银联只有到第 6 步执行绑卡时才做身份验证。所以在处理上，还需要做一些调整，来确保和银行的流程的一致  一种处理方法是，对银联在第 5 步就开始调用银联接口执行绑卡操作，但在本地标记为预绑卡状态；商户侧发送短信验证码，验证通过后，才将状态设置为绑卡成功  银联网银绑卡：用户在电商页面上输入卡号，然后被导航到银联页面上去完成绑卡操作，成功后，银联返回一个 token 作为签约号，用于支持后续操作。问题在于用户可以在银联页面上绑定一个别人的卡，而电商侧是无法知道这个卡的情况的。所以尽量不要用这种方式  4.8 实名认证  绑卡操作有个不错的副产品，就是实名认证。常说的二要素，三要素，四要素认证，可以通过这个操作完成  二要素：指姓名和身份证号 三要素：加上银行卡号 四要素：加上手机号  看起来，似乎银行都应该支持四要素验证，但大部分银行接口仅支持三要素，毕竟手机号还是非常容易变 实名认证，也就是二要素认证，是应用最多的认证 国内唯一的库是在公安部，由 NCIIC 负责对外提供接口。可以提供如下功能：  简项核查：返回“一致”“不一致”“库中无此号” 返照核查：返回“一致+网纹照片”“不一致”“库中无此号” 人像核查：返回“同一人”“不同人”“库中无此号”  官方接口收费是 5 元/条。市面上主要的第三方服务提供商有国政通(简项、返照)、诺证通(简项)、IDface(三接口)等。收费一般和访问量有关，量大从优  简项核查：0.5~2.0 元 返照核查：0.8~2.1 元 人像核查：2.0~8.0 元不等  注意：涉密人员是没法查到相关信息的 性能上，XX 通一般在 200ms 内即可返回结果，普通商用没问题。有些公司还会额外提供四要素接口，以 XX 通为例，它号称支持大部分银行卡的四要素认证。但是实现上是实时请求银行的接口，这就导致接口延迟非常高，1 秒以上的占大部分，甚至 10 秒以上的都不少见，基本无法商用。这种情况下，还不如直接上银联  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2b366576ffee730512a6a58d890cf358","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/4_%E7%BB%91%E5%8D%A1%E7%AD%BE%E7%BA%A6%E5%92%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/4_%E7%BB%91%E5%8D%A1%E7%AD%BE%E7%BA%A6%E5%92%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81/","section":"blog","summary":"4.1 前言 4.2 绑卡场景 4.3 绑卡流程 4.4 卡 bin 4.5 短信和身份验证 4.6 绑卡接口 4.7 银联绑卡 4.8 实名认证 4.1 前言 用户绑卡和快捷支付有关 绑卡是将用户卡信息提供给电商，以后","tags":["o2o"],"title":"4 绑卡、签约和身份验证","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  4.1 账户体系  4.1.1 资产类账户 4.1.2 负债类账户 4.1.3 所有者权益类账户 4.1.4 损益类账户 4.1.5 成本类账户 4.1.6 共同类账户 4.1.7 账户体系  4.2 账户结构 4.3 支付流程 4.4 支付订单 4.5 支付记录 4.6 支付记账 4.7 会计记账 4.8 对账  4.8.1 内部对账 4.8.2 渠道对账 4.8.3 账账核对 4.8.4 账实核对  4.9 结束语  4.1 账户体系  在设计清结算系统前，首先需要完成账户体系的梳理 账户是用来记录会计科目所反映的业务内容的工具，它根据会计科目开设 账户有多种维度的分类  按照经济内容来说，账户分为资产类账户、负债类账户、所有者权益类账户、损益类账户、成本类账户和共同类账户 按照会计周期内期末是否有余额，也分为实账户和虚账户   4.1.1 资产类账户  资产类账户：用来反映资产增加、减少以及增减变动结果的账户 和支付系统相关的主要资产类账户有：银行存款、应收账款、预付账款、库存商品、发出商品等 资产增加登记在借方，减少登记在贷方，期末有余额的话，一般出现在借方 在一个会计期间，所有借方金额的累加为“借方本期发生额”，所有贷方金额的累加为“贷方本期发生额”\n资产账户的余额=借方期初余额+借方本期发生额-贷方本期发生额。\n 为了跟踪在每个银行的存款变更情况，需要对公司在各个银行开通的收款账户设置对应的银行存款账户、应收账款账户。在小明购买会员卡的案例中，资产类账户包括\n 银行存款：这是一个总账账户，记录电商公司在各个银行的总存款 应收账款：这是一个总账账户，记录在银行的应收账款，这是虚账户，期末无余额 银行存款-工行：这是一个明细账户，对应在工行的对公账户的存款变化 应收账款-工行：这是一个明细账户，记录在工行的收款情况，这是虚账户，期末无余额   4.1.2 负债类账户  负债类账户：实账户，记账规则跟资产类相反，负债增加记为贷，负债减少记为借，期末如有余额，一般在贷方，表明期末有债务实有额，负债类账户的余额计算\n贷方期末余额=贷方期初余额+贷方本期发生额-借方本期发生额。\n 从支付系统的角度，电商公司的自有账户，包括针对个人的账户和针对商户的账户，一般放在负债类账户下\n 此外，应付账款、预收账款、应交税费等，也是负债类账户\n  4.1.3 所有者权益类账户  所有者权益类账户：用来反映所有者权益增加、减少和变动结果的账户 记账规则跟负债类账户一致：所有者权益增加记为贷，减少记为借 和支付系统有关的所权账户包括：本年利润、利润分配等账户 企业取得的收入最终会使得所有者权益增加，因此收入类账户的记账方法跟所有者权益一致：增加记为贷，减少或者转销记为借，通常该账户期末无余额(因为期末收入都会转为所有者权益，如未分配利润等)，属于虚账户  4.1.4 损益类账户  损益类账户分为收入类和费用类账户  收入类账户：指各种收入、补贴、投资收益，如主营业务收入、其他业务收入和营业外收入等，增加记为贷，减少记为借 费用类账户包括：主营业务成本、其他业务成本、营销费用等。企业在日常经营活动中会发生各种各样的耗费，这些耗费在会计学上称为成本费用，它们是收入的抵减项目，在抵销收入之前，可以视为一种资产，因此成本费用类账户的记账规则跟资产类一样：增加记为借，减少或者转销记为贷  按照企业会计制度的规定，损益类账户的科目余额，应该结转入利润分配科目，期末余额为零，为虚账户 在本案例中，损益类账户包括  主营业务收入，这是总分类账户 主营业务收入-会员卡，针对会员卡业务的收入 营销费用，这是总分类账户 营销费用-优惠券，用来跟踪优惠券相关的支出 渠道费用，这是总分类账户 渠道费用-工行： 用来跟踪在工行的渠道费用支出   4.1.5 成本类账户  有成本核算的企业需要设立的账户，包括生产成本、劳务成本等，本文暂不涉及  4.1.6 共同类账户  这是反映特殊经济业务的账户，本文暂不涉及  4.1.7 账户体系 4.2 账户结构  采用复式借贷记账法。对于分户账，或者说明细账，如下示例  在这个实例中，账户中账务相关的结构包括  账户名称：如上述的“应收账款-工行收款” 会计分录： 除了登记借方金额、贷方金额，还需更新账户余额 期末借方余额、期末贷方余额、期末余额：按期定时计算。在日切时，计算日发生额和余额。在按月、季度和年作为会计周期时也采用类似的方法处理。 除了日切是必须的，其它时间段的处理是根据财务需要来实现  在实现上，账户的各个属性更新时间并不一致，所以在设计账户表的时候，可以按照更新时机来划分表   4.3 支付流程  接着之前的小明购买会员卡的案例，不考虑优惠券和卡采购的情况，会计分录：\n借： 应收账款-工行收款 100-100*0.1% = 99.9 服务成本-工行手续费 100*0.1% = 0.1 贷：主营业务收入-会员卡 100\n 在线上的实时处理流程如下\n 1 用户购买会员卡，提交订单，会员卡向订单系统请求生成订单，订单系统向支付系统发出支付请求 2 支付系统生成支付记录，并向银行发出请求 3 银行实时从小明的银行卡账户上扣款 100 元，通知支付系统小明支付成功 4 支付系统账务子系统在自己的账户体系中记录小明的这一笔消费支出，给会员卡业务账户增加对应的资金，通知会员卡系统发送卡给小明 5 支付系统发送消息异步通知会计系统进行记账  这 5 个步骤都是线上的流程，在此过程中，各个子系统之间的交互如下图所示   4.4 支付订单  这个流程中，首先生成的是支付订单。这是一个比较简单的订单，仅涉及到一个商家和一个商品 在比较复杂的电商场景中，一个订单会涉及到多个商家、多种商品以及对应的优惠活动。也就是，一个总订单会被拆分为多个子订单 而订单中和资金相关的内容，都需要在账户体系中建立对应的科目和账户。在请求支付时，只会将总订单提交支付，拆分子订单是在订单系统中完成的  针对上述场景，为了简化处理，假定老熊公司当天总共完成了三笔会员卡交易，支付订单如下   4.5 支付记录  在这个流程中，订单系统向支付系统请求支付时，支付系统将产生支付记录(支付订单) 支付记录内容比较多，这些数据是后续进行记账的基础  上述的三个订单，两笔通过工行支付，一笔通过支付宝支付，其产生的支付记录如下，此处省略了其他和记账无关的字段内容  这里需要注意的几个属性  订单号: 这是总订单号。支付系统不再对订单进行拆分。订单拆分是订单系统的功能 支付流水号：在支付记录中，针对每个(总)订单号，会有对应的支付流水号。如果用户使用组合支付，如上述场景，小明使用余额支付了 20 元，使用银行卡支付了剩余的 80 元，那这将产生 2 个支付流水号。为了避免洗钱风险，简化订单处理，包括淘宝在内，现在一般都不再提供组合支付的支持 支付方式和支付渠道：用户选择的支付方式和实际执行支付的渠道可以是不一样的。比如用户选择了广发信用卡来支付，但实际上电商公司没有直接对接农行，而是通过支付宝来对接，那对应的支付渠道就是支付宝 本条记录在支付成功后，会产生记账凭证和对账凭证 这一条记录将产生多条会计分录，记账凭证是关联这些会计分录和支付记录的字段 对账凭证是根据对账周期来分配的。在日切后，对账凭证号相应的也会做更新  在产生支付记录后，在上述流程的第 5 步通过消息机制来异步触发记账流程。账务系统接收到记账消息后，开始更新账户信息。记账分为两个阶段  支付记账：针对线上的账户实时更新的需求，需要让用户及时看到账户余额和订单状态，账务信息记录到用户和商户上，采用单边账的形式 会计记账：采用复式记帐法，满足会计记账需求，记录会计分录和余额，为对账和清结算提供支持   4.6 支付记账  支付记账是在支付流程中完成的，目的是让用户完成购买后，能够立即看到支付结果和账户余额。为了提升性能，支付记账一般采用单边账的形式，即将会计分录登记在用户侧或者商户侧 在上述案例中，第 6 步处理，在服务器上与银行侧同步登记一笔从小明银行卡的支出，并在会员业务账户上登记一笔收入。如果使用的是零钱支付，这一个步骤就很重要，从零钱账户上扣除费用计算余额，添加对应的消费记录，是在一个事务中完成  4.7 会计记账  会计记账采用复式记账，不同业务记账方式也不一样。小明买卡的案例中，需要记录的条目有  在工行收款账户下，登记 99.9 元的借记条目 在工行手续费的账户下，登记 0.1 元的借记条目 在主营业务收入-会员卡的账户下，登记 100 元的贷记条目  这 3 条记录是通过事务处理一次生成。当天发生的三笔交易，产生的记账内容如下  实际实现上，科目一列，使用账号 ID 来替代。每个账户的本期发生额，可以在另一个表中单独异步计算  4.8 对账  在会计上，对账分三个部分：账证核对、账账核对和账实核对，做到账证相符、账账相符和账实相符 在电商支付系统中，需要完成的对账工作包括内部对账、外部对账和资金对账。其中外部对账又分为和支付渠道的对账、和商户的对账以及和用户的对账   4.8.1 内部对账  内部对账的内容包括  核实账户系统中的账务与支付记录的一致性 核实会计系统中的账务与支付记录的一致性  这是后续账账核对和账实核对的基础，也是对外对账的基础。这两个对账任务一般是在后台定时运行(5分钟运行一次)，除非系统有 bug 或者发生故障，内部对账一般不会出现差错。如有差错，也需要人工处理  4.8.2 渠道对账  一般银行、第三方支付提供 T+1 的对账单，这是执行渠道对账的依据 在上述案例中，支付系统每天拉取工行前一天的对账单，核对交易流水。与此同时，按照从工行获取的对账单，记录资金归集的账务 接收到工行对账单后，按照对账单生成凭证  注意上述的日期、凭证号，以及借贷关系  4.8.3 账账核对  完成渠道对账后，需要进行日结和试算平衡  总分类账各账户本期借方发生额合计与贷方余额合计是否相等 总分类账各账户借方余额合计与贷方发生额合计是否相符 核对各种明细账及现金、银行存款日记账的本期发生额及期末余额同总分类账中有关账户的余额是否相等  从科目维度，计算  科目期初余额+科目当日发生额=科目期末余额 下级科目余额总和=上级科目余额(科目总分检查)   4.8.4 账实核对  对电商公司来说，最重要的账实核对，是验证银行存款的变化和实际资金流向是一致的。一般是需要登录到银行网银系统中来人工核实 如果对接的银行多，银行提供网银对账单，也可以自动进行，查询出入款总额  4.9 结束语  本文主要介绍支付清结算中的账户和账务的处理。清结算是一个很专业的话题，这个专业不是计算机专业，而是会计专业。每个公司的账户和账务处理都有自己的要求和特点 这一系列文章，主要是从软件开发的角度来协助大家梳理清结算相关的基础知识。具体的账户、账务、会计处理流程，需要和公司会计详细沟通  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5e07f49ef9f394cec6ea36a4285af79c","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/4_%E8%B4%A6%E6%88%B7%E5%92%8C%E8%B4%A6%E5%8A%A1%E5%A4%84%E7%90%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/%E6%94%AF%E4%BB%98%E6%B8%85%E7%BB%93%E7%AE%97/4_%E8%B4%A6%E6%88%B7%E5%92%8C%E8%B4%A6%E5%8A%A1%E5%A4%84%E7%90%86/","section":"blog","summary":"4.1 账户体系 4.1.1 资产类账户 4.1.2 负债类账户 4.1.3 所有者权益类账户 4.1.4 损益类账户 4.1.5 成本类账户 4.1.6 共同类账户 4.1.7 账户体系 4.2 账户结构 4.3 支付流程 4.4 支付订单 4.5 支付记录 4.6","tags":["o2o"],"title":"4 账户和账务处理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  4.1 功能需求和非功能需求 4.2 软件需求文档 4.3 需求描述 4.4 需求工程过程 4.5 需求导出和分析 4.6 需求有效性验证 4.7 需求管理\n 需求工程：对服务和约束的发现、分析、建立文档、检验的过程\n 服务：系统提供的服务 约束：系统所受到的约束  用户需求：表达高层的概要需求\n 用自然语言加图的形式给出的、关于系统需要提供哪些服务以及系统操作受到哪些约束的声明  系统需求：对系统应该提供服务的详细描述\n 详细地给出系统将要提供的功能以及系统所受到的约束 有时也称为功能描述，应该是精确的   4.1 功能需求和非功能需求  功能需求：包括对系统应该提供的服务、如何对特殊输入做出反应，以及系统在特定条件下的行为的描述  某些情况下，可能需明确声明系统不应该做什么 系统的功能需求描述应该完备且一致 完备性：用户所需的所有服务都应该给出描述 一致性：需求描述不能前后矛盾  非功能需求：对系统提供的服务或功能给出的约束  包括时间约束、开发过程的约束和所受到的标准的约束 经常适用于整个系统而不是个别的系统或功能 如果有可能，使非功能需求得以量化，从而可测试   4.2 软件需求文档  软件需求文档是对系统开发者需要实现什么的正式陈述  应该包括系统的用户需求和一个详细的系统需求描述  敏捷：增量式收集用户需求，并把它们作为用户故事情节卸载卡片上；然后对需求给出优先级排序，优先考虑紧急的需求  4.3 需求描述  需求描述就是在需求文档写下用户需求和系统需求  用户需求：从用户角度描述，使用自然语言、图形描述 系统需求：是软件工程师系统设计的起点，仅仅描述系统的外部行为和对它的操作上的限制   4.4 需求工程过程  需求工程包括  1 业务需求描述 2 可行性研究：在需求工程早起进行。考虑三个相关问题 系统是否对机构的总体目标有贡献 采用当前技术，系统是否能在时间要求和预算范围内实现 系统是否能和正在使用中的其他系统集成 3 用户需求导出 4 用户需求描述 5 原型构造 6 系统需求导出 7 系统需求描述和建模 8 复查(需求有效性验证) 重复上述步骤   4.5 需求导出和分析  1 需求发现：也称为需求导出，是一个对准备建立的系统和正在使用的系统进行信息收集，并从这些信息中提取用户需求和系统需求的过程 2 需求分类和组织 3 需求优先级排序和协商 4 需求描述 重复上述步骤  4.6 需求有效性验证  需求有效性验证是检验需求是否真正按客户的意愿来定义系统的过程 对需求文档定义的需求执行多种类型的检查  有效性检查：某个用户可能认为系统应该执行某项功能 一致性检查：在文档中，需求不应该彼此冲突 完备性检查：需求文档应该包括所有系统用户想要的功能和约束 真实性检查：基于对已有技术的了解，检查需求以保证需求能真正实现。这些检查考虑到系统开发的预算和进度安排 可检验性检查：系统书写的需求应该是可以检验的，即能设计出一组检查方法来验证交付的系统是否满足每一个定义的需求  需求有效性验证技术包括  需求评审：由一组评审人员对需求进行系统性分析，主要是错误检查和不一致性检查 原型建立：为客户和最终用户生成一个可执行的系统模型，他们能在这个模型上体验从而检查系统是否符合他们的真正需要 测试用例生成：需求应该是可测试的。把对需求的测试作为有效性验证过程的一部分，从而发现问题。如果很难或者不可能设计测试，那以为着需求的实现很困难，应重新考虑   4.7 需求管理  需求管理是一个对系统需求变更了解和控制的过程 需求变更管理过程有 3 个阶段  问题分析和变更描述：对问题或变更提议进行分析检查有效性。将分析结果反馈给变更请求者，请求者产生一个更详尽的需求变更提议或取消变更请求 变更分析和成本计算 变更实现：必要的话，修改需求文档以及系统设计和实现。尽量避免先修改系统再修改需求文档   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"667d848ec3e2cba3a2e21ac93c77260f","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/4-requirement-engineering/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/4-requirement-engineering/","section":"blog","summary":"4.1 功能需求和非功能需求 4.2 软件需求文档 4.3 需求描述 4.4 需求工程过程 4.5 需求导出和分析 4.6 需求有效性验证 4.7 需求管理 需求工程：对服务和约束的发现、分析、建","tags":["sa","engineer"],"title":"4 需求工程","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  5.1 用户故事 5.2 迭代 5.3 发布  5.1 用户故事  一个用户故事是由用户几句日常语言表叔的需求，应该在一个迭代中完成 用户故事完成时  检查了所有相关代码 通过所有单元测试 case 通过所有验收测试 case 写了帮助文档 产品负责人已经验收了这个故事   5.2 迭代  一个迭代发布一个产品，来验收解决的用户故事或故障 迭代在迭代计划会议中定义，通过一个迭代演示和评审会议完成 一个迭代也叫一个冲刺(sprint) 一个迭代完成时  产品需求列表已完成 测试了性能 用户故事被验收或移动到下次迭代 故障被解决或推迟到下次迭代   5.3 发布  一个发布是一个主要的里程碑，代表内部或外部工作的交付，是产品或系统的测试版本 一个发布完成时  测试了系统压力 调整了性能 执行了安全验证 测试了灾难恢复计划   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"de864999892e718d66bf113c0610d33c","permalink":"https://xueqing.github.io/translation/agile/tutorial/5-definition-of-done/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/5-definition-of-done/","section":"translation","summary":"5.1 用户故事 5.2 迭代 5.3 发布 5.1 用户故事 一个用户故事是由用户几句日常语言表叔的需求，应该在一个迭代中完成 用户故事完成时 检查了所有相关代码 通过所有单元","tags":["agile"],"title":"5 完成标准","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  5.1 为什么使用 IAP 5.2 IAP 支付流程 5.3 IAP 订阅  5.3.1 续费周期的计算 5.3.2 自动续费 5.3.3 免费试用 5.3.4 Receipt 验证  5.4 IAP 破解和防御 5.5 两套账户体系 5.6 分成，定价和国际化 5.7 更多的坑 5.8 Android IAP  5.1 为什么使用 IAP  应用内支付(In-App Purchase, IAP)：指使用手机操作系统自带的支付功能支持支付。目前国内主要的应用内支付有 Google Pay、Apple Pay、小米支付、华为支付等。其中 Apple Pay 是典型的一个应用内支付，Android平台的各种支付也一般是沿用 Apple Pay 的设计 相对来说，应用内支付的用户体验，和微信支付、支付宝相比，还是有一定差距的.但是为什么要开发应用内支付呢？这个和苹果的 AppStore 的审核政策有关。在官方的 App Store Review Guidelines 中，有如下几条意见：  在 App 内使用非 IAP 的系统来购买内容、功能或服务将被拒绝    1.2 Apps utilizing a system other than the In-App Purchase API (IAP) to purchase content, functionality, or services in an App will be rejected.\n  IAP 购买实物或者应用外的商品或服务将会被拒绝    11.3 Apps using IAP to purchase physical goods or goods and services used outside of the App will be rejected.\n  通过 IAP 购买的积分或者其他货币必须只在 App 内使用    11.4 Apps that use IAP to purchase credits or other currencies must consume those credits within the App\n  问题：如果要购买的服务，既在 IOS 内使用，也在 Android 等 IOS 系统外使用，那应该是使用规则 11.2 还是规则 11.3 来执行？比如说视频网站，视频既可以在 IOS 上看，也可以在 Android 上看，那是否是需要通过 IAP 来购买？苹果公司在这一点上采取模糊的策略。爱奇艺、腾讯视频，在 IOS 上购买会员，只能用 IAP 支付。这就和苹果公司的审核有关  5.2 IAP 支付流程  一般 IAP 支付的开发流程，首先需要一些准备工作，包括  1 在 developer.apple.com 上配置一个 App ID，使用该 ID 生成和安装相应的 Provisioning Profile 文件 2 登录到 iTunes Connect，使用 App ID 创建一个新的应用，在该应用中，创建应用内付费项目，设置好价格和 Product ID 以及购买介绍和截图 3 添加一个用于在 sandbox 付费的测试用户，填写相关的税务、银行、联系人信息  完成这些准备工作后，既可以进入正式的开发，开发流程如下  1 用户选择要购买的内容并点击购买按钮 2 用户通过 AppStore 账户验证 3 苹果服务器验证用户请求 4 苹果服务器从用户帐号扣款 5 苹果向用户返回购买成功信息 6 软件接收并显示用户购买信息  上述流程的坑  账号坑：用户访问 AppStore 时使用的是 Apple 的账号，不是应用系统的账号。也就是说，我们并不知道到底是谁在购买这个内容。比如在应用中有两个账号 A 和 B，用 A 账号登录后，上 IAP 买了东西，然后用 B 账号来登录，也上 IAP 买东西，这两次购买用的是同一个 Apple 账号。苹果也不会告诉你，到底是哪个账号付了钱。账号坑在单次购买中还没什么问题，但碰到订阅的情况，得好好处理下 从上述流程可以看出，苹果服务器都是和客户端打交道的，这里面似乎没有应用服务器什么事情。只有在客户端接收到苹果返回信息后，才可以把这个信息转发给应用服务器。如果用户一直不打开手机上的应用，那应用服务器就一直收不到通知了。好在后来苹果提供了一个验证功能，应用服务器可以把接收到的返回信息(加密后的字符串)发送给苹果服务器来验证和解密   5.3 IAP 订阅  IAP Subscription 又是一个大坑，参考官方的文档  5.3.1 续费周期的计算  IAP 主要提供给周期性订阅的音乐、电子书等内容使用 一般就按月来计算周期。苹果是以自然月来算权益周期。比如在 1 月 3 号买了权益，到 2 月 3 号，这个权益就过期啦，需要在此之前完成续费。1 月 31 号买的权益，以自然月算，会在 3 月 1 日前到期，如果 2、3 月份都续费了，到 4 月份，也是享受到 4 月 30 日  5.3.2 自动续费  应用开发应该不需要关心续费的细节。苹果会做自动处理。在权益到期前 10 天，苹果检查用户账户是否可以扣款，商品价格是否有变动。在权益到期前 24 小时，苹果开始扣款，如果失败，会多次重试，直到成功 这个重试会延续到用户权益过期后一小段时间，苹果没有说这段时间该算是有权益还是没有，但开发人员需要注意应该如何处理  5.3.3 免费试用  免费试用不是强制需求，但这有利于用户判断是否值得购买这个物品 免费试用期是在 iTunes connect 中设置。当用户第一次购买这个东西的时候，客户端接收到的 Receipt 中包含免费试用信息。在免费期快到的时候，苹果发起第一次扣款。整个过程和自动续费类似，唯一区别是第一个月是免费的  5.3.4 Receipt 验证  客户端接收到 Receipt 之后，需要提交到服务器端进行处理，开通权益 Receipt 应该在服务器端处理，这样可以防止越狱后的一些插件，如 IAP Cracker、IAP Free 等伪造交易凭证，欺骗苹果服务器，开通权益 还需注意，客户端和服务器端之间需通过 HTTPS 以及参数签名等方式来确保通讯安全。服务器端接收到 Receipt 之后，首先验证请求的有效性，然后将 Receipt 发送到苹果服务器上进行验证和解析。接收到苹果处理结果后，将 Receipt 中的 user_id、product_id、purchase_date、transaction_id 等做验证和处理  5.4 IAP 破解和防御  既然 IAP 的验证主要是在苹果服务器端和手机客户端进行，并且是使用域名。这简直是为攻击打开了一扇大门，而不仅仅是漏洞。早期的 IAP 内购解锁工具 IAP cracker 对 IAP 的破解比较简单粗暴。程序中基本都是用 transactionState 判断交易是否成功。 transactionState 有四个状态  SKPaymentTransactionStatePurchasing SKPaymentTransactionStatePurchased：表示购买成功 SKPaymentTransactionStateFailed SKPaymentTransactionStateRestored  只要修改 SKPaymentTransactionStatePurchased 值，如果客户端应用直接根据交易状态来处理业务流程，那就会收到这个假的交易成功信息，接下来用户就能不花钱得到所买的物品。这个过程甚至都不需要接入网络 另一个工具 IAP Free 功能更强大，安装使用也复杂很多。它是通过修改 DNS，让客户端访问黑客提供的服务器来取代访问苹果服务器，实现所谓的 MITM 中间人攻击  当用户在客户端触发购买流程时，会被引导到伪装的苹果服务器上，不扣款而直接返回扣款成功收据。用户不需要支付任何资金，客户端能够拿到完整的收据 如果是在客户端处理收据验证也没有任何问题。为了避免用户所使用的设备被封，这些软件甚至可以提供伪造 UDID 的功能 为此，苹果特别说明，一定要在服务器端验证用户购买信息，验证内容包括收据签名、证书、产家信息等，确保收据无误后，才能授予权益。如果发现有诈，则将用户拉黑   5.5 两套账户体系  苹果支付的账户体系是以 Apple id 为基础，它允许用户在多台设备上共用一个账户  一台设备上，一般只有一个激活账户。但对应用系统来说，大部分是允许多个账号登陆的 这对续费来说是个问题。用户以账户 A 登录后，发起续费，获得权益。然后以账号 B 登录了，显然，A 的权益不会衍生给 B。过几天 A 开始续费了，续费之后，切换到 B 账号登录，客户端在 B 账号登录时得到续费的收据并发送给应用服务器。这算是 A 的续费请求。在这个 Apple id 发起的续费请求，所有的收据都会有一个相同的原始交易号 original transaction Id。在用户发起订阅时，需要记录这个 id 和账号的关系，每次续费，需要在解析收据后，根据原始交易号从这里获取真正的充值账户，不能从客户端提交的用户 id 作为凭据  如果在账户 B 登录后也发起订阅请求，这个调用将会失败，所以需要阻止用户发起这样的请求。或者设置多个产品副本来让用户购买  5.6 分成，定价和国际化  在 iTunes 中的给的产品定价必须是税前的，苹果和商家的分成也是按税前算 商家给出在一个主要销售国家和地区(比如国内的基本就是中国)的价格，即基准价格。在其他地区的销售价格，苹果会自动根据当前的汇率来换算成当地的货币。当然，也可以自己修改设定在这些国家或者地区的当地价格。目前是支持到 155 个国家。还要特别注意版权问题 基准价格调整，如果是往高了调整，则在用户下一次续费时，需要用户确认。如果往低了调，那就不需要用户确认，直接扣款了 苹果对商家的产品价格体系有分组(Group)的概念，同国内说的价格体系，比如白金会员、黄金会员、贵宾等，在同一个 Group 里面，用户只能选择一个档，比如用户要么是白金要么是黄金会员，不会同时是 在同一个 Group 中，如果用户订阅时间超过一年(365 天)，则商家可以得到来自这个用户收益的更多的分成，目前是 85%。这个订阅时间不包括免费试用期。同时可以有 60 天的宽限。也就是说，这一年中，如果用户曾经停止续费，然后又开始继续续费，只要中间不续费的时间不超过 60 天就行  5.7 更多的坑  目前用的是 IOS 10.0 版本，这个版本和 IAP 有关的坑  沙盒环境，没法做取消订阅操作。只能在线上模拟。所以产品设计和开发时，尽量不要依赖取消订阅操作，也应该不依赖于这个操作 沙盒环境下，有些 receipt 可能会收不到 transaction id，线上的暂未发现这个问题 苹果提供单个收据和列表收据两种格式。推荐使用列表数据，但问题是这个列表收据的长度，苹果也不知道最多会有多少   5.8 Android IAP  IOS 上用苹果支付是被逼的 Android 上用支付宝和微信支付：后者有大量用户基数，接入也很方便，费用比 IAP 便宜  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a8d69f1a99d18f30bf5169a02e48587a","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/5_%E5%BA%94%E7%94%A8%E5%86%85%E6%94%AF%E4%BB%98/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/5_%E5%BA%94%E7%94%A8%E5%86%85%E6%94%AF%E4%BB%98/","section":"blog","summary":"5.1 为什么使用 IAP 5.2 IAP 支付流程 5.3 IAP 订阅 5.3.1 续费周期的计算 5.3.2 自动续费 5.3.3 免费试用 5.3.4 Receipt 验证 5.4 IAP 破解和防御 5.5 两套账户体系 5.6 分成，定价和国际化 5.7 更多的坑 5.8 Android","tags":["o2o"],"title":"5 应用内支付","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  5.1 处理目录的常用命令  5.1.1 ls 列出目录 5.1.2 cd 切换目录 5.1.3 pwd 显示当前目录 5.1.4 mkdir 创建新目录 5.1.5 rmdir 删除空的目录 5.1.6 cp 复制文件或目录 5.1.7 rm 移除文件或目录 5.1.8 mv 移动文件与目录，或修改名称 5.1.9 touch 创建文件及修改文件时间戳 5.1.10 ln 在文件之间建立链接(硬链接和软链接)  5.2 Linux 文件内容查看  5.2.1 cat 由第一行开始显示文件内容 5.2.2 tac 5.2.3 nl 显示行号 5.2.4 more 一页一页翻动 5.2.5 less 一页一页翻动 5.2.6 head 取出文件前面几行 5.2.7 tail 取出文件后面几行  5.3 Linux 链接\n 5.3.1 硬链接 5.3.2 软链接 5.3.3 inode 属性 5.3.4 ln 命令  Linux的目录结构为树状结构，最顶级的目录为根目录/\n 其他目录可以通过挂载将添加到树中，通过解除挂载可以移除\n 绝对路径：由根目录/写起，如/usr/share/doc\n 相对路径：不是由/写起，是相对于当前路径的写法，如由/usr/share/doc要到/usr/share/man底下时，可以写成cd ../man\n  5.1 处理目录的常用命令  可以使用man 命令来查看各个命令的使用文档，如man cp     命令 功能     ls 列出目录   cd 切换目录   pwd 显示目前的目录   mkdir 创建一个新的目录   rmdir 删除一个空的目录   cp 复制文件或目录   rm 移除文件或目录   mv 移动文件与目录，或修改文件与目录的名称    5.1.1 ls 列出目录  语法  ls [-aAdfFhilnrRSt] 目录名称 ls [--color={never,auto,always}] 目录名称 ls [--full-time] 目录名称  选项与参数     选项 功能     -a 显示全部文件，包括隐藏文件（开头为 . 的文件），是最常用的选项之一   -A 显示全部文件，连同隐藏文件，但不包括 . 与 ..   -d 仅列出目录本身，不列出目录内的文件数据   -f ls 默认会以文件名排序，使用 -f 会直接列出结果，不进行排序   -F 在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，/ 代表目录，= 代表 socket 文件，   -h 以易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等   -i 显示 inode 节点信息   -l 使用长格式列出文件和目录信息，包含文件的属性与权限等数据   -n 以 UID 和 GID 分别代替文件用户名和群组名显示   -r 将排序结果反向输出，比如若原本文件名由小到大，反向则为由大到小   -R 连同子目录内容一起列出来，等于将该目录下的所有文件都显示出来   -S 以文件容量大小排序   -t 以时间排序   \u0026ndash;color=never 不依据文件特性给予颜色显示   \u0026ndash;color=always 表示显示颜色，ls 默认采用这种方式   \u0026ndash;color=auto 表示让系统自行依据配置来判断是否给予颜色   \u0026ndash;full-time 以完整时间模式（包含年、月、日、时、分）输出   \u0026ndash;time={atime,ctime} 输出访问时间或改变权限属性时间（ctime），而不是内容变更时间    # 将主目录下的所有文件列出来(含属性与隐藏文件) ls -al ~  5.1.2 cd 切换目录  cd(Change Directory)：用来变换工作目录 语法 cd [相对路径或绝对路径]\n# 回到自己的主目录，对于 root 用户，其主目录为 /root [root@localhost vbird]# cd ~ # 没有加上任何路径，代表回到当前登录用户的主目录 [root@localhost ~]# cd # 切换到 vbird 这个用户的主目录，即 /home/vbird [root@localhost ~]# cd ~vbird # 切换到目前的上一级目录，即 /root 的上一级目录 # 需要注意，在 Linux 系统中，根目录存在 .（当前目录）以及 ..（当前目录的父目录）两个目录 # 但由于根目录是最顶级目录，因此根目录的 .. 和 . 属性和权限完全一致，即根目录的父目录是自身 [root@localhost ~]# cd .. # 回到上次所在目录 [root@localhost /]# cd -   5.1.3 pwd 显示当前目录  pwd(Print Working Directory)：显示当前所在目录(链接路径) 语法 pwd [-P] 选项与参数\n -P ：显示出实际路径，而非使用链接(link)路径\n# 确定当前登陆的用户 [root@www ~]# whoami root # 显示出目录 [root@www ~]# pwd /root # /var/mail是一个链接文件 [root@www ~]# cd /var/mail # 列出目前的工作目录 [root@www mail]# pwd /var/mail [root@www mail]# pwd -P # /var/spool/mail [root@www mail]# ls -ld /var/mail lrwxrwxrwx 1 root root 10 Sep 4 17:54 /var/mail -\u0026gt; spool/mail # /var/mail 链接到 /var/spool/mail # 加上 -P 选项后，会不以链接文件的数据显示，而是显示正确的完整路径    5.1.4 mkdir 创建新目录  语法 mkdir [-mp] 目录名称 选项与参数\n -m：配置文件的权限，直接配置，不需要看默认权限(umask) -p：直接递归创建目录(包含上一级目录)\n[root@www ~]# cd /tmp # 创建一名为 test 的新目录 [root@www tmp]# mkdir test # 没办法直接创建此目录 [root@www tmp]# mkdir test1/test2/test3/test4 # mkdir: cannot create directory `test1/test2/test3/test4': # No such file or directory # 加 -p 选项可以自行创建多层目录 [root@www tmp]# mkdir -p test1/test2/test3/test4 # 如果没有加上 -m 来强制配置属性，系统会使用默认属性。 [root@www tmp]# mkdir -m 711 test2 [root@www tmp]# ls -l drwxr-xr-x 3 root root 4096 Jul 18 12:50 test drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 drwx--x--x 2 root root 4096 Jul 18 12:54 test2    5.1.5 rmdir 删除空的目录  语法 rmdir [-p] 目录名称 选项与参数\n -p：递归删除空目录\n#删除 runoob 目录 [root@www tmp]# rmdir runoob/ # 将 mkdir 实例中创建的目录(/tmp 底下)删除掉 [root@www tmp]# ls -l drwxr-xr-x 3 root root 4096 Jul 18 12:50 test drwxr-xr-x 3 root root 4096 Jul 18 12:53 test1 drwx--x--x 2 root root 4096 Jul 18 12:54 test2 [root@www tmp]# rmdir test # 因为尚有内容，所以无法删除 [root@www tmp]# rmdir test1 # rmdir: `test1': Directory not empty # 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除 [root@www tmp]# rmdir -p test1/test2/test3/test4 [root@www tmp]# ls -l \u0026lt;==您看看，底下的输出中test与test1不见了！ drwx--x--x 2 root root 4096 Jul 18 12:54 test2   要注意 rmdir 仅能删除空的目录，可以使用 rm 命令来删除非空目录\n  5.1.6 cp 复制文件或目录  语法  cp [-adfilprsu] 源文件(source) 目标文件(destination) cp [options] source1 source2 source3 .... directory  选项与参数\n -a：等同于 -pdr -d：若源文件为链接文件(link file)，则复制链接文件属性而非文件本身 -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次 -i：若目标文件(destination)已经存在，在覆盖时会先询问动作 -l：进行硬式连结(hard link)的链接文件创建，而非复制文件本身 -p：连同文件的属性(所有者、所属组和时间等)一起复制，而非使用默认属性(备份常用) -r：递归复制，用于复制目录 -s：复制成为符号链接文件(symbolic link) -u：destination 比 source 旧才更新(update) destination\n# 用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc [root@www ~]# cp ~/.bashrc /tmp/bashrc [root@www ~]# cp -i ~/.bashrc /tmp/bashrc # cp: overwrite `/tmp/bashrc'? n \u0026lt;==n不覆盖，y为覆盖    5.1.7 rm 移除文件或目录  语法 rm [-fir] 文件或目录 选项与参数\n -f：force，忽略不存在的文件，不会出现警告信息 -i：互动模式，在删除前会询问使用者是否动作 -r：递归删除\n# 删除创建的 bashrc [root@www tmp]# rm -i bashrc # rm: remove regular file `bashrc'? y # 如果加上 -i 就会主动询问    5.1.8 mv 移动文件与目录，或修改名称  语法  mv [-finuv] source destination mv [options] source1 source2 source3 .... directory  选项与参数\n -f：force 强制，如果目标文件已经存在，不会询问而直接覆盖 -i：若目标文件 (destination) 已经存在，就会询问是否覆盖，默认选项 -n：若目标文件已经存在，则不会覆盖移动，且不会询问用户 -u：若目标文件已经存在，且 source 比较新，才会更新(update) -v：显示文件或目录的移动过程\n# 复制一文件，创建一目录，将文件移动到目录中 [root@www ~]# cd /tmp [root@www tmp]# cp ~/.bashrc bashrc [root@www tmp]# mkdir mvtest [root@www tmp]# mv bashrc mvtest # 将刚刚的目录名称更名为 mvtest2 [root@www tmp]# mv mvtest mvtest2    5.1.9 touch 创建文件及修改文件时间戳  语法  touch [options] 文件名  选项与参数  -a：只修改文件的访问时间 -c：仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件 -d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间 -m：只修改文件的数据修改时间 -t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm  touch 命令可以只修改文件的 atime，也可以只修改文件的数据 mtime，但是不能只修改文件的 ctime。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即 ctime 会随之改变(更新为操作当前文件的真正时间)\n# 建立名为 bols 的空文件 [root@www ~]# touch bols # 查看文件的访问时间 [root@www ~]# ll --time=atime bols # 文件上次的访问时间为 9 月 25 号 21：23 -rw-r--r-- 1 root root 0 Sep 25 21:23 bols [root@localhost ~]# touch bols [root@localhost ~]# ll --time=atime bols -rw-r--r-- 1 root root 0 May 15 16:36 bols # 而如果文件已经存在，则也不会报错，只是会修改文件的访问时间 # 修改 bols 文件的 atime 和 mtime [root@localhost ~]# touch -d \u0026quot;2017-05-04 15:44\u0026quot; bols [root@localhost ~]# ll bols; ll --time=atime bols; ll --time=ctime bols -rw-r--r-- 1 root root 0 May 4 2017 bols -rw-r--r-- 1 root root 0 May 4 2017 bols -rw-r--r-- 1 root root 0 Sep 25 21:40 bols # ctime 不会变为设定时间，但更新为当前服务器的时间   5.1.10 ln 在文件之间建立链接(硬链接和软链接)  Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间  访问时间(Access Time, atime)：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变 数据修改时间(Modify Time, mtime)：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变 状态修改时间(Change Time, ctime)：当文件的状态发生变化，就会相应改变这个时间。比如，如果文件的权限或者属性发生改变，此时间就会相应改变  语法  touch [options] 文件名  选项与参数  -a：只修改文件的访问时间 -c：仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件 -d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间 -m：只修改文件的数据修改时间 -t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 YYMMDDhhmm  touch 命令可以只修改文件的 atime，也可以只修改文件的数据 mtime，但是不能只修改文件的 ctime。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即 ctime 会随之改变(更新为操作当前文件的真正时间)\n# 建立名为 bols 的空文件 [root@www ~]# touch bols # 查看文件的访问时间 [root@www ~]# ll --time=atime bols # 文件上次的访问时间为 9 月 25 号 21：23 -rw-r--r-- 1 root root 0 Sep 25 21:23 bols [root@localhost ~]# touch bols [root@localhost ~]# ll --time=atime bols -rw-r--r-- 1 root root 0 May 15 16:36 bols # 而如果文件已经存在，则也不会报错，只是会修改文件的访问时间 # 修改 bols 文件的 atime 和 mtime [root@localhost ~]# touch -d \u0026quot;2017-05-04 15:44\u0026quot; bols [root@localhost ~]# ll bols; ll --time=atime bols; ll --time=ctime bols -rw-r--r-- 1 root root 0 May 4 2017 bols -rw-r--r-- 1 root root 0 May 4 2017 bols -rw-r--r-- 1 root root 0 Sep 25 21:40 bols # ctime 不会变为设定时间，但更新为当前服务器的时间   5.2 Linux 文件内容查看  可以使用man 命令来查看各个命令的使用文档，如man cp     命令 功能     cat 由第一行开始显示文件内容   tac 从最后一行开始显示，可以看出 tac 是倒著写 cat   nl 显示的时候，输出行号   more 一页一页的显示文件内容   less 与 more 类似，但是比 more 更好的是，可以往前翻页   head 只看头几行   tail 只看尾几行    5.2.1 cat 由第一行开始显示文件内容  语法 cat [-AbEnTv] 选项与参数\n -A：等同于 -vET，可列出一些特殊字符而不是空白 -b：列出行号，仅针对非空白行做行号显示，空白行不标行号 -E：将结尾的断行字节 $ 显示出来 -n：列印出行号，连同空白行也会有行号，与 -b 的选项不同 -T：将 [tab] 按键以 ^I 显示出来 -v：列出一些看不出来的特殊字符\n# 查看 /etc/issue 文件内容 [root@www ~]# cat /etc/issue CentOS release 6.4 (Final) Kernel \\r on an \\m    5.2.2 tac  tac 与 cat 命令相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 倒着写\n[root@www ~]# tac /etc/issue Kernel \\r on an \\m CentOS release 6.4 (Final)   5.2.3 nl 显示行号  语法 nl [-bnw] 文件 选项与参数\n -b：指定行号显示的方式，主要有两种 -b a：不论是否为空行，也同样列出行号(类似 cat -n) -b t：如果有空行，空的那一行不要列出行号(默认值) -n：列出行号表示的方法，主要有三种 -n ln：行号在荧幕的最左方显示 -n rn：行号在自己栏位的最右方显示，且不加 0 -n rz ：行号在自己栏位的最右方显示，且加 0 -w ：行号栏位的占用的位数\n# 用 nl 列出 /etc/issue 的内容 [root@www ~]# nl /etc/issue 1 CentOS release 6.4 (Final) 2 Kernel \\r on an \\m    5.2.4 more 一页一页翻动 [root@www ~]# more /etc/man_db.config # # Generated automatically from man.conf.in by the # configure script. # # man.conf from man-1.6d --More--(28%) # 光标在这一行等待命令   在 more 程序的运行过程中，有几个按键可以按  空白键(space)：代表向下翻一页 Enter：代表向下翻一行 /字串：代表在这个显示的内容当中，向下搜寻\u0026rdquo;字串\u0026rdquo;关键字 :f：立刻显示出文件名以及目前显示的行数 q：代表立刻离开 more，不再显示该文件内容 b 或 [ctrl]-b：代表往回翻页，不过这动作只对文件有用，对管线无用   5.2.5 less 一页一页翻动 ，以下实例输出/etc/man.config文件的内容：\n[root@www ~]# less /etc/man.config # # Generated automatically from man.conf.in by the # configure script. # # man.conf from man-1.6d # : 这里可以等待输入命令   less 运行时可以输入的命令  空白键：向下翻动一页 [pagedown]：向下翻动一页 [pageup]：向上翻动一页 /字串：向下搜寻\u0026rdquo;字串\u0026rdquo;的功能 ?字串：向上搜寻\u0026rdquo;字串\u0026rdquo;的功能 n：重复前一个搜寻(与 / 或 ? 有关) N：反向的重复前一个搜寻(与 / 或 ? 有关) q：离开 less 程序   5.2.6 head 取出文件前面几行  语法 head [-n number] 文件 选项与参数\n -n：后面接数字，代表显示几行\n[root@www ~]# head /etc/man.config # 默认的情况中，显示前面 10 行 # 若要显示前 20 行，就得 [root@www ~]# head -n 20 /etc/man.config    5.2.7 tail 取出文件后面几行  语法 tail [-n number] 文件 选项与参数\n -n：后面接数字，代表显示几行 -f：表示持续侦测后面所接的文件名，要等到按下 [ctrl]-c 才会结束 tail\n[root@www ~]# tail /etc/man.config # 默认的情况中，显示最后 10 行 # 若要显示最后的 20 行，就得 [root@www ~]# tail -n 20 /etc/man.config    5.3 Linux 链接  Linux 链接分两种：硬链接(Hard Link)和符号链接(Symbolic Link) 默认情况下，ln 命令产生硬链接  5.3.1 硬链接  硬链接指通过索引节点进行链接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index) 在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接(A 和 B 都是文件名)，则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问 硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止“误删”的功能 其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其它的链接，只有当最后一个链接被删除后，文件的数据块及目录链接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除 修改源文件和硬链接文件都会改变另一个文件的数据。硬链接不会建立新的 inode 信息，也不会更改 inode 的总数  5.3.2 软链接  符号链接(Symbolic Link)，也叫软链接。软链接文件类似于 Windows 的快捷方式。它实际上是一个特殊的文件，用于指向另一个文件。此链接方式也适用于目录 在符号链接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接(A 和 B 都是文件名)，A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名(可以根据这个找到 B 的目录项)。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在(因为两个是不同的文件)，但指向的是一个无效的链接  5.3.3 inode 属性  Linux 目前使用 ext4 文件系统：分区分为两大部分(不考虑超级块)，小部分用于保存文件的 inode 信息；剩余大部分用于保存 block 信息  iNode 默认大小是 128 Byte，用于记录文件的权限、所有者和属组、大小、ctime、atime、mtime、文件数据的 block 编号，每个文件一个 inode block 默认大小是 4KB。用于实际的数据存储，一个 block 只属于一个文件，可能未占满。一个文件占用的 block 也可以是不连续的 总之，每个文件一个 inode，文件内容由 inode 的记录指向。目录的 block 记录该目录下所有一级子文件和子目录的文件名及对应的 inode。需要根据文件名找到对应的 inode，再找到文件内容所在的 block 块  Linux 操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等) 文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性存放在 inode 中，至于实际数据则放置到 data block 区块中  inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block  还有一个超级区块(superblock)会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等 在 Linux 中，可以使用 stat 命令查看某个文件的 inode 信息，包括文件大小、占用的 block 数量、block 大小、文件类型(普通文件或其他)、inode 节点号、链接数、权限、所有者、所属组、访问时间、数据修改时间、状态修改时间\nstat /etc/passwd linux-peanut:~/Desktop # stat /etc/passwd File: '/etc/passwd' Size: 2269 Blocks: 8 IO Block: 4096 regular file Device: 802h/2050d Inode: 1149740 Links: 1 Access: (0644/-rw-r--r--) Uid: ( 0/ root) Gid: ( 0/ root) Access: 2018-04-09 17:16:42.000000000 +0800 Modify: 2018-04-09 17:16:36.000000000 +0800 Change: 2018-04-09 17:16:36.000000000 +0800 Birth: -   5.3.4 ln 命令  语法 ln [选项] 源文件 目标文件 选项与参数\n -s：建立软链接文件。如果不加 \u0026ldquo;-s\u0026rdquo; 选项，则建立硬链接文件 -f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件 目标文件可以只写路径没有写文件名，会和原名一致 软链接文件的源文件必须写成绝对路径，而不能写成相对路径(硬链接没有这样的要求)；否则软链接文件会报错 No such file or directory\n# 创建一个测试文件f1 [oracle@Linux]$ touch f1 # 创建f1的一个硬链接文件f2 [oracle@Linux]$ ln f1 f2 # 创建f1的一个符号链接文件f3 [oracle@Linux]$ ln -s f1 f3 # -i参数显示文件的inode节点信息 [oracle@Linux]$ ls -li total 0 9797648 -rw-r--r-- 2 oracle oinstall 0 Apr 21 08:11 f1 9797648 -rw-r--r-- 2 oracle oinstall 0 Apr 21 08:11 f2 9797649 lrwxrwxrwx 1 oracle oinstall 2 Apr 21 08:11 f3 -\u0026gt; f1 # 硬链接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，符号链接文件的 inode 节点不同 [oracle@Linux]$ echo \u0026quot;I am f1 file\u0026quot; \u0026gt;\u0026gt;f1 [oracle@Linux]$ cat f1 I am f1 file [oracle@Linux]$ cat f2 I am f1 file [oracle@Linux]$ cat f3 I am f1 file [oracle@Linux]$ rm -f f1 [oracle@Linux]$ cat f2 I am f1 file [oracle@Linux]$ cat f3 cat: f3: No such file or directory # 当删除原始文件 f1 后，硬链接 f2 不受影响，但是符号链接 f1 文件无效   删除符号链接 f3，对 f1 f2 无影响\n 删除硬链接 f2，对 f1 f3 也无影响\n 删除原文件 f1，对硬链接 f2 没有影响，导致符号链接 f3 失效\n 同时删除原文件 f1 和 硬链接 f2，整个文件会真正的被删除\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0a97f1fd267bcb6fb525f97e8d25126e","permalink":"https://xueqing.github.io/blog/linux/5_%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/5_%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","section":"blog","summary":"5.1 处理目录的常用命令 5.1.1 ls 列出目录 5.1.2 cd 切换目录 5.1.3 pwd 显示当前目录 5.1.4 mkdir 创建新目录 5.1.5 rmdir 删除空的目录 5.1.6 cp 复制文件或目录 5.1.7 rm 移除文件或目录 5.1.8 mv 移动文件与","tags":["linux"],"title":"5 文件与目录管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e1eef830733ff483fba8e65a7d04a383","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/5-system-modeling/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/5-system-modeling/","section":"blog","summary":"","tags":["sa","engineer"],"title":"5 系统建模","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  6 体系结构设计\n 6.1 体系结构设计决策 6.2 体系结构视图 6.3 体系结构模式 6.4 应用体系结构  必要性：开发过程的早期应当涉及建立整体的系统体系结构\n 体系结构的增量式开发并不总是成功的 重构一个系统体系结构可能是非常昂贵的  方块图：系统体系结构经常用方块图建模\n 方块：代表一个组件 方块中的方块：表示所代表的组件又被分解成一些子组件 箭头：表示所示方向有数据和控制信号从一个组件流到另一个组件   6.1 体系结构设计决策 非功能性系统需求主要有\n 性能：定位组件的关键操作，部署到同一个平台，减少通信次数 信息安全性：采用分层结构，重要资源放在内层，每层采用严格的信息安全有效性验证 安全性：安全相关的操作集中在一个或少数几个组件，降低成本和减少安全有效性验证 可用性：采用冗余组件以便更新替换和更新组件 可维护性：使用小粒度的自包含组件以便于更换。分离数据的生产者和消费者，避免数据共享  6.2 体系结构视图  4+1 视图：  逻辑视图：显示系统中对象和对象类的抽象，将系统需求和实体关联 进程视图：显示运行时系统如何组织为一组交互的进程。对非功能系统特征的判断很有效 开发视图：显示软件如何为了开发而被分解，即将软件分解成可由单独的开发人员或开发团队实现的组件。对软件管理者和程序员有用 物理视图：显示了系统硬件和软件组件如何分布在处理器上。对系统工程师规划系统部署有用 概念视图：系统的抽象视图，可作为把高层次需求分解为详细描述的基础  UML：在详细地文档化一个体系结构或使用模型驱动开发时使用 ADL：基本要素是组件和连接器，为特定领域涉及，或许可作为模型驱动开发的基础  6.3 体系结构模式  模式的思想：作为一种表示、共享和复用软件系统知识的方法  名称 | 描述 | 实例 | 使用时机 | 优点 | 缺点 \u0026mdash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | \u0026mdash; 分层体系结构 | 将系统组织成分层结构，每层包含一组相关功能。每层提供服务给紧邻的上一层，因此最底层有可能是整个系统核心服务 | 存在于不同图书馆的共享版权文档的系统分层模型 | 在已有系统的基础上构建新设施使用；开发团队是分散的小团队，每个小团队负责一层功能；系统存在多层信息安全性需求 | 允许在接口不变时更换整层；每层可提供冗余服务以增加系统可靠性 | 很难分离各层，高层可能必须与低层交互；服务在每层被处理会降低性能 容器体系结构 | 系统所有数据在一个中央容器中管理，可被所有系统组件访问；组件不能直接交互，只通过容器交互 | 指挥和控制系统、CAD 系统和软件的交互开发环境 | 系统生成的大量数据需要持久保存；数据驱动系统中，每当容器中收入数据时触发一个工作或工具 | 组件是独立的，无需知道其他组件的存在；一个组件的变更可传播到所有的组件；所有数据得到一致的管理，因为数据存在同一个地方 | 容器是单点故障，容器会影响整个系统；所有通过容器进行通信会低效；容器分布到多个计算机会困难 客户机-服务器体系结构 | 系统功能以服务的形态存在，每个服务来自某个单独的服务器。客户机是使用服务和访问服务器的用户 | 电影和视频资料库 | 需要从很多地方访问共享数据；服务器可以复制，适用于系统负载经常变化 | 服务器可分布到网络上。一般性的功能可被所有客户机使用，但不需要被所有服务实现 | 每个服务是单点故障，不能阻止拒绝服务供给或服务器失败；依赖于网络和系统导致性能无法预知；服务器属于不同的机构时不易管理 管道和过滤器体系结构 | 每个处理组件(过滤器)是分类的，执行某个类型的数据转换。数据流从一个组件流向另一个组件 | 票据处理系统 | 数据处理应用(批处理和事务处理)，一些不同的阶段处理输入数据，并产生响应的输出 | 易于理解并支持变换的复用；工作流风格与很多业务处理体系结构很匹配；通过变换的方式进行进化；可实现为顺序或并发系统 | 通信变换期间所传输的数据格式必须协调好；每个变换必须解析它的输入并写成约定的格式输出；增加了系统负荷，因为不能复用使用不兼容数据结构的函数变换\n6.4 应用体系结构 常见的应用类型的体系结构\n   类型 描述 场景 适用的体系结构     事务处理应用 以数据库为中心，处理来自用户对信息的请求并更新数据库的数据，都是交互式系统 交互式银行系统、电子商务系统、信息系统和预订系统 管道和过滤器   语言处理系统 用户意图用形式化语言来表达的系统，语言处理系统将这种语言处理成一种内部格式，然后解释这种内部表示 编译器 容器和管道过滤器的复合模型   信息系统 所有涉及与共享数据库交互的系统都可看成基于事务的信息系统。信息系统允许对一个大信息库进行适当的访问 基于 web 的系统 分层    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ed3daf7851f619c7f01c239c51c7c6d4","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/6-architectural-design/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/6-architectural-design/","section":"blog","summary":"6 体系结构设计 6.1 体系结构设计决策 6.2 体系结构视图 6.3 体系结构模式 6.4 应用体系结构 必要性：开发过程的早期应当涉及建立整体的系统体系结构 体系结构的增量","tags":["sa","engineer"],"title":"6 体系结构设计","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  6.1 参与者 6.2 计划的先决条件- 6.3 需要的材料 6.4 计划数据 6.5 输出 6.6 日程  发布计划的目的是创建一个计划，来增量交付产品。每 2~3 个月做一次。\n6.1 参与者  流程管理员：敏捷交付团队的引导者 产品负责人：代表产品需求列表的一般观点 敏捷团队：提出技术可行性和任何依赖的观点 利益相关者：当发布会议作出决定时，利益相关者比如客户、程序管理者、主体专家提出建议  6.2 计划的先决条件-  排好序的产品需求列表：由产品负责人管理。一般考虑 5~10 个特性，由产品负责人考虑可被纳入一个发布 团队能力的输入、已知的速度或任何关于技术的挑战 高等级的愿景 市场和业务目标 确认新产品的需求列表项是否需要  6.3 需要的材料  贴出的日常，目的 挂图，白板，记号笔 投影仪，用于共享计划会议中所需数据或工具的电脑 计划数据  6.4 计划数据  上次迭代或发布计划的结果 不同的利益相关者对于产品、市场条件和截止日期的反馈 上次发布或迭代的行动计划 需要考虑的特性或故障 上次发布或预估的速度 组织和个人的日程表 其他团队和主体专家管理依赖性的输入  6.5 输出  发布计划 承诺 要监察的问题、关注点、依赖性和假设 改进未来发布计划的建议  6.6 日程  开场仪式：欢迎消息，评审目的和提成，组织工具，介绍业务赞助者 产品愿景，蓝图：展示产品的大图 评审之前的发布：太累可能影响这次计划的条目 发布名字或主题：检查蓝图主题的当前状态，做出所需的调整 速度：代表当前发布和之前发布的速度 发布安排：评审发布中关键的里程碑和决定 问题和关注点：检查并记录所有的关注点或问题 评审和更新完成标准：评审完成标准，基于上次迭代或发布之后的技术、技巧或团队成员的改变做出合适的改变 需要考虑的故事和条目：展示来自产品需求列表需要考虑的用户故事和特点，用于当前发布的安排 确定分级值：如果速度未知，计划发布计划中药使用的分级值 粗粒度划分故事：交付团队考虑之后确定故事的合适大小，且当故事比较大时，将故事划分成多个迭代。产品负责人和主体专家澄清疑问，详细制作验收标准，并做出合适的故事划分。流程管理者促进合作 将故事映射到迭代：交付团队和产品负责人基于大小和速度将故事或故障移到迭代。流程管理者促进合作 新的关注点或问题：基于之前的计划检查新问题，记录相同的问题 依赖性和假设：价差发布计划中的任何依赖性或假设 承诺：流程管理者好找计划。交付团队和产品负责人视其为最好的计划，并承诺开展下个级别的计划，即迭代计划 沟通和后勤计划：为发布评审或更新沟通和后勤计划 停车场：所有条目应该被解决或作为行动条目 分发行动条目和行动计划：分发负责人的行动条目，处理行动计划 回顾：征求参与者的反馈使会议成功 结束：庆祝成功  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8a44c0d00e26680302b5c2486835a38c","permalink":"https://xueqing.github.io/translation/agile/tutorial/6-release-planning/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/6-release-planning/","section":"translation","summary":"6.1 参与者 6.2 计划的先决条件- 6.3 需要的材料 6.4 计划数据 6.5 输出 6.6 日程 发布计划的目的是创建一个计划，来增量交付产品。每 2~3 个月做一次。 6.1 参与者 流程管理员","tags":["agile"],"title":"6 发布计划","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  6.1 前言 6.2 产品分类 6.3 模块功能 6.4 业务流程  6.1 前言  支付产品模块是按照支付场景来为业务方提供支付服务 支付产品模块一般位于支付网关之后，支付渠道之前。根据支付能力将不同的支付渠道封装成统一的接口，通过支付网关来对外提供服务。 从微服务的角度，支付产品本身也是一个代理模式的微服务，它通过支付网关响应业务方请求，进行一些统一处理后，分发到不同的支付渠道去执行，最后将执行结果做处理后，通过支付网关再回传给业务方 支付产品在支付系统参考下图架构图中的位置  也有设计是将支付产品模块与支付网关合并到一起的  6.2 产品分类  支付产品：由支付系统对支付渠道进行封装而对业务方提供的支付能力 在不同的公司，由于接入渠道和应用的差异，支付产品分类略有不同 综合支付场景和流程，支付产品可以分为如下几类   | 支付产品 | 操作 | 优点 | 不足 | 实现方式 | | \u0026mdash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | | 快捷支付 | 用户在完成绑卡之后，在支付的时候，不需要再输入卡或者身份信息，仅需要输入支付密码就可以完成支付。对于小额度的支付，甚至可以开通小额免密，直接完成支付 | 不会打断用户的体验，是目前主要的在线支付方式 | - | 一般是封装银行或者第三方支付平台提供的快捷支付接口或者代付接口 | | 网银支付 | 用户在支付的时候，需要跳转到银行网银页面来完成支付。在网银页面，需要输入用户的卡号和身份信息 | - | 会中断用户当前的体验，一般仅用于 PC Web 上的支付 | 封装银行提供的网银支付 | | 协议支付 | 也称代收或者代扣，代收指渠道授权商户可以从用户的银行账户中扣款 | 一般用于定期扣款 | 不用于日常消费(如水电煤气、有线电视费) | 封装银行、第三方支付提供的代扣或者快捷接口 | | 平台支付 | 使用微信、支付宝等第三方支付平台来完成支付 | 由于微信、支付宝已经被大量使用，用户也产生对这些平台的信任，平台支付往往是电商公司的主要支付方式 | 使用时，一般需要用户预先安装支付平台系统(手机)，注册并登录到第三方支付平台，并且已经在该平台上完成绑卡等操作 | - | | 外卡支付 | 国内不少支付渠道都能支持外卡支付(如支付宝全球购) | 支持海外支付 | - | 直接对接 Paypal，也是目前用的最多的外卡支付渠道 | | 话费支付 | - | 对于有包月小额类型的支付，可使用手机话费支付 | - | 目前有一些平台可以支持话费支付(如虹软、联动优势) | | 虚币支付 | 不少公司会有自己的虚拟币(如京豆、Q 币)。这些虚币也可以作为一种支付方式 | - | - | - | | 账户支付 | 也称为余额支付、零钱支付等。指为用户建立本地账户，之后可以使用这个账户来完成支付 | 支持充值 | - | - | | 信用支付 | (如京东白条，蚂蚁花呗)指使用信用账户进行透支，类似信用卡支付 | - | - | - | | 代付 | 和代扣相反，代付是平台将钱打给用户 | - | - | - |\n6.3 模块功能  支付产品根据其支付能力，对外提供不同的功能。整体上来说，一般支付产品需要提供如下接口   | 接口 | 功能描述 | 备注 | | \u0026mdash; | \u0026mdash; | \u0026mdash; | | 签约 | 在快捷支付、代扣等产品中，用户在使用前，需要先完成签约 | 签约可在渠道侧进行，一般第三方支付采用这种方式，当电商需要接入时，让第三方给授权。银行和银联的签约一般在电商侧进行，电商侧负责收集用户的信息，调用银行和银联的接口进行签约。签约后，后续的支付行为使用签约号进行，无需再输入个人信息 | | 解约 | 取消签约关系 | 和签约对应 | | 支付 | 不同产品中支付行为不一样 | 快捷支付在电商服务器上发起，请求渠道进行支付；网银支付是跳转到银行支付网关进行; 账户支付、虚币支付，是在本地进行 | | 撤销 | 取消当天在渠道侧未结算的交易 | 有些渠道区分撤销和退款(如银联、农行)，有些渠道则不作区分 | | 退款 | 仅针对已经结算的交易 | 有些渠道区分撤销和退款(如银联、农行)，有些渠道则不作区分 | | 查询签约状态 | 对于需要签约的交易，可以通过此接口查询签约状态 | - | | 查询订单状态 | 通过此接口查询支付清单状态以及退款的订单状态 | - | | 预授权 | 预授权交易用于受理方向持卡人的发卡方确认交易许可 | 受理方将预估的消费金额作为预授权金额，发送给持卡人的发卡方 | | 预授权撤销 | 对已成功的预授权交易，在结算前使用预授权撤销交易，通知发卡方取消付款承诺 | 预授权撤销交易必须是对原始预授权交易或追加预授权交易最终承兑金额的全额撤销 | | 预授权完成交易 | 对已批准的预授权交易，用预授权完成做支付结算 | - | | 预授权完成撤销 | 预授权完成撤销交易必须是对原始预授权完成交易的全额撤销 | 预授权完成撤销后的预授权仍然有效 | | 对账 | 通过 FTP 或 HTTP 方式提供对账文件供商户侧对账 | - | | 余额查询 | 查询商户的交易账户余额，避免由于余额不足导致交易失败 | 注意不是客户的余额。不是所有的银行或者第三方支付都提供这个接口 |\n6.4 业务流程  上述操作，除对账、查单外，每个操作实现的主流程，一般会包括参数校验、支付路由、生成订单、风险评估、调用渠道服务、更新订单和发送消息这 7 步 对于一些比较复杂的服务，还会涉及到异步同通知处理的步骤  1 执行参数校验：所有的支付操作，都需要对输入执行参数校验，避免接口受到攻击  验证输入参数中各字段的有效性验证：如用户 ID、商户 ID、价格、返回地址等 验证账户状态：交易主体、交易对手等账户的状态是处于可交易的状态 验证订单：如果涉及到预单，还需要验证订单号的有效性，订单状态是未支付。为了避免用户缓存某个 URL 地址，还需要校验下单时间和支付时间是否超过预定的间隔 验证签名：签名也是为了防止支付接口被伪造。一般签名是使用分发给商户的 key 来对输入参数拼接成的字符串做 MD5 Hash 或 RSA 加密，然后作为一个参数随其他参数一起提交到服务器端。如支付网关设计所介绍，签名验证也可以在网关中统一完成  2 根据支付路由寻找合适的支付服务：根据用户选择的支付方式确定用来完成该操作的合适的支付渠道  用户指定的支付方式不一定是最终的执行支付的渠道。比如用户选择通过工行信用卡来执行支付，但是我们没有实现和工行的对接，而是可以通过第三方支付，比如支付宝、微信支付、易宝支付，或银联完成 选择合适的支付渠道，通过支付路由实现。支付路由会综合考虑收费、渠道的可用性等因素来选择最优方案  3 评估交易风险：检查本次交易是否有风险。风控接口返回三种结果：阻断交易、增强验证和放行交易  阻断交易：说明该交易是高风险的，需要终止，不执行第 5 个步骤 增强验证：说明该交易有一定的风险，需要确认下是不是用户本人在操作。这可以通过发送短信验证码或者其他可以验证用户身份的方式来做校验，验证通过后，可以继续执行该交易 放行交易，即本次交易是安全的，可以继续往下走  4 生成交易订单：将订单信息持久化到数据库中  当访问压力大的时候，数据库写入会成为一个瓶颈  5 调用支付渠道提供的服务：所有的支付服务都需要第三方通道来完成执行  一般银行渠道的调用比较简单，可以直接返回结果 一些第三方支付，如支付宝，微信支付等，会通过异步接口来告知支付结果  6 更新订单：对于同步返回的结果，需要在主线程中更新订单的状态，标记是支付成功还是失败。对于异步返回的渠道，需要在异步程序中处理 7 发送消息：通过消息来通知相关系统关于订单的变更  风控、信用 BI 等，都需要依赖这数据做准实时计算  8 异步通知  上述流程，其中涉及到调用远程接口，其延迟不可控。如果调用方一直阻塞等待，很容易超时 引入异步通知机制，可以让调用方在主线程中尽快返回，通过异步线程来得到支付结果 对于通过异步来获取支付结果的渠道接口，也需要对应的在异步通知中将结果返回给调用方 异步通知需要调用方提供一个回调地址，一般以 HTTP 或 HTTPS 的方式。这就有技术风险，如果调用失败，还需要重试。而重试不能过于频繁，需要逐步拉大每一次重试的时间间隔 在异步处理程序中，订单根据处理结果变更状态后，也要发消息通知相关系统   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8b848dda1d43427700f49693e358073d","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/6_%E6%94%AF%E4%BB%98%E4%BA%A7%E5%93%81%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/6_%E6%94%AF%E4%BB%98%E4%BA%A7%E5%93%81%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1/","section":"blog","summary":"6.1 前言 6.2 产品分类 6.3 模块功能 6.4 业务流程 6.1 前言 支付产品模块是按照支付场景来为业务方提供支付服务 支付产品模块一般位于支付网关之后，支付渠道之前。根","tags":["o2o"],"title":"6 支付产品服务设计","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  6.1 简介 6.2 Linux 系统用户账号的管理  6.2.1 useradd 添加新的用户账号 6.2.2 userdel 已有的用户账号 6.2.3 usermod 修改已有用户帐号 6.2.4 passwd 指定和修改用户口令  6.3 Linux系统用户组的管理  6.3.1 groupadd 增加一个新的用户组 6.3.2 groupdel 删除一个已有的用户组 6.3.3 groupmod 修改用户组的属性 6.3.4 newgrp 切换用户组  6.4 与用户账号有关的系统文件  6.4.1 /etc/passwd 是用户管理工作涉及的最重要的一个文件 6.4.2 拥有帐户文件 6.4.2.1 /etc/shadow 文件 6.4.2.2 /etc/shadow vs /etc/passwd 6.4.2.3 /etc/group 文件  6.5 添加批量用户  6.5.1 编辑一个文本用户文件 6.5.2 以 root 身份执行命令 /usr/sbin/newusers 6.5.3 执行命令 /usr/sbin/pwunconv 6.5.4 编辑每个用户的密码对照文件 6.5.5 以 root 身份执行命令 /usr/sbin/chpasswd 6.5.6 确定密码经编码写入 /etc/passwd 的密码栏后   6.1 简介  Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护 每个用户账号都拥有一个唯一的用户名和各自的口令 用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录 实现用户账号的管理，要完成的工作主要有如下几个方面  用户账号的添加、删除与修改 用户口令的管理 用户组的管理   6.2 Linux 系统用户账号的管理  用户账号的管理工作主要涉及到用户账号的添加、修改和删除  添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源 刚添加的账号是被锁定的，无法使用   6.2.1 useradd 添加新的用户账号  语法 useradd 选项 用户名 选项  -c comment 指定一段注释性描述 -d 目录 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录 -g 用户组 指定用户所属的用户组 -G 用户组，用户组 指定用户所属的附加组 -s Shell文件 指定用户的登录Shell -u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号  用户名：指定新账号的登录名\n# 创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam(/usr为默认的用户主目录所在的父目录) useradd –d /usr/sam -m sam # 新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组 useradd -s /bin/sh -g group –G adm,root gem # 可能新建组 groupadd group groupadd adm  增加用户账号就是在/etc/passwd为新用户增加一条记录，同时更新其他系统文件如/etc/shadow，/etc/group等\n Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理\n  6.2.2 userdel 已有的用户账号  如果一个用户的账号不再使用，可以从系统中删除 删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录 语法 userdel 选项 用户名 选项\n -r 是把用户的主目录一起删除\n# 删除用户sam在系统文件中(主要是/etc/passwd, /etc/shadow, /etc/group等)的记录，同时删除用户的主目录 userdel -r sam    6.2.3 usermod 修改已有用户帐号  修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等 语法 usermod 选项 用户名 选项\n -c, -d, -m, -g, -G, -s, -u及-o等，意义与useradd命令中的选项一样，可以为用户指定新的资源值 有些系统可以使用选项：-l 新用户名。这个选项指定一个新的账号，即将原来的用户名改为新的用户名\n# 此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer usermod -s /bin/ksh -d /home/z –g developer sam    6.2.4 passwd 指定和修改用户口令  用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令 超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令 语法 passwd 选项 用户名 选项  -l 锁定口令，即禁用账号 -u 口令解锁 -d 使账号无口令 -f 强迫用户下次登录时修改口令  默认用户名，则修改当前用户的口令\n# 假设当前用户是sam，修改该用户自己的口令 $ passwd Old password:****** New password:******* Re-enter new password:******* # 如果是超级用户，可以用下列形式指定任何用户的口令 # passwd sam New password:******* Re-enter new password:******* # 将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令 passwd -d sam # 锁定某一用户，使其不能登录 passwd -l sam  普通用户修改自己的口令时，passwd 命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令\n 为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用 8 位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同\n  6.3 Linux系统用户组的管理  每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理 不同 Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新  6.3.1 groupadd 增加一个新的用户组  格式 groupadd 选项 用户组 选项\n -g GID 指定新用户组的组标识号(GID) -o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同\n# 系统中增加一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1 groupadd group1 # 系统中增加一个新组group2，同时指定新组的组标识号是101 groupadd -g 101 group2    6.3.2 groupdel 删除一个已有的用户组  格式 groupdel 用户组\n# 从系统中删除组group1 groupdel group1   6.3.3 groupmod 修改用户组的属性  格式 groupmod 选项 用户组 选项\n -g GID 为用户组指定新的组标识号。 -o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同 -n 新用户组 将用户组的名字改为新名字\n# 将组group2的组标识号修改为102 groupmod -g 102 group2 # 将组group2的标识号改为10000，组名修改为group3 groupmod –g 10000 -n group3 group2    6.3.4 newgrp 切换用户组  如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限 用户可以在登录后，使用newgrp 目的用户组切换到其他用户组\n# 将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成 newgrp root   6.4 与用户账号有关的系统文件  完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改 与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等  6.4.1 /etc/passwd 是用户管理工作涉及的最重要的一个文件  Linux 系统中每个用户在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性 这个文件对所有用户都是可读的。它的内容类似下面的例子\ncat /etc/passwd root❌0:0:Superuser:/: daemon❌1:1:System daemons:/etc: bin❌2:2:Owner of system commands:/bin: sys❌3:3:Owner of system files:/usr/sys: adm❌4:4:System accounting:/usr/adm: uucp❌5:5:UUCP administrator:/usr/lib/uucp: auth❌7:21:Authentication administrator:/tcb/files/auth: cron❌9:16:Cron daemon:/usr/spool/cron: listen❌37:4:Network daemon:/usr/net/nls: lp❌71:18:Printer administrator:/usr/spool/lp: sam❌200:50:Sam san:/usr/sam:/bin/sh  可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段\n 格式用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 用户名：代表用户账号的字符串 通常长度不超过8个字符，且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符 为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头 口令：一些系统中，存放着加密后的用户口令字 这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患 现在许多 Linux 系统(如SVR4)都使用了 shadow 技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*” 用户标识号：一个整数，系统内部用它来标识用户 一般情况下与用户名一一对应 如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等 通常用户标识号的取值范围是0～65535  0是超级用户root的标识号 1～99由系统保留，作为管理账号 普通用户的标识号从100开始。在Linux系统中，这个界限是500。  组标识号：记录用户所属的用户组。对应着/etc/group文件中的一条记录 注释性描述：记录用户的一些个人情况 例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途 在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出 主目录：用户的起始工作目录 是用户在登录到系统之后所处的目录 大多数系统中，各用户的主目录被组织在同一个特定目录下，而用户主目录的名称就是该用户的登录名 各用户对自己的主目录有读、写、执行(搜索)权限，其他用户对此目录的访问权限则根据具体情况设置 登录Shell：用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序 Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等 系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh 用户的登录Shell也可以指定为某个特定的程序(此程序不是一个命令解释器) 利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中 系统中有一类用户称为伪用户(pseudo users) 这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求 常见的伪用户如下所示  | 伪用户 | 含义 | | bin | 拥有可执行的用户命令文件 | | sys | 拥有系统文件 | | adm | 拥有帐户文件 | | uucp | UUCP使用 | | lp | lp或lpd子系统使用 | | nobody | NFS使用 |\n  6.4.2 拥有帐户文件 6.4.2.1 /etc/shadow 文件  除了上面列出的伪用户外，还有许多标准的伪用户，如audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要 由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性  6.4.2.2 /etc/shadow vs /etc/passwd  /etc/shadow中的记录行与/etc/passwd一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生 文件格式与/etc/passwd类似，由若干个字段组成，字段之间用\u0026rdquo;:\u0026ldquo;隔开 字段有 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志  登录名：与/etc/passwd文件中的登录名相一致的用户账号 口令：存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合{ ./0-9A-Za-z }中的字符，则对应的用户不能登录 最后一次修改时间：表示从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日 最小时间间隔：指两次修改口令之间所需的最小天数 最大时间间隔：指口令保持有效的最大天数 警告时间：表示从系统开始警告用户到用户密码正式失效之间的天数 不活动时间：表示用户没有登录活动但账号仍能保持有效的最大天数 失效时间：是一个绝对天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了  下面是/etc/shadow的一个例子：\ncat /etc/shadow root:Dnakfw28zf38w:8764:0:168:7::: daemon:*::0:0:::: bin:*::0:0:::: sys:*::0:0:::: adm:*::0:0:::: uucp:*::0:0:::: nuucp:*::0:0:::: auth:*::0:0:::: cron:*::0:0:::: listen:*::0:0:::: lp:*::0:0:::: sam:EkdiSECLWPdSa:9740:0:0::::   6.4.2.3 /etc/group 文件  将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段  每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组 当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组 用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员  用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段 字段有 组名:口令:组标识号:组内用户列表  组名：用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复 口令：字段存放的是用户组加密后的口令字。一般 Linux 系统的用户组都没有口令，即这个字段一般为空，或者是* 组标识号：与用户标识号类似，也是一个整数，被系统内部用来标识组 组内用户列表：属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组  /etc/group文件的一个例子\ncat /etc/group root::0:root bin::2:root,bin sys::3:root,uucp adm::4:root,adm daemon::5:root,daemon lp::7:root,lp users::20:root,sam   6.5 添加批量用户  Linux 系统提供了创建大量用户的工具，可以立即创建大量用户，方法如下  6.5.1 编辑一个文本用户文件  每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号 一个范例文件user.txt\nuser001::600:100:user:/home/user001:/bin/bash user002::601:100:user:/home/user002:/bin/bash user003::602:100:user:/home/user003:/bin/bash user004::603:100:user:/home/user004:/bin/bash user005::604:100:user:/home/user005:/bin/bash user006::605:100:user:/home/user006:/bin/bash   6.5.2 以 root 身份执行命令 /usr/sbin/newusers # 从刚创建的用户文件 user.txt 中导入数据，创建用户 newusers \u0026lt; user.txt # 执行命令 vipw 或 vi /etc/passwd 检查 /etc/passwd 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建  6.5.3 执行命令 /usr/sbin/pwunconv # 将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将 /etc/shadow 的 shadow 密码栏删掉 # 这是为了方便下一步的密码转换工作，即先取消 shadow password 功能 pwunconv  6.5.4 编辑每个用户的密码对照文件  范例文件passwd.txt内容\nuser001:密码 user002:密码 user003:密码 user004:密码 user005:密码 user006:密码   6.5.5 以 root 身份执行命令 /usr/sbin/chpasswd # 创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏 chpasswd \u0026lt; passwd.txt  6.5.6 确定密码经编码写入 /etc/passwd 的密码栏后 # 执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow pwconv   这样就完成了大量用户的创建了，之后可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b9641315da1e9c61d6e0b69bb12ac9ff","permalink":"https://xueqing.github.io/blog/linux/6_%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/6_%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/","section":"blog","summary":"6.1 简介 6.2 Linux 系统用户账号的管理 6.2.1 useradd 添加新的用户账号 6.2.2 userdel 已有的用户账号 6.2.3 usermod 修改已有用户帐号 6.2.4 passwd 指定和修改用户口令 6.3 Linux系统用户组的管理 6.3.1 groupadd","tags":["linux"],"title":"6 用户和用户组管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  7.1 支付的典型架构  7.1.1 支付宝 7.1.2 京东金融 7.1.3 去哪儿 7.1.4 美团  7.2 参考架构  7.2.1 支撑系统 7.2.2 支付核心系统 7.2.3 支付服务系统  7.3 支付应用 7.4 参考链接  7.1 支付的典型架构  每个公司根据其业务和公司发展的不同阶段，所设计的支付系统也不同  7.1.1 支付宝  支付宝的支付系统整体架构设计如下  这个整体架构上并没有与众不同之处。在模块划分上，这个图显示的是最顶层的划分，也无法告知更多细节\n 但支付宝架构强点在两个方面\n 账务处理：分为内外两个子系统，外部子系统是单边账，内部子系统走复式记账。不少支付平台是从这里得到启发来搞定的对账系统 柔性事务处理：利用消息机制来实现跨系统的事务处理，避免数据库锁导致的性能问题   7.1.2 京东金融  京东金融是在网银在线的基础上发展起来的。网银在线的原班技术人员有不少来自易宝公司，在京东收购之后，又引入了支付宝的人才。因而从架构上受这两个公司的影响很大 京东支付平台总体架构设计如下   7.1.3 去哪儿  去哪儿公司的支付产品架构如下   7.1.4 美团  美团的支付平台规划架构如下：这是2015年的文档。2016年美团才拿到支付牌照   7.2 参考架构  一般来说，支付系统典型架构会包含如下模块  支付系统从架构上来说，分为三层：  支撑层: 用来支持核心系统的基础软件包和基础设施，包括运维监控系统、日志分析系统等 核心层：支付系统的核心模块，内部又分为支付核心模块以及支付服务模块 产品层：通过核心层提供的服务组合起来，最终对用户、商户、运营管理人员提供的系统   7.2.1 支撑系统  支撑系统是一个公司提供给支付系统运行的基础设施。主要包括如下子系统  运维监控：支付系统在运行过程中不可避免的会受到各种内部和外部的干扰，光纤被挖断、黑客攻击、数据库被误删、上线系统中有 bug 等。运维人员必须在第一时间内对这些意外事件作出响应，又不能够一天 24 小时盯着。这就需要一个运维监控系统来协助完成 日志分析：日志是支付系统统计分析、运维监控的重要依据。公司需要提供基础设施来支持日志统一收集和分析 短信平台：短信在支付系统中有重要作用，包括身份验证、安全登录、找回密码，及报警监控 安全机制：安全是支付的生命线。SSL、证书系统、防刷接口等，都是支付的必要设施 统计报表：支付数据的可视化展示，是公司进行决策的基础  远程连接管理、分布式计算、消息机制、全文检索、文件传输、数据存储、机器学习等，都是构建大型系统所必须的基础软件，这里不再一一详细介绍  7.2.2 支付核心系统  支付核心系统指用户执行支付的核心流程，包括  1 用户从支付应用启动支付流程 2 支付应用根据应用和用户选择的支付工具调用对应的支付产品执行支付 3 支付路由根据支付工具、渠道费率、接口稳定性等因素选择合适的支付渠道来落地支付 4 支付渠道调用银行、第三方支付等渠道提供的接口来执行支付操作，最终落地资金转移   7.2.3 支付服务系统  支持支付核心系统所提供的功能。服务系统又分为基础服务系统、资金系统、风控和信用系统  基础服务系统：提供支撑线上支付系统运行的基础业务功能 客户信息管理：对用户、商户的实名身份、基本信息、协议的管理 卡券管理：对优惠券、代金券、折扣券的制作、发放、使用流程的管理 支付通道管理: 通道接口、配置参数、费用、限额以及 QOS 的管理 账户和账务系统：管理账户信息以及交易流水、记账凭证等。这里的账务一般指对接线上系统的账务，采用单边账的记账方式。内部账记录在会计核算系统中 订单系统：一般订单系统可独立于业务系统实现。这里的订单主要指支付订单 资金系统：围绕财务会计而产生的后台资金核实、调度和管理的系统，包括 会计核算：提供会计科目、内部账务、试算平衡、日切、流水登记、核算和归档 资金管理：管理公司在各个支付渠道的头寸，在余额不足时进行打款。对第三方支付公司，还需要对备付金进行管理 清算分润：对于有分润需求的业务，还需要提供清分清算、对账处理和计费分润功能 风控系统：支付系统必备的基础功能，所有的支付行为必须做风险评估并采取对应的措施 信用系统：在风控基础上发展的高级功能，京东白条，蚂蚁花呗等都是成功的案例   7.3 支付应用  支撑系统、核心系统和服务系统，在每个公司的架构上应该是大同小异的，都是必不可少的模块 支付应用是每个公司根据自己的业务来构建的，各不相同。总的来说，可以按照使用对象分为针对最终用户的应用、针对商户的应用、针对运营人员的运营管理、BI 和风控后台  7.4 参考链接  最全最强解析：支付宝钱包系统架构内部剖析（架构图） 京东：支付平台总体架构设计图 美团支付平台产品规划  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c821bd7a1c36c832fa70bf8818c820d8","permalink":"https://xueqing.github.io/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/7_%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F/7_%E6%94%AF%E4%BB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/","section":"blog","summary":"7.1 支付的典型架构 7.1.1 支付宝 7.1.2 京东金融 7.1.3 去哪儿 7.1.4 美团 7.2 参考架构 7.2.1 支撑系统 7.2.2 支付核心系统 7.2.3 支付服务系统 7.3 支付应用 7.4 参考链接 7.1 支付的典型架构 每个公司","tags":["o2o"],"title":"7 支付系统的整体架构","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  7.1 磁盘管理命令  7.1.1 df 7.1.2 du 7.1.3 fdisk 7.1.4 mkfs  7.2 磁盘检验 7.3 磁盘挂载与卸除 7.4 使用文件系统组织磁盘存储和数据管理的必要性  7.1 磁盘管理命令  Linux 磁盘管理好坏直接关系到整个系统的性能问题 Linux 磁盘管理常用三个命令为df、du和fdisk  df：列出文件系统的整体磁盘使用量 du：检查磁盘空间使用量 fdisk：用于磁盘分区 mkfs：磁盘格式化   7.1.1 df  df：检查文件系统的磁盘空间占用情况 可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息 语法 df [-ahikHTm] [目录或文件名] 选项与参数\n -a：列出所有的文件系统，包括系统特有的 /proc 等文件系统 -k：以 KBytes 的容量显示各文件系统 -m：以 MBytes 的容量显示各文件系统 -h：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示 -H：以 M=1000K 取代 M=1024K 的进位方式 -T：显示文件系统类型, 连同该 partition 的 filesystem 名称(如 ext3)也列出 -i：不用硬盘容量，而以 inode 的数量来显示\n# 将系统内所有的文件系统列出来！ [root@www ~]# df Filesystem 1K-blocks Used Available Use% Mounted on /dev/hdc2 9920624 3823112 5585444 41% / /dev/hdc3 4956316 141376 4559108 4% /home /dev/hdc1 101086 11126 84741 12% /boot tmpfs 371332 0 371332 0% /dev/shm # 没有加任何选项，默认将系统内所有(不含特殊内存内的文件系统与 swap)以 1 Kbytes 容量列出来 # 将容量结果以易读的容量格式显示出来 [root@www ~]# df -h Filesystem Size Used Avail Use% Mounted on /dev/hdc2 9.5G 3.7G 5.4G 41% / /dev/hdc3 4.8G 139M 4.4G 4% /home /dev/hdc1 99M 11M 83M 12% /boot tmpfs 363M 0 363M 0% /dev/shm # 将系统内的所有特殊文件格式及名称都列出来 [root@www ~]# df -aT Filesystem Type 1K-blocks Used Available Use% Mounted on /dev/hdc2 ext3 9920624 3823112 5585444 41% / proc proc 0 0 0 - /proc sysfs sysfs 0 0 0 - /sys devpts devpts 0 0 0 - /dev/pts /dev/hdc3 ext3 4956316 141376 4559108 4% /home /dev/hdc1 ext3 101086 11126 84741 12% /boot tmpfs tmpfs 371332 0 371332 0% /dev/shm none binfmt_misc 0 0 0 - /proc/sys/fs/binfmt_misc sunrpc rpc_pipefs 0 0 0 - /var/lib/nfs/rpc_pipefs # 将 /etc 下的可用的磁盘容量以易读的容量格式显示 [root@www ~]# df -h /etc Filesystem Size Used Avail Use% Mounted on /dev/hdc2 9.5G 3.7G 5.4G 41% /    7.1.2 du  du：查看使用空间 与 df 命令不同：du 命令是对文件和目录磁盘使用的空间的查看，df 检查文件系统的磁盘空间占用情况 与 df 不一样的是，du 会直接到文件系统内去搜寻所有的文件数据 语法 du [-ahskm] 文件或目录名称 选项与参数\n -a：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已 -h：以人们较易读的容量格式 (G/M) 显示 -s：列出总量而已，而不列出每个各别的目录占用容量 -S：不包括子目录下的总计，与 -s 有点差别 -k：以 KBytes 列出容量显示 -m：以 MBytes 列出容量显示\n# 列出当前目录下的所有文件容量，包括隐藏文件的目录 # 当前目录(.)所占用的总量 [root@www ~]# du 8 ./test4 8 ./test2 12 ./.gconfd 220 . # 没有加任何选项时，du 会分析当前所在目录的文件与目录所占用的硬盘空间 # 将文件的容量也列出来 [root@www ~]# du -a 12 ./install.log.syslog 8 ./.bash_logout 8 ./test4 8 ./test2 12 ./.gconfd 220 . # 检查根目录下每个目录所占用的容量 # 通配符 * 代表每个目录 [root@www ~]# du -sm /* 7 /bin 6 /boot 0 /proc 1 /tmp 3859 /usr 77 /var    7.1.3 fdisk  fdisk：磁盘分区表操作工具 语法 fdisk [-l] 装置名称 选项与参数\n -l：输出后面接的装置所有的分区内容 若仅有fdisk -l时， 系统将会把整个系统内能够搜寻到的装置的分区均列出来\n# 列出所有分区信息 [root@AY120919111755c246621 tmp]# fdisk -l Disk /dev/xvda: 21.5 GB, 21474836480 bytes 255 heads, 63 sectors/track, 2610 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x00000000 Device Boot Start End Blocks Id System /dev/xvda1 * 1 2550 20480000 83 Linux /dev/xvda2 2550 2611 490496 82 Linux swap / Solaris Disk /dev/xvdb: 21.5 GB, 21474836480 bytes 255 heads, 63 sectors/track, 2610 cylinders Units = cylinders of 16065 * 512 = 8225280 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disk identifier: 0x56f40944 Device Boot Start End Blocks Id System /dev/xvdb2 1 2610 20964793+ 83 Linux # 找出系统中的根目录所在磁盘，并查阅该硬盘内的相关信息。重点在找出磁盘文件名 [root@www ~]# df / Filesystem 1K-blocks Used Available Use% Mounted on /dev/hdc2 9920624 3823168 5585388 41% / # 不要加上数字 [root@www ~]# fdisk /dev/hdc The number of cylinders for this disk is set to 5005. There is nothing wrong with that, but this is larger than 1024, and could in certain setups cause problems with: 1) software that runs at boot time (e.g., old versions of LILO) 2) booting and partitioning software from other OSs (e.g., DOS FDISK, OS/2 FDISK) # 输入 m 后，就会看到命令介绍 Command (m for help): # 离开 fdisk 时按下 q，那么所有动作都不会生效。相反的， 按下 w 就是动作生效 # 使用 p 可以列出目前这颗磁盘的分割表信息，这个信息的上半部显示整体磁盘的状态 Command (m for help): p # 这个磁盘的文件名与容量 Disk /dev/hdc: 41.1 GB, 41174138880 bytes # 磁头、扇区与磁柱大小 255 heads, 63 sectors/track, 5005 cylinders # 每个磁柱的大小 Units = cylinders of 16065 * 512 = 8225280 bytes # 装置文件名 启动区否 开始磁柱 结束磁柱 1K大小容量 磁盘分区槽内的系统 Device Boot Start End Blocks Id System /dev/hdc1 * 1 13 104391 83 Linux /dev/hdc2 14 1288 10241437+ 83 Linux /dev/hdc3 1289 1925 5116702+ 83 Linux /dev/hdc4 1926 5005 24740100 5 Extended /dev/hdc5 1926 2052 1020096 82 Linux swap / Solaris # 想要不储存离开按下 q Command (m for help): q    7.1.4 mkfs  磁盘分割完毕后自然就是要进行文件系统的格式化 语法 mkfs [-t 文件系统格式] 装置文件名 选项与参数\n -t：可以接文件系统格式，如 ext3, ext2, vfat 等(系统有支持才会生效)\n# 查看 mkfs 支持的文件格式 # 按下两个[tab]，会发现 mkfs 支持的文件格式 [root@www ~]# mkfs[tab][tab] mkfs mkfs.cramfs mkfs.ext2 mkfs.ext3 mkfs.msdos mkfs.vfat # 将分区 /dev/hdc6(可指定你自己的分区)格式化为 ext3 文件系统 [root@www ~]# mkfs -t ext3 /dev/hdc6 mke2fs 1.39 (29-May-2006) # 指的是分割槽的名称(label) Filesystem label= OS type: Linux # block 的大小配置为 4K Block size=4096 (log=2) Fragment size=4096 (log=2) # 由此配置决定的inode/block数量 251392 inodes, 502023 blocks 25101 blocks (5.00%) reserved for the super user First data block=0 Maximum filesystem blocks=515899392 16 block groups 32768 blocks per group, 32768 fragments per group 15712 inodes per group Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912 Writing inode tables: done # 有日志记录 Creating journal (8192 blocks): done Writing superblocks and filesystem accounting information: done This filesystem will be automatically checked every 34 mounts or 180 days, whichever comes first. Use tune2fs -c or -i to override. # 这样就创建起来 Ext3 文件系统了    7.2 磁盘检验  fsck（file system check）用来检查和维护不一致的文件系统 若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查 语法 fsck [-t 文件系统] [-ACay] 装置名称 选项与参数\n -t: 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数 -s: 依序一个一个地执行 fsck 的指令来检查 -A: 对/etc/fstab 中所有列出来的分区（partition）做检查 -C: 显示完整的检查进度 -d: 打印出 e2fsck 的 debug 结果 -p: 同时有 -A 条件时，同时有多个 fsck 的检查一起执行 -R: 同时有 -A 条件时，省略 / 不检查 -V: 详细显示模式 -a: 如果检查有错则自动修复 -r: 如果检查有错则由使用者回答是否修复 -y: 指定检测每个文件自动输入yes，在不确定哪些是不正常的时候，可以执行fsck -y全部检查修复\n# 查看系统有多少文件系统支持的 fsck 命令 [root@www ~]# fsck[tab][tab] fsck fsck.cramfs fsck.ext2 fsck.ext3 fsck.msdos fsck.vfat # 强制检测 /dev/hdc6 分区 [root@www ~]# fsck -C -f -t ext3 /dev/hdc6 fsck 1.39 (29-May-2006) e2fsck 1.39 (29-May-2006) Pass 1: Checking inodes, blocks, and sizes Pass 2: Checking directory structure Pass 3: Checking directory connectivity Pass 4: Checking reference counts Pass 5: Checking group summary information vbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks # 如果没有 -f，则由于这个文件系统不曾出现问题，检查的经过非常快速 # 若加上 -f 强制检查，才会一项一项的显示过程    7.3 磁盘挂载与卸除  Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令 磁盘挂载语法 mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点\n# 用默认方式，将刚刚创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面 [root@www ~]# mkdir /mnt/hdc6 [root@www ~]# mount /dev/hdc6 /mnt/hdc6 [root@www ~]# df Filesystem 1K-blocks Used Available Use% Mounted on /dev/hdc6 1976312 42072 1833836 3% /mnt/hdc6  磁盘卸载命令 umount 语法 umount [-fn] 装置文件名或挂载点\n 选项与参数\n -f：强制卸除。可用在类似网络文件系统(NFS)无法读取到的情况下 -n：不升级 /etc/mtab 情况下卸除\n# 卸载/dev/hdc6 [root@www ~]# umount /dev/hdc6    7.4 使用文件系统组织磁盘存储和数据管理的必要性  使用文件系统是和使用裸设备相对而言的。裸设备是一种没有格式化的磁盘或磁盘分区，也就是让操作系统或者程序直接操作磁盘设备 文件系统是操作系统和磁盘之间的一个桥梁，因此对磁盘的任何写操作，都要经过文件系统，然后才到磁盘 通过文件系统的方式来组织磁盘存储和数据管理。优点  数据的读取、管理操作变得简单：文件系统给用户提供了一个简单的操作界面，用户可以通过对文件系统的简单操作，实现对磁盘的管理。虽然 Linux 系统下也可以直接使用裸设备，但是在读取性能上，裸设备并不比文件系统能高出多少，同时还造成了管理与维护的麻烦，普通用户是无法接受的 磁盘分区管理灵活：在文件系统下提供了很多的磁盘分区管理工具(如 LVM)，通过这些工具可以灵活地对磁盘分区进行大小的修改，而在裸设备下，必须预先规划好磁盘空间，可能造成空间的不足或者浪费 支持数据容错机制，数据安全能得到保障：一个好的文件系统提供了对于数据读取和写入的各种容错和保护机制，很好地保障了数据的安全，而裸设备没有这种灵活的管理机制，对于数据安全只能通过手工的备份方式来实现  缺点：在大量写操作下，文件系统本身也会产生开销，例如对元数据的维护、文件系统缓存等，这个桥梁就成了一个障碍。不过，现在很多类型的文件系统都在做写入性能的改进，因而相对于文件系统提供的这些优点，缺点基本可以忽略  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9753857b13323d2608ae6d1706e2b93d","permalink":"https://xueqing.github.io/blog/linux/7_%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/7_%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/","section":"blog","summary":"7.1 磁盘管理命令 7.1.1 df 7.1.2 du 7.1.3 fdisk 7.1.4 mkfs 7.2 磁盘检验 7.3 磁盘挂载与卸除 7.4 使用文件系统组织磁盘存储和数据管理的必要性 7.1 磁盘管理命令 Linux 磁盘管理好坏直接关系到整","tags":["linux"],"title":"7 磁盘管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0de98e844b54b83a77a068db78f91a4f","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/7-design-and-implementation/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/7-design-and-implementation/","section":"blog","summary":"","tags":["sa","engineer"],"title":"7 设计与实现","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  7.1 参与者 7.2 计划的先决条件 7.3 计划流程 7.4 速度计算 7.5 任务容量 7.6 计划步骤  迭代计划的目的是为了完成优先级高的产品需求列表项。承诺是基于迭代时间和团队速度的时间盒\n7.1 参与者  流程管理者：敏捷交付团队的引导者 产品负责人：处理产品需求列表及其验收标准的详细的看法 敏捷团队：敏捷交付定义他们的任务，并设置完成承诺所需的努力评估  7.2 计划的先决条件  产品需求列表项有大小，且指定了相关的故事点 产品负责人条目集合排好序 每个条目有清晰描述的验收标准  7.3 计划流程  确定一个迭代包含的故事 划分这些故事成任务，并分配每个任务给对应的负责人 每个任务按小时评估 这些评估帮助团队成员检查每个成员对于这此迭代的任务时 根据团队成员的速度分配任务，以便他们不会负担过重  7.4 速度计算  敏捷团队基于过去的迭代计算速度 速度是迭代中所需的平均数字单位以便完成用户故事  比如，一个团队在过去的三个迭代中分别用12，14，10个故事点，这个团队下次迭代的速度是 12  计划的速度高速团队可以在当前迭代完成多少用户故事。如果团队快速完成分配的任务，那么可以加入更多的用户故事。否则，可在下次迭代移除一些故事  7.5 任务容量  一个团队的容量从下面三个因素考量  每天理想的工作小时 这次迭代中成员可用的天数 一个成员在此团队中不可用的时间百分比  假设一个团队 5 个成员，承诺为一个项目满时工作(每天 8 小时)，且没有人在迭代中离开，那么一个两周迭代的任务容量是 5*8*10=400 小时  7.6 计划步骤  产品负责人描述产品需求列表排序最高的条目 团队描述完成条目需要的任务 团队成员负责任务 团队成员估计完成每个任务的时间 在迭代中重复上述步骤 如果有人任务过多，将任务分给其他团队成员  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"886640033a8007816e7621437853cb6e","permalink":"https://xueqing.github.io/translation/agile/tutorial/7-iteration-planning/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/7-iteration-planning/","section":"translation","summary":"7.1 参与者 7.2 计划的先决条件 7.3 计划流程 7.4 速度计算 7.5 任务容量 7.6 计划步骤 迭代计划的目的是为了完成优先级高的产品需求列表项。承诺是基于迭代时间和团队速","tags":["agile"],"title":"7 迭代计划","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  8.1 产品需求列表的重要性 8.2 产品需求列表的特点\n 一个产品需求列表是将要做的条目的列表。条目具有特性描述，被排好序\n 在理想的场景中，条目应划分成用户故事\n  8.1 产品需求列表的重要性  准备好产品需求列表，以便可以评估每个特性 帮助计划产品蓝图 帮助对特性重排序，以便产品具有更多价值 帮助确定需要优先处理的事情。团队对条目排序并建立值  8.2 产品需求列表的特点  每个产品应该有一个产品需求列表，具有很多大的特性 多个团队可以为一个产品需求列表工作 特性排序基于业务价值、技术值、风险管理或策略调整排序 在发布计划中将优先级高的条目分解成小的故事，以便可以在未来的迭代中完成它们  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"97e1ab3fc2857903e12c25b6abf11201","permalink":"https://xueqing.github.io/translation/agile/tutorial/8-product-backlog/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/8-product-backlog/","section":"translation","summary":"8.1 产品需求列表的重要性 8.2 产品需求列表的特点 一个产品需求列表是将要做的条目的列表。条目具有特性描述，被排好序 在理想的场景中，条目应划分成用户故","tags":["agile"],"title":"8 产品需求列表","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  概念 命令  tar tar 命令做打包操作 tar 命令做解打包操作 tar 命令做打包压缩(解压缩解打包)操作 zip unzip gzip gunzip bzip2 bunzip2   概念  打包：也称为归档，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和 压缩：指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示  有损压缩：指即便丢失个别的数据，对文件也不会造成太大的影响。广泛应用于动画、声音和图像文件中，典型代表就是影碟文件格式 mpeg、音乐文件格式 mp3 以及图像文件格式 jpg 无损压缩：指压缩数据必须准确无误  压缩包：采用压缩工具对文件进行压缩，生成的文件。该文件的体积通常只有原文件的一半甚至更小 解压：压缩包中的数据无法直接使用，使用前需要利用压缩工具将文件数据还原的过程称为解压缩  命令  常用的归档命令：tar 和 dd(相对而言，tar 的使用更为广泛) 常用的压缩命令：如 tar、gzip、zip、bzip2 等  tar  tar 可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。使用 tar 命令归档的包通常称为 tar 包(tar 包文件都是以 .tar 结尾) tar 还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包  tar 命令做打包操作  语法 tar [选项] 源文件或目录 选项与参数  -c：将多个文件或目录进行打包 -A：追加 tar 文件到归档文件 -f 包名：指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名 -v：显示打包文件过程  在使用 tar 命令指定选项时可以不在选项前面输入 \u0026ldquo;-\u0026rdquo; 选项 \u0026ldquo;-cvf\u0026rdquo; 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 \u0026ldquo;.tar\u0026rdquo; 作为扩展名 打包并压缩目录。压缩命令不能直接压缩目录，必须先用 tar 命令将目录打包，然后才能用 gzip 命令或 bzip2 命令对打包文件进行压缩  tar 命令做解打包操作  语法 tar [选项] 压缩包 选项与参数  -x：对 tar 包做解打包操作 -f 包名：指定要解压的 tar 包的包名 -t：只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作 -C 目录：指定解打包位置 -v：显示解打包的具体过程  习惯使用 \u0026ldquo;-xvf\u0026rdquo; 选项，会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用 \u0026ldquo;-C(大写)\u0026rdquo; 选项 只想查看文件包中有哪些文件，则可以把解打包选项 \u0026ldquo;-x\u0026rdquo; 更换为测试选项 \u0026ldquo;-t\u0026rdquo;  tar 命令做打包压缩(解压缩解打包)操作  语法 tar [选项] 压缩包 源文件或目录 选项与参数  -z：压缩和解压缩 \u0026ldquo;.tar.gz\u0026rdquo; 格式，习惯使用 \u0026ldquo;-zcvf\u0026rdquo; 和 \u0026ldquo;-zxvf\u0026rdquo; -j：压缩和解压缩 \u0026ldquo;.tar.bz2\u0026rdquo;格式，习惯使用 \u0026ldquo;-jcvf\u0026rdquo; 和 \u0026ldquo;-jxvf\u0026rdquo;   zip  \u0026rdquo;.zip\u0026rdquo; 格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式(zip、rar等)之一，是一种相当简单的分别压缩每个文件的存储格式 语法 zip [选项] 压缩包名 源文件或源目录列表  zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用  选项与参数  -r：递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩 -m：将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中 -v：显示详细的压缩过程信息 -q：在压缩的时候不显示命令的执行过程 -压缩级别：压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好 -u：更新压缩文件，即往压缩文件中添加新文件   unzip  unzip 命令可以查看和解压缩 zip 文件 语法 unzip [选项] 压缩包名 选项与参数  -d 目录名：将压缩文件解压到指定目录下 -n：解压时并不覆盖已经存在的文件 -o：解压时覆盖已经存在的文件，并且无需用户确认 -v：查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作 -t：测试压缩文件有无损坏，但并不解压 -x 文件列表：解压文件，但不包含文件列表中指定的文件   gzip  gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为 “.gz” gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件，即对目录内每个文件执行 gzip 命令 语法 gzip [选项] 源文件  命令中的源文件，当进行压缩操作时，指的是普通文件；当进行解压缩操作时，指的是压缩文件 不带参数时，默认将源文件压缩，生成压缩文件，不会保留源文件  选项与参数\n -c：将压缩数据输出到标准输出中，并保留源文件 -d：对压缩文件进行解压缩 -r：递归压缩指定目录下以及子目录下的所有文件 -v：对于每个压缩和解压缩的文件，显示相应的文件名和压缩比 -l：对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称 -数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6\n# 保留源文件压缩 [root@localhost ~]# gzip -c anaconda-ks.cfg \u0026gt;anaconda-ks.cfg.gz # 使用-c，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件，这样可以压缩文件的同时不删除源文件 [root@localhost ~]# ls anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog    gunzip  用于解压被 gzip 压缩过的文件(扩展名为 “.gz”) 对于解压被 gzip 压缩过的文件，还可以使用 gzip 命令，即 gzip -d 压缩包 语法 gunzip [选项] 文件 选项与参数  -r 目录名：递归处理，解压缩指定目录下以及子目录下的所有文件 -c：把解压缩后的文件输出到标准输出设备 -f：强制解压缩文件，不理会文件是否已存在等情况 -l：列出压缩文件内容 -v：显示命令执行过程 -t：测试压缩文件是否正常，但不对其做解压缩操作  如果压缩的是一个纯文本文件，则可以直接使用 zcat 命令在不解压缩的情况下查看这个文本文件中的内容  bzip2  同 gzip 命令类似，只能对文件进行压缩(或解压缩)，对于目录只能压缩(或解压缩)该目录及子目录下的所有文件。当执行压缩任务完成后，会生成一个以 “.bz2” 为后缀的压缩包 从理论上来讲，\u0026rdquo;.bz2\u0026rdquo;格式的算法更先进、压缩比更好；而 \u0026ldquo;.gz\u0026rdquo;格式相对来讲的时间更快 语法 bzip2 [选项] 源文件  源文件指的要压缩或解压缩的文件  选项与参数  -d：执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件 -k：bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项 -f：bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件 -t：测试压缩包文件的完整性 -v：压缩或解压缩文件时，显示详细信息 -数字：这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高  gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项  bunzip2  要解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 bunzip2 命令只能用于解压文件，即便解压目录，也是解压该目录以及所含子目录下的所有文件 语法 bunzip2 [选项] 源文件 选项与参数  -k：解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数 -f：解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项 -v：显示命令执行过程 -L：列出压缩文件内容  \u0026rdquo;.bz2\u0026rdquo; 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 bzcat  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3ee3e2b8d5f6fb1320437ca79c9cf6a9","permalink":"https://xueqing.github.io/blog/linux/8_%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/linux/8_%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/","section":"blog","summary":"概念 命令 tar tar 命令做打包操作 tar 命令做解打包操作 tar 命令做打包压缩(解压缩解打包)操作 zip unzip gzip gunzip bzip2 bunzip2 概念 打包：也称为归档，指的是一个文件或目录的集合","tags":["linux"],"title":"8 打包(归档)和压缩","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"44f252b59aa1d19c50867b6a52081afa","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/8-software-testing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/8-software-testing/","section":"blog","summary":"","tags":["sa","engineer"],"title":"8 软件测试","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":" 验收标准 Acceptance Criteria：由产品负责人或客户设置的条件，为了验收一个特性时有效的且和他们的需求一致 列表修整 Backlog Grooming：一个持续的过程，是产品管理者或客户通过从敏捷团队获取反馈管理产品需求列表。包含条目项的排序、分解条目项成更小的条目、规划未来的迭代、创建新的故事、更小验收标准和消息描述验收标准 容量 Capacity：一个迭代中团队可以完成的工作 特性 Feature：对于产品的一个改进，或对利益相关者价值的兼容，在一个发布中开发 迭代 Iteration：基于主题的工作项可在一个时间盒完成，并在产品的一个迭代中验收。迭代工作由迭代计划定义，结果是一个 demo 和评审会议。也叫做 Sprint 增量 Increment：一个增量是逐渐开发的产品变化的状态。通常展示为里程碑或固定的迭代数 产品负责人 Product Owner：敏捷交付团队的一名成员，负责收集和排序产品需求列表中的业务需求。一个产品负责人沟通一个发布或迭代中要做的工作。产品负责人设置成活，并负责保护团队在一个迭代中需求不被改变 产品需求列表 Product Backlog：功能性和非功能性的产品需求的集合 产品需求列表项 Product Backlog Items：可以是用户故事、故障、特性，由敏捷团队开发 点 Points：一个通用单位，用以设置用户故事、特性或其他条目的相对大小 发布 Release：在一个时间箱中，完成工作以支持一个软件的可测试的增量交付。在一个 Scrum 中，一个发布由多个迭代组成 需求 Requirement：软件产品的规格说明，用于满足规定的合同或功能。用户故事和条目项是需求类型 故事点 Story Points：敏捷团队用于评估用户故事和特性的相对大小的单位 冲刺 Sprint：同迭代 时间箱 Timebox：一个固定的持续时间，在这期间开发出一个可交付产品。通常，伴随固定的开始和结束时间，资源的数目也是固定的 任务 Task：在迭代中，对于一个用户故事有共享的工作的单位。用户故事被分解成多个任务，且每个任务被分给团队成员作为任务负责人。团队成员可为每个任务负责，更新评估，记录已完成和要做的工作日志 用户故事 User Story：一个列举的验收标准用于实现用户的一些需求。通常从一个终端用户的角度写 速度 Velocity：度量迭代或时间箱的验收工作。通常是迭代中验收的故事点的总和  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"84b042822c16e29e28051ae44abf3b69","permalink":"https://xueqing.github.io/translation/agile/tutorial/9-useful-terms/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/agile/tutorial/9-useful-terms/","section":"translation","summary":"验收标准 Acceptance Criteria：由产品负责人或客户设置的条件，为了验收一个特性时有效的且和他们的需求一致 列表修整 Backlog Grooming：一个持续的过","tags":["agile"],"title":"9 有用的术语","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"bda9e58939c62f8ed276e2c88d6680cf","permalink":"https://xueqing.github.io/blog/software_architecture/software_engineering/9-software-evolution/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/software_architecture/software_engineering/9-software-evolution/","section":"blog","summary":"","tags":["sa","engineer"],"title":"9 软件进化","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 Authentication 证明，身份验证 2 Authorization 授权 3 Encryption 加密 4 参考  1 Authentication 证明，身份验证  服务器使用身份验证：当服务器需要知道谁在访问信息或网站 客户端使用身份验证：当客户端需要知道服务器是其所声明的系统 在身份验证中，用户或极端及需要向服务器或客户端证明它的身份 通常，服务器的身份验证需要用户名和密码。其他的身份验证方式可以通过卡片、视网膜扫描、语音识别、指纹等 通常，客户端的身份验证是服务器给客户端一个证书，且证书中第三方可信机构声明服务器是客户端所期望的实体 身份认证不判断个人可以做的任务或者个人可以看到的文件。身份认证只是识别和认证个人或系统  2 Authorization 授权  授权是服务器确定客户端是否有权限使用一个资源或访问一个文件的过程 授权通常和身份认证一起，以便于服务器识别正在请求访问的客户端身份 授权要求的身份认证类型可能不同：某些情况可能需要密码，某些情况可能不需要密码 在某些情况下，没有授权：任何用户可以使用一个资源或访问一个文件。网络上大部分网页不要求任何身份认证或授权  3 Encryption 加密  加密包括转换数据的过程，以使得没有解密密钥的人不可读 SSH 和 SSL 协议通常用户加密流程 SSL 业务中，客户端(浏览器)和服务器(web 服务)之间所有的数据在发送到对方之前都会加密 SSH 会话中，客户端和服务器之间的数据都会加密 通过加密客户端和服务器之间的交互数据，使得网络传输过程中被拦截的风险降低  4 参考  Understanding Authentication, Authorization, and Encryption  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"56abc6f1cf61ca5d127e28b546357575","permalink":"https://xueqing.github.io/blog/sip/authentication_authorization/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/authentication_authorization/","section":"blog","summary":"1 Authentication 证明，身份验证 2 Authorization 授权 3 Encryption 加密 4 参考 1 Authentication 证明，身份验证 服务器使用身份验证：当服务器需要知道谁在访问信息或网站 客户端使用身份验证：当客户端","tags":["sip"],"title":"Authentication vs Authorization","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  auto_ptr unique_ptr shared_ptr weak_ptr reference  auto_ptr  C++11 已经弃用。unique_ptr是新的具有相似功能的智能指针，但是安全性更高。 auto_ptr是管理对象的指针，通过new的操作创建，当auto_ptr销毁的时候会删除该对象。 一个用auto_ptr存储了一个指针指向一个被分配的对象，确保当代码运行到指针的范围之外时，指针指向的对象会自动销毁。 auto_ptr基于独有的所有权模型(exclusive ownership model)，也就是说，两个相同类型的指针不能同时指向同一个资源。复制或者赋值给指针会改变所有权，即源指针会把所有权移交给目的指针。 下面的代码可以看出复制指针的时候所有权的转移\n// C++ program to illustrate the use of auto_ptr #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class A { public: void show() { cout \u0026lt;\u0026lt; \u0026quot;A::show()\u0026quot; \u0026lt;\u0026lt; endl; } }; int main() { // p1 is an auto_ptr of type A auto_ptr\u0026lt;A\u0026gt; p1(new A); p1-\u0026gt;show(); // returns the memory address of p1 cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; // copy constructor called, this makes p1 empty. auto_ptr \u0026lt;A\u0026gt; p2(p1); p2-\u0026gt;show(); // p1 is empty now cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; // p1 gets copied in p2 cout\u0026lt;\u0026lt; p2.get() \u0026lt;\u0026lt; endl; return 0; }  输出结果如下\nA::show() 0x1b42c20 A::show() 0 // NULL 0x1b42c20  auto_ptr的拷贝构造函数和赋值运算符实际上不会拷贝存储的指针，而是转移指针，从而使得源指针为空。auto_ptr实现了严格的所有权管理，使得同一时刻只有一个auto_ptr对象可以拥有该指针。\n 丢弃auto_ptr的原因：auto_ptr的赋值运算转移所有权，并且重置右值的auto_ptr为空指针。因此，auto_ptr不能用于 STL 容器。\n  unique_ptr  unique_ptr是 C++11 开发用于替换std::auto_ptr的。 unique_ptr具有更好的安全性(没有“虚假”的拷贝赋值)，增加了特性(删除器)，支持数组。它是一个保存原始指针的容器。unique_ptr显式地避免持有的指针拷贝赋值，它只允许指针有一个持有者。所以对于一个资源，至多只有一个unique_ptr指向，当unique_ptr销毁时，资源会自动释放。 对unique_ptr拷贝赋值会导致编译错误。比如下面的代码：\nunique_ptr\u0026lt;A\u0026gt; ptr1 (new A); unique_ptr\u0026lt;A\u0026gt; ptr2 = ptr1; // Error: can't copy unique_ptr  可以使用std::move()语法转移持有指针的所有权给另外一个unique_ptr。unique_ptr\u0026lt;A\u0026gt; ptr2 = move(ptr1);\n 下面的代码阐述了unique_ptr的使用\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; class A { public: void show() { cout \u0026lt;\u0026lt; \u0026quot;A::show()\u0026quot; \u0026lt;\u0026lt; endl; } }; int main() { unique_ptr\u0026lt;A\u0026gt; p1(new A); p1-\u0026gt;show(); // returns the memory address of p1 cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; // transfers ownership to p2 unique_ptr\u0026lt;A\u0026gt; p2 = move(p1); p2-\u0026gt;show(); cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p2.get() \u0026lt;\u0026lt; endl; // transfers ownership to p3 unique_ptr\u0026lt;A\u0026gt; p3 = move (p2); p3-\u0026gt;show(); cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p2.get() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p3.get() \u0026lt;\u0026lt; endl; return 0; }   输出结果如下：\nA::show() 0x1c4ac20 A::show() 0 // NULL 0x1c4ac20 A::show() 0 // NULL 0 // NULL 0x1c4ac20   下面的代码返回一个资源，如果我们不显式的接收返回值，资源会被清理。反之，我们会得到对该资源的唯一所有权。因此，可以认为unique_ptr比auto_ptr更安全。\nunique_ptr\u0026lt;A\u0026gt; fun() { unique_ptr\u0026lt;A\u0026gt; ptr(new A); // do something return ptr; }   shared_ptr  shared_ptr是一个保存原始指针的容器。它是引用计数所有权模型(reference counting ownership model)。shared_ptr维护了持有指针的引用计数以及所有对shared_ptr的拷贝。因此，当一个新的指针指向资源的时候计数增加，当指针析构的时候计数减少。 引用计数(reference counting)：是一种存储对于一个资源(比如对象，内存块，磁盘空间或者其他资源)的引用、指针或者句柄的数目的技术。 当代码执行到指向资源的所有shared_ptr的范围之外，资源才会销毁释放。 下面的代码阐述了shared_ptr的使用\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;memory\u0026gt; using namespace std; class A { public: void show() { cout \u0026lt;\u0026lt; \u0026quot;A::show()\u0026quot; \u0026lt;\u0026lt; endl; } }; int main() { shared_ptr\u0026lt;A\u0026gt; p1(new A); cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; p1-\u0026gt;show(); shared_ptr\u0026lt;A\u0026gt; p2(p1); p2-\u0026gt;show(); cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p2.get() \u0026lt;\u0026lt; endl; // Returns the number of shared_ptr objects referring to the same managed object. cout \u0026lt;\u0026lt; p1.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p2.use_count() \u0026lt;\u0026lt; endl; // Relinquishes ownership of p1 on the object and pointer becomes NULL p1.reset(); cout \u0026lt;\u0026lt; p1.get() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p2.use_count() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p2.get() \u0026lt;\u0026lt; endl; return 0; }   输出结果如下：\n0x1c41c20 A::show() A::show() 0x1c41c20 0x1c41c20 2 2 0 // NULL 1 0x1c41c20    weak_ptr  weak_ptr是shared_ptr的拷贝。它可以访问被一个或多个shared_ptr实例持有的对象，但是不参与引用计数。weak_ptr的存在或销毁对shared_ptr及其拷贝没有影响。weak_ptr对于打破shared_ptr实例之间的循环引用必不可少。 相互依赖(Cyclic Dependency,shared_ptr存在的问题)：考虑一个场景，类 A 和类 B，二者都有指针指向另外一个类。因此，如果有两个shared_ptr的指针ptr_A和ptr_B分别指向 A 和 B的某个对象，总是ptr_A持有 B 的对象而且ptr_B持有 A 的对象。A 和 B 的对象引用计数一直不会变成 0，A 和 B 的对象都不会被删除。 现在把ptr_A换成weak_ptr，ptr_A可以访问 B 的对象但是不会持有该对象。B 对象的引用计数就是 0，可以先释放，之后 A 对象的引用计数变成 0 就可以释放内存。 使用ptr_A之前需要检查 B 对象的有效性，因为 B 对象可能销毁。 什么时候需要用weak_ptr？当希望从不同的地方访问对象，且不关心这些引用的删除。但是尝试间接引用该对象的时候需要注意检查对象的有效性。  reference  auto_ptr, unique_ptr, shared_ptr and weak_ptr std::auto_ptr to std::unique_ptr  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"635c148e386cf6f5aa0c3e5a2740e290","permalink":"https://xueqing.github.io/blog/cplusplus/smart_ptr/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/smart_ptr/","section":"blog","summary":"auto_ptr unique_ptr shared_ptr weak_ptr reference auto_ptr C++11 已经弃用。unique_ptr是新的具有相似功能的智能指针，但是安全性更高。 auto_ptr是管理对象的指针，通过new的操作","tags":["c++"],"title":"auto_ptr, unique_ptr, shared_ptr and weak_ptr","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  脚本基本架构 工作原理 将外部变量传递给 awk  脚本基本架构  awk 'BEGIN{ print \u0026quot;start\u0026quot; } pattern{ commands } END{ print \u0026quot;end\u0026quot; }' file 一个 awk 脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块 3 部分组成 这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中  工作原理 awk 'BEGIN{ commands } pattern{ commands } END{ commands }'\n 第一步：执行BEGIN{ commands }语句块中的语句  BEGIN语句块在 awk 开始从输入流中读取行之前被执行 这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中  第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕\n pattern语句块中的通用命令是最重要的部分，它也是可选的 如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk 读取的每一行都会执行该语句块 echo -e \u0026quot;A line 1\\nA line 2\u0026quot; | awk 'BEGIN{ print \u0026quot;Start\u0026quot; } { print } END{ print \u0026quot;End\u0026quot; }'输出\nStart A line 1 A line 2 End   当使用不带参数的print时，它就打印当前行，当print的参数是以逗号进行分隔时，打印时则以空格作为定界符。在 awk 的print语句块中双引号是被当作拼接符使用\n echo | awk '{ var1=\u0026quot;v1\u0026quot;; var2=\u0026quot;v2\u0026quot;; var3=\u0026quot;v3\u0026quot;; print var1,var2,var3; }'输出v1 v2 v3 echo | awk '{ var1=\u0026quot;v1\u0026quot;; var2=\u0026quot;v2\u0026quot;; var3=\u0026quot;v3\u0026quot;; print var1\u0026quot;=\u0026quot;var2\u0026quot;=\u0026quot;var3; }'输出v1=v2=v3  第三步：当读至输入流末尾时，执行END{ commands }语句块\n END语句块在 awk 从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成 也是一个可选语句块   将外部变量传递给 awk  借助-v选项，可以将外部值（并非来自 stdin）传递给 awk\nVAR=10000 echo | awk -v VARIABLE=$VAR '{ print VARIABLE }' ## 输出\u0026quot;10000\u0026quot;  另一种传递外部变量方法\nvar1=\u0026quot;aaa\u0026quot; var2=\u0026quot;bbb\u0026quot; echo | awk '{ print v1,v2 }' v1=$var1 v2=$var2 ## 输出\u0026quot;aaa bbb\u0026quot;  当输入来自于文件时使用awk '{ print v1,v2 }' v1=$var1 v2=$var2 filename\n 以上方法中，变量之间用空格分隔作为 awk 的命令行参数跟随在BEGIN、{}和END语句块之后\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"02e1f2ca7bf44aa0d749db7f28925112","permalink":"https://xueqing.github.io/blog/ubuntu/awk/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/awk/","section":"blog","summary":"脚本基本架构 工作原理 将外部变量传递给 awk 脚本基本架构 awk 'BEGIN{ print \u0026quot;start\u0026quot; } pattern{ commands } END{ print \u0026quot;end\u0026quot; }' file 一个 awk 脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块","tags":["ubuntu","linux"],"title":"awk 命令","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  B2B B2C C2C O2O P2P P2C  production to consumer platform to creditAssignment  B2B vs B2C vs C2C vs O2O  B2B  B2B：business to business，企业对企业的电子商务模式 B2B 是企业对企业之间的营销关系。它将企业内部网通过 B2B 网站对客户紧密结合起来，通过网络的快速反应，为客户提供更好的服务，从而促进企业的业务发展 B2B 指进行电子商务交易的供需双方都是商家(或企业、公司)，他们使用了互联网的技术或各种商务网络平台，完成商务交易的过程 B2B 有 3 个要素  买卖：B2B 网站平台为消费者提供质优价廉的商品，吸引消费者购买的提示促使更多商家入驻 合作：与物流公司建立合作关系，为消费者的购买行为提供最终保障。这是 B2B 平台硬性条件之一 服务：物流主要是为消费者提供购买服务，从而实现再一次的交易  代表网站：阿里巴巴、中国制造网、中国供应商  B2C  B2C：business to customer，商对客，商家对个人 B2C 是电子商务的一种模式，也就是通常所说的商业零售，直接面向消费者销售产品和服务  这种形式的电子商务一般以网络零售业为主，主要借助互联网开展在线销售获得 B2C 即企业通过互联网为消费者提供一个新型的购物环境——网上商店，消费者在网上购物和支付  B2C 电子商务网站有 3 个基本部分  商场网站：为顾客提供在线购物场所 配送系统：为客户所购商品进行配送 银行及认证系统：负责顾客身份的认证以及货款结算  B2C 代表网站  天猫：为人服务做平台 京东：自主经营卖产品 凡客：自产自销做品牌   C2C  C2C：customer to customer，个人与个人之间的电子商务，是电子商务的专业用语 如消费者有一台电脑，通过网络进行交易，出售给另一个消费者 代表网站：淘宝网、易趣网、拍拍网  O2O  O2O：online to offline，线上到线下 O2O 将线下商务的机会与互联网结合在一起，使互联网称为线下交易的平台 线下服务可用线上平台揽客，消费者进而用线上平台筛选服务，还有成交可以在线上结算，很快达到规模 特点：推广效果可查，交易可跟踪 优势：在于把线上和线下优势完美结合。通过网购导购机，把互联网和实体店完美对接，实现互联网落地；让消费者享受线上优惠价格的同事，可享受线下贴身的服务；O2O 模式还可实现不同商家的联盟 O2O 营销模式的核心是在线预付：在线支付不仅是支付本身的完成，是某次消费得以最终形成的唯一标识，更是消费数据唯一可靠的考核标识。对提供线上服务的互联网专业公司来说，只有用户在线上完成支付，自身才可从中获得收益 O2O 有 4 种运营模式  online to offline：线上交易到线下消费体验 offline to online：线下营销到线上交易 offline to online to offline：线下营销到线上交易再到线下消费体验 online to offline to online：线上交易或营销到线下消费体验再到线上消费体验  代表：保险直购 O2O，苏宁易购 O2O，大众点评 O2O  P2P  P2P：peer to peer，个人对个人 P2P 借贷：是一种将非常小额度的资金聚集起来借贷给有资金需求人群的一种民间小额借贷模式  P2P 借贷指个人通过第三方平台(P2P 公司)在收取一定服务费的前提下，向其他个人提供小额借贷的金融模式  P2P 模式  一种是纯线上模式，是纯粹的 P2P。在这种平台模式进行信息匹配，帮助资金借贷双方更好的进行资金匹配，缺点是这种线上模式不参与担保 一种是债权转让模式，平台本身先行放贷，再将债权放到平台进行转让，明显可让企业提高融资端的工作效率，但容易出现资金池，不能让资金充分发挥效益   P2C production to consumer  P2C：production to consumer，商品和顾客 P2C 是产品从生产企业直接送到消费者手中，中间没有任何的交易环节。也叫做生活服务平台 具体表现：如果家乐福、沃尔玛、大中电器等零售业巨头进军电子商务，通过互联网开展商务活动 P2C 把人们日常生活中一切密切相关的服务信息，如餐饮、房产、交友、家政服务、票务、健康、医疗、保健等聚合到平台，实现服务业的电子商务化  platform to creditAssignment  P2C：platform to creditAssignment，平台和债权转让 是互联网金融新概念。此理论是国内首个 P2C 互联网金融服务，对债权转让企业进行资质审核、实地考察，筛选出具有投资价值的优质债权项目在平台上向投资者公开；并提供在线投资的交易平台，实时为投资者生成具有法律效力的债权转让及服务协议；监督企业的项目经验，管理评估风险，确保投资者资金安全  B2B vs B2C vs C2C vs O2O    模式 描述 说明     B2B 企业间的 是你也成立了公司买我公司的东西，如阿里巴巴   B2C 商家对个人 我成立个公司卖东西，如卓越、当当、京东   C2C 个人对个人 我卖东西你来买，如淘宝小店铺   O2O 线上和线下结合 我成立个公司卖东西，你来买但是需要你自己拿     B2C 和 C2C 是在线支付，且运用了物流，购买的商品会通过物流公司送到消费者手中 O2O 是在线支付，购买线下的商品、服务，再到线下享受服务     不同点 B2C O2O     侧重性 购物(实物商品，如电器，服饰) 服务性消费(餐饮、电影、美容、SPA、旅游、健身、租车、租房等)   涉及点 消费者到现场获得服务，涉及客流 消费者等货上门，涉及物流   库存 服务 商品    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c8b3bb90f7746f76ea88921de8abc63d","permalink":"https://xueqing.github.io/blog/o2o/b2b_b2c_c2c_o2o_p2p_p2c/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/b2b_b2c_c2c_o2o_p2p_p2c/","section":"blog","summary":"B2B B2C C2C O2O P2P P2C production to consumer platform to creditAssignment B2B vs B2C vs C2C vs O2O B2B B2B：business to business，企业对企业的电子商务模式 B2B 是企业对企业之间的营销关系。它","tags":["o2o"],"title":"B2B vs B2C vs C2C vs O2O vs P2P vs P2C","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  description synopsis options  single character options multi character options  arguments invocation definitions reserverd_words shell grammar  simple commands pipelines lists compound commands coprocesses 函数定义  comments quoting parameters  positional parameters special parameters shell variables array  expansion  brace expansion tilde expansion parameter expansion command substitution arithmetic expansion process substitution word splitting pathname expansion quote removal  redirection  input output appending redirected output redirecting standard output and standard error appending standard output and standard error here documents here strings duplicating file descriptors moving file descriptors opening file descriptors for reading and writing  aliases functions arithmetic evaluation conditional expressions simple command expansion command execution command execution environment environment exit status signals job control prompting readline  readline notation readline initialization readline key bindings readline variables readline conditional constructs searching readline command names commands for moving commands for manipulating the history commands for changing text killing and yanking numeric arguments completing keyboard macros miscellaneous programmable completion  history history expansion  event designators word designators modifiers  shell builtin commands restricted shell files  description  bash(Bourne-Again SHell)，是一种 sh-兼容的命令语言解释器，执行从标准输入或文件读取的命令 bash 也吸收了 knor 和 C shell(ksh 和 csh)的一些有用的特点  synopsis 总览bash [options] [command_string | file]\noptions single character options  -c表示从第一个非选项的command_string读命令。如果command_string之后有参数，赋值给对应位置的参数，从$0开始 -i表示 shell 是交互式的 -r表示 shell 是受限的 -s或者选项后面没有参数，表示从标准输入读命令。这个选项允许在启动交互式 shell 时设置位置参数 O [shopt option]shopt option 是由内置的shopt接收的参数  如果有shopt option，-O设置该选项的值；+O取消设置 如果没有shopt option，选项的名字和值被输出到标准输出 如果调用选项是+O，输出按一定格式展示可当做输入  --标记选择的终止，不再处理选项。后面的参数都当做文件名或参数  multi character options  --rcfile file在交互式 shell 中，执行file的命令，而不是系统范围的初始化文件/etc/bash.bashrc或标准的个人初始化文件~/.bashrc --noprofile在启动一个交互式 shell 的时候，选项会根据几个默认的文件配置环境。此选项表示不要读这些文件  系统范围的开始文件/etc/profile 所有的个人初始化文件~/.bash_profile，~/.bash_login和~/.profile  --norc在交互式 shell 中，不要读系统范围的初始化文件/etc/bash.bashrc和标准的个人初始化文件~/.bashrc  arguments  如果处理的选项之后还要参数，且没有-c和-s，第一个参数被认为是包含 shell 命令的文件。$0设置成这个文件名，其他的位置参数设置为剩下的参数 bash 从这个文件读并执行命令，然后退出 bash 的退出状态是最后执行的命令的状态，没有执行命令则退出状态是 0 bash 先尝试从当前目录查找文件，如果没有，则从PATH中查找这个脚本文件  invocation  当 bash 作为一个交互式的登录 shell，或非交互式的带有--login的 shell  如果/etc/profile存在则读并执行命令 按照~/.bash_profile，~/.bash_login和~/.profile的顺序查找文件，存在的话就读和执行命令  如果是一个登录 shell，如果~/.bash_logout文件存在，则读和执行命令 如果是一个交互式的非登录 shell如果/etc/bash.bashrc和~/.bashrc文件存在，则读和执行命令 如果是非交互式 shell，比如运行一个 shell 脚本，查找环境的BASH_ENV，如果存在则展开它的值  definitions  blank 一个空格或制表符 word shell 认为是一个整体的字符序列，也叫 token name 一个只包含字母和下划线的 word，而且以字母或下划线开头，也叫 identifier metacharacter 当未加引号时，用来分离 word 的字符，包括| \u0026amp; ; ( ) \u0026lt; \u0026gt;、空格和制表符 control operator 执行一个控制函数的 token，包括|| \u0026amp; \u0026amp;\u0026amp; ; ;; ( ) | |\u0026amp;和换行  reserverd_words 保留字是对 shell 有特殊含义的单词。包括! case coproc do done elif else esac fi for function if in select then until while { } time [[ ]]\nshell grammar simple commands  简单命令的格式第一个 word 是要执行的命令，作为参数 0，即$0，剩余的 word 作为命令的参数 简单命令的返回值就是它的退出状态；如果是被信号n终止的，则返回128+n  pipelines  一个 pipeline 是一个或多个命令，使用控制操作符|或|\u0026amp;分割 格式[time [-p]] [ ! ] command [ [|或|\u0026amp;] command2 ... ]  管道的连接在重定向之前执行 使用|\u0026amp;，前一个命令的标准错误和标准输出通过管道连接到下一个命令的标准输入，是2\u0026gt;\u0026amp;1 |的简写 返回值 管道的返回值是最后一个目录的返回状态，除非开启了pipefail 允许pipefail，返回状态是最后一个最正确(rightmost)命令，退出一个非 0 状态，或者都正常退出的话返回 0 管道之前有!，则返回的是上述返回值的逻辑否定值 shell 等待管道中的所有命令终止才会返回 包括字time使得管道终止的时候，报告所有花费的时间，包括用户和系统时间 -p使用 POSIX 指定的输出格式  管道中的每个命令都是一个单独的进程(比如，在一个子 shell 执行)  lists  list 是值一个 pipeline 或由符号; \u0026amp; \u0026amp;\u0026amp; ||分隔的多个 pipeline，以; \u0026amp;或换行终止 优先级：\u0026amp;\u0026amp; = || \u0026gt; ; = \u0026amp; 以\u0026amp;控制符结尾表示 shell 将在一个子 shell 中执行该命令，且在后台运行，不会等待该命令结束，返回状态是 0 以;分隔的命令按顺序执行，返回状态是最后执行的命令的返回状态 command1 \u0026amp;\u0026amp; command2只有 command1 返回状态是 0 时才会执行 command2 command1 || command2只有 command1 返回状态非 0 时才会执行 command2  compound commands  (list)在子 shell 中执行 list，返回状态是 list 的返回状态 { list; }在当前 shell 中执行 list，是group command，返回状态是 list 的返回状态 ((expression))以算术求值规则计算表达式，如果值非 0 则返回 0，否则返回 1，等同于let \u0026quot;expression\u0026quot; [[ expression ]]根据条件表达式的值确定返回状态是 0 还是 1  表达式中不会执行word splitting和pathname expansion  当使用== !=时，操作符右边的字符串被认为是模式，根据模式匹配规则  =等同于== 如果 shell 选项nocasematch设置的话，可以忽略大小写 匹配返回 0，否则返回 1  二元操作符=~和== !=优先级相同，操作符右边的被视为扩展的正则表达式  如果正则表达式语法错误返回 2 匹配的子串保存在BASH_REMATCH中，下标为 0 表示匹配整个子串，下标为 n 表示匹配第 n 个圆括号的子表达式  表达式的形式包括  ( expression )返回表达式的值，可用于修改操作符的优先级 ! expression expression1 \u0026amp;\u0026amp; expression2 expression1 || expression2 for name [ [ in [ word ... ] ] ; ] do list ; done in后面的内容被扩展，生成一个元素列表 name每次循环设置成列表中的元素 如果没有in，for对每个位置参数执行一次 返回状态是最后一个执行命令的返回值 如果in生成的元素集合为空，则返回 0，不执行任何命令 for (( expr1 ; expr2 ; expr3 )) ; do list ; done 以算术求值规则计算expr1 重复计算算术表达式expr2直到值是 0：每次得到一个非 0 值，执行list，然后计算算术表达式expr3 如果对应位置的表达式没有，则认为值为 1 返回值是list最后一个执行的命令的返回状态；如果所有表达式都是无效的返回 false select name [ in word ] ; do list ; done in后面的内容被扩展，生成一个元素列表 扩展的单词背打印到标准错误，每个前面一个数字 如果没有in，则打印位置参数 每次选择之后执行list，知道遇到break命令 返回值是list最后一个执行的命令的返回状态；如果没有执行命令则返回 0 case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac 找到匹配，执行对应的list  如果使用了;;，则不会再继续 如果使用了;\u0026amp;，则继续执行后面的list 如果使用了;;\u0026amp;，则继续尝试匹配后面的模式，如果匹配则执行对应的list  如果没有匹配的模式返回 0，否则返回list中最后执行的命令的状态 if list; then list; [ elif list; then list; ] ... [ else list; ] fi while list-1; do list-2; done 当list-1的最后一个命令的返回状态为 0 时执行list-2 返回list-2中最后执行的命令的返回状态，什么都没有执行则返回 0 until list-1; do list-2; done 当list-1的最后一个命令的返回状态非 0 时执行list-2 返回list-2中最后执行的命令的返回状态，什么都没有执行则返回 0   coprocesses  语法coproc [NAME] command [redirections] 创建一个叫做NAME的协同进程，如果不指定则是COPROC 如果是简单命令则不能知道名字，名字就是简单命令的第一个单词 协同进程在一个子 shell 中异步执行，类似于在后台执行命令，在执行的 shell 和协同进程之间建立了一个双向的 pipeline 执行协同进程的时候，shell 在执行 shell 的上下文创建一个叫NAME的数组变量  command的标准输出通过管道连接到一个文件描述符，值为NAME[0] command的标准输入通过管道连接到一个文件描述符，值为NAME[1] 管道的建立在重定向之前完成 文件描述符可以被 shell 命令和重定向用作参数，子 shell 中不能访问这个文件描述符 执行协同进程的子 shell 的进程 ID可以通过变量NAME_PID访问 内置的wait命令可用来等待协同进程终止  coproc命令总是返回成功，coprocess 的返回状态是command的退出状态  函数定义  语法支持两种  name () compound-command [redirection] function name [()] compound-command [redirection]  定义了一个叫做name的函数，关键字function可选 如果使用了关键字function，则圆括号是可选的  comments  在非交互式的 shell 和开启了 interactive_comments 的交互式 shell 中，以#开头到行末的内容视为注释  quoting  引用用于移除单词或字符对于 shell 具有的特殊含义，也可用于防止参数扩展 metacharacter(包括| \u0026amp; ; ( ) \u0026lt; \u0026gt;)在加引号时可用来代表自身，而不是分离单词的字符 一共有三种引用机制：反斜线、单引号和双引号  反斜线：保留它后面紧跟字符的含义，除了新行(此时代表一行的继续，在输入流中会忽视此反斜线) 单引号：保留单引号   parameters positional parameters special parameters shell variables array expansion brace expansion tilde expansion parameter expansion command substitution arithmetic expansion process substitution word splitting pathname expansion quote removal redirection input output appending redirected output redirecting standard output and standard error appending standard output and standard error here documents here strings duplicating file descriptors moving file descriptors opening file descriptors for reading and writing aliases functions arithmetic evaluation conditional expressions simple command expansion command execution command execution environment environment exit status signals job control prompting readline readline notation readline initialization readline key bindings readline variables readline conditional constructs searching readline command names commands for moving commands for manipulating the history commands for changing text killing and yanking numeric arguments completing keyboard macros miscellaneous programmable completion history history expansion event designators word designators modifiers shell builtin commands restricted shell files ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c07da406a1c60a919706c25b49a8dea6","permalink":"https://xueqing.github.io/blog/shell/bash/bash_shell/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/shell/bash/bash_shell/","section":"blog","summary":"description synopsis options single character options multi character options arguments invocation definitions reserverd_words shell grammar simple commands pipelines lists compound commands coprocesses 函数定义 comments quoting parameters positional parameters special parameters shell variables array expansion brace expansion tilde expansion parameter expansion command substitution arithmetic expansion process substitution word splitting pathname expansion quote removal redirection input output appending redirected output redirecting standard output and standard error appending standard output","tags":["shell","bash"],"title":"bash","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 原文\n 约定 重要概念 BitTorrent DHT 协议  概述 路由表 BitTorrent 协议扩展 种子文件扩展 KRPC 协议 DHT 查询  Bittorrent DHT 几个重要过程  种子制作 启动过程 刷新路由表   约定  peers vs 客户端（client）：  一个 peer 可以是任何参与下载的 BitTorrent 客户端 客户端也是一个 peer  片（piece） vs 块（block）：  片指在元信息文件中描述的一部分已下载的数据，可通过 sha-1 hash 验证 块是客户端向 peer 请求的一部分数据。两块或更多块可以组成一个完整的可被验证的片  B 编码（Bencoding）：B 编码是一种以简洁的格式描述和组织数据的方法，支持字节串、整数、lists 和 dictionaries  字节串： 字节串没有开始和结束分隔符 编码方式\u0026lt;以十进制 ASCII 编码的串长度\u0026gt;:\u0026lt;串数据\u0026gt; 如：4:spam表示字节串\u0026rdquo;spam\u0026rdquo; 整数： 编码方式i\u0026lt;以十进制 ASCII 编码的整数\u0026gt;e i和e分别是开始和结束分隔符 如i0e，i-1e；i01e是无效的 lists： 编码方式l\u0026lt;B 编码值\u0026gt;e l是小写的L，是开始分隔符；e是结束分隔符 lists 可以包含任何 B 编码的类型，包括整数、串、dictionaries 和其他的 lists 如l4:spam4:eggse表示含义两个串的 lists：[\u0026ldquo;spam\u0026rdquo;, \u0026ldquo;eggs\u0026rdquo;] dictionaries： 编码方式d\u0026lt;B 编码串\u0026gt;\u0026lt;B 编码元素\u0026gt;e d和e分别是开始和结束分隔符 键 key 必须被 B 编码为串  串必须以排序的方式出现（以原始串排序，而不是字母数字顺序） 串采用二进制比较方式，而不是特定于某种文化的自然比较（不是中文或英文的排序方式）  值 value 可以是任何 B 编码的类型，包括整数、串、lists 和其他的 dictionaries 如 d3:cow3:moo4:spam4:eggse表示 dictionaries {\u0026ldquo;cow\u0026rdquo;=\u0026gt;\u0026ldquo;moo\u0026rdquo;, \u0026ldquo;spam\u0026rdquo;=\u0026gt;\u0026ldquo;eggs\u0026rdquo;} 如 d4:spaml1:a1:bee表示 dictionaries {\u0026ldquo;spam\u0026rdquo;=\u0026gt;[\u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;]}   重要概念  元信息文件结构（Metainfo file structure）：所有数据以 B 编码方式编码 元信息文件：一个 B 编码的 dictionary  元信息文件包含的键 key 如下，其中字符串类型的值均以 UTF-8 编码 info：dictionary 类型，，值描述了种子文件。该 dictionary 可能是  没有目录结构的单文件，即种子文件只包含一个文件 有目录文件的多文件  announce：string 类型，值是 tracker 的 announce URL announce-list： [lists/string] 类型，可选，对正式规范的一个扩展，提供向后兼容性 creation date：整数类型，是 unix 时间戳，可选，值是种子文件的创建时间 comment：string 类型，可选，值是种子文件制作者的评论 create by：string 类型，可选，值是只做种子文件的程序的名称和版本 encoding：string 类型，可选，用于生成分片（当info dictionary 过大时，需要对其分片） 元信息文件包含的值 value info dictionary，即 info 对应的值，其单文件和多文件模式公共的键 可以 如下：  piece length：整数类型，值是每个 piece 的字节数 一般是 2 的整数次方，根据种子文件数据的总大小来选择 piece 的大小 piece 过小使得种子文件过大，piece 过大则降低下载效率 以前的 piece 大小是种子文件不超过 50-75KB，目前保持为 256KB，512KB 或 1MB 除了最后一块，其他块大小相同，piece 的数量取决于 total_length/piece_size 多文件模式的 piece 可能跨越文件边界 pieces：string 类型，值由每个 piece的 20 字节 sha1 散列值连接而成，每个 piece 包含一个唯一的 sha1 散列值 private：整数类型，可选，值 为 0 或者 1，可不设置，表示是否有外部的 peer 源 值为 1：客户端必须广播自己的存在，通过元信息文件中显式描述的 trackers 得到其他的 peers 不设置或值为 0：客户端可以通过其他方式得到其他的 peers  单文件模式（Single file mode）的 info dictionary 包含的键：  name：string 类型，文件名，建议使用 length：整数类型，文件所占字节数 md5sum：string 类型，可选，相当于文件 MD5 和的 32 个字符的 16 进制字符串， BT 不使用这个键  多文件模式（Multiple file mode）的 info dictionary 包含的键：  name：string 类型，存储文件的目录名，建议使用，utf-8 name.files：[dictionaries] 每个文件对应一个 dictionary，list 中每个 dictionary 包含的键包括： length：整数类型，文件所占字节数 md5sum：string 类型，可选，相当于文件 MD5 和的 32 个字符的 16 进制字符串， BT 不使用这个键 path：包含单个或多个元素的 list，元素合成在一起表示文件路径或文件名，utf-8  list 中每个元素对应一个目录名或文件名（最后一个元素对应文件名） 如dir1/dir2/file.txt会被编码成 B 编码的字符串 list l4:dir14:dir28:file.txte    tracker：响应 HTTP GET 请求的 HTTP/HTTPS 服务  请求包含来自客户端的度量信息，这些信息能够帮助 tracker 全面统计种子文件 响应包含一个 peers 列表   BitTorrent DHT 协议 概述  peer：在一个 TCP 端口上监听的客户端/服务端，实现了 BitTorrent 协议 节点：一个在 UDP 端口上监听的客户端/服务端，实现了 DHT 协议  DHT 由节点组成，存储了 peer 的位置 BitTorrent 客户端包含一个 DHT 节点，该节点用来联系 DHT 中其他节点，从而得到 peer 的位置，进而通过 BitTorrent 协议下载  节点为种子文件寻找 peer 时，返回值包含一个不透明的值，称之为令牌 token。如果一个节点 announce 它控制的 peer 正在下载一个种子，必须在回复中加上被请求方之前在 get_peers 回复中发送的 token  当节点试图 announce 一个种子时，被请求的节点会核对 token 和请求节点的 IP 地址。这可以防止恶意的主机登记其他主机的种子 token 只能由请求查询的节点返回给之前发送此 token 给它的节点 token 必须在发布的一段时间内被接收，即有时效性。BitTorrent 使用 SHA1 哈希 IP 地址，后面跟上一个 secret（5 分钟改变一次），token 在 10 分钟之内是可接受的   路由表  每个节点维护一个路由表保存已知的好节点，用来作为在 DHT 请求的起始点。路由表中的节点是在向其他节点请求过程中，被请求的节点回复的 一个好的节点是在过去 15 分钟回复过某个请求的节点，或者增加回复过请求而且在过去 15 分钟发送过请求的节点  当节点 15 分钟没有活跃，则成为可疑的节点 当节点连续不能回复时，节点变为坏的 和状态未知的节点相比，已知的好节点有更高的优先级  目前每个 k-bucket 中可疑保存 8 个节点，即 k=8 k-bucket 节点的更新  当得到一个新的好节点时 如果已有节点都是好的，则丢弃新的节点 如果已知有坏节点，则用新节点替换坏节点 如果有可疑的节点，则试图 ping 该节点  收到回复，则 ping 下一个可疑节点，直到遇到未回复的节点或者所有节点都是好的 可疑节点没有回复建议再发一次，仍然没有回复则丢弃，用新节点替换   每个 bucket 持有一个 last changed 属性，标记内容的新鲜度  ping 一个节点并且收到回复，插入一个新节点，替换一个节点都会更新 bucket 的属性 15 分支没有更新的 bucket 应当被刷新 在 bucket 中随机选取一个 ID，执行一个 find_node 操作  当在路由表中插入第一个节点并启动时，节点应该尝试一个 find_node 操作，参数是它本身，以更新 DHT 中此节点临近的节点 路由表应保存在客户端软件  BitTorrent 协议扩展  BitTorrent 协议扩展用于交换 peer 之间的 UDP 端口数 客户端可以通过正常的下载种子文件自动更新路由表  新安装的客户端下载一个没有 tracker 的种子，一开始路由表也没有节点，需要从种子文件获得联系信息  支持 DHT 的 peers 在 BitTorrent 的握手协议中设置预留的 8-byte 的最后一位为 1，收到握手的 peer 表明远端的 peer 支持 DHT 协议，应该发送 PORT 消息  消息一 0x09 字节开头，有两个字节的 payload，包含了该 DHT peer 使用的网络字节序的 UDP 端口 收到 PORT 消息的 peer 应该尝试用收到的端口和 IP 地址 ping 这个节点。如果收到回复，该节点应该插入这个新的联系方式到它的路由表   种子文件扩展  一个没有 tracker 的种子 dictionary 没有 announce 键  取而代之的是 nodes 键，这个键设为客户端路由表中 k 个最近的节点 也可以设置为已知的好的节点，比如种子文件的创建者  不要自动加入router.bittorrent.com到种子文件或者自动加入此节点到客户端路由表  一开始节点不在 DHT 网络中，可以向router.bittorrent.com:6881或dht.transmissionbt.com:6881等发送 find_node 请求   KRPC 协议  KRPC 协议是一个简单的 RPC 结构，由 bencode 编码的 dictionaries 组成，通过 UDP 发送 发出去一个单独的查询包然后回复一个单独的包，消息不会重试 有三种消息类型  查询 query，有四种查询：ping，find_node，get_peers，announce_peer 回复 response， 错误 error，  一个 KRPC 消息是一个单独的 dictionary，有三个共同的键以及和消息类型相关的附加键  t：string 类型，表示会话 transaction ID，由查询节点生成，回复的时候携带，因此回复可能和同一节点的多个查询相关 会话 ID 应当被编码成二进制的段字符串，比如 2 个字节可以覆盖 2^16 个请求 y：单字符类型，描述消息类型，q-query，r-response，e-error v：字符串类型，表示客户端版本，2 个字符表示客户端注册标识符，2 个字符表示版本标记 不是所有实现有包含 v 键  联系信息编码 contact encoding  peers 的联系信息被编码为 6 字节的字符串，又被称为“Compact IP-address/port info” 4 字节的 IP 地址，网络字节序 2 字节的端口，网络字节序 节点的联系信息被编码为 26 字节的字符串，又被称为“Compact node info” 20 字节的 Node ID，网络字节序 6 字节的 “Compact IP-address/port info”  查询 query 消息字典  y：q q：string 类型，包含 query 的 method 名称 a：dictionary 类型，包含参数名字和值  回复 response 消息字典  y：r r：dictionary 类型，包含返回值名字和值 当查询正确执行完成之后才会发送回复消息  错误 error 消息字典  y：e e：list 类型 第一个元素是一个整数代表错误码  201：generic 错误 202：server 错误 203：protocol 错误，比如 malformed packet，无效参数，bad token 204：未知的 method  第二个元素是一个 string 包含错误消息 当一个查询不能完成的时候发送错误消息 比如generic error={\u0026quot;t\u0026quot;:\u0026quot;aa\u0026quot;, \u0026quot;y\u0026quot;:\u0026quot;e\u0026quot;, \u0026quot;e\u0026quot;:[201, \u0026quot;A Generic Error Occured\u0026quot;]} bencode 编码是d1:eli201e23:A Generic Error Occurred1:t2:aa1:y1:ee   DHT 查询  所有的查询都有一个 id 的键，表示查询节点的 Node ID，所有的回复有一个 id 的键，表示回复节点的 Node ID ping：\u0026quot;q\u0026quot;=\u0026quot;ping\u0026quot;\n id：string 类型，20 字节，指的发送者的节点 ID，网络字节序 回复的键只有 id 表示回复者的节点 ID\nping query:{\u0026quot;t\u0026quot;:\u0026quot;aa\u0026quot;, \u0026quot;y\u0026quot;:\u0026quot;q\u0026quot;, \u0026quot;q\u0026quot;:\u0026quot;ping\u0026quot;, \u0026quot;a\u0026quot;:{\u0026quot;id\u0026quot;:\u0026quot;querying_node_id\u0026quot;}} {\u0026quot;bencoded\u0026quot;: \u0026quot;d1:ad2:id14:querying_node_ide1:q4:ping1:t2:aa1:y1:qe\u0026quot;} response:{\u0026quot;t\u0026quot;:\u0026quot;aa\u0026quot;, \u0026quot;y\u0026quot;:\u0026quot;r\u0026quot;, \u0026quot;r\u0026quot;:{\u0026quot;id\u0026quot;:\u0026quot;queried_nodes_id\u0026quot;} {\u0026quot;bencoded\u0026quot;: \u0026quot;d1:rd2:id16:queried_node_ide1:t2:aa1:y1:re\u0026quot;}   find_node：\u0026quot;q\u0026quot;=\u0026quot;find_node\u0026quot;\n 指定节点 ID，查询节点的联系信息 id：查询节点的 ID target：查询者要查询的节点 ID 回复的键 id：接收者的节点 ID nodes：string 类型，包含目的节点的紧密（compact）信息或者接收者路由表中 k 个最近最好的节点信息  get_peers：\u0026quot;q\u0026quot;=\u0026quot;get_peers\u0026quot;\n 请求与种子文件的 info_hash 相关 id：查询节点的 ID info_hash：种子文件的 info_hash 值 回复的键：接收者有 info_hash 的 peers 则返回 values，否则返回 nodes id：接收者的节点 ID token：用于后续的 announce_peer 查询，是一个短的二进制字符串 values：list of string 类型，每个字符串包含一个紧密（compact）格式的 peer 信息 nodes：接收节点路由表最接近 info_hash 的 k 个节点信息  announce_peer：\u0026quot;q\u0026quot;=\u0026quot;announce_peer\u0026quot;\n 宣布一个控制请求节点的 peer 正在某个端口下载一个种子文件 id：查询请求节点的 ID info_hash：种子文件的 info_hash port：整数类型，表示在哪个端口下载 token：之前的一个“get_peers”回复中的 token 被请求的节点必须验证 token 之前发送的节点 IP 地址与请求节点相同，然后被请求的节点保存这个请求节点的 IP 地址和提供的端口到它自己的 peer 联系信息 implied_port：可选，0 或者 1，如果存在且不为 0，port 参数值应该忽略，而且 UDP 包的源端口应作为 peer 的端口 这对于 NAT 之后的 peer 有用，因为 peer 不知道自己外部端口，但是支持 uTP，接收同一 DHT 端口的连接  总结：DHT 是一个 hash 表，发送 KRPC 的 find_node 或 get_peers 消息，就是对表执行 get(key) 操作，发送 announce_peer 消息，就是对表执行 set(key,val) 操作\n  Bittorrent DHT 几个重要过程 种子制作  use_tracker 设置为 false，则不会产生 announce tracker 字段 读取本地路由表文件，从中找到 k 个离 info_hash 最近的节点，作为 nodes 字段  启动过程  从路由表文件装载之前保存的路由表 k-bucket 信息，初始化内存路由表信息 强制刷新路由表的每一个 k-bucket，刷新过世是随机产生一个 id 进行 find_node 操作  刷新路由表  启动的时候强制刷新 每 15 分钟如果 k-bucket 中信息没有更新，则刷新一次，即 refreshTable 每 5 分钟进行一次 checkPoint 操作，把当前的路由表保存到 routing_table 文件  routing_table 文件格式{'id':node_id, 'host':node_host, 'port':node_port, 'age':int(node_age)}  每个路由表的 k-bucket 有一个 last changed 属性，具体描述参考上面的BitTorrent DHT 协议-\u0026gt;路由表  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"42ab93961082bf39d56ba9dd592bc2a7","permalink":"https://xueqing.github.io/blog/p2p/bittorrent%E5%8D%8F%E8%AE%AE/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/p2p/bittorrent%E5%8D%8F%E8%AE%AE/","section":"blog","summary":"原文 约定 重要概念 BitTorrent DHT 协议 概述 路由表 BitTorrent 协议扩展 种子文件扩展 KRPC 协议 DHT 查询 Bittorrent DHT 几个重要过程 种子制作 启动过程 刷新路由表 约定 peers vs 客户端（client）","tags":["p2p"],"title":"BitTorrent 协议","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 关于 new int() 和 new int[] #define LEN 100 int *arr1 = new int(LEN); int *arr2 = new int[LEN];   第一行的代码arr1指向内存中int = 100的一个数的地址 第二行的代码arr2指向长度为 100 的数组的内存块 圆括号是对象赋值的意思；方括号是声明数组大小的意思  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a7f3b5728240167dc9f8ec1afbddd406","permalink":"https://xueqing.github.io/blog/cplusplus/cplusplus_new/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/cplusplus_new/","section":"blog","summary":"关于 new int() 和 new int[] #define LEN 100 int *arr1 = new int(LEN); int *arr2 = new int[LEN]; 第一行的代码arr1指向内存中int = 100的一个数的地址 第二行的代码arr2指向长度为 100 的数组的内","tags":["c++"],"title":"C++ new","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"#include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; void CString::StringToUpper(std::string \u0026amp;str) { std::transform(str.begin(), str.end(), str.begin(), ::toupper); } void CString::StringToLower(std::string \u0026amp;str) { std::transform(str.begin(), str.end(), str.begin(), ::tolower); }   提示出错error: no matching function for call to ‘transform(__gnu_cxx::__normal_iterator\u0026lt;char*, std::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt; \u0026gt;, __gnu_cxx::__normal_iterator\u0026lt;char*, std::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt; \u0026gt;, __gnu_cxx::__normal_iterator\u0026lt;char*, std::basic_string\u0026lt;char, std::char_traits\u0026lt;char\u0026gt;, std::allocator\u0026lt;char\u0026gt; \u0026gt; \u0026gt;, \u0026lt;unknown type\u0026gt;)’的解决方法：既有 C 版本的toupper/tolower函数，又有 STL 模板函数toupper/tolower，二者存在冲突，在toupper/tolower前加上::表示强制指定 C 版本的 ::toloweer/::toupper 只用于单字节字符的替换，不适用于多字节编码（如 UTF-8）？ 可使用 boost 库\n#include \u0026lt;boost/algorithm/string.hpp\u0026gt; using namespace boost; // use to_lower/to_upper function   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f65b5c4af1e617ab6c25b7485bc36b6d","permalink":"https://xueqing.github.io/blog/cplusplus/cplusplus_string_case_convert/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/cplusplus_string_case_convert/","section":"blog","summary":"#include \u0026lt;string\u0026gt; #include \u0026lt;algorithm\u0026gt; void CString::StringToUpper(std::string \u0026amp;str) { std::transform(str.begin(), str.end(), str.begin(), ::toupper); } void CString::StringToLower(std::string \u0026amp;str) { std::transform(str.begin(), str.end(), str.begin(), ::tolower); } 提示出错error: no matching function for call to ‘transform(__gnu_cxx::__normal_i","tags":["c++"],"title":"C++ string 转换大小写","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" UB(Undefined behavior):程序的行为没有限制。常见的未定义行为例子包括：数组访问内存越界，有符号数溢出，间接访问空指针，在一个表达式中无顺序多次修改标量，用不同类型的指针访问对象 UB and optimization\n 正确的 C++ 程序是没有未定义行为的，所以当编译器优化了含有 UB 的代码，程序会出现不可预料的结果 有符号数溢出，下面是 C++ 代码和对应可能生成的机器语言 没有溢出时返回 1，溢出时是 UB，编译器可能优化，每次都返回 1\nint foo(int x) { return x+1 \u0026gt; x; // either true or UB due to signed overflow }  foo(int): movl $1, %eax ret  访问越界，下面是 C++ 代码和对应可能生成的机器语言\n 访问下标在 0-3 时，如果存在元素 v 返回true，否则会访问越界，编译器可能优化，每次都返回 true，也不会访问越界\nint table[4] = {}; bool exists_in_table(int v) { // return true in one of the first 4 iterations or UB due to out-of-bounds access for (int i = 0; i \u0026lt;= 4; i++) { if (table[i] == v) return true; } return false; }  exists_in_table(int): movl $1, %eax ret  未初始化的标量，下面是 C++ 代码和对应可能生成的机器语言\n 当 x 非 0 时，a 会被赋值 42，否则 a 未初始化，编译器可能优化，每次都将 a 赋值42，然后返回\nstd::size_t f(int x) { std::size_t a; if(x) // either x nonzero or UB a = 42; return a; }  f(int): mov eax, 42 ret  间接访问空指针，下面是 C++ 代码和对应可能生成的机器语言\n 函数foo：当 p 是空指针时，x 的赋值是间接访问空指针。否则返回 0。编译器可能优化，每次返回 0 而不会访问到空指针\n xorl %eax,%eax按位异或，相当于清 0，将寄存器%eax设置为 0。也可以使用movl $0,%eax，但是前者需要 2 个字节，后者需要 5 个字节  函数bar：直接访问空指针指向的值是 UB，编译器可能优化，每次直接执行下一行代码\n retq等同于addq $8,%rsp; jmpq -8(%rsp)，retq将%esp指向的返回地址弹出，存入寄存器%eip 寄存器%eip是程序计数器，存储了 CPU 要读取指令的地址，即 CPU 将要执行的指令的地址。每次 CPU执行完相应的汇编指令后，%eip的值就会增加 寄存器%esp是栈指针指向栈顶元素。栈向低地址方向增长，可以通过增加栈指针来释放空间 函数调用时会先将返回地址入栈，即程序中紧跟在调用函数后面的那条指令的地址，所以栈顶指针%esp指向的就是调用函数后面的那条指令的地址，retq会将该地址存入%eip，CPU 就会继续往后执行 在 64-bit 时，ret会从栈中弹出四字节的地址保存到寄存器%eip 在 32-bit 时，ret会从栈中弹出两字节的地址保存到寄存器%eip\nint foo(int* p) { int x = *p; if(!p) return x; // Either UB above or this branch is never taken else return 0; } int bar() { int* p = nullptr; return *p; // Unconditional UB }  foo(int*): xorl %eax, %eax ret bar(): retq     ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"866b2bab3f174401b8bb836b4e48b466","permalink":"https://xueqing.github.io/blog/cplusplus/undefined_behavior/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/undefined_behavior/","section":"blog","summary":"UB(Undefined behavior):程序的行为没有限制。常见的未定义行为例子包括：数组访问内存越界，有符号数溢出，间接访问空指针，在一个表达式中无顺序多次","tags":["c++"],"title":"C++ 未定义的行为","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  Chrome 导入和导出密码  启用功能 导出密码 导入密码 重置功能 密码管理软件   启用功能  进入地址栏，输入chrome://flags/#PasswordImport，启用功能并重启浏览器生效  导出密码  打开 Chrome，进入 [settings] — [passwords]，可看到已保存的密码列表 右键点击 [Saved Passwords] 右面的图标，下拉菜单选择 [Export passwords\u0026hellip;]，选择保存的文件夹，确定 为保障安全，在进行密码导出时先输入当前 Windows 用户的密码以完成身价验证，验证成功后 Chrome 才会将密码导出成以逗号分隔的 Excel 文件(CSV)  导入密码  打开 Chrome，进入 [settings] — [passwords]，可看到已保存的密码列表 右键点击 [Saved Passwords] 右面的图标，下拉菜单选择 [Import]，选择导入的文件，确定  重置功能  进入地址栏，输入chrome://flags/#PasswordImport，重置功能并重启浏览器生效  密码管理软件 Lastpass、1Password（推荐）、Keepass\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"edf22ac4242f434d856bb2d39df29c24","permalink":"https://xueqing.github.io/blog/chrome/ex_import_pwd/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/chrome/ex_import_pwd/","section":"blog","summary":"Chrome 导入和导出密码 启用功能 导出密码 导入密码 重置功能 密码管理软件 启用功能 进入地址栏，输入chrome://flags/#PasswordImpo","tags":["chrome"],"title":"Chrome 导入和导出密码","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"   插件 功能     Infinity 新标签页，还有邮件提醒、天气预报、笔记、TODO、壁纸、历史记录等   QRImagefromURL 把 Chrome 当前的网址，生成标准二维码格式图片，扫描二维码会得到网址，就可以使用扫描软件自带的浏览器进行阅读   DotVPN 免费的 VPN 代理插件，相比 ProxySwitchySharp 代理插件，DotVPN 具有很强大的数据保护功能，可以保障用户在使用 VPN 代理时的数据传输安全   小云插件 优酷、土豆、爱奇艺、乐视网、搜狐视频、酷六、腾讯视频、等视频去广告插件   谷歌卫星地图 每天打开标签页都是随机的卫星地图，点击右下角的地球标志可切换位置   VideoHunter+ 可帮助用户找到正在播放视频的真实网络地址，用户可根据这个地址直接下载视频到本地计算机   如意淘插件 查看某商品在各大商城的价格对比，以及该商品的在该商场的价格走势   购物党自动比价工具 查看某商品在各大商城的价格对比，以及该商品的在该商场的价格走势    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8b85a5a8c0bcd783998bd97ac438ffa5","permalink":"https://xueqing.github.io/blog/chrome/extensions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/chrome/extensions/","section":"blog","summary":"插件 功能 Infinity 新标签页，还有邮件提醒、天气预报、笔记、TODO、壁纸、历史记录等 QRImagefromURL 把 Chrome 当前的网址，生成标准二维码格式图片，扫描二维码会得到网址，","tags":["chrome"],"title":"Chrome 插件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  关于 CR  目的 前提 需要做什么 步骤 标准  执行  事前准备阶段 实施阶段 事后跟踪  注意事项  经常进行 CR CR 不要太正式，而且要短 尽可能的让不同的人 Reivew 你的代码 保持积极的正面的态度 学会享受 CR  操作  自我审查 开发互审 上级审查 冲突解决  附录 审核记录 附录 审核结果  关于 CR 代码审查(Code Review, CR)是项目进展到编码阶段非常重要的品质保证活动\n目的  CR 是一种用来确认方案设计和代码实现的质量保证机制，通过这个机制我们可以对代码、测试过程和注释进行检查 CR 主要用来在软件工程过程中改进代码质量，通过 CR 可以达到如下目的  在项目早期发现代码中的 BUG 帮助初级开发人员学习高级开发人员的经验，达到知识共享 避免开发人员犯一些很常见，很普通的错误 保证项目组人员的良好沟通 项目或产品的代码更容易维护   前提  进入 CR 需要检查的条件如下  CR 人员是否理解了 CR 的概念和 CR 将做什么 如果做 CR 的人员不能理解 CR 对项目成败和代码质量的重要程度，他们的做法可能就会是应付了事 代码是否已经正确的 build，build 使得代码已经不存在基本语法错误 我们总不希望高级开发人员或是主管将时间浪费在检查连编译都通不过的代码上吧 代码执行时功能是否正确 CR 人员不负责检查代码的功能是否正确，需要复查的代码必须由开发人员或质量人员负责该代码的功能的正确性 Review 人员是否理解代码 做复查的人员需要对该代码有一个基本的了解，其功能是什么，是哪一方面的代码，涉及到数据库或是通讯，这样才能采取针对性的检查 开发人员是否对代码做了单元测试 这一点也是为了保证 CR 前一些语法和功能问题已经得到解决，CR 人员可以将精力集中在代码的质量上   需要做什么 CR 主要检查代码中是否存在以下方面问题： 代码的一致性、编码风格、代码的安全问题、代码冗余、是否正确设计以满足需求(性能、功能）等等 以下内容参考了《Software Quality Assurance: Documentation and Reviews》一文中的代码检查部分\n 完整性检查(Completeness)  代码是否完全实现了设计文档中提出的功能需求 代码是否已按照设计文档进行了集成和 Debug 代码是否已创建了需要的数据库，包括正确的初始化数据 代码中是否存在任何没有定义或没有引用到的变量、常数或数据类型  一致性检查(Consistency)  代码的逻辑是否符合设计文档 代码中使用的格式、符号、结构等风格是否保持一致  正确性检查(Correctness)  代码是否符合制定的标准 所有的变量都被正确定义和使用 所有的注释都是准确的 所有的程序调用都使用了正确的参数个数  可修改性检查(Modifiability)  代码涉及到的常量是否易于修改(如使用配置、定义为类常量、使用专门的常量类等) 代码中是否包含了交叉说明或数据字典，以描述程序是如何对变量和常量进行访问的 代码是否只有一个出口和一个入口(严重的异常处理除外)  可预测性检查(Predictability)  代码所用的开发语言是否具有定义良好的语法和语义 是否代码避免了依赖于开发语言缺省提供的功能 代码是否无意中陷入了死循环 代码是否是否避免了无穷递归  健壮性检查(Robustness)  代码是否采取措施避免运行时错误(如数组边界溢出、被零除、值越界、堆栈溢出等)  结构性检查(Structuredness)  程序的每个功能是否都作为一个可辩识的代码块存在 循环是否只有一个入口  可追溯性检查(Traceability)  代码是否对每个程序进行了唯一标识 是否有一个交叉引用的框架可以用来在代码和开发文档之间相互对应 代码是否包括一个修订历史记录，记录中对代码的修改和原因都有记录 是否所有的安全功能都有标识  可理解性检查(Understandability)  注释是否足够清晰的描述每个子程序 是否使用到不明确或不必要的复杂代码，它们是否被清楚的注释 使用一些统一的格式化技巧(如缩进、空白等）用来增强代码的清晰度 是否在定义命名规则时采用了便于记忆，反映类型等方法 每个变量都定义了合法的取值范围 代码中的算法是否符合开发文档中描述的数学模型  可验证性检查(Verifiability)  代码中的实现技术是否便于测试   步骤  代码编写者和代码审核者坐在一起，由代码编写者按照设计文档中的用例依次讲解自己负责的代码和相关逻辑  可采用从前端到后台的方式，例如从 Web 层到 DAO 层  代码审核者在此过程中可以随时提出自己的疑问，同时积极发现隐藏的 bug  对这些 bug 记录在案 代码编写者修改后再次提交审核 代码审核者对 bug 记录进行回验  代码讲解完毕后，代码审核者给自己安排几个小时再对代码审核一遍  代码需要一行一行静下心看。同时代码又要全面的看，以确保代码整体上设计优良  代码审核者根据审核的结果编写“审核报告”  “审核报告”中记录发现的问题及修改建议 将“审核记录”和“审核结果”提交至 git  代码编写者从 git 拉取，根据“审核报告”给出的修改意见，修改好代码，有不清楚的地方可积极向代码审核者提出 代码编写者 bug fix 完毕之后提交代码审核者再次进行审核  通过审核则更新审核结果并提交至 git 审核通过的代码不能再进行修改，需要修改必须重新进行审核流程  代码审核者把 CR 中发现的有价值的问题更新到\u0026rdquo;代码审核规范\u0026rdquo;的文档中，对于特别值得提醒的问题可群发 email 给所有技术人员  提示：CR 必备的文档\n “代码审核规范”文档：记录代码应该遵循的标准 代码审核者根据这些标准来 CR 代码，同时在 CR 过程中不断完善该文档  标准 代码审核的基础是 设计文档规范、代码规范、日志规范、测试代码规范。针对新增的业务场景和设计尚未有规范时应先确立规范后进行代码审核流程\n执行 一个标准的 CR 活动应该分为三个阶段\n事前准备阶段 在一次 CR 前，对以下内容进行充分准备\n CR 的对象  在准备 CR 代码对象时，我们要注意代码的数量，如果代码量比较大，要对代码进行必要的分解，确定其中的关键代码，对关键代码进行 CR，可以达到举一反三的目的  CR 的内容  我们对代码的审查内容很多，如代码的编写是否规范（注释的书写格式、命名规范等）、技术处理规范（异常处理、日志处理、代码组织结构等）、业务实现等 我们不能希望通过一次 CR 活动，完成所有这些内容的审查，因此我们必须设定本次 CR 活动内容界限，确定审查重点  评审规范和标准  在 CR 前设计确定评审规范和标准是必要，通过规范和标准我们在审查过程中可以有据可依，有理可循，而且还可以做到标准统一  选择 CR 活动的参与者  在 CR 开始前，必须把本次 CR 活动的对象、审查内容以及审查的规范和标准通报给所有的参与者  选择 CR 活动的实施方式  CR 活动有很多形式可供我们选择，我们可以根据实际情况选择桌面式 CR、演示讲解式 CR、一对一的座位 CR 等等   实施阶段 充分的事前准备，只是做好 CR 活动的前提，在 CR 实施过程中，我们要做好以下工作\n 准确记录  对于 CR 过程发现的问题，我们必须清晰准确的记录，可以使用问题点记录单，明确记录的项目和内容  讲解与提问  CR 过程中，要采用代码作者讲解和审查者提问方式。审查者不能只在发现问题时提问，同时也要根据本次审查的内容要求代码作者对某个特定问题的讲解  逐项审查  对事前确定的审查内容，要逐项审查，不能因为时间不足等因素一扫而过  注意气氛  实施审查时，要营造一个讨论问题、解决问题的氛围，不能把审查会搞成批判会，这样会影响相关人员的积极性   事后跟踪  确认发现的问题  CR 结束后，对发现的问题，首先需要确定以下内容 问题点的难易程度以及影响的范围 解决问题的责任者和问题点修正结果的确认者 解决问题点的时限  修正问题责任者  对于修正问题责任者，在问题点的修正过程中，要三方面内容的记录 问题点的原因 解决问题点的对策 修正的内容  修正结果确认者  做为修正结果的确认者，必须按照事前约定的时限及时的对修正结果进行全面的确认   注意事项 经常进行 CR  要 Review 的代码越多，那么要重构，重写的代码就会越多。而越不被程序作者接受的建议也会越多，唾沫口水战也会越多  建议每一个功能，每一个用例完成之后就进行审核  程序员代码写得时候越长，程序员就会在代码中加入越来越多的个人的东西 越接近软件发布的最终期限，代码也就不能改得太多  先 review 设计实现思路 review 设计模式 review 成形的骨干代码 review完成的代码 如果程序复杂的话，需要拆成几个单元或模块分别 review 每次 review 的代码再 1000 行以内，时间不超过 1.5 小时   CR 不要太正式，而且要短 忘了那个代码评审的 Checklist 吧，走到你的同事座位跟前，像请师父一样请他坐到你的电脑面前，然后，花 5 分钟给他讲讲你的代码，给他另外一个 5 分钟让他给你的代码提提意见，这比什么都好。而如果你用了一个 Checklist，让这个事情表现得很正式的话，下面两件事中必有一件事会发生：\n 只有在 Checklist 上存在的东西才会被 Review CR 变成了一种礼节性的东西，你的同事会装做很关心你的代码，但其实他心里想着尽快地离开你  只有不正式的 CR 才会让你和评审者放轻松，人只有放松了，才会表现得很真实，很真诚。记住R eview 只不过是一种形式，而只有在相互信任中通过相互的讨论得到了有意义和有建设性的建议和意见，那才是最实在的。不然，作者和评审者的关系就会变成小偷和警察的关系。\n尽可能的让不同的人 Reivew 你的代码 如果可能的话，不要总是只找一个人来 Review 你的代码，不同的人有不同的思考方式，有不同的见解，所以，不同的人可以全面的从各个方面评论你的代码。 但不要太多了，人多嘴杂反而适得其反，基本上来说，不要超过3个人，这是因为，这是一个可以围在一起讨论的最大人员尺寸。\n下面是几个优点\n 从不同的方向（实现、需求、用户使用、算法、性能效率、易读性、扩展性）评审代码总是好的 会有更多的人帮你在日后维护你的代码 这也是一个增加团队凝聚力的方法 不要超过 3 个人，减少讨论的代价  保持积极的正面的态度 程序员最大的问题就是“自负”，尤其当我们 Reivew 别人的代码的时候，我已经见过无数的场面，程序员在 CR 的时候，开始抨击别人的代码，质疑别人的能力。太可笑了，我分析了一下，这类的程序员其实并没有什么本事，因为他们指责对方的目的是想告诉大家自己有多么的牛，靠这种手段来表现自己的程序员，其实是就是传说中所说的“半瓶水”。\n所以，无论是代码作者，还是评审者，都需要一种积极向上的正面的态度，作者需要能够虚心接受别人的建议，因为别人的建议是为了让你做得更好；评审者也需要以一种积极的正面的态度向作者提意见，因为那是和你在一个战壕里的战友。记住，你不是一段代码，你是一个人！\n学会享受 CR 这可能是最重要的一个提示了，如果你到了一个人人都喜欢 CR 的团队，那么你会进入到一个生机勃勃的地方，在那里，每个人都能写出质量非常好的代码，在那里，你不需要经理的管理，团队会自适应一切变化，他们相互学习，相互帮助，不仅仅是写出好的代码，而且团队和其中的每个人都会自动进化，最关键的是，这个是一个团队\n操作 自我审查  提交代码前自我审查，添加对代码的说明  所有团队成员先进行自我审查，除了检查代码的正确性以外，还可以完成 对代码添加注释，说明本次修改背后的原因，方便其他人进行审查 修正编码风格，尤其是一些关键数据和方法的命名，提高代码的可读性 从全局审视设计，是否完整的考虑了所有情景 提交自己的单元测试报告   开发互审 任意两名开发人员（建议不要固定配对，避免思维定式）进行交叉代码审查\n 代码编写者：  准备所开发的代码相关的全部资料列表：需求、设计文档、代码工程、类、方法、配置文件、数据库修改等全部资料的版本号等详细信息 向代码审查者全面介绍代码的目标和设计实现  代码审查者  根据需求文档、设计文档、开发规范进行代码审查（业务、日志、测试） 将审查结果提交至 git 代码编写者对问题进行修改并由代码审查者复审，复审结果提交至 git 保留 代码审查者对审查的代码负责   上级审查 开发互审完成后，由上级进行上级审查，流程与开发互审相同，对于三次复审仍未通过的代码需要代码编写者进行组内检讨问题原因，并书面列出改进计划\n冲突解决 当开发互审对于检查内容出现争议时由上级进行协调解决或逐级向上协调解决\n附录 审核记录  审核记录如同修改记录一样，直接记录入代码头部，代码审核者修改审核记录后提交代码至 git 参考即可 之后的审核可以基于两次审核间的变更利用对比工具进行增量审核 示例如下\n/** * 名称：xxxxx类 * 创建者：xx * 创建时间：2018-12-07 * 创建描述：实现xxxxxx * 修改者：xxx * 修改时间：2018-12-08 * 修改描述：添加xxx，修改xxx * 审核者：xxx * 审核时间：2018-12-08 * 审核描述：审核通过 * 审核者：xxx * 审核时间：2018-12-09 * 审核描述：审核不通过，xxxxxxxxxxxxx */   附录 审核结果  审核结果建议以表格的形式描述，每个问题分别列出 可通过标注行号来具体执行位置，给出合理的修改意见并说明标准 审核结果写入 commit message 中，以软表格的形式描述\ndocs(代码审核)：审核通过 docs(代码审核)：审核失败 1 日志不符合规范 问题：没有使用 log4j2，日志不规范 建议：建议使用 log4j2，包括包引用和代码修改 行号：53 行 2 命名不符合规范 问题：log 命名不符合规范 建议：修改为 logger 行号： 53 行   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"88c3b8b4a34c3287c6eec6356369494e","permalink":"https://xueqing.github.io/blog/coolshell/code_review/codereview/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/coolshell/code_review/codereview/","section":"blog","summary":"关于 CR 目的 前提 需要做什么 步骤 标准 执行 事前准备阶段 实施阶段 事后跟踪 注意事项 经常进行 CR CR 不要太正式，而且要短 尽可能的让不同的人 Reivew 你的代码 保持积极","tags":["coolshell"],"title":"Code Review 代码审查","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" code_review 中的几个提示 从 code_review 谈如何做技术 简单实用的 code_review 工具 Review board  追踪待决代码的改动，并可以让 Code-Review 更为容易和简练  Codestriker Groogle  各式各样语言的语法高亮 支持整个版本树的比较 支持当个文件不同版本的 diff 功能，并有一个图形的版本树 邮件通知所有的 Reivew 的人当前的状态 认证机制  Rietveld JCR  主要面对的是大型的项目，或是非常正式的代码评审 主要想协助： 审查者：所有的代码更改会被高亮，以及大多数语言的语法高亮。Code extracts 可以显示代码评审意见。如果你正在 Review Java 的代码，你可以点击代码中的类名来查看相关的类的声明 项目所有者。可以轻松创建并配置需要 Review 的项目，并不需要集成任何的软件配置管理系统（SCM） 流程信仰者。所有的评语都会被记录在数据库中，并且会有状态报告，以及各种各样的统计 架构师和开发者。这个系统也可以让我们查看属于单个文件的评语，这样有利于我们重构代码  Jupiter  是一个 Eclipse IDE 的插件  风格检查工具：PC-Lint  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"176435cbe9d1948dcdaccdd43ea668b8","permalink":"https://xueqing.github.io/blog/coolshell/code_review/code_review/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/coolshell/code_review/code_review/","section":"blog","summary":"code_review 中的几个提示 从 code_review 谈如何做技术 简单实用的 code_review 工具 Review board 追踪待决代码的改动，并可以让 Code-Review 更为容易和简练 Codestriker Groogle 各式各样语言的语法高亮 支持整个版本树的比较","tags":["coolshell"],"title":"code_review 预研","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" sudo dpkg -i *.deb安装服务 卸载服务  dpkg -l | grep xxx查看包是否正确安装 第一列的ii指的是installed ok installed dpkg -r xxx移除安装包，但是保留配置文件 dpkg -P/--purge xxx完全移除安装包，包括配置文件 再用dpkg -l | grep xxx查看安装状态 使用-r移除，可以看到第一列的的状态是rc 使用-P移除，输出为空，找不到对应条目   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"db8cea1000699ae0fe6df1190f0380e2","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_dpkg/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_dpkg/","section":"blog","summary":"sudo dpkg -i *.deb安装服务 卸载服务 dpkg -l | grep xxx查看包是否正确安装 第一列的ii指的是installed ok installed dpkg -r xxx移除安装包，但是保留配置文","tags":["ubuntu","linux"],"title":"dpkg 安装和卸载程序","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1.让自己习惯 C++  01.视 C++ 为一个语言联邦 02.常量，枚举和内联优于宏定义 03.尽可能使用常量 04.确定对象被使用前已先被初始化  2.构造/析构/赋值运算  05.了解 C++ 默默编写并调用哪些函数 06.明确拒绝不想用的编译器自动生成的函数 07.声明多态基类析构函数为虚函数 08.别让异常逃离析构函数 09.绝不在构造和析构过程中调用虚函数 10.使 operator= 返回一个 *this 的引用 11.在 operator= 中处理“自我赋值” 12.复制对象的所有部分  3.资源管理  13.以对象管理资源 14.在资源管理类中小心复制行为 15.在资源管理类中提供对原始资源的访问 16.在对应的 new 和 delete 采用相同形式 17. 以独立语句将 newed 对象保存到智能指针  4.设计与声明  18.让接口易被正常使用，不易被误用 19.把类设计看作类型设计 20.常量引用传递优于值传递 21.必须返回对象时，不要返回引用 22.声明数据成员为私有的 23.成员函数优于非成员、非友元函数 24.当类型转换需应用到所有参数，声明为非成员函数 25.考虑支持不抛异常的 swap 函数  5.实现  26.尽可能推迟变量定义 27.最小化 cast 操作 28.避免返回指向对象内部的句柄 29.努力写异常安全的代码 30.了解内联的细节 31.最小化文件编译依赖  6.继承与面向对象设计  32.确保公有继承是\u0026rdquo;is-a\u0026rdquo;关系 33.避免隐藏继承的名字 34.区分接口继承和实现继承 35.考虑虚函数的替代 36.绝不重定义继承的非虚函数 37.绝不重定义函数继承的默认参数值 38.通过组合对\u0026rdquo;has-a\u0026rdquo;或\u0026rdquo;is-implemented-in-terms-of\u0026rdquo;建模 39.慎重使用私有继承 40.慎重使用多重继承  7.模板与泛型编程  41.理解隐式接口和编译期多态 42.理解 typename 的双重定义 43.了解如何访问模板化基类内的名称 44.把参数无关的代码分离出模板 45.使用成员函数模板来接受“所有兼容类型” 46.需要类型转化时在模板内定义非成员函数 47.使用 traits class 表现类型信息 48. 认识模板元编程  8.定制 new 和 delete  49.理解 new-handler 的行为 50.理解何时替换 new 和 delete 有意义 51.写 new 和 delete 时遵循惯例 52.写了 placement new 也要写 placement delete  9.杂项讨论  53.注意编译器警告 54.熟悉包括 TR1 在内的标准库 55.熟悉 Boost   1.让自己习惯 C++    Accustoming yourself to C++\n   01.视 C++ 为一个语言联邦    View C++ as a federation of languages\n    C 面向对象的 C++：类、封装、继承、多态 模板 C++：泛型编程 STL：模板库  02.常量，枚举和内联优于宏定义    Prefer consts, enums, inlines to #defines\n    对于单纯常量，以 const 对象或枚举 对于形似函数的宏，用内联函数替换  常量、枚举和内联更具封装性，可以限定作用域 枚举比常量约束更多，不能为该常量创建指针或引用   03.尽可能使用常量    Use const whenever possible\n    指定语义约束，即“不该被改动”的对象  可帮助编译器侦测错误用法  const 在 * 左边，表示被指物是常量  也可将 const 放在类型之前 例如const widget *pw等同于widget const *pw 指针所指东西不可被改动  const 在 * 右边，表示指针自身是常量  指针不得指向不同的东西，但所指东西的值可以改动  const 在 * 两侧，表示被指物和指针自身都是常量 const 成员函数  可作用于 const 对象，不可更改对象内任何非静态成员变量 成员变量前加mutable，也可在 const 成员函数内部修改该成员变量 当 const 和 non-const 成员函数有着实质等价的实现时，另 non-const 版本调用 const 版本避免代码重复   04.确定对象被使用前已先被初始化    Make sure that objects are initialized before they\u0026rsquo;re used\n    对于内置类型手动初始化 对于类，在构造函数中初始化成员变量  赋值不等于初始化 使用成员初始化列表列替换赋值动作，前者效率更高，后者先设初值再赋值 可使用无参数构造函数来初始化 对于多个构造函数，可添加私有成员函数，接收初始化参数，在函数内部使用赋值操作给成员变量“初始化” 初始化顺序 先基类再衍生类 类内部，按照声明的顺序初始化，与成员初始化列表列操作顺序无关 最好按照声明顺序初始化 不同编译单元内的 non-local static 对象的初始化顺序未定义  static 对象包括全局对象、定义于命名空间作用域内的对象、类内、函数内，以及在文件作用域内被声明为 static 的对象 函数内的 static 对象称为 local-static 对象，其他的则是 non-local static 对象 程序结束时 static 对象会被自动销毁，即在 main 函数结束时调用他们的析构函数 编译单元是产出单一目标文件的源码 将每个 non-local static 对象移到自己的专属函数内，改函数返回对该对象的引用，保证该函数被调用期间，首次遇到该对象的定义时被初始化，即以函数调用替换直接访问 non-local static 对象    2.构造/析构/赋值运算    Contructors, destructors, and assignments operators\n   05.了解 C++ 默默编写并调用哪些函数    Know what functions C++ silently writes and calls\n    编译器自动为类创建默认构造函数、拷贝构造函数、拷贝赋值操作和析构函数  06.明确拒绝不想用的编译器自动生成的函数    Explicitly disallow the use of complier-generated functions you do not want\n    如果不想用编译器自动生成的函数，可将相应的成员函数声明为 private 并且不予实现 可以继承 Uncopyable 这样的基类，但是可能会多重继承\nclass Uncopyable { protected: // allow constructor and destructor for derived object Uncopyable() {} ~Uncopyable() {} private: Uncopyable(const Uncopyable\u0026amp;); //avoid copying Uncopyable\u0026amp; operator=(const Uncopyable\u0026amp;); };   07.声明多态基类析构函数为虚函数    Declare destructors virtual in polymorphic base classes\n    包含虚函数的类需要额外的信息来实现虚函数：vptr(virtual table pointer)指向一个由函数指针构成的数组，称为 vtbl(virtual table)，每个有虚函数的类都有一个相应的 vtbl 析构顺序：先父类再子类，构造函数的调用顺序相反 带有多态性质的基类应声明一个虚析构函数 如果一个类带有任何虚函数，就声明一个虚析构函数 类的设计目的不是作为基类使用，或者不是为了多态性，不应该声明虚析构函数  08.别让异常逃离析构函数    Prevent exceptions from leaving destructors\n    如果析构函数内可能抛出异常，应该在析构函数内捕获异常，然后不传播或结束程序 如果需要客户自定义异常的反应，类应该提供接口执行该操作  09.绝不在构造和析构过程中调用虚函数    Never call virtual functions during construction or destruction\n    在构造和析构中不要调用虚函数没因为这类调用不会下降到衍生类，即调用的仍然是基类的实现  10.使 operator= 返回一个 *this 的引用    Having assignment operators return a reference to *this\n    赋值相关运算(包括 operator=/+=、-=、*=)操作符返回一个 *this 的引用  11.在 operator= 中处理“自我赋值”    Handle assignment to self in operator=\n    确保对象自我赋值时，operator= 行为良好，包括比较源对象和目标对象的地址、精心周到的语句顺序(先复制源对象，再执行删除)，以及icopy-and-swap 确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，行为仍然正确  12.复制对象的所有部分    Copy all parts of an object\n    拷贝构造函数和拷贝赋值操作符都是 copying 函数 copying 函数应该确保复制“对象内的所有成员变量”和“所有基类成分” 不要尝试以某个 copying 函数实现另一个 copying 函数，应该将相同的东西抽象成一个函数，二者都调用这个函数  3.资源管理    Resource management\n   13.以对象管理资源    Use objects to manage resources\n    为防止内存泄漏，建议使用 RAII(Resource Acquisition Is Initialization，资源取得时机就是初始化时机) 对象，它们在构造函数中获得资源并在析构函数中释放资源 常用的 RAII 类是 shared_ptr 和 auto_ptr。前者的拷贝行为比较直观，后者的复制动作会转移资源的所有权：shared_ptr 有引用计数，但是无法打破环装引用 参考智能指针一文  14.在资源管理类中小心复制行为    Think carefully about copying behavior in resource-managing classes\n    复制 RAII 对象必须一并复制它锁管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为 一般情况下，RAII 类的 copying 行为是：阻止 copying、实行引用计数法  15.在资源管理类中提供对原始资源的访问    Provide access to raw resources in resource-managing classes\n    APIs 往往要求访问原始资源，所以每一个 RAII 类应该提供一个接口可以获得其管理的资源 对原始资源的访问可以是显示转换或隐式转换：一般显示转换比较安全，隐式转换对客户比较方便  16.在对应的 new 和 delete 采用相同形式    Use the same form in corresponding uses of new and delete\n    调用 new 时使用[]，那么对应调用 delete 时也调用[] 调用 new 时没有使用[]，那么也不该在调用 delete 时使用[]  17. 以独立语句将 newed 对象保存到智能指针    Store newed onjects in smart pointers in standalone statements\n    以独立语句将 newed 对象保存在智能指针内。否则，抛出异常的时候，可能会导致内存泄漏  4.设计与声明    Designs and declarations\n   18.让接口易被正常使用，不易被误用    Make interfaces easy to use correctly and hard to use incorrectly\n    “促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容 “阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任 shared_ptr 支持自定义删除器，可以防止 DLL 问题，可被用来自动解除互斥锁  19.把类设计看作类型设计    Treat class design as type design\n   在设计一个类之前，考虑以下问题\n 新类型的对象如何被创建和销毁 对象的初始化和对象的赋值该有什么样的差别：区分构造函数和赋值操作符的行为 新类型的对象如果以值传递，意味着什么：取决于拷贝构造函数 什么是新类型的“合法值”：确定需要做的错误检查工作 新类型需要配合某个继承图系吗：受继承类的约束，如果允许被继承，析构函数是否为虚函数 新类型需要什么样的转换：显示类型转换和隐式类型转换 什么样的操作符和函数对此新类型是合理的：确定需要声明的函数，哪些是成员函数，哪些不是成员函数 谁该调用新类型的成员：确定成员的属性(public/protected/private)，也确定类之间的关系(所属，友元) 什么是新类型的未声明接口 新类型有多一般化：是否需要定义一个模板类 真的需要一个新类型吗：是否可以为已有类添加非成员函数或模板来实现  20.常量引用传递优于值传递    Prefer pass-by-reference-to-const to pass-by-value\n    值传递效率低，而且可能造成对象切割(slicing)：值传递一个衍生类对象时，如果函数声明的是基类，那么调用的是基类的拷贝构造函数 C++ 编译器底层使用指针实现，不同情形使用不同的方式  内置类型(如 int)采用值传递 STL 的迭代器和函数对象使用值传递 其他的采用常量引用传递   21.必须返回对象时，不要返回引用    Don\u0026rsquo;t try to return a reference when you must return an object\n    绝不要返回指针或引用指向一个 local stack 对象 绝不要返回引用指向一个 heap-allocated 对象 绝不要返回指针或引用指向一个 local static 对象而有可能同时需要多个这样的对象  22.声明数据成员为私有的    Declare data memebers private\n    语法一致性：public 接口内的所有东西都是函数 可细微划分访问控制、允诺约束条件获得保证 protected 并不比 public 更具封装性  23.成员函数优于非成员、非友元函数    Prefer non-member non-friend functions to member function\n    将所有功能函数放在多个头文件内但隶属同一命名空间，使用者可以轻松扩展这一组功能函数  在命名空间添加非成员非友元函数，以便为使用者提供方便的接口  优先考虑非成员、非友元函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性  24.当类型转换需应用到所有参数，声明为非成员函数    Declare non-member functions when type conversions should apply to all parameters\n    如果需要为某个函数的所有参数(包括被 this 指针所指的隐喻参数)进行类型转换，那么这个函数必须是非成员函数  编译器可对每一个实参执行隐式类型转换   25.考虑支持不抛异常的 swap 函数    Consider support for a non-throwing swap\n    如果 std::swap 缺省实现对自定义的类或类模板的效率不足，试着做  提供一个 public swap 成员函数，在函数内高效地置换两个对象值 在类或模板所在的命名空间提供一个非成员的 swap 函数，在函数内调用上述 swap 函数 如果正在编写一个类或类模板，让该类特化 std::swap，另其调用上述的 swap 函数  如果调用 swap，确定包含using std::swap，然后不加任何 namespace 修饰符，直接调用 swap，编译器就会查找适当的 swap 函数并调用 警告：成员函数 swap 不可抛出异常  5.实现    Implementations\n   26.尽可能推迟变量定义    Postpone variable definitions as long as possible\n    尽可能延后变量定义式的出现，最好是延后到可以用有意义的参数进行始化 对于循环，如果构造和析构的代码大于赋值操作，则将定义放在循环外  27.最小化 cast 操作    Minimize casting\n    C 风格的转换操作，将 expression 转换为 T：(T)expression和T(expression) C++ 另外提供 4 种转换操作  const_cast\u0026lt;T\u0026gt;( expression )用来移除对象的常量性，唯一可以实现这个目的的 C++ 风格的转换操作符 dynamic_cast\u0026lt;T\u0026gt;( expression )用于执行“安全向下转换”，用于确定某对象是否归属继承体系中的某个类型，可能耗费重大运行成本，唯一一个 C 风格无法实现的转换操作 reinterpret_cast\u0026lt;T\u0026gt;( expression )意图执行低级转换，实际动作和结果可能取决于编译器，即不可移植 static_cast\u0026lt;T\u0026gt;( expression )用于强迫隐式转换，例如 non-const 转换为 const，或者 int 转 double 等  倾向使用 C++ 风格的转换操作，不要使用 C 风格的转换  易被辨识，因而得以简化查找类型被破坏的过程 各转换工作有各自的局限，便于编译器诊断错误的运用  如果可以，尽量避免转换操作，特别是在注重效率的代码中避免 dynamic_cast，如果有需要，尝试改成无需转换的设计  使用类型安全容器，确定是哪种衍生类或基类 将虚函数放在父类，然后添加空实现  如果必须转换，试着用函数封装，可以调用函数，而无需将转换操作引入代码  28.避免返回指向对象内部的句柄    Avoid returning \u0026ldquo;handles\u0026rdquo; to object internals\n    避免返回 handles(包括引用、指针、迭代器)指向对象内部。一遍增加封装性，帮助 const 成员函数的行为像个 const，并将发生 dangling handles 的可能性降至最低  29.努力写异常安全的代码    Strive for exception-safe code\n    异常安全函数即使发生议程也不会内存泄漏或破坏任何数据结构。这样的函数分为三种可能的保证：基本型、强烈型、不抛异常型 “强烈保证”往往以 copy-and-swap 实现，但“强烈保证”并非对所有函数都可实现或具备现实意义 函数提供的“异常安全保证”通常最高只等于其调用的各个函数的“异常安全保证”中的最弱者  30.了解内联的细节    Understand the ins and outs of inlining\n    将大多数内联限制在小型、被频繁调用的函数。可使日后的调试过程和二进制升级更容易，也可最小化潜在的代码膨胀问题，最大化提升程序的速度  内联函数无法随着程序库的升级而升级：内联函数修改，用到该函数的程序必须重新编译 大部分调试器不支持内联函数调试  隐式内联：函数定义在类定义内 显式内联：添加关键字 inline  没有要求每个函数都是内联，就避免声明一个模板是内联  大多数编译拒绝复杂的函数内联：比如虚函数，带有循环或递归的函数。此时会有警告信息 编译器通常不对“通过函数指针进行的调用”执行内联 不要只因为函数模板出现在头文件，就将其声明为内联  31.最小化文件编译依赖    Minimize compilation dependencies between files\n    pimply idiom(pointer to implementation)：将一个类分为两个，一个提供接口，一个负责实现接口，前者在类内包含一个后者的 shared_ptr，做到“接口与实现分离” 使用接口类、衍生类和工厂模式进行实现 分离的关键在于“声明的依存性”替换“定义的依存性”：让头文件尽可能自我满足，万一做不到，则使用前置声明 设计策略  尽量使用对象引用或对象指针，而不是对象：可以在头文件中使用前置声明 尽量使用 class 声明式而不是 class 定义式 为声明式和定义式提供不同的头文件  程序头文件应该以“完全且仅有声明式”的形式存在  6.继承与面向对象设计    Inheritance and object-oriented design\n   32.确保公有继承是\u0026rdquo;is-a\u0026rdquo;关系    Make sure public inheritance models \u0026ldquo;is-a\u0026rdquo;\n    public 继承意味着 is-a。适用于基类的每一件事情一定适用于衍生类，每一个衍生类对象也都是一个基类对象  33.避免隐藏继承的名字    Avoid hiding inherited names\n    衍生类内的名称会隐藏基类内的名称  如果继承基类并加上重载函数，又希望重新定义或覆盖其中一部分，必须为那些原本会被隐藏的名称引入一个 using 声明式，否则继承的名称会被隐藏  为了让隐藏的名称仍然可见，可使用 using 声明式或 forwarding 函数  内置的 forwarding 函数的另一个用途是为那些不支持 using 声明式的编译器而用   34.区分接口继承和实现继承    Differentiate between inheritance of interface and inhertance of implementation\n    接口继承和实现继承不同。在 public 继承时，衍生类会继承基类的接口，即成员函数 声明纯虚函数的目的是让衍生类只继承函数接口 声明非纯虚函数的目的是让衍生类继承该函数的接口和缺省实现 声明非虚函数的目的是让衍生类继承函数的接口和一份强制性实现  35.考虑虚函数的替代    Condider alternatives to virtual functions\n    虚函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式  使用 non-virtual interface(NVI)手法，是 Template Method 设计模式的一种特殊形式。以 public non-virtual 成员函数包裹较低访问性的虚函数 将虚函数替换为“函数指针成员变量”。是 Strategy 设计模式的一种分解表现形式 以 function 成员变量替换虚函数，因而允许使用任何可调用实体(callable entities)搭配一个兼容与需求的签名式。这也是 Strategy 设计模式的某种形式 将继承体系内的虚函数替换为另一继承体系的虚函数。这是 Strategy 设计模式的传统实现手法  将功能从成员函数移到类外部，缺点是非成员函数无法访问类的 non-public 成员 function 对象的行为就像一般函数指针。这样的对象可接纳“与给定的目标签名式兼容”的所有可调用实体  36.绝不重定义继承的非虚函数    Never redefine an inherited non-virtual function\n    非虚函数是静态绑定的，虚函数是动态绑定的 任何情况下都不该重新定义一个继承而来的非虚函数，否则调用的函数取决于对象最开始的声明类型，跟实际所指类型无关  37.绝不重定义函数继承的默认参数值    Never redefine a function\u0026rsquo;s inherited default parameter value\n    虚函数是动态绑定，但是缺省参数是静态绑定  调用虚函数时，默认参数可能是基类的默认参数，而不是实际指向的父类的默认参数  静态类型是声明的类型，动态类型是“目前所指对象的类型”  动态类型可以表现出一个对象将会有什么行为 动态类型可在程序执行过程中改变  可以使用 NVI 手法：另基类内的一个 public 非虚函数调用 private 虚函数，后者可被衍生类重新定义。让非虚函数知道缺省参数，虚函数负责真正的工作  38.通过组合对\u0026rdquo;has-a\u0026rdquo;或\u0026rdquo;is-implemented-in-terms-of\u0026rdquo;建模    Model \u0026ldquo;has-a\u0026rdquo; or \u0026ldquo;is-implemented-in-terms-of\u0026rdquo; through composition\n    复合是类型间的一种关系，当某种类型的对象内包含其他类型的对象，就是复合关系 在应用域，复合意味着 has-a(有一个)。在实现域，复合以为着 is-implemented-in-terms-of(根据某物实现出)  39.慎重使用私有继承    Use private inheritance judiciously\n    private 继承意味着 is-implemented-in-terms-of。通常比复合的级别低，但是当衍生类需要访问基类的 protected 成员，或需要重新定义继承而来的虚函数时，private 继承是合理的  private 继承时，编译器不会自动将一个衍生类对象转换为一个基类对象 由 private 继承而来的所有成员，在衍生类中都是 private 属性 private 继承是一种实现技术，意味着只有实现部分被继承，接口部分应忽略  与复合相比，private 继承可以使得空白基类最优化(EBO, empty base optimization)。对致力于“对象尺寸最小化”的程序库开发者比较重要 尽可能使用复合，必要时采用 private 继承  当想要访问一个类的 protected 成员，或需要重新定义该类的一个或多个虚函数 当空间更加重要，衍生类的基类可以不包含任何 non-static 成员变量 “独立(非附属)”对象的大小一定不为零，不适用于单一继承(多重继承不可以)衍生类对象的基类   40.慎重使用多重继承    Use multiple inheritance judiciously\n    多重继承是继承一个以上的基类，但这些基类并不常在继承体系中又有基类  虚继承：防止多重继承时，基类之间又有基类，从而上层的基类的成员变量被父类复制 虚继承的类产生的对象体积更大，访问虚基类的成员变量速度慢，增加初始化(及赋值)的复杂度 如果虚基类不带任何数据，是具有使用价值的情况  多重继承比单一继承复杂，可能导致新的歧义性，以及对虚继承的需要 多重继承的用途：涉及“public 继承某个接口类”和“private 继承某个协助实现的类”  7.模板与泛型编程    Templates and generic programming\n   41.理解隐式接口和编译期多态    Understand implicit interfaces and compile-time polymorphism\n    类和模板都支持接口和多态 对类而言接口是显式的，以函数签名为中心。多态则是通过虚函数发生于运行期 对模板参数而言，接口是隐式的，基于有效表达式。多态则是通过模板具体化和函数重载解析，发生于编译期  42.理解 typename 的双重定义    Understand the two meanings of typename\n    声明模板类型参数的两种方式：  template\u0026lt;class T\u0026gt; class widget; template\u0026lt;typename T\u0026gt; class widget;  从属名称：模板内的名称依赖于某个模板参数  非从属名称：模板内不依赖模板参数的名称  嵌套从属名称：从属名称在类内呈嵌套状 嵌套从属类型名称：嵌套从属名称且指向某类型  想在模板中指定一个嵌套从属类型名称，就必须在紧邻它的前一个位置加上关键字 typename typename 不可出现在基类列表类的嵌套从属类型名称前，也不可在成员初始化列表中作为基类的修饰符   43.了解如何访问模板化基类内的名称    Know how to access names in templatized base classes\n    当基类从模板中被具体化时，它假设对基类的内容一无所知，即衍生类基类继承一个基类模板，不能再衍生类的实现中直接调用基类的成员(变量和函数)  可在衍生类模板内添加this-\u0026gt;指向基类模板的成员(变量和函数) 使用 using 声明式，假设已经存在这个成员(变量和函数) 明确指出被调用的函数位于基类内，使用基类::，如果是一个虚函数，会关闭虚函数的动态绑定行为   44.把参数无关的代码分离出模板    Factor parameter-independent code out of templates\n    模板生成多个类和多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生依赖关系 因非类型模板参数造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数 因类型参数造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表示的具体类型实现共享代码  45.使用成员函数模板来接受“所有兼容类型”    Use member function templates to accept \u0026ldquo;all compatible types\u0026rdquo;\n    具有基类-衍生类关系的两个类型分别具体化某个模板，生成的两个结构并不带有基类-衍生类关系 使用成员函数模板生成“可接受所有兼容类型”的函数 如果声明成员模板用于“泛化拷贝构造”或“泛化赋值操作”，必须声明正常的拷贝构造函数和拷贝赋值操作符  声明泛化拷贝构造函数和拷贝赋值操作符，不会阻止编译器生成默认的拷贝构造函数和拷贝赋值操作符   46.需要类型转化时在模板内定义非成员函数    Define non-member functions inside templates when type conversions are desired\n    模板实参推导过程中不会考虑隐式类型转换函数 写类模板时，当它提供的“与此模板相关的”函数支持“所有参数的隐式类型转换”时，将那些函数定义为类模板内部的友元函数  在类内部声明非成员函数作为友元函数，成为内联函数 为了将内联声明的影响最小化，在类外定义一个辅助函数模板，在友元函数内只调用辅助函数   47.使用 traits class 表现类型信息    Use traits classes for information about types\n    STL 有 5 种迭代器  input 迭代器：只能向前移动，一次异步，只可读取(不能修改)所指的东西，且只能读取一次。模仿了指向输入文件的读指针。如 C++ 的 istream_iterator output 迭代器：只能向前移动，一次一步，只可修改所指的东西，且只能修改一次。模仿了指向输出文件的写指针。如 C++ 的 ostream_iterator input 和 output 迭代器都只适合“单步操作算法(one-pass algorithms)” forward 迭代器：既能完成上述两种迭代器的工作，且可以读或写所指对象一次以上。使得可以实施“多步操作算法(multi-pass algorithms)”。如单向链表的迭代器 bidirectional 迭代器：既能完成 forward 迭代器的工作，还支持向后移动。STL 的 list/set/multiset/map/multimap 迭代器就属于这一分类 random access 迭代器：可以执行“迭代器运算”，即可以在常量时间内向前或向后跳跃任意距离。如 array/vector/deque/string 提供的都是随机访问迭代器  如何设计一个 traits 类  确认若干希望将来可取得的类型相关信息。例如迭代器希望取得分类(category) 为该信息选择一个名词。如迭代器是 iterator_category 提供一个模板和一组特化版本，其中包含希望支持的类型相关信息 traits 类的名称常以\u0026rdquo;traits\u0026rdquo;结束  如何使用一个 traits 类  建立一组重载函数(类似劳工)或函数模板，彼此间的差异只在于各自的 traits 参数。令每个函数实现与其接受的 traits 信息相对应 建立一个控制函数(类似工头)或函数模板，调用上述的函数并传递 traits 类所提供的信息  traits 类使得“类型相关信息”在编译期可用。它们以模板和一组“模板特化”完成实现 整合重载技术后，traits 类可在编译期对类型执行 if\u0026hellip;else 测试  48. 认识模板元编程    Be aware of template metaprogramming\n    模板元编程(TMP, template metaprogramming)是编写基于模板的 C++ 程序并在编译期执行的过程  即以 C++ 写成、在 C++ 编译期内执行的程序 TMP 程序结束执行，输出的 C++ 源码可以像往常一样编译 优点： 让某些事情更容易 可将工作从运行期转移到编译期。使得原本在运行期才可以侦测的错误在编译期被找到 TMP 的 C++ 程序在每一方面可能更加高效：较小的可执行文件、较短的运行期、较少的内存需求 缺点：导致编译时间变长  TMP 主要是函数式语言，可以达到的目的  确保度量单位正确：在编译期确保程序所有度量单位的组合是正确的 优化矩阵运算：使用 expression template，可能会消除中间计算生成的临时对象并合并循环 可生成用户自定义设计模式的实现品。设计模式如 Strategy/Observer/Visitor 等都可以多种方式实现  问题：  语法不直观 支持工具不充分，如没有调试器   8.定制 new 和 delete    Customizing new and delete\n    new和delete只适合分配单一对象；new []和delete []用来分配数组 STL 容器所使用的 heap 内存是由容器所拥有的分配器对象(allocator objects)管理，而不是 new 和 delete 管理  49.理解 new-handler 的行为    Understand the behavior of the new-handler\n    当 new 操作抛出异常以反映一个未获满足的内存需求之前，会先调研一个客户指定的错误处理函数，即 new-handler  可以用是set_new_handler设置该函数 参数是个指针，指向 new 无法分配足够内存时该调用的函数 返回值是个指针，指向set_new_handler被调用之前正在执行的 new_handler 函数 new_handler 是个 typedef，定义一个指针指向函数，函数没有参数也没有返回值  设计良好的 new-handler 函数  让更多内存可被使用：程序一开始执行就分配一大块内存，而后第一次调用 new-handler，将该内存释放给程序使用 设置另一个 new-handler：如果已知哪个 new-handler 可以获得更多可用内存，调用时设置该 new-handler 替换自己。比如令 new-handler 修改“会影响 new-handler 行为”的静态数据、命名空间数据或全局数据 取消设置 new-handler：即将 null 指针传给set_new_handler，内存分配不成功时就会抛异常 抛出 bad_alloc 或派生自 bad_alloc 的异常：该异常不会被 new 操作捕获，但会传播给请求内存的代码 不返回：通常调用 abort 或 exit  nothrow new是一个有局限性的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常  50.理解何时替换 new 和 delete 有意义    Understand when it makes sense to replace new and delete\n    三个替换编译器提供的 new 和 delete 理由：  检测运用上的错误：自定义 new 操作，可超额分配内存，以额外空间放置特定的 byte patterns(即签名，signature)。对应的 delete 操作可以检查上述签名是否原封不动，若否表示在分配区的某个声生命时间点发生了 overrun(写入点在分配区块尾端之后) 或 underrun(写入点在分配区块起点之前)。此时 delete 可以日志记录该时间和发生错误的指针 强化效能：编译器的 new 和 delete 无法解决碎片问题，导致程序可能无法申请大区块内存。通常来说这种自定制的性能更好 收集使用上的统计数据：先收集软件如何使用动态内存，包括分配区块的大小分布、寿命分布、分配和释放的次序(FIFO/LIFO/随机)、任何时刻内存分配上限 增加分配和释放的速度：当定制型分配器专门针对某特定类型的对象设计时，往往比泛用型分配器更快 降低缺省内存管理器带来的空间额外开销：泛用型内存管理器往往使用更多内存 弥补缺省分配器中的非最佳对齐：缺省的分配器一般是 4 字节对齐，但是对于 x86 最好是 8 字节对齐 将相关对象成簇集中：将往往被一起使用某个数据结构放在一起创建，可以减少 page fault 的错误 获得非传统的行为：比如添加数据初始化工作   51.写 new 和 delete 时遵循惯例    Adhere to convention when writing new and delete\n    new 操作  应该包含一个无穷循环，并在其中尝试分配内存 如果无法满足需求，调用 new-handler 也应该可以处理 0 字节申请 类的自定义版本还应该处理“比正确大小更大的(错误)申请”  delete 操作  收到 null 指针不做任何事 类的自定义版本还应该处理“比正确大小更大的(错误)申请”   52.写了 placement new 也要写 placement delete    Write placement delete if you write placement new\n    如果自己实现一个 placement operator new，也要写出对应的 placement operator delete。否则会发生隐蔽时断时续的内存泄漏 当声明 placement new 和 placement delete，确定不要无意识地遮掩它们的正常版本  9.杂项讨论    Miscellany\n   53.注意编译器警告    Pay attention to compiler warnings\n    严肃对待编译器发出的警告信息。努力在编译器的最高(最严苛)警告级别下争取“无任何警告” 不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度不相同。一旦移植到另一个编译器上，原本依赖的警告信息有可能消失  54.熟悉包括 TR1 在内的标准库    Familiarize yourself with the standard library, including TR1\n   55.熟悉 Boost    Familiarize yourself with Boost\n   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"61e64427a86d0540bec36fb21584afdc","permalink":"https://xueqing.github.io/blog/cplusplus/effectivec++_3/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/effectivec++_3/","section":"blog","summary":"1.让自己习惯 C++ 01.视 C++ 为一个语言联邦 02.常量，枚举和内联优于宏定义 03.尽可能使用常量 04.确定对象被使用前已先被初始化 2.构造/析构","tags":["c++"],"title":"Effective C++, 3rd","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"/* Exercise: Equivalent Binary Trees 1. Implement the Walk function. 2. Test the Walk function. The function tree.New(k) constructs a randomly-structured (but always sorted) binary tree holding the values k, 2k, 3k, ..., 10k. Create a new channel ch and kick off the walker: go Walk(tree.New(1), ch) Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10. 3. Implement the Same function using Walk to determine whether t1 and t2 store the same values. 4. Test the Same function. Same(tree.New(1), tree.New(1)) should return true, and Same(tree.New(1), tree.New(2)) should return false. The documentation for Tree can be found here. */ package main import ( \u0026quot;fmt\u0026quot; \u0026quot;golang.org/x/tour/tree\u0026quot; ) // Walk walks the tree t sending all values // from the tree to the channel ch. func Walk(t *tree.Tree, ch chan int) { if t.Left != nil { Walk(t.Left, ch) } ch \u0026lt;- t.Value if (t.Right) != nil { Walk(t.Right, ch) } } // Same determines whether the trees // t1 and t2 contain the same values. func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int) ch2 := make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for i := 1; i \u0026lt;= 10; i++ { v1, v2 := \u0026lt;-ch1, \u0026lt;-ch2 fmt.Println(\u0026quot;Walk two tree: \u0026quot;, v1, v2) if v1 != v2 { return false } } return true } func main() { ch := make(chan int) go Walk(tree.New(1), ch) for i := 1; i \u0026lt;= 10; i++ { v := \u0026lt;-ch fmt.Println(\u0026quot;Walk tree: \u0026quot;, v) if i != v { fmt.Println(\u0026quot;Test Walk failure\u0026quot;) return } } fmt.Println(\u0026quot;Test Walk success\u0026quot;) if Same(tree.New(1), tree.New(1)) \u0026amp;\u0026amp; !Same(tree.New(1), tree.New(2)) { fmt.Println(\u0026quot;Test Same success\u0026quot;) } else { fmt.Println(\u0026quot;Test Same failure\u0026quot;) } }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8f43c5f8e8deabd910d89681c886891d","permalink":"https://xueqing.github.io/translation/go-doc/gotour/equivalent_binary_trees/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/equivalent_binary_trees/","section":"translation","summary":"/* Exercise: Equivalent Binary Trees 1. Implement the Walk function. 2. Test the Walk function. The function tree.New(k) constructs a randomly-structured (but always sorted) binary tree holding the values k, 2k, 3k, ..., 10k. Create a new channel ch and kick off the walker: go Walk(tree.New(1), ch) Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10. 3. Implement the Same function using Walk to determine whether t1 and t2 store the same values.","tags":["go-tour"],"title":"Equivalent Binary Trees","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"/* Exercise: Errors Copy your Sqrt function from the earlier exercise and modify it to return an error value. Sqrt should return a non-nil error value when given a negative number, as it doesn't support complex numbers. Create a new type type ErrNegativeSqrt float64 and make it an error by giving it a func (e ErrNegativeSqrt) Error() string method such that ErrNegativeSqrt(-2).Error() returns \u0026quot;cannot Sqrt negative number: -2\u0026quot;. Note: A call to fmt.Sprint(e) inside the Error method will send the program into an infinite loop. You can avoid this by converting e first: fmt.Sprint(float64(e)). Why? Change your Sqrt function to return an ErrNegativeSqrt value when given a negative number. */ package main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type errNegativeSqrt float64 func (e errNegativeSqrt) Error() string { // 因为e变量是一个通过实现Error()的接口函数成为了error类型，那么在fmt.Sprint(e)时就会调用e.Error()来输出错误的字符串信息 return fmt.Sprint(\u0026quot;cannot Sqrt negative number: \u0026quot;, float64(e)) } func mySqrt(x float64) (float64, error) { if x \u0026lt; 0 { return -1, errNegativeSqrt(x) } z := x / 2 tmp := 0.0 for math.Abs(z-tmp) \u0026gt;= 0.000000000001 { tmp = z z -= (z*z - x) / (2 * z) } return z, nil } func main() { fmt.Println(mySqrt(2)) fmt.Println(mySqrt(-2)) }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"77be69173bb7bda00f50c1a51e0b8e74","permalink":"https://xueqing.github.io/translation/go-doc/gotour/errors/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/errors/","section":"translation","summary":"/* Exercise: Errors Copy your Sqrt function from the earlier exercise and modify it to return an error value. Sqrt should return a non-nil error value when given a negative number, as it doesn't support complex numbers. Create a new type type ErrNegativeSqrt float64 and make it an error by giving it a func (e ErrNegativeSqrt) Error() string method such that ErrNegativeSqrt(-2).Error() returns \u0026quot;cannot Sqrt negative number: -2\u0026quot;. Note: A","tags":["go-tour"],"title":"Errors","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":" 原文\n 概述 示例  EXTM3U EXT-X-PLAYLIST-TYPE EXT-X-TARGETDURATION EXT-X-VERSION EXT-X-MEDIA-SEQUENCE EXTINF  更新 playlist 文件  概述 通过 EXT-X-PLAYLIST-TYPE 标记的值设为 EVENT 指定一个 event playlist。它起初没有 EXT-X-ENDLIST 标签，表示当新的媒体文件可访问时将会被加到 playlist。\n示例 下面的代码是一个第一个出现在会话中的 event playlist 的示例：\n#EXTM3U #EXT-X-PLAYLIST-TYPE:EVENT #EXT-X-TARGETDURATION:10 #EXT-X-VERSION:4 #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.00, fileSequence0.ts #EXTINF:10.0, fileSequence1.ts #EXTINF:10.0, fileSequence2.ts #EXTINF:10.0, fileSequence3.ts #EXTINF:10.0, fileSequence4.ts  event playlist 示例中使用的标记有：\nEXTM3U 表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。\nEXT-X-PLAYLIST-TYPE 提供了适用于整个 playlist 文件的易变信息。这个标记可能包含一个 EVENT 或 VOD 值。如果标记存在且值为 EVENT，服务器一定不能修改或删除 playlist 文件的任意部分(但是它可以追加行到 playlist 文件)。如果标记存在且值为 VOD，playlist 文件一定不能改变。\nEXT-X-TARGETDURATION 指定最大的媒体文件时长。\nEXT-X-VERSION 表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。\nEXT-X-MEDIA-SEQUENCE 表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。\nEXTINF 一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。\n注意：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。\n更新 playlist 文件 当使用 EVENT 标记时，你不能从 playlist 中删除任何东西；你只可能追加新的片段到文件直到这个事件终止，那是会追加一个 EXT-X-ENDLIST 标签。下面的示例展示了使用新的媒体 URL 更新且该事件已经终止的同一 playlist：\n#EXTM3U #EXT-X-PLAYLIST-TYPE:EVENT #EXT-X-TARGETDURATION:10 #EXT-X-VERSION:4 #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, fileSequence0.ts #EXTINF:10.0, fileSequence1.ts #EXTINF:10.0, fileSequence2.ts #EXTINF:10.0, fileSequence3.ts #EXTINF:10.0, fileSequence4.ts // List of files between 4 and 120 go here. #EXTINF:10.0, fileSequence120.ts #EXTINF:10.0, fileSequence121.ts #EXT-X-ENDLIST  大概你想要支持用户跳转到事件内的任何一点时，比如一个音乐会或者运动事件，通常使用 event playlist。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"189a40cddce9dea9d35a61826ae5a5f7","permalink":"https://xueqing.github.io/translation/hls/event_playlist_construction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/hls/event_playlist_construction/","section":"translation","summary":"原文 概述 示例 EXTM3U EXT-X-PLAYLIST-TYPE EXT-X-TARGETDURATION EXT-X-VERSION EXT-X-MEDIA-SEQUENCE EXTINF 更新 playlist 文件 概述 通过 EXT-X-PLAYLIST-TYPE 标记的值设为 EVENT 指定一个 event playlist。它起初没有 EXT-X-ENDLIST 标签，表示当新的媒体文件可访问时将会被加到","tags":["hls"],"title":"Event playlist 构造","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" expect 是用来进行自动化控制和测试的工具，可以执行交互式的脚本 在执行脚本过程中，一些交互式的过程可能需要用户输入等信息，这种情况下课使用 expect 脚本 基本命令  send：向进程发送字符串，用于模拟用户的输入，一定要加 \\r 回车 expect：从进程接收字符串 spawn：启动进程，spawn 启动的进程的输出可被 expect 捕获 interact：用户交互  下面的脚本可将文件 scp 远程拷贝到某台机器\n#!/usr/bin/expect set timeout 100 ## 设置超时时间， -1 可无限等待 set filename [lindex $argv 0] ## 接收输入参数，保存文件名 set machineURL [lindex $argv 1] ## 接收输入参数，保存远程机器的上传的 URL，包括用户名，IP 地址和路径 set machinePWD [lindex $argv 2] ## 接收输入参数，保存远程机器的密码 spawn scp $filename $machineURL ## 执行 scp 命令 expect { \u0026quot;yes/no\u0026quot; { send \u0026quot;yes\\r\u0026quot;; exp_continue} ## 如果出现\u0026quot;yes/no\u0026quot;，则输入\u0026quot;yes\u0026quot;，然后继续这个循环 \u0026quot;password:\u0026quot; { send \u0026quot;$machinePWD\\r\u0026quot; } ## 如果出现\u0026quot;password:\u0026quot;，则输入保存的密码，然后退出这个循环，继续往下 } expect 100% ## 出现 100% 表明上传成功 expect eof ## 等待结束标记，由 spawn 启动的命令在结束时回产生一个 eof 标记   注意： expect 不能正确解释 shell 的 glob 模式，所以执行类似 spawn scp -r /home/user/dir1/ cluster_server: 的命令会出错。解决方法：\nspawn bash -c \u0026quot;scp -r /home/user/dir1/* cluster_server:\u0026quot;  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e14aaeb85897003bf3d8924abd926e3c","permalink":"https://xueqing.github.io/blog/shell/expect_shell/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/shell/expect_shell/","section":"blog","summary":"expect 是用来进行自动化控制和测试的工具，可以执行交互式的脚本 在执行脚本过程中，一些交互式的过程可能需要用户输入等信息，这种情况下课使用 expect 脚本 基本","tags":["shell","expect"],"title":"expect 脚本","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 播放器一般原理 Windows DirectShow\n 媒体文件基本模块：读文件、解复用、视频解码、音频解码、颜色空间转换、视频显示、音频播放 模块：过滤器 filter。  输入输出：pin，管脚。input pin 和 output pin source filter 和 sink filter filter 组成 graph。媒体文件的数据流在 graph 中流动  source filter： demux filter： decoder filter： color space converter filter： render filter：  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"336e04e8487b1664bdf3d9eae8beedd3","permalink":"https://xueqing.github.io/blog/ffmepg/ffmpeg/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ffmepg/ffmpeg/","section":"blog","summary":"播放器一般原理 Windows DirectShow 媒体文件基本模块：读文件、解复用、视频解码、音频解码、颜色空间转换、视频显示、音频播放 模块：过滤器 filter。 输入输出：","tags":["ffmpeg"],"title":"FFMPEG/FFPLAY 源码剖析","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"/* Exercise: Fibonacci closure Let's have some fun with functions. Implement a fibonacci function that returns a function (a closure) that returns successive fibonacci numbers (0, 1, 1, 2, 3, 5, ...). */ package main import \u0026quot;fmt\u0026quot; func fibonacci() func() int { before, val := 0, 1 return func() int { ret := before before, val = val, before + val return ret } } func main() { f := fibonacci() for i := 0; i \u0026lt; 10; i++ { fmt.Println(f()) } }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"aa1301ea7b9439d45b4d128b4e586d81","permalink":"https://xueqing.github.io/translation/go-doc/gotour/fibonacci_closure/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/fibonacci_closure/","section":"translation","summary":"/* Exercise: Fibonacci closure Let's have some fun with functions. Implement a fibonacci function that returns a function (a closure) that returns successive fibonacci numbers (0, 1, 1, 2, 3, 5, ...). */ package main import \u0026quot;fmt\u0026quot; func fibonacci() func() int { before, val := 0, 1 return func() int { ret := before before, val = val, before + val return ret } } func main() { f := fibonacci() for i := 0; i \u0026lt; 10; i++ { fmt.","tags":["go-tour"],"title":"Fibonacci closure","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" 递归删除文件夹下某个文件或文件夹 find 指定-name查找类型默认包括文件和文件夹  find ./ -name .git | xargs rm -rf递归删除当前路径下的.git文件和文件夹 find ./ -name .git -type f | xargs rm -rf递归删除当前路径下的.git文件 find ./ -name .git -type d | xargs rm -rf递归删除当前路径下的.git文件夹 find ./ -name .git -print -exec rm -rf {} \\; -print输出查找的文件或文件夹名 -exec后边跟着要执行的命令，表示将 find 查找的文件或目录执行该命令  选项后面跟着要执行的命令和脚本，然后是一对{}，一个空格和一个\\，然后是一个分号   xargs- build and execute command lines from standard input  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0914bd470ab7b5480f4196db9a3f753b","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_find/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_find/","section":"blog","summary":"递归删除文件夹下某个文件或文件夹 find 指定-name查找类型默认包括文件和文件夹 find ./ -name .git | xargs rm -rf递归删除当前路径下的.git文件和文件夹 find ./","tags":["ubuntu","linux"],"title":"find 命令","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":" 参考 Golang 官网文档 学习。\n导入语句：import \u0026quot;fmt\u0026quot;\n概述 fmt 包用类似于 C 的 printf 和 scanf 的函数实现了格式化的 I/O。格式 “verbs” 衍生自 C 但是更简单。\n打印 verbs 包括：\n通用的：\n%v 默认格式的值 当打印结构体时，增加标识 (%+v) 会增加域名。 %#v 值的一个 Go 语法显示 %T 值类型的一个 Go 语法显示 %% 一个字面百分比符号；不消费任何值  布尔型：\n%t 单词是 true 还是 false  整型：\n%b base 2 %c the character represented by the corresponding Unicode code point %d base 10 %o base 8 %O base 8 with 0o prefix %q a single-quoted character literal safely escaped with Go syntax. %x base 16, with lower-case letters for a-f %X base 16, with upper-case letters for A-F %U Unicode format: U+1234; same as \u0026quot;U+%04X\u0026quot;  索引 参考\n例子 参考\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"563de0170ea7052e8e644e1de3ccc892","permalink":"https://xueqing.github.io/translation/go-doc/golangpkg/fmt/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangpkg/fmt/","section":"translation","summary":"参考 Golang 官网文档 学习。 导入语句：import \u0026quot;fmt\u0026quot; 概述 fmt 包用类似于 C 的 printf 和 scanf 的函数实现了格式化的 I/O。格式 “verbs” 衍生自 C 但是更简单。 打印","tags":["golang-pkg"],"title":"fmt 包","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" Ubuntu16 在启动的时候出错 fsck exited with status code 4 出错原因：磁盘检测不能通过 解决方法：fsck.ext4 -y /dev/sda1  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"200e09017264cc033833bcfd04f14b39","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_fsck/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_fsck/","section":"blog","summary":"Ubuntu16 在启动的时候出错 fsck exited with status code 4 出错原因：磁盘检测不能通过 解决方法：fsck.ext4 -y /dev/sda1","tags":["ubuntu","linux"],"title":"fsck 命令","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  GDB 学习  g++ 编译 启动 GDB 调试 设置断点 查看各类信息 运行被调试的程序 设置程序中断后欲显示的数据及格式 帮助命令   g++ 编译  添加编译参数-std=c++11 -fpermissive 指定编译生成的可执行文件名字-o gdb-sample 添加调试编译，将源代码信息编译到可执行文件中-g 不用 -g，看不到程序的函数名、变量名，代替的是运行时的内存地址 没有源代码，调试和跟踪时只能是汇编代码级别的  启动 GDB 调试  先启动 gdb，再加载被调试的可执行程序文件：  gdb file gdb-sample  也可在启动调试时载入被调试程序名字gdb gdb-sample 同时调试一个运行程序和 core 文件，core 是程序非法执行后 core dump 后产生的文件gdb gdb-sample core 指定程序运行的进程 ID：gdb gdb-sample 2048，主要用于服务程序 退出 GDB 调试环境q(quit)  设置断点  b + 行号b 8 b + 函数名称b main b + *函数名称，将断点设置在由编译器生成的 prolg 代码处b *main b + *代码地址b *004835c 删除断点，不指定编号则删除所有断点d(delete breakpoints) N 禁用某个断点disable breakpoints N 允许使用某个断点enable breakpoints N 清除源文件某一行代码的所有断点clean number  查看各类信息  查看当前的所有断点信息i(info) breakpoints 查看程序是否在运行，进程号，被暂停的原因 显示指定变量（临时变量或全局变量）的值p(print) 查看程序运行路径show paths 设置环境变量set env(environment) varname[=value] 查看环境变量show environment [varname] 显示当前所在目录pwd 查看函数堆栈bt 指定运行时参数set args 参数 查看设置好的参数show args  运行被调试的程序  运行r(run)，如果没有断点则执行完，否则暂停在第一个可用断点处 继续执行被调试程序c(continue)，直至下一个断点或程序结束 执行一行源程序代码：  如果该行有程序调用，则进入该函数s(step into)，单步跟踪进入 一并执行该行代码中的函数调用n(step over)，单步跟踪  执行一行汇编指令si/ni，类似于 s/n 命令  设置程序中断后欲显示的数据及格式  例如display /i $pc，每次程序中断后可以看到即将被执行的下一条汇编指令，$pc代表当前汇编指令，/i表示以十六进制显示 取消先前的 display 设置undisplay N，编号从 1 递增  帮助命令  help，提供对 GDB 各种命令的解释说明  指定了命令名称参数，则显示该命令的详细说明help display 没有指定参数，则分类显示所有 GDB 命令  直接回车，表示重复上一次命令  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"eb1169f7a7b3d2fb98f9b94f74ed430c","permalink":"https://xueqing.github.io/blog/ubuntu/gdb/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/gdb/","section":"blog","summary":"GDB 学习 g++ 编译 启动 GDB 调试 设置断点 查看各类信息 运行被调试的程序 设置程序中断后欲显示的数据及格式 帮助命令 g++ 编译 添加编译参数-std=c++11 -fpermissive 指","tags":["ubuntu","linux"],"title":"GDB 学习","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  git add: 添加内容到下一次提交中. 当使用 git commit 时, git 将依据暂存区域的内容来进行文件的提交 可以用它开始跟踪新文件, 或者把已跟踪的文件放到暂存区, 还能用于合并时把有冲突的文件标记为已解决状态等\n# 把 path 添加到索引库, path 可以是文件或目录 git add path # 添加所有文件 git add . # 添加指定文件 git add file1 file2 # 不处理未跟踪(untracked)的文件 git add -u [\u0026lt;path\u0026gt;] # 添加所有 git add -A [\u0026lt;path\u0026gt;] # 查看所有修改过或已删除文件但是未提交的文件 git add -i [\u0026lt;path\u0026gt;] # 交互式添加修改内容到本次提交 git add -i # 交互式选择当前的修改添加到本次提交，只需输入 y/n git add -p   提交空文件  方法 1：在空文件夹创建一个空文件 .gitkeep，提交该文件 方法 2：在空文件夹创建一个空文件 .gitignore，文件内容如下。提交文件\n# 忽视目录所有内容 * # 不忽视 .gitignore 文件 !.gitignore   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c9e8110973146e5a34209467b18e4e74","permalink":"https://xueqing.github.io/blog/git/git_add/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_add/","section":"blog","summary":"git add: 添加内容到下一次提交中. 当使用 git commit 时, git 将依据暂存区域的内容来进行文件的提交 可以用它开始跟踪新文件, 或者把已跟踪的文件放到暂存区, 还能用","tags":["git"],"title":"git add 添加文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 已知 HEAD 节点是错误的，正确版本是 xxxxx 对应的提交，使用git bisect查找错误的提交\ngit bisect start git bisect bad HEAD git bisect good xxxxx # git 从中间的历史记录检出一个中间状态，在此状态上测试功能 # 1 如果此状态错误 git bisect bad # 2 如果此状态正确 git bisect good # 迭代多次之后可以找到导致错误的提交 # 返回到原始状态 git bisect reset   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9d176066425a7018bef84d9e47a5f5a7","permalink":"https://xueqing.github.io/blog/git/git_bisect/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_bisect/","section":"blog","summary":"已知 HEAD 节点是错误的，正确版本是 xxxxx 对应的提交，使用git bisect查找错误的提交 git bisect start git bisect bad HEAD git bisect good xxxxx # git 从中间的历史记录检出一个中间状态，","tags":["git"],"title":"git bisect 查找错误提交","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" git blame可标注出指定文件的每一行内容的最后修改者和最后修改时间 线下完成，即读本地磁盘完成\ngit blame bug.c   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"17c8c04845bc7bfdc8aa068506ed34c4","permalink":"https://xueqing.github.io/blog/git/git_blame/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_blame/","section":"blog","summary":"git blame可标注出指定文件的每一行内容的最后修改者和最后修改时间 线下完成，即读本地磁盘完成 git blame bug.c","tags":["git"],"title":"git blame","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 打包整个仓库\n# 发送者使用仓库创建一个文件包 git bundle create somefile HEAD # 接收者使用 somefile 文件获取提交 git pull somefile  打包部分提交：假设 xxxx 是发送者和接收者共享的最近提交\n# 发送者打包增加的变更 git bundle create somefile HEAD ^xxxx # 使用标签记录最近一次打包的节点 git tag -f lastbundle HEAD # 一段时间后创建新文件包 git bundle create newbundle HEAD ^lastbundle   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4387288c06913f4da3b161161ad66ae6","permalink":"https://xueqing.github.io/blog/git/git_bundle/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_bundle/","section":"blog","summary":"打包整个仓库 # 发送者使用仓库创建一个文件包 git bundle create somefile HEAD # 接收者使用 somefile 文件获取提交 git pull somefile 打包部分提交：假设 xxxx 是发送者和接收者共享的最近提交 # 发送","tags":["git"],"title":"git bundle","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# 选择某次提交应用到当前分支 git cherry-pick \u0026lt;commit-id\u0026gt; # 选择某次提交应用到当前分支，并保留原提交者信息 git cherry-pick -x \u0026lt;commit-id\u0026gt;   批量操作\n# 应用 start-commit-id （不包含） 到 end-commit-id （包含）之间的提交到当前分支 git cherry-pick \u0026lt;start-commit-id\u0026gt;..\u0026lt;end-commit-id\u0026gt; # 应用 start-commit-id （包含） 到 end-commit-id （包含）之间的提交到当前分支 git cherry-pick \u0026lt;start-commit-id\u0026gt;^..\u0026lt;end-commit-id\u0026gt;   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"52966b086e46dc863200dc0285131449","permalink":"https://xueqing.github.io/blog/git/git_-cherry-pick/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_-cherry-pick/","section":"blog","summary":"# 选择某次提交应用到当前分支 git cherry-pick \u0026lt;commit-id\u0026gt; # 选择某次提交应用到当前分支，并保留原提交者信息 git cherry-pick -x \u0026lt;commit-id\u0026gt; 批量操作 # 应用 start-commit-id （不包含） 到 end-commit-id （包含）之间的提交到","tags":["git"],"title":"git cherry-pick 选择某次提交","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" git clean 从工作目录移除未被跟踪的文件，直接删除，不能从回收站找到 -d 移除未跟踪的目录 -f 强制移除文件或目录，如果 clean.requireForce 设置为 true，git clean 只有添加 -f-n-i 才会清理\n# 移除工作目录中所有未追踪的文件以及空的目录 git clean -f -d  -n “演示”查看将会清除的内容，不会移除任何文件或目录\n# 可以打印“将要移除什么”，并未真正移除，相当于“演示” git clean -d -n  -x 不使用 .gitignore 或者 $GIT_DIR/info/exclude 指定的忽略规则，仍然使用 -e 选项指定的忽略规则\n 可以移除所有的未跟踪文件，包括构建目录，可以用来创建一个干净的工作目录\n# 移除未跟踪的文件和目录 git clean -d -x   -X 只移除忽略的文件，可以用于保留手动创建的文件\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6d6335608a396b9318c77391a23ab3da","permalink":"https://xueqing.github.io/blog/git/git_clean/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_clean/","section":"blog","summary":"git clean 从工作目录移除未被跟踪的文件，直接删除，不能从回收站找到 -d 移除未跟踪的目录 -f 强制移除文件或目录，如果 clean.requireForce 设置为 true，git clean 只有添加 -f-n-i","tags":["git"],"title":"git clean 清理工作目录","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# 将提交信息与命令放在同一行 git commit -m \u0026quot;add README\u0026quot; # 自动把所有已经跟踪过的文件暂存起来一并提交, 跳过 git add 步骤 git commit -a -m \u0026quot;add README\u0026quot; # 在日志信息之后添加提交者的信息，--signoff git commit -s # git commit \u0026lt;file\u0026gt;... git commit -p git commit –allow-empty # 改变上一次提交 git commit --amend # 把本地的修改包含在上一次提交 git commit --amend -a  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3acfec5ce9f678767c081fb3cecb6f20","permalink":"https://xueqing.github.io/blog/git/git_commit/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_commit/","section":"blog","summary":"# 将提交信息与命令放在同一行 git commit -m \u0026quot;add README\u0026quot; # 自动把所有已经跟踪过的文件暂存起来一并提交, 跳过 git add 步骤 git commit -a -m \u0026quot;add README\u0026quot; # 在日志信息之后添加提交者的信息","tags":["git"],"title":"git commit 提交更新","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  配置  修改配置信息 查看配置信息   修改配置信息  /etc/gitconfig：包含系统上每一个用户及他们仓库的通用配置, 使用--system会从此文件读写配置变量\n# 输出中文文件名显示问题 git config --system core.quotepath false # 开启颜色显示 git config --system color.ui true  ~/.gitconfig 或 ~/.config/git/config：只针对当前用户. 使用--global让 git 读写此文件\n# 配置全局用户名 git config --global user.name kiki # 配置全局 email git config --global user.email kiki@bmi.com # 配置默认文本编辑器(默认 vim) git config --global core.editor emacs  为 git 命令设置别名，参考git_alias\n rep-dir/.git/config：当前使用仓库的 Git 目录中的 config 文件, 只针对该仓库\n# 配置某个项目用户名 git config user.name xueqing # 配置某个项目 email git config user.email haijuanchen.sun@gmail.com  每一个级别覆盖上一级别的配置, 所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量\n  查看配置信息 # 列出所有 git 当时能找到的配置 git config --list git config -l # git config \u0026lt;key\u0026gt; 检查 Git 的某一项配置 # 查看用户名 git config user.name  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d2a2b57893aa775e2b7b046fab444118","permalink":"https://xueqing.github.io/blog/git/git_config/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_config/","section":"blog","summary":"配置 修改配置信息 查看配置信息 修改配置信息 /etc/gitconfig：包含系统上每一个用户及他们仓库的通用配置, 使用--system会从此文","tags":["git"],"title":"git config 配置","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  diff 插件 git diff  diff 插件  可以使用 git difftool 命令来用 Araxis , emerge 或 vimdiff 等软件通过图形化的方式或其它格式输出方式输出 diff 分析结果 使用 git difftool --tool-help 命令查看系统支持哪些 git diff 插件  git diff # 工作目录中当前文件和暂存区域快照之间的差异, 即修改之后还没有暂存起来的变化内容 git diff # HEAD 和暂存区比较, 即已暂存的将要添加到下次提交里的内容, --staged git diff --cached # HEAD 和工作区比较 git diff HEAD # HEAD 和 HEAD 的父版本比较 git diff HEAD HEAD^ # HEAD 父父版本和 HEAD 的父版本比较 git diff HEAD~2 HEAD^  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e5f59a4bfdaf8504510c0e56acb99eb0","permalink":"https://xueqing.github.io/blog/git/git_diff/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_diff/","section":"blog","summary":"diff 插件 git diff diff 插件 可以使用 git difftool 命令来用 Araxis , emerge 或 vimdiff 等软件通过图形化的方式或其它格式输出方式输出 diff 分析结果 使用 git difftool --tool-help 命令查看系统支持哪些 git diff 插件 git","tags":["git"],"title":"git diff 版本比较","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7a09ad48bc8b00ca1f37237e935819c9","permalink":"https://xueqing.github.io/blog/git/git_grep/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_grep/","section":"blog","summary":"","tags":["git"],"title":"git grep","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  语法 常用命令 引用日志 reflog 参考  语法 git log [\u0026lt;options\u0026gt;] [\u0026lt;revision range\u0026gt;] [[--] \u0026lt;path\u0026gt;…​]\n options     参数 含义     -L \u0026lt;start\u0026gt;,\u0026lt;end\u0026gt;:\u0026lt;file\u0026gt; 查看指定文件的开始行到结束行的提交历史   -L :\u0026lt;funcname\u0026gt;:\u0026lt;file\u0026gt; 查看指定文件的函数的提交历史    常用命令  git log \u0026ndash;pretty # 使用其他格式显示历史提交信息. 可用 oneline/short/full/fuller/format\n# 按行显示每次提交 git log --pretty=oneline # 定制要显示的记录格式 git log --pretty=format  git log \u0026ndash;stat # 显示每次更新的文件修改统计信息\n git log \u0026ndash;graph # 显示 ASCII 图形表示的分支合并历史\n git log -p # 按补丁格式显示每个更新之间的差异\n# 比较本地 master 分支和 origin/master 分支的差别 git log -p master..origin/master # 显示最近两次提交的差别 git log -p -2  git log \u0026ndash;decorate # 查看各个分支当前所指的对象\n# 输出提交历史、各个分支的指向以及项目的分支分叉情况 git log --oneline --decorate --graph --all # 显示简短且唯一的 SHA-1 值 git log --abbrev-commit  git log -(n) # 仅显示最近的 n 条提交\n git log \u0026ndash;since, \u0026ndash;after # 仅显示指定时间之后的提交\n git log \u0026ndash;until, \u0026ndash;before # 仅显示指定时间之前的提交\n git log \u0026ndash;author # 仅显示指定作者相关的提交\n git log \u0026ndash;committer # 仅显示指定提交者相关的提交\n git log \u0026ndash;grep # 仅显示含指定关键字的提交\n git log -S # 仅显示添加或移除了某个关键字的提交\n git log -g # 查看类似于 git log 输出格式的引用日志信息\n  引用日志 reflog  工作时, git 会在后台保存一个引用日志(reflog), 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史 每当 HEAD 指向的位置发生了变化, git 就会将这个信息存储到引用日志 引用日志只存在于本地仓库, 一个记录你在你自己的仓库里做过什么的日志\n# 查看引用日志 git reflog # 使用`@{n}`引用 reflog 中输出的提交记录 git show HEAD@{5} # 查看 master 分支在昨天的时候指向了哪个提交 git show master@{yesterday}  祖先引用是另一种指明一个提交的方式. 如果在引用的尾部加上一个^, git 会将其解析为该引用的上一个提交\n# 查看上一个提交, 也就是 “HEAD 的父提交” git show HEAD^ # d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并(merge)的提交 git show d921970^2 # HEAD^^^, 也是第一父提交的第一父提交的第一父提交 git show HEAD~3 # HEAD^^^, 也是第一父提交的第一父提交的第一父提交的第二父提交 git show HEAD~3^2   参考  git log  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"df2875ab48e9ce7b4cda91569dd26461","permalink":"https://xueqing.github.io/blog/git/git_log/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_log/","section":"blog","summary":"语法 常用命令 引用日志 reflog 参考 语法 git log [\u0026lt;options\u0026gt;] [\u0026lt;revision range\u0026gt;] [[--] \u0026lt;path\u0026gt;…​] options 参数 含义 -L \u0026lt;start\u0026gt;,\u0026lt;end\u0026gt;:\u0026lt;file\u0026gt; 查看指定文件的开始行到结束行的提交历史 -L :\u0026lt;funcname\u0026gt;:\u0026lt;file\u0026gt; 查看指定文件","tags":["git"],"title":"git log","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# git rm + git add git mv file_from file_to  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0521f606c4e540cb02afcfeeb337cbc0","permalink":"https://xueqing.github.io/blog/git/git_mv/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_mv/","section":"blog","summary":"# git rm + git add git mv file_from file_to","tags":["git"],"title":"git move 移动文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  普通补丁 正式补丁 git format-patch  参数 用于邮件发送 直接用于 git am  参考  普通补丁 # 发送者生成一个补丁 git diff xxx \u0026gt; my.patch # 接收者在其他地方使用这个补丁 git apply \u0026lt; my.patch  正式补丁 git format-patch  git format-patch生成补丁用于 email 发送，格式是类似 UNIX mailbox 命令的输出用于 email 发送或者git am直接使用 是更正式的设置，记录作者名字或签名  参数  --root从提交历史开始的所有提交 -M检测重命名 -B分割完整的重写信息为删除和创建对，即把提交当做删除旧文件，创建新文件  -M -B可将一个完全重写的文件当做重命名  --stdout将所有提交以 mbox 格式打印到标准输出，而不是为每个提交创建一个文件\n 不使用时，在当前文件夹为每次提交生成一个单独的文件，并打印文件的名字\n# 为某一时刻生成补丁 git format-patch xxxx # 为某一个提交范围生成补丁 git format-patch xxxx..HEAD^^ # 提取在当前分支但是不在 origin 分支的提交 git format-patch origin # 提取工程开始到 \u0026lt;commit\u0026gt; 的所有的提交 git format-patch --root \u0026lt;commit\u0026gt; # 等同于 git format-patch -M -B origin # 提取当前分支最上面的 3 次提交，生成补丁 git format-patch -3    用于邮件发送 # 发送者可使用 git-send-email 发送 git format-patch 的结果给接收者 # 接收者保存邮件到文件 email.txt，然后应用补丁创建一个提交，会自动包含作者的信息 git am \u0026lt; email.txt  直接用于 git am  git am 将 mailbox 的邮件信息分割成提交日志信息、作者信息和补丁，应用它们至当前分支\n# 提取 R1 和 R2 之间的提交，使用 git am 来 cherry-pick 提交应用到当前分支 git format-patch -k --stdout R1..R2 | git am -3 -k   参考  git format-patch doc gitrevisions doc git am doc git send-email doc git apply doc  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5210c43e12870b54d38446efae0cb6a3","permalink":"https://xueqing.github.io/blog/git/git_patch/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_patch/","section":"blog","summary":"普通补丁 正式补丁 git format-patch 参数 用于邮件发送 直接用于 git am 参考 普通补丁 # 发送者生成一个补丁 git diff xxx \u0026gt; my.patch # 接收者在其他地方使用这个补丁 git apply \u0026lt; my.patch 正式补丁 git format-patch","tags":["git"],"title":"git patch 补丁","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# 将本地的 master 分支推送至 origin 服务器的 dev 分支 git push origin master:dev git push url master  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"eb9c0b8ab2fdf4defbdd1b85fc0e9cfc","permalink":"https://xueqing.github.io/blog/git/git_push/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_push/","section":"blog","summary":"# 将本地的 master 分支推送至 origin 服务器的 dev 分支 git push origin master:dev git push url master","tags":["git"],"title":"git push 推送数据","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  变基 git rebase  git rebase -i  参考  变基  变基和三方合并整合的最终结果指向的快照始终是一样的, 只是提交历史不同 变基是将一系列提交按照原有次序依次应用到另一分支上, 而三方合并是把最终结果合在一起 变基使得提交历史更加简洁 注意：不要对在你的仓库外有副本的分支执行变基  git rebase # 将当前分支变基到 base_branch git rebase base_branch # 将 topic_branch 变基到 base_branch # 等同于 git checkout topic_branch \u0026amp;\u0026amp; git rebase base_branch git rebase base_branch topic_branch  git rebase -i  交互式变基的命令\n pick/p：使用提交 reword/r：使用提交，但是修改日志信息 edit/e：标记一个提交需要修改 squash/s：将当前提交与前一个提交合并 fixup/f：将当前提交与前一个提交合并，并丢弃日志信息 exec/x：使用 shell 运行剩下的命令行 drop/d：删除提交\n# 放弃修改 git rebase --abort # 重写从初次提交到达 commit 的所有历史 git rebase -i --root \u0026lt;commit\u0026gt;    参考  git rebase  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a68cd2be78bcc5e3e78c545a80a21955","permalink":"https://xueqing.github.io/blog/git/git_rebase/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_rebase/","section":"blog","summary":"变基 git rebase git rebase -i 参考 变基 变基和三方合并整合的最终结果指向的快照始终是一样的, 只是提交历史不同 变基是将一系列提交按照原有次序依次应用到另一分支上","tags":["git"],"title":"git rebase 变基","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# 查看指定的每一个远程服务器的简写 git remote # 查看需要读写远程仓库使用的 git 保存的简写与其对应的 URL git remote -v # 查看某一个远程仓库信息 git remote show [remote-name] # 添加一个新的远程 git 仓库, 同时指定一个简写 git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt; # 移除一个远程仓库 git remote rm lvlin # 修改一个远程仓库的简写名, 这同样也会修改远程分支名字 git remote rename temp lvlin # 列出远端分支 git remote -r  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"796d0c79db48eb9b5cee9a9b74744aa5","permalink":"https://xueqing.github.io/blog/git/git_remote/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_remote/","section":"blog","summary":"# 查看指定的每一个远程服务器的简写 git remote # 查看需要读写远程仓库使用的 git 保存的简写与其对应的 URL git remote -v # 查看某一个远程仓库信息 git remote show [remote-name] # 添加一个新","tags":["git"],"title":"git remote 远程仓库","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2683817ee2ec6b2fa1c9ab51bbee79a8","permalink":"https://xueqing.github.io/blog/git/git_revert/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_revert/","section":"blog","summary":"","tags":["git"],"title":"git revert","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# 从工作目录中删除指定的文件并存入暂存区 git rm file1 # 删除之前修改过并且已经放到暂存区域的文件, --forced, 用于防止误删还没有添加到快照的数据 git rm -f file1 # 从 git 仓库中删除文件, 即从暂存区域移除, 但仍然保留在当前工作目录 git rm --cached file1 # 可以使用 glob 模式 # 删除 log/ 目录下扩展名为 .log 的所有文件 git rm log/\\*.log  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"624d48a4dfcf27b0704bd5b554c0e6c2","permalink":"https://xueqing.github.io/blog/git/git_rm/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_rm/","section":"blog","summary":"# 从工作目录中删除指定的文件并存入暂存区 git rm file1 # 删除之前修改过并且已经放到暂存区域的文件, --forced, 用于防止误删还没有添加到快照的数据 git rm -f file1 # 从 git","tags":["git"],"title":"git rm 移除文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# 查看哪些文件处于什么状态 git status # 得到一种更为紧凑的格式输出, --short git status -s git status --ignored  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3379aef4a8c8b71540dde4d1df1c5afb","permalink":"https://xueqing.github.io/blog/git/git_status/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_status/","section":"blog","summary":"# 查看哪些文件处于什么状态 git status # 得到一种更为紧凑的格式输出, --short git status -s git status --ignored","tags":["git"],"title":"git status 跟踪状态","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  git submodule\n 应用场景 问题 高级命令  git将submodule有关的信息保存在两个地方：\n .gitmodules在仓库中，有版本控制，修改之后会同步到其他仓库，使用submodule相关命令的时候会自动更新 .git/config在本地，需要手动更新，或者执行git submodule sync将新的配置从.gitmodules拷贝到.git/config git submodule sync会将submodule远程的 url 配置设置到.gitmodules，并且只会影响.git/config已经有 url 的条目 指定--recursive，将会递归更新注册的submodule   应用场景  场景1：添加一个submodule  git submodule add repo_url local_path 此命令做三件事：克隆工程到本地；创建/修改.gitmodules标记submodule的具体信息；更新.git/config文件，增加submodule的地址 可用git submodule add -b branch_name repo_url local_path指定submodule跟踪的分支  场景 2：删除一个submodule  git submodule deinit -f -- path_to_submodule(路径最后不要加斜线) 删除.git/modules下面的文件夹 从 git 版本控制中删除缓存的子模块对应文件夹 本地仍保留文件git rm --cached path_to_submodule(路径最后不要加斜线) 本地不保留文件git rm -f path_to_submodule(路径最后不要加斜线)  场景 3：更新submodule的url  删除.git/config相关代码 删除工程目录下的.gitmodules相关代码 执行git submodule sync --recursive更新到本地的配置文件  场景 4：克隆一个有submodule的项目  分步克隆 git clone repo_url，submodule的代码不会和父项目一起克隆出来 git submodule update --init [--recursive]可以检出submodule的代码，recursive适用于嵌套submodule的项目 git submodule update --init [--recursive] subname可以检出指定子模块subname的代码，recursive适用于嵌套submodule的项目 一步克隆 git clone repo_url --recursive  场景 5：更新submodule，与远程仓库同步\n 更改对应的submodule提交到远程仓库 在父工程中，进入该submodule，执行git pull，可以用git status查看submodule是否有改到 如果有改到，需要执行git add提交该submodule的更新 也可在父工程中执行git submodule update --remote更新所有子模块到最新版本，再执行git add提交所有子模块的更新 注意：在含有子模块的工程中，每次执行git pull之后需要执行git submodule update --remote更新子模块 技巧：可以通过修改~/.gitconfig设置每次git pull之后执行git submodule update --remote\n[alias] psu = !git pull \u0026amp;\u0026amp; git submodule update    问题  问题 1：git submodule add时报错A git directory for xxx is found locally with remote(s): origin  删除.git/config相关代码 删除工程目录下的.gitmodules相关代码 删除缓存的子模块git rm --cached path_to_submodule`(路径最后不要加斜线) 执行git submodule sync --recursive更新到本地的配置文件  问题 2：git submodule add时报错Pathspec xxx is in submodule  删除缓存的子模块git rm --cached path_to_submodule(路径最后不要加斜线)   高级命令  查看差异输出，使得子模块的差异输出更加具体git diff --cached --submodule 修改子模块跟踪分支  只修改本地：修改.git/config文件中对应子模块的设置 修改仓库： 修改.gitmodule的命令git config -f .gitmodules submodule.Utility.branch dev  Utility是子模块的名字 dev是Utility的分支 不用-f .gitmodules只会应用到本地  同步到本地配置git submodule sync????  在主项目查看子模块的更改摘要：配置选项status.submodulesummary，使用命令git config status.submodulesummary 1 子模块遍历  遍历子模块保存工作进度git submodule foreach 'git stash save' 遍历子模块新建工作分支git submodule foreach 'git checkout -b featureA' 在主项目查看所有子模块的修改内容git diff; git submodule foreach 'git diff' 删除所有子模块本地的修改git submodule foreach --recursive 'git checkout .'  在主项目修改子模块  git submodule update更新子模块的文件时，会将子仓库留在一个游离的HEAD状态，本地没有工作分支跟踪改到 首先进入子模块检出一个分支，修改之后提交到本地 拉取远程仓库的子模块提交并合并到本地git submodule update --remote --rebase/merge  发布子模块的改到  在主项目推送代码到远程仓库前检查本地有没有未推送的子模块修改git push --recursive-submodules=check 如果提交的子模块改到未推送，会导致主项目的推送失败，可以根据提示进入子模块然后推送到远程仓库 或者使用git push --recursive-submodules=on-demand，git会尝试推送子模块修改到远程仓库，只有子模块都推送成功，主项目才可以推送   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f247bea73e3b6106088545b15b22b822","permalink":"https://xueqing.github.io/blog/git/git_submodule/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_submodule/","section":"blog","summary":"git submodule 应用场景 问题 高级命令 git将submodule有关的信息保存在两个地方： .gitmodules在仓库中，有版本控制，修改之后会同步到其他","tags":["git"],"title":"git submodule","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 标签不能像分支一样来回移动. 分为轻量标签（lightweight）与附注标签（annotated）\n 轻量标签：很像一个不会改变的分支, 只是一个特定提交的引用. 本质上是将提交校验和存储到一个文件中 - 没有保存任何其他信息 附注标签：存储在 git 数据库中的一个完整对象. 是可以被校验的；包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证\n# 列出已有的标签 git tag # 列出 1.8.5 系列的标签 git tag -l 'v1.8.5*' # 创建一个附注标签 git tag -a v1.4 -m 'v1.4' # 查看标签信息与对应的提交信息 git show v1.4 # 创建一个轻量标签 git tag v1.4-lw # 不会看到额外的标签信息. 只会显示出提交信息 git show v1.4-lw # 在 commit-id 提交上打标签 git tag -a v1.2 \u0026lt;commit-id\u0026gt; # 把所有不在远程仓库服务器上的标签全部推送到远程仓库服务器 git push origin --tags # 把 [tagname] 标签推送到远程仓库服务器 git push origin [tagname] # 在标签 v2.0.0 上创建分支 v2 git checkout -b v2 v2.0.0    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"df50fb7997876aeafe7067c913d962dc","permalink":"https://xueqing.github.io/blog/git/git_tag/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_tag/","section":"blog","summary":"标签不能像分支一样来回移动. 分为轻量标签（lightweight）与附注标签（annotated） 轻量标签：很像一个不会改变的分支, 只是一个","tags":["git"],"title":"git tag 标签","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  HEAD git branch git checkout 合并分支 拉取分支 删除远程仓库分支 分支引用  HEAD  HEAD：一个指针, 指向当前所在的本地分支  HEAD 分支随着提交操作自动向前移动 检出时 HEAD 随之移动   git branch # 查看当前所有分支列表, 星号表示 HEAD 指向的分支 git branch # 创建新分支 dev git branch dev # 以7次前的提交创建新的 master 分支 git branch master HEAD~7 # 在 commit-id 创建分支 dev git branch dev [commit-id] # 删除 dev 分支 git branch -d dev # 强制删除 dev 分支 git branch -D dev # 查看每个分支的最后一次提交 git branch -v # 查看哪些分支已经合并到当前分支 git branch --merged # 查看所有包含未合并工作的分支 git branch --no-merged # 设置已有的本地分支正在跟踪的上游分支,--set-upstream-to git branch -u origin/dev # 重命名 master 分支为 fix git branch -m master fix # 列举所有本地分支并显示具体信息 git branch -vv  git checkout # 切换至 dev 分支 git checkout dev # 创建并切换至分支 dev，等同于 git branch + git checkout git checkout -b dev # 在 commit-id 创建并切换至分支 dev git checkout -b dev [commit-id] # 从远程 dev 分支创建本地分支 deve, 本地 deve 分支会自动从 origin/dev 分支拉取 git checkout -b deve origin/dev # 以7次前的提交创建并切换到新的 master 分支 git checkout HEAD~7 -b master # 从远程 dev 分支创建本地分支 dev, 本地 dev 分支会自动从 origin/dev 分支拉取 git checkout --track origin/dev  合并分支 # 合并 dev 分支至当前分支 # 当设置好跟踪分支后, 可以通过 @{upstream} 或 @{u} 快捷方式来引用它 # 所以在 master 分支且它正在跟踪 origin/master 时, 可以使用 git merge @{u} 来取代 git merge origin/master git merge dev  拉取分支 # 抓取所有的远程仓库 git fetch --all  删除远程仓库分支 # 删除远程 dev 分支, git v1.7.0 git push origin --delete dev # git v1.5.0 git push origin :dev # git v2.8.0 git push origin -d dev  分支引用 # 查看某个分支指向的SHA-1 git rev-parse branch_name  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8bae80c640057e4a9fb3c8c30c67c34e","permalink":"https://xueqing.github.io/blog/git/git_branch/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_branch/","section":"blog","summary":"HEAD git branch git checkout 合并分支 拉取分支 删除远程仓库分支 分支引用 HEAD HEAD：一个指针, 指向当前所在的本地分支 HEAD 分支随着提交操作自动向前移动 检出时 HEAD 随之移动","tags":["git"],"title":"git 分支","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 使用git config为命令设置别名\n输入 git cpick commit-id 就可以引用某次提交 git config --global alias.cpick cherry-pick git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status  使用git config新建命令\n# 输入 git unstage fileA 就可以取消文件暂存 git config --global alias.unstage 'reset HEAD --' # 输入 git last 可以查看最后一次提交 git config --global alias.last 'log -1 HEAD'  使用git config可以执行外部命令，在命令前加!\n# 输入 git visual 等同于执行 gitk git config --global alias.visual '!gitk'   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"58e565a3cf318adf93089cdf15ee0720","permalink":"https://xueqing.github.io/blog/git/git_alias/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_alias/","section":"blog","summary":"使用git config为命令设置别名 输入 git cpick commit-id 就可以引用某次提交 git config --global alias.cpick cherry-pick git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status 使用git config新建","tags":["git"],"title":"git 别名管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 添加 SSH ke 到 github 账户  检查 .ssh 文件夹是否有密钥 ls ~/.ssh/  没有的话生成密钥 ssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot;  添加 SSH key 到 ssh-agent\n# 后台启动 ssh-agent eval $(ssh-agent -s) # 添加 key ssh-add ~/.ssh/id_rsa  在 github 的个人设置中添加一个 ssh-key\n 也可在某个 repository 中单独管理访问的 ssh-key\n  测试连接 github 网站 # 尝试 ssh 到 github ssh -T git@github.com # 看到更详细的信息 ssh -vT git@github.com # 看到 warning 之后输入 yes 尝试继续连接，如果看到 Hi username 说明连接成功  验证捆绑到 github 账户的 public key # 启动 ssh-agent 服务 ssh-agent -s # 查看 public key 的 fingerprint ssh-add -l  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"98bfd774b6301e138cb6c53658970621","permalink":"https://xueqing.github.io/blog/git/account_ssh/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/account_ssh/","section":"blog","summary":"添加 SSH ke 到 github 账户 检查 .ssh 文件夹是否有密钥 ls ~/.ssh/ 没有的话生成密钥 ssh-keygen -t rsa -C \u0026quot;your_email@example.com\u0026quot; 添加 SSH key 到 ssh-agent # 后台启动 ssh-agent eval $(ssh-agent -s) # 添加 key ssh-add ~/.ssh/id_rsa 在 github 的个人设置中添加一个 ssh-key 也可","tags":["git"],"title":"github 账户管理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" cache  使用 gitlab 的 CI/CD 时，将项目的 runner 设置为 group-runner 若同一个 pipeline 中的 stage 之间共享的 cache 依赖于同一个 runner，所以要保证同一个 pipeline 使用的是一个 runner 可以定义基类的 job，指定某个 tag 的 runner，其他需要共享 cache 的 job 继承此 job。例如\n.job: tags: - vdms1 build-job: extends: .job package-job: extends: .job   问题  含有子模块的工程在克隆源码时遇到下面的问题\nChecking out 7f97aadf as master... Skipping Git submodules setup  解决方案参考\n 1 确定子模块的 URL 使用相对路径 2 gitlab-runner 版本是 v1.10+ 的，设置GIT_SUBMODULE_STRATEGY为normal或recursive 3 gitlab-runner 版本较低的，在before-script中使用git submodule sync/update\nbefore_script: - git submodule sync --recursive - git submodule update --init --recursive    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4c2ad987ccd8cceb050c9cc612601a7a","permalink":"https://xueqing.github.io/blog/gitlab/gitlab/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/gitlab/gitlab/","section":"blog","summary":"cache 使用 gitlab 的 CI/CD 时，将项目的 runner 设置为 group-runner 若同一个 pipeline 中的 stage 之间共享的 cache 依赖于同一个 runner，所以要保证同一个 pipeline 使用的是一个 runner 可以定义基类的 job","tags":["gitlab"],"title":"gitlab 踩坑","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"用法：go bug\n命令打开默认浏览器，并开启一个新的缺陷报告。报告包含有用的系统信息。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"cf29a495a2a90e9d36a5e931e8badb51","permalink":"https://xueqing.github.io/translation/go-doc/command/bug/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/bug/","section":"translation","summary":"用法：go bug 命令打开默认浏览器，并开启一个新的缺陷报告。报告包含有用的系统信息。","tags":["go-command"],"title":"go bug","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令 源码文件 编译多个 Go 源码文件 go build 的参数 依赖包 构建标签  命令  go build [-o output] [-i] [build flags] [packages] go build 命令用于编译我们指定的源码文件或代码包以及它们的依赖包 如果在执行 go build 命令时不后跟任何代码包，那么命令将试图编译当前目录所对应的代码包 编译码包 cnet/ctcp  在 GOPATH/src/cnet/ctcp 执行 go build 在 GOPATH/src/cnet/ 执行 go build ctcp 在任意目录下执行 go build cnet/ctcp  go build 会忽略目录下以 “_” 或 “.” 开头的 go 文件 -o 强制将生成的可执行文件或目标文件写到指定的输出文件或文件夹。如果指定的输出是存在的文件夹，生成的可执行文件会写到文件夹 -i 安装依赖包  源码文件  Go 语言的源码文件有三大类，即：命令源码文件、库源码文件和测试源码文件  命令源码文件：总是作为可执行的程序的入口 库源码文件：一般用于集中放置各种待被使用的程序实体（全局常量、全局变量、接口、结构体、函数等等） 测试源码文件：主要用于对前两种源码文件中的程序实体的功能和性能进行测试。另外也可以用于展现命令源码文件和库源码文件中程序的使用方法  如果是库源码文件，执行 go build 之后，不会产生任何文件。如果需要在 $GOPATH/pkg 下生成相应的文件，那就得执行 go install 如果是命令源码文件(main 包)，执行 go build 之后，它就会调用链接器在当前目录下生成一个可执行文件，可执行程序的名字取自包的导入路径的最后一段。如果需要在 $GOPATH/bin 下生成相应的文件，需要执行 go install，或者使用 go build -o 可执行文件  编译多个 Go 源码文件  go build 默认会编译当前目录下的所有 go 文件  构建所有需要的包及其依赖，然后丢弃除了可执行程序之外的所有编译的代码  可以同时编译多个 Go 源码文件，在 go build 后跟要编译的文件名，用空格分隔  限制：作为参数的多个 Go 源码文件必须在同一个目录中  go build 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查性的编译，而不会输出任何结果文件 go build 命令既不能编译包含多个命令源码文件的代码包，也不能同时编译多个命令源码文件。因为，如果把多个命令源码文件作为一个整体看待，那么每个文件中的 main 函数就属于重名函数，在编译时会抛出重复定义错误 如果编译的多个属于 main 包的源码文件中没有 main 函数的声明，那么就会使编译器立即报出“未定义 main 函数声明”的错误并中止编译 总结：同时编译多个 main 包的源码文件时，要保证其中有且仅有一个 main 函数声明，否则编译是无法成功的 如果有多个声明为属于 main 包的源码文件，且其中只有一个文件声明了 main 函数的话，那么是可以使用 go build 命令同时编译它们的。在这种情况下，不包含 main 函数声明的那几个源码文件会被视为库源码文件。如此编译之后的可执行文件的名称来自指定的编译目标中最左边的那个源码文件的主文件名相同  go build 的参数  下面的编译标志被 build/clean/get/install/list/run/test 共享     标志 描述     -a 强行重新构建包，即使它们已经是最新的了，但是对标准包不适用   -n 打印将要执行的命令，但是不执行   -p n 指定执行命令的并行程序数量。默认等于可用的 CPU 逻辑数。在 darwin/arm (iPhone 和 iPad) 平台，默认是1   -race 开启竞态条件检测。仅在 linux/amd64、freebsd/amd64、darwin/amd64和windows/amd64 平台支持   -v 打印被编译的包名   -work 打印临时工作目录名称，且如果存在不会在执行命令后删除。默认结束命令时会删除该目录   -x 打印命令。注意它与 -n 标记的区别     其他参数  -mod 控制对 go.mod 的更新和使用 -mod=readonly 不能隐式自动更新 go.mod。当需要修改 go.mod 时会失败。用于检查 go.mod 不需要任何更新，比如在持续集成和测试系统  这个参数对 go get 不生效，即命令仍然可以更新 go.mod 文件  -mod=vendor: 使用模块的顶层的 vendor 目录来编译以满足依赖(不使用通常的网络源码和本地缓存)   依赖包  go build 命令在执行时，编译程序会先查找目标代码包的所有依赖包，以及这些依赖包的依赖包，直至找到最深层的依赖包为止。在此过程中，如果发现有循环依赖的情况，编译程序就会输出错误信息并立即退出。此过程完成之后，所有的依赖关系也就形成了一棵含有重复元素的依赖树。对于依赖树中的一个节点（代码包）来说，它的直接分支节点（前者的依赖包），是按照代码包导入路径的字典序从左到右排列的。最左边的分支节点会最先被编译。编译程序会依此设定每个代码包的编译优先级 执行 go build 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：依赖代码包 -\u0026gt; 当前代码包 -\u0026gt; 触发代码包 在执行 go build 命令时加入标记 -p 1，那么就可以保证代码包编译顺序严格按照预先设定好的优先级进行  构建标签  构建标签：go build 只会在构建指定规格的目标文件的时候才进行编译，叫做构建标签的特殊注释，提供更细力度的控制。 注释需要加在包的声明之前，这是文档注释。如 // +build linux darwin // +build ignore 指出任何时候都不要编译这个文件  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b49eb959654be04848757ecbc4cffd9f","permalink":"https://xueqing.github.io/translation/go-doc/command/build/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/build/","section":"translation","summary":"命令 源码文件 编译多个 Go 源码文件 go build 的参数 依赖包 构建标签 命令 go build [-o output] [-i] [build flags] [packages] go build 命令用于编译我们指定的源码文件或代码包以及它们的依赖包 如果在执","tags":["go-command"],"title":"go build","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令 go clean 的参数  命令  go clean 命令会删除掉执行其它命令时产生的一些文件和目录，包括  有一些目录和文件是在编译 Go 或 C 源码文件时留在相应目录中的 目录 _obj/：旧的 object 目录，由 Makefiles 遗留 目录 _test/：旧的 test 目录，由 Makefiles 遗留 文件 _testmain.go：旧的 gotest 文件，由 Makefiles 遗留 文件 test.out：旧的 test 记录，由 Makefiles 遗留 文件 build.out：旧的 test 记录，由 Makefiles 遗留 文件 a.out 文件 DIR(.exe)： 由 go build 在当前代码包下生成的与包名同名或者与 Go 源码文件同名的可执行文件(Windows 带有 .exe 后缀) 文件 DIR.test(.exe)： 由 go test -c 在当前代码包下生成(Windows 带有 .test.exe 后缀) 文件 MAINFILE(.exe)： 由 go build MAINFILE.go 产生 文件 *.so：由 SWIG 遗留 执行 go clean 命令时带有标记 -i，则会同时删除安装当前代码包时所产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区的 pkg 目录的相应目录下的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区的 bin 目录下的可执行文件。这些目录和文件是在执行 go build 命令时生成在临时目录中的。临时目录的名称以 go-build 为前缀 执行 go clean 命令时带有标记 -r，则还包括当前代码包的所有依赖包的上述目录和文件   go clean 的参数    参数 描述     -i 清除关联的安装的包和可运行文件   -n 打印执行命令期间所用到的其它命令，但是并不真正执行它们   -r 循环的清除在 import 中引入的包   -x 打印执行命令期间所用到的其它命令。注意它与 -n 标记的区别    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fbe7ca90289165e7ec5234eb4293e274","permalink":"https://xueqing.github.io/translation/go-doc/command/clean/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/clean/","section":"translation","summary":"命令 go clean 的参数 命令 go clean 命令会删除掉执行其它命令时产生的一些文件和目录，包括 有一些目录和文件是在编译 Go 或 C 源码文件时留在相应目录中的 目录 _ob","tags":["go-command"],"title":"go clean","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令 Go 语言程序实体 go doc 的参数 godoc  命令行模式 Web 服务器模式   命令  go doc 命令可以打印附于 Go 语言程序实体上的文档。可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的 go doc 可以接受一个参数，指定包/包成员/方法：go doc http.Request  go doc 命令根据参数查找代码包或程序实体的顺序：Go 语言根目录（GOROOT 环境变量指定的目录）-\u0026gt; 工作区目录（GOPATH 环境变量包含的目录）。在内部遵循字典序 如果某个工作区目录中的代码包与标准库中的包重名了，那么它是无法被打印出来的。go doc 命令只会打印出第一个匹配的代码包或程序实体的文档  go doc 也可以接受两个参数：go doc net/http Request  这是一种更加精细的指定代码包或程序实体的方式 第一个参数的代码包名称必须是完整的导入路径 在给定两个参数时，go doc 会打印出所有匹配的文档，而不是像给定一个参数时那样只打印出第一个匹配的文档。这对于查找只有大小写不同的多个方法（如 New、new）的文档来说非常有用   Go 语言程序实体  Go 语言的程序实体，是指变量、常量、函数、结构体以及接口 程序实体的标识符即是代表它们的名称。标识符又分非限定标识符和限定标识符  限定标识符一般用于表示某个代码包中的程序实体或者某个结构体类型中的方法或字段 如：标准库代码包 io 中的名为 EOF 的变量用限定标识符表示即 io.EOF 如：如果有一个 sync.WaitGroup 类型的变量 wg 并且想调用它的 Add 方法，那么可以这样写 wg.Add()。其中，wg.Add 就是一个限定标识符，而后面的 () 则代表了调用操作。   go doc 的参数    参数 描述     -c 区分参数中字母的大小写。默认情况下，命令是大小写不敏感的   -cmd 打印出 main 包中的可导出的程序实体（其名称的首字母大写）的文档。默认情况下，这部分文档是不会被打印出来的   -u 打印出不可导出的程序实体（其名称的首字母小写）的文档。默认情况下，这部分文档是不会被打印出来的    godoc  在 Go1.2 版本之前还支持 go doc 命令，但是之后全部移到了 godoc 这个命令下，需要这样安装 go get golang.org/x/tools/cmd/godoc 在 Go1.5 版本中，go doc 是一个内置的标准命令 命令有两种模式可供选择  命令行模式  不加入 -http 标记：以命令行模式运行。在打印纯文本格式的文档到标准输出后，命令执行就结束了。如 godoc fmt Printf，godoc fmt Printf Println 加 -src 标记：不但可以在文档中查看可导出的程序实体的声明，还可以看到源码。如 godoc -src fmt Printf godoc 命令只能把代码包和程序实体的标识符拆成两个参数。也就是说，godoc 命令不支持前文所述的 go doc 命令的单参数用法 在实际的环境中，可能会遇到一个命令源码文件所产生的可执行文件与代码包重名的情况。比如，标准命令 go 和官方代码包 go。们要明确的告诉 godoc 命令要查看可执行文件 go 的文档，需要在名称前加入 cmd/ 前缀 godoc cmd/go 查看 HTML 格式的文档，就需要加入标记 -html，可以在其中找到一些相应源码的链接地址  Web 服务器模式  加上 -http 标记：以 Web 服务器模式运行。以 Web 页面的形式提供 Go 语言文档 godoc -http=:6060 标记 -http 的值 :6060 表示启动的 Web 服务器使用本机的 6060 端口。之后，可通过在浏览器中输入 http://localhost:6060 查看以网页方式展现的 Go 文档 这使得在不方便访问 Go 语言官方站点的情况下也可以查看 Go 语言文档。并且通过本机的 Go 文档 Web 服务，还可以查看所有本机工作区下的代码的文档 godoc -http=:9090 -index 使用 -index 标记开启搜索索引。这个索引会在服务器启动时创建并维护。如果不加入此标记，那么无论在 Web 页面还是命令行终端中都无法进行查询操作  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5d15ae980d246c8da956f6b51261274c","permalink":"https://xueqing.github.io/translation/go-doc/command/doc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/doc/","section":"translation","summary":"命令 Go 语言程序实体 go doc 的参数 godoc 命令行模式 Web 服务器模式 命令 go doc 命令可以打印附于 Go 语言程序实体上的文档。可以通过把程序实体的标识符作为该命令的参","tags":["go-command"],"title":"go doc","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令 go env 命令可打印出的 Go 语言通用环境信息 go env 的参数  命令  go env 用于打印 Go 语言的环境信息：go env GOARCH 或 go env GOARCH GOCHAR go env -w 重写 Go 语言的环境信息：go env -w GOPRIVATE=\u0026quot;*.bmi\u0026quot;  go env 命令可打印出的 Go 语言通用环境信息 | 名称 | 描述 | | CGO_ENABLED | 指明 cgo 工具是否可用的标识 | | GOARCH | 程序构建环境的目标计算架构 | | GOBIN | 存放可执行文件的目录的绝对路径 | | GOCHAR | 程序构建环境的目标计算架构的单字符标识 | | GOEXE | 可执行文件的后缀 | | GOHOSTARCH | 程序运行环境的目标计算架构 | | GOOS | 程序构建环境的目标操作系统 | | GOHOSTOS | 程序运行环境的目标操作系统 | | GOPATH | 工作区目录的绝对路径 | | GORACE | 用于数据竞争检测的相关选项 | | GOROOT | Go 语言的安装目录的绝对路径 | | GOTOOLDIR | Go 工具目录的绝对路径 |\ngo env 的参数    参数 描述      ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7c571b11f19ff6f065f6b5b60ab05f29","permalink":"https://xueqing.github.io/translation/go-doc/command/env/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/env/","section":"translation","summary":"命令 go env 命令可打印出的 Go 语言通用环境信息 go env 的参数 命令 go env 用于打印 Go 语言的环境信息：go env GOARCH 或 go env GOARCH GOCHAR go env -w 重写 Go 语言的环境信息：go env -w GOPRIVATE=\u0026quot;*.bmi\u0026quot;","tags":["go-command"],"title":"go env","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令 gofmt 的参数  命令  go 代码有标准的风格。go fmt file_name.go 命令可以格式化写好的代码文件 开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了 go fmt 使用 go fmt 命令，其实是调用了 gofmt，而且需要参数 -w，否则格式化结果不会写入文件。gofmt -w -l src 可以格式化整个项目  gofmt 的参数    参数 描述     -l 显示需要格式化的文件   -w 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出   -r 添加形如 “a[b:len(a)] -\u0026gt; a[b:]” 的重写规则，方便做批量替换   -s 简化文件中的代码   -d 显示格式化前后的 diff 而不是写入文件，默认是 false   -e 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误   -cpuprofile 支持调试模式，写入相应的 cpufile 到指定的文件    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"55f569685a53b991d636539cb4146dd1","permalink":"https://xueqing.github.io/translation/go-doc/command/fmt/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/fmt/","section":"translation","summary":"命令 gofmt 的参数 命令 go 代码有标准的风格。go fmt file_name.go 命令可以格式化写好的代码文件 开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是","tags":["go-command"],"title":"go fmt","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令  命令  go generate 用于在编译前自动化生成某类代码 go generate 通过分析源码中特殊的注释，然后执行相应的命令。注意  此特殊注释必须在 .go 源码文件 每个源码文件可包含多个 generate 注释 显示运行 go generate 命令时，才会执行特殊注释后面的命令 命令串执行时，如果出错则终止后面的执行  //go:generate go tool yacc -o gopher.go -p parser gopher.y  //go:generate 没有空格，这是一个固定的格式，在扫描源码文件的时候是根据这个来判断的 使用 yacc 来生成代码：-o 指定输出文件名，-p 指定 package 名称 这是一个单独的命令。如果想让 go generate 来触发这个命令，那么就可以在当然目录的任意一个 xxx.go 文件里面的任意位置增加此注释   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"02b4a5facad4cc216e3416a177c389cf","permalink":"https://xueqing.github.io/translation/go-doc/command/generate/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/generate/","section":"translation","summary":"命令 命令 go generate 用于在编译前自动化生成某类代码 go generate 通过分析源码中特殊的注释，然后执行相应的命令。注意 此特殊注释必须在 .go 源码文件 每个源码文件可包含","tags":["go-command"],"title":"go generate","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令 go get 命令支持的 VCS go get 的参数  命令  go get 命令用来动态获取远程代码包，从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装 在内部实际上分成了两步操作：第一步是下载源码包第一个工作区的 src 目录下，第二步是执行 go install 目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下  BitBucket (Mercurial Git) GitHub (Git) Google Code Project Hosting (Git, Mercurial, Subversion) Launchpad (Bazaar) 这些网站的项目包路径有一个共同标准：远程包路径格式是 网站域名/作者或机构/项目名  如 go get github.com/hyper-carrot/go_lib/logging go get 支持自定义域名的功能，具体参见 go help remote 除非要求强行更新代码包，否则 go get 命令不会进行重复下载  go get 命令支持的 VCS  代码版本控制系统（Version Control System，VCS） 这几个版本控制系统都有一个共同点，那就是会在检出的项目目录中存放一个元数据目录，名称为 “.” 前缀加其主命令名     名称 主命令 说明     Mercurial hg Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强   Git git Git 最开始是 Linux Torvalds 为了帮助管理 Linux 内核开发而开发的一个开源的分布式版本控制软件。但现在已被广泛使用。它是被用来进行有效、高速的各种规模项目的版本管理   Subversion svn Subversion 是一个版本控制系统，也是第一个将分支概念和功能纳入到版本控制模型的系统。但相对于 Git 和 Mercurial 而言，它只算是传统版本控制系统的一员   Bazaar bzr Bazaar 是一个开源的分布式版本控制系统。但相比而言，用它来作为 VCS 的项目并不多     对于不知名的网站，需要指出导入路径使用哪种版本控制协议 位置由诸如 googlesource.com 或 github.com 之类通用服务托管，包可以在其导入路径中使用自定义域名。其 HTML 网页下包含元数据重定向 go 工具到实际托管地址的服务仓库  go get 的参数  go get 命令可以接受所有可用于 go build 命令和 go install 命令的参数。这是因为 go get 命令的内部步骤中完全包含了编译和安装这两个动作 go get 命令还有一些特有的参数     参数 描述     -d 只下载不安装   -f 只有在包含 -u 参数时才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用   -fix 在获取源码之后先运行 fix，而后再进行编译和安装   -insecure 允许使用非安全的 scheme（如HTTP）去下载指定的代码包。如果代码仓库（如公司内部的Gitlab）没有 HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它   -t 下载并安装指定的代码包中的测试源码文件中依赖的代码包   -u 强制使用网络更新已有代码包及其依赖包。默认情况该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包   -v 显示执行的命令    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b3c470e075960698ecee92434bbaffab","permalink":"https://xueqing.github.io/translation/go-doc/command/get/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/get/","section":"translation","summary":"命令 go get 命令支持的 VCS go get 的参数 命令 go get 命令用来动态获取远程代码包，从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装 在内部实","tags":["go-command"],"title":"go get","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  命令 安装代码包 安装命令源码文件 go install 的参数  命令  go install 用于编译并安装指定的代码包及它们的依赖包 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或 .a 包)，第二步会把编译好的结果移到指定目录($GOPATH/bin 或 $GOPATH/pkg)  go install 命令只比 go build 命令多做了一件事，即安装编译后的结果文件到指定目录  go install 命令可以接受所有可用于 go build 命令的参数  安装代码包  go install 命令会把编译后的可执行文件保存在源码文件所在工作区的 bin 目录下，包保存在 pkg 目录 如果 go install 命令后跟的代码包中仅包含库源码文件，那么 go install 命令会把编译后的结果文件保存在源码文件所在工作区的 pkg 目录下。结果文件是对应的代码包归档文件（也叫静态链接库文件，名称以 .a 结尾）  go build 命令对仅包含库源码文件的代码包进行编译时，不会在当前工作区的 src 以及 pkg 目录下产生任何结果文件。结果文件会出于编译目的被生成在临时目录，但并不会使当前工作区目录产生任何变化。只会留下可执行文件。go build -i 可将包安装在独立于构建目标的地方  go install 命令时不后跟任何代码包参数，那么命令将试图编译当前目录所对应的代码包  安装命令源码文件 go install 的参数    参数 描述     -d 只下载不安装   -f 只有在包含 -u 参数时才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用   -fix 在获取源码之后先运行 fix，而后再进行编译和安装   -insecure 允许使用非安全的 scheme（如HTTP）去下载指定的代码包。如果代码仓库（如公司内部的Gitlab）没有 HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它   -t 下载并安装指定的代码包中的测试源码文件中依赖的代码包   -u 强制使用网络更新已有代码包及其依赖包。默认情况该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包   -v 显示执行的命令    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"cdbb2fa885480d7f223a33aba8a08365","permalink":"https://xueqing.github.io/translation/go-doc/command/install/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/install/","section":"translation","summary":"命令 安装代码包 安装命令源码文件 go install 的参数 命令 go install 用于编译并安装指定的代码包及它们的依赖包 这个命令在内部实际上分成了两步操作：第一步是生成结果","tags":["go-command"],"title":"go install","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  用法 -f -m  用法  列举命名包，每行一个。不带参数时判断一个包是否存在工作空间，存在则输出包的导入路径 命令 go list [-f format] [-json] [-m] [list flags] [build flags] [packages]  常用的参数是 -f 和 -json，用于控制输出格式  go list cnet hash ... 通配符用于匹配包的导入路径中的任意子串  go list ... 枚举工作空间的所有包 go list ch3/... 指定子树中的所有包 go list ...xml.. 指定具体主题  go list 获取每个包的完整元数据，提供各种用于对用户或其他工具可访问的格式     标志 描述     -e 以容错模式加载和分析指定的代码包，这样讲不会打印错误信息   -json 把代码包的结构实体用 JSON 样式打印，所有值为对应类型的空值的字段会被忽略   -compiled -   -deps -   -export -   -find -   -test -   -m 列举模块而不是包。使用 -f 指定的是模块模板    -f  使用包模板语法指定可选格式。默认输出等价于 -f '{{ImportPath}}'。-f 的值需要满足 text/template 中定义的语法  {{.S}} 代表根结构体的 S 字段的值。go list 对应的跟结构体就是指定的代码包所对应的的结构体 go list -f {{.GoFiles}} cnet/ctcp go list -e -f {{.Error.Err}} cnet go list -e -f 'The package {{.ImportPath}} is {{if .Incomplete}}incomplete!{{else}}complete.{{end}}' cnet  模板结构如下\ntype Package struct { Dir string // directory containing package sources ImportPath string // import path of package in dir ImportComment string // path in import comment on package statement Name string // package name Doc string // package documentation string Target string // install path Shlib string // the shared library that contains this package (only set when -linkshared) Goroot bool // is this package in the Go root? Standard bool // is this package part of the standard Go library? Stale bool // would 'go install' do anything for this package? StaleReason string // explanation for Stale==true Root string // Go root or Go path dir containing this package ConflictDir string // this directory shadows Dir in $GOPATH BinaryOnly bool // binary-only package (no longer supported) ForTest string // package is only for use in named test Export string // file containing export data (when using -export) Module *Module // info about package's containing module, if any (can be nil) Match []string // command-line patterns matching this package DepOnly bool // package is only a dependency, not explicitly listed // Source files GoFiles []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles) CgoFiles []string // .go source files that import \u0026quot;C\u0026quot; CompiledGoFiles []string // .go files presented to compiler (when using -compiled) IgnoredGoFiles []string // .go source files ignored due to build constraints CFiles []string // .c source files CXXFiles []string // .cc, .cxx and .cpp source files MFiles []string // .m source files HFiles []string // .h, .hh, .hpp and .hxx source files FFiles []string // .f, .F, .for and .f90 Fortran source files SFiles []string // .s source files SwigFiles []string // .swig files SwigCXXFiles []string // .swigcxx files SysoFiles []string // .syso object files to add to archive TestGoFiles []string // _test.go files in package XTestGoFiles []string // _test.go files outside package // Cgo directives CgoCFLAGS []string // cgo: flags for C compiler CgoCPPFLAGS []string // cgo: flags for C preprocessor CgoCXXFLAGS []string // cgo: flags for C++ compiler CgoFFLAGS []string // cgo: flags for Fortran compiler CgoLDFLAGS []string // cgo: flags for linker CgoPkgConfig []string // cgo: pkg-config names // Dependency information Imports []string // import paths used by this package ImportMap map[string]string // map from source import to ImportPath (identity entries omitted) Deps []string // all (recursively) imported dependencies TestImports []string // imports from TestGoFiles XTestImports []string // imports from XTestGoFiles // Error information Incomplete bool // this package or a dependency has an error Error *PackageError // error loading package DepsErrors []*PackageError // errors loading dependencies } type PackageError struct { ImportStack []string // shortest path from package named on command line to this one Pos string // position of error (if present, file:line:col) Err string // the error itself }  模板函数 join 调用 strings.Join\n go list -f '{{join .Deps \u0026quot; \u0026quot;}}' strconv 输出 strconv 包的依赖过渡关系记录，空格分隔 go list -f '{{.ImportPath}} -\u0026gt; {{join .Imports \u0026quot; \u0026quot;}}' compress/... 输出标准库的 compress 子树中每个包的直接导入记录  模板函数 context 返回构建上下文，定义如下\ntype Context struct { GOARCH string // target architecture GOOS string // target operating system GOROOT string // Go root GOPATH string // Go path CgoEnabled bool // whether cgo can be used UseAllFiles bool // use files regardless of +build lines, file names Compiler string // compiler to assume when computing target paths BuildTags []string // build constraints to match in +build lines ReleaseTags []string // releases the current release is compatible with InstallSuffix string // suffix to use in the name of the install dir }   -m  默认输出模块路径、版本信息，如果有替换，输出替换信息  如果有替换，即 Replace 不为 nil 时，下面的 Dir 设置的是 Replace.Dir  主模块是包含当前目录的模块。活动模块是主模块及其依赖模块。默认显示主模块  all 指定所有活动模块  和 -f 一起使用，指定模块模板 结构体 Module 有一个 String 方法，用于格式化输出行，因此默认输出等价于 -f {{.String}}\ntype Module struct { Path string // module path Version string // module version Versions []string // available module versions (with -versions) Replace *Module // replaced by this module Time *time.Time // time version was created Update *Module // available update, if any (with -u) Main bool // is this the main module? Indirect bool // is this module only an indirect dependency of main module? Dir string // directory holding files for this module, if any GoMod string // path to go.mod file for this module, if any GoVersion string // go version used in module Error *ModuleError // error loading module } type ModuleError struct { Err string // the error itself }  -u 增加了关于可以升级的信息：go list -m -u -json all\n -version 设置 Module.Version 域为模块已知的版本\n 模板函数 module 接收一个字符串参数(必须是一个模块路径或查询)，返回指定的模块对应的 Module 结构体\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4d3af960cff930fed92677b8dd1d730a","permalink":"https://xueqing.github.io/translation/go-doc/command/list/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/list/","section":"translation","summary":"用法 -f -m 用法 列举命名包，每行一个。不带参数时判断一个包是否存在工作空间，存在则输出包的导入路径 命令 go list [-f format] [-json] [-m] [list flags] [build flags] [packages] 常用的参数是 -f 和 -j","tags":["go-command"],"title":"go list","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  用法 download edit graph init tidy vendor verify why  用法  用于操作模块。注意：所有的 go 命令支持模块 用法：go mod \u0026lt;command\u0026gt; [arguments]     命令 功能     download 下载模块到本地缓存   edit 使用工具或脚本更新 go.mod   graph 打印模块需求图   init 在当前目录初始化一个新模块   tidy 添加缺失模块，删除无用模块   vendor 创建依赖的 vendor 拷贝   verify 验证依赖拥有预期的内容   why 解释为什么需要一个包或者模块    download  用法： go mod download [-json] [modules] 不带模块参数时，默认下载主模块的所有依赖 其他 go 命令会自动下载所需模块，go mod download 主要用于预先填充本地缓存或用户计算 Go 模块代理 默认将错误发生给标准错误。-json 会打印 JSON 对象到标准输出，描述每个下载的模块(或失败)\ntype Module struct { Path string // module path Version string // module version Error string // error loading module Info string // absolute path to cached .info file GoMod string // absolute path to cached .mod file Zip string // absolute path to cached .zip file Dir string // absolute path to cached source root directory Sum string // checksum for path, version (as in go.sum) GoModSum string // checksum for go.mod (as in go.sum) Latest bool // would @latest resolve to this version? }   edit  用法：go mod edit [edit flags] [go.mod] 命令只会读写主模块 go.mod 文件，可在编辑参数指定另外需要编辑的文件 编辑标识包括\n -fmt: 只格式化文件。其他参数默认会格式化。只有在没有其他编辑参数时需要指定 -fmt -module: 修改模块路径(module 行) -require=path@version/-droprequire=path: -exclude=path@version/-dropexclude=path@version: -replace=old[@v]=new[@v]/-dropreplace=old[@v]: -go=version: -print: -json: 以 JSON 格式打印最终的 go.mod 而不是写到 go.mod。JSON 输出符合下面的 Go 类型 命令只会描述 go.mod 文件，间接引用的模块不会包含。需要查看编译所需的所有模块使用 go list -m -json all\ntype Module struct { Path string Version string } type GoMod struct { Module Module Go string Require []Require Exclude []Module Replace []Replace } type Require struct { Path string Version string Indirect bool } type Replace struct { Old Module New Module }   工具可以通过解析 go mod edit -json 的输出获取 go.mod 数据结构，然后通过 go mod edit 修改\n  graph  用法：go mod graph 功能：以文本格式打印模块需求图(使用 replaced 模块)。每一行输出包含模块及其一个依赖  init  用法：go mod init [module] 功能：在当前目录初始化并写一个新的 go.mod，实际上是以当前目录为根创建一个新模块。go.mod 一定不能已经存在。可能的话，命令会从导入注释或版本控制配置(git 等)猜测模块路径。要 覆盖猜测，可以提供模块路径参数  tidy  用法：go mod tidy [-v] 功能：确保 go.mod 和模块的源码匹配。拉取需要的缺失模块，删除无用模块。同时修改 go.sum -v 会输出删除模块信息到标准错误  vendor  用法：go mod vendor [-v] 功能：重置主模块的 vendor 目录一包含编译和测试主模块所有包所需的包。目录不包含 vendored 包的测试代码 -v 打印 vendored 模块和包的名称到标准错误  verify  用法：go mod verify 功能：检查当前模块的依赖在下载之后不曾被修改，该依赖存储在一个本地下载的源码缓存。如果所有模块未被修改，输出 all modules verified.。否则打印被修改的模块，并导致 go mod 以非 0 状态码返回  why  用法：go mod why [-m] [-vendor] packages... 功能：显示主模块到每个列举包的最短导入路径 -m 将参数视为一系列模块，并为模块的每个包找到一个路径  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2febc55e5dc0e9aa93adf5a71107750e","permalink":"https://xueqing.github.io/translation/go-doc/command/mod/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/mod/","section":"translation","summary":"用法 download edit graph init tidy vendor verify why 用法 用于操作模块。注意：所有的 go 命令支持模块 用法：go mod \u0026lt;command\u0026gt; [arguments] 命令 功能 download 下载模块到本地缓存 edit 使用工具或脚本更新 go.mod graph 打印模块","tags":["go-command"],"title":"go mod","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":" 构建并运行程序  对于简单的程序，可以使用 go run program.go 直接构建并允许程序 go run 不会再运行目录生成任何文件，可执行文件被放在临时文件中执行，工作目录被设置为当前目录 go run 可以跟参数，第一个不是以 .go 结尾的参数会作为可执行程序的参数列表的开始  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"bd57bbe073bd71deb3a1bb32299cc649","permalink":"https://xueqing.github.io/translation/go-doc/command/run/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/run/","section":"translation","summary":"构建并运行程序 对于简单的程序，可以使用 go run program.go 直接构建并允许程序 go run 不会再运行目录生成任何文件，可执行文件被放在临时文件中执行，工作目录被设置","tags":["go-command"],"title":"go run","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"用法：go test [build/test flags] [packages] [build/test flags \u0026amp; test binary flags]\ngo test 自动测试通过导入路径命名的包。命令按下面的格式打印测试结果的概要：\nok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ...  之后是每个失败的包的详细输出。\ngo test 重新编译每个包以及所有名字匹配 “*_test.go” 的文件。这些额外的文件可以包含测试函数，基准测试函数和示例函数。查看 go help testfunc 获取更多信息。每个列举的包执行一个单独的二进制测试。忽视以 “_” (包括 “_test.go”) 或 “.” 开始的文件。\n声明了后缀为 “_test” 的包的测试文件会作为一个单独的包被编译，然后被主二进制测试链接和运行。\ngo tool 会忽视 “testdata” 命名的目录，使得可以包含测试所需的辅助数据。\n作为编译一个二进制测试的一部分，go test 在包及其测试源文件上运行 go vet 以识别显著的问题。如果 go vet 发现任何问题，go test 报告这些问题并且不再运行二进制测试。只使用了默认 go vet 检查的高可信度的子集。这些子集包括：atomic、bool、buildtags、nilfunc 和 printf。你可以通过 go doc cmd/vet 查看他们的文档以及其他的 vet 测试。使用 -vet=off 标识禁用 go vet 的运行。\n即使测试打印输出到它自己的标准错误，所有的测试输出和总结行会被打印到 go 命令的标准输出。(保留 go 命令的标准错误用于打印编译这些测试的错误。)\ngo test 运行包括两种模式：\n 叫做本地目录模式。当调用 go test 不带包参数时发生(如 go test 或 go test -v)。在这种模式，go test 在当前目录找到的包源文件和测试文件，然后运行生成的二进制测试。在这种模式，禁用缓存(后面会讨论)。包测试结束之后，go test 打印一个总结行显示测试状态(“ok” 或 “FAIL”)、包名和用时。 叫做包列表模式。当调用 go test 携带显式的包参数时发送(如 go test math、go test ./... 甚至 go test ..)。在这种模式，go test 编译和测试命令行列举的每个包。如果一个包测试通过，go test 只打印最后的 “ok” 总结行。如果一个包测试失败，go test 打印完整的测试输出。如果调用时携带 -bench 或 -v 标识，go test 也会为通过测试包打印完整的输出，以显示请求的基准测试结果或错误日志。当所有列举的包测试结束且打印了他们的输出之后，如果任何一个包测试失败，go test 打印一个最终的 “FAIL” 状态。  只有在包列表模式，go test 会缓存成功的包测试结果以避免不必要的重复运行测试。当一个测试的结果可从缓存中恢复时，go test 会再次显示之前的输出而不是再次运行二进制测试。这时，go test 打印 “(cached)” 取代总结行中的用时。\n缓存匹配的规则是 go 命令调用相同的二进制测试，且命令行标识完全来自受限的可缓存的测试标识集合，被定义为 -cpu、-list、-parallel、-run、-short 和 -v。如果允许一次 go test 包含任何这个集合之外的测试标识或非测试标识，结果都是不可缓存的。要禁用测试缓存，使用除了可缓存的标识以外的任意的测试标识或参数。惯用的显式禁用测试缓存的方法是使用 -count=1。打开在包的源根(通常是 $GOPATH)或者查询环境变量的测试只有在这些文件和环境变量不改变时才会与之后的运行匹配。一个缓存的测试结果被视为立刻执行，因此无论如何设置 -timeout，一个成功的包测试结果会被缓存且重用。\n除了编译标志，go test 专属的标识包括：\n args：传递命令行的剩余部分(-args 之后的所有)给二进制测试，不解释且不修改。因为这个标识使用了命令行的剩余部分，包列表(如果有)必须出现在这个标识之前。 -c：编译二进制测试为 pkg.test 但不要运行(pkg 是包导入路径的最后一个元素)。文件名可以使用 -o 标识修改。 -exec xprog：使用 xprog 运行二进制测试。这个行为和 go run 相同。查看 go run 获取更多信息。 -i：安装测试的依赖包。不要运行测试。 -json：将测试输出转化为 JSON 用于自动处理。查看 go doc test2json 获取编码信息。 -o file：编译二进制测试到指定名称的文件。测试仍然运行(除非指定 -c 或 -i)。  二进制测试也接收控制测试执行的标识；这些标识也可被 go test 访问。查看 go help testflag 获取更多信息。\n需要更多关于编译标识，查看 go help build。需要更多关于指定包的，查看 go help package。\n查看其他：go build、go vet\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e2d42fb61ceb1fcc90383fb94bf4a788","permalink":"https://xueqing.github.io/translation/go-doc/command/test_package/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/test_package/","section":"translation","summary":"用法：go test [build/test flags] [packages] [build/test flags \u0026amp; test binary flags] go test 自动测试通过导入路径命名的包。命令按下面的格式打印测试结果的概要： ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... 之后是每个失败的包的","tags":["go-command"],"title":"go test","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  sync.Mutex  sync.Mutex  互斥：保证每次只有一个 goroutine 可以访问一个共享的变量 go 标准库提供 sync.Mutex 互斥锁类型及两个方法： Lock 和 Unlock\n 在代码前调用 Lock，在代码后调用 Unlock 保证这段代码的互斥执行 可用 defer 语句保证互斥锁一定会被解锁\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;sync\u0026quot; \u0026quot;time\u0026quot; ) // SafeCounter is safe to use concurrently. type SafeCounter struct { v map[string]int mux sync.Mutex } // Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mux.Unlock() } // Value returns the current value of the counter for the given key. func (c *SafeCounter) Value(key string) int { c.mux.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mux.Unlock() return c.v[key] } func main() { c := SafeCounter{v: make(map[string]int)} for i := 0; i \u0026lt; 1000; i++ { go c.Inc(\u0026quot;somekey\u0026quot;) } time.Sleep(time.Second) fmt.Println(c.Value(\u0026quot;somekey\u0026quot;)) }    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ba6c1ccb2ec0606c4b3299ada8bbb59c","permalink":"https://xueqing.github.io/blog/go/basic/go_mutex/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_mutex/","section":"blog","summary":"sync.Mutex sync.Mutex 互斥：保证每次只有一个 goroutine 可以访问一个共享的变量 go 标准库提供 sync.Mutex 互斥锁类型及两个方法： Lock 和 Unlock 在代码前调用 Lock，在代码后调用 Unlock 保证这段代码","tags":["go"],"title":"go 互斥锁","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  函数 function 函数用法 函数值  匿名函数 可变函数 variadic function  方法 vs 函数  方法的值接收者 vs 函数的值参数 方法的指针接收者和函数的指针参数   函数 function  函数是基本的代码块，用于执行一个任务 最少有一个 main 函数，且 main 函数必须在 main 包中 可通过函数划分不同功能，逻辑上每个函数执行指定的任务 函数声明包含名称、返回类型和参数\n 参数可选，类似于占位符，是函数的形参。当连续两个或多个已命名形参类型相同时，除最后一个类型外，其它都可以忽略 值传递：调用函数时将实际参数复制一份传递给函数，函数内修改参数不会影响实际参数 引用传递：调用函数时传递参数的地址，函数内修改参数会影响到实际的值 默认使用值传递 返回类型可选 多值返回：函数可以返回任意数量的返回值 命名返回值：返回值可以是命名的，可以当做是定义在函数顶部的变量\n 这些名字应当具有一定的意义，可作为文档使用用于记录返回值的含义 一个不带参数的 return 语句返回命名返回值，也就是直接返回。直接返回语句应只用于短函数，否则会破坏函数的可读性\nfunc func_name( [param_list] ) [return_types] { // func_body } func swap(x, y string) (string, string) { return y, x } // 命名返回值 func split(sum int) (x, y int) { sx = sum * 4 / 9 sy = sum - x sreturn }     函数用法 函数值  函数作为值，即定义后作为值使用 函数值可以像其他值一样传递，可以用作函数的参数或返回值\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) }   匿名函数  闭包，即匿名函数，在动态编程中使用 闭包是一个函数值，它引用了其函数体外的变量。该函数可以访问并赋予其引用的变量的值，即该函数被这些变量“绑定”在一起 匿名函数是一个“内联”语句或表达式，其优越性在于可以直接使用函数内的变量，不必声明\nfunc getSequence() func() int { i := 0 return func() int { i += 1 return i } } nextNum := getSequence() //i=0 fmt.Println(nextNum()) //i=1 fmt.Println(nextNum()) //i=2 fmt.Println(nextNum()) //i=3 nextNum1 := getSequence() //i=0 fmt.Println(nextNum1()) //i=1 fmt.Println(nextNum1()) //i=2  package main import \u0026quot;fmt\u0026quot; func fibonacci() func() int { before := 0 val := 1 return func() int { ret := before before = val val = ret + val return ret } } func main() { f := fibonacci() for i := 0; i \u0026lt; 10; i++ { fmt.Println(f()) } }   可变函数 variadic function  可变函数的参数数目是可变的，当最后一个参数用...T表示时，函数就可以接受任意数目的类型 T 作为最后一个参数 可变函数实际是将传递的可变数目的参数转成一个新建的切片作为参数 不能直接传递一个切片作为参数给可变函数，还需要在切片后面加上...，才可以将切片作为可变函数的参数，而且不用创建新切片，而是直接传递原始的切片  方法 vs 函数  方法是包含了接收者的函数 可以把接收者作为函数的参数来实现方法 为什么使用方法  go 不是一个纯粹的面向对象的变成语言，可以使用方法来实现和类类似的行为 可以定义类型不同的同名方法，但是不能定义同名函数   方法的值接收者 vs 函数的值参数  具有值参数的函数，只能接受值作为参数 具有值接收者的方法，可以接受指针和值接收者\ntype rectangle struct { len float64 width float64 } func area(rec rectangle) { fmt.Println(\u0026quot;area: %f * %f = %f\u0026quot;, rec.len, rec.width, (rec.len * rec.width)) } func (rec rectangle) area() { fmt.Println(\u0026quot;area: %f * %f = %f\u0026quot;, rec.len, rec.width, (rec.len * rec.width)) } func caller() { r := rectangle( len: 3, width: 4, ) area(r) r.area() p := \u0026amp;r //area(p),编译错误 p.area() //go 会解释成(*p).area() }   方法的指针接收者和函数的指针参数  具有指针参数的函数，只能接受指针作为参数 具有指针接收者的方法，可以接受指针和值接收者\ntype rectangle struct { len float64 width float64 } func area(rec *rectangle) { fmt.Println(\u0026quot;area: %f * %f = %f\u0026quot;, rec.len, rec.width, (rec.len * rec.width)) } func (rec *rectangle) area() { fmt.Println(\u0026quot;area: %f * %f = %f\u0026quot;, rec.len, rec.width, (rec.len * rec.width)) } func caller() { r := rectangle( len: 3, width: 4, ) p := \u0026amp;r area(p) p.area() //area(r),编译错误 r.area() //go 会解释成(\u0026amp;p).area() }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"315fc64ab9c0cc34cd0ed1585e3a9ee9","permalink":"https://xueqing.github.io/blog/go/basic/go_function/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_function/","section":"blog","summary":"函数 function 函数用法 函数值 匿名函数 可变函数 variadic function 方法 vs 函数 方法的值接收者 vs 函数的值参数 方法的指针接收者和函数的指针参数 函数 function 函数是基本的代码块，用于","tags":["go"],"title":"go 函数","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  slice slice 长度和容量  append 追加到 slice  copy 对 slice 拷贝 对 slice 切片 slice vs array  创建 array 和 slice 切片底层是数组  使用 make 函数创建 slice slice 内存储 slice 内存优化  slice  切片是对数组的抽象，是一种“动态数组”，长度不固定，可以追加元素 定义 var slice_name []type 初始化  直接初始化slice_name := [] int {var1, var2..., varn} 引用数组初始化slice_name := arr_name[:] 引用部分数组初始化 slice_name := arr_name[startIndex:endIndex]，引用下标 startIndex 到 endIndex-1 下的元素创建为一个新的切片 slice_name := arr_name[startIndex:]，引用下标 startIndex 到最后一个元素创建为一个新的切片 slice_name := arr_name[startIndex:]，引用第一个元素到 endIndex-1 下的元素创建为一个新的切片 通过切片初始化slice_name := origina_slice[startIndex:endIndex]   slice 长度和容量  使用 len(slice_name) 方法获取切片长度，指的是 slice 中元素的数目 使用 cap(slice_name) 方法获取切片容量，即最长可以达到多少，指的是底层数组的元素数目，起始下标是创建切片时的起始下标 空切片 nil，即未初始化的切片，长度为 0，容量为 0，没有底层数组 切片截取slice_name[lower_bound : upper_bound]  下限默认为 0 上限默认为 len(slice_name)  增加切片容量：创建一个更大的数组并把原数组的内容拷贝到新数组，新切片的容量增加一倍  使用 append(slice_name, [param_list]) 函数往切片追加新元素 [param_list]也可以是一个切片，用...，如newslice := append(slice1, slice2...) 使用 copy(dst_slice, ori_slice) int 函数拷贝切片   append 追加到 slice  使用 func append(slice_name []T, [param_list]) []T 函数往切片追加新元素\n slice 的类型是 T [param_list]是要追加到 slice 的 T 类型的值，也可以是一个切片，用 ...，如 newslice := append(slice1, slice2...) 返回值是一个 slice，包含了 slice_name 的所有元素以及追加的所有元素 如果 slice_name 不能包含所有追加的元素，会分配一个更大的数组，返回的 slice 指向新分配的数组\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { var s []int printSlice(s) //len=0 cap=0 [] s = append(s, 0) printSlice(s) //len=1 cap=1 [0] s = append(s, 1) printSlice(s) //len=2 cap=2 [0 1] s = append(s, 2, 3, 4) printSlice(s) //len=5 cap=6 [0 1 2 3 4] a := []int{7, 8, 9} s = append(s, a...) //使用 ... 语法将参数展开为参数列表 printSlice(s) //len=8 cap=12 [0 1 2 3 4 7 8 9] } func printSlice(s []int) { fmt.Printf(\u0026quot;len=%d cap=%d %v\\n\u0026quot;, len(s), cap(s), s) }    copy 对 slice 拷贝  使用 copy(dst_slice, ori_slice) int 函数拷贝切片  将 ori_slice 的元素复制到 dst_slice 返回复制元素的数目   对 slice 切片  当 slice 容量足够大，可以对一个 slice 进行再切片\npackage main import \u0026quot;fmt\u0026quot; func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) //len=6 cap=6 [2 3 5 7 11 13] s = s[:0] //分割 slice 长度为 0 printSlice(s) //len=0 cap=6 [] s = s[:4] //扩展 slice 长度 printSlice(s) //len=4 cap=6 [2 3 5 7] s = s[2:] //丢弃前两个值 printSlice(s) //len=2 cap=4 [5 7] s = s[:4] //扩展 slice printSlice(s) //len=4 cap=4 [5 7 11 13] // s = s[:6] //error: slice bounds out of range [:6] with capacity 4 } func printSlice(s []int) { fmt.Printf(\u0026quot;len=%d cap=%d %v\\n\u0026quot;, len(s), cap(s), s) }   slice vs array  参考 Go 切片：用法和本质  创建 array 和 slice  创建一个数组 [3] bool {true, true, false} 创建一个相同的数组，并且创建数组的一个 slice 引用 [] bool {true, true, false} 切片没有指定元素的数目\npackage main import \u0026quot;fmt\u0026quot; func main() { slice1 := []int{2, 3, 5, 7, 11, 13} fmt.Println(slice1) slice2 := []bool{true, false, true, true, false, true} fmt.Println(slice2) st := []struct{ i int b bool } { {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } fmt.Println(st) }   切片底层是数组  slice 是一个数组片段的描述。它包含了指向数组的指针、片段的长度和容量(片段的最大长度)  长度是 slice 引用的元素数目 容量是底层数组的元素数目(从切片指针开始计数) 切片增长不能超出其容量，否则会导致运行时异常。也不能使用小于零的索引访问切片之前的元素  slice 其实是对底层数组的引用，本身不存储数据，对 slice 的修改会修改底层的数组，其他共享底层数据的 slice 也会看到底层数组的修改  slice 操作不会复制底层指向的元素。它创建一个新的 slice 并复用之前 slice 的底层数组 slice 操作和数组索引一样高效  slice 作为函数变量，函数内对 slice 的修改也会影响调用者底层数组的元素\nfunc sliceTest() { arr := [...]int{1, 2, 3, 4, 5, 6, 7} sli := arr[1:4] fmt.Printf(\u0026quot;slice len=%d, cap=%d\u0026quot;, len(sli), cap(sli)) //1,2,3,4,5,6,7 fmt.Println(\u0026quot;original array \u0026quot;, arr) //1,2,3,4,5,6,7 for i := range sli { sli[i]++ } fmt.Println(\u0026quot;modifiled array \u0026quot;, arr) //1,3,4,5,5,6,7 }   使用 make 函数创建 slice  可使用内置 make 函数创建切片var slice_name []type = make([]type, len, cap)或slice_name := make([]type, len, cap)\n make 函数创建一个数组，然后返回一个引用数组的切片 len 是数组的长度也是切片的初始长度 cap 容量参数可选，默认为指定的长度大小 通过 make 函数初始化slice_name := make([]type, len, cap)\npackage main import \u0026quot;fmt\u0026quot; func main() { s := make([]int, 5) //长度和容量为 5，初始值都为 0 printSlice(\u0026quot;s\u0026quot;, s) //s len=5 cap=5 [0 0 0 0 0] a := make([]int, 0, 5) //长度为 0，容量为 5，初始为空 printSlice(\u0026quot;a\u0026quot;, a) //a len=0 cap=5 [] b := a[:2] //长度为 2，容量为 5，初始值为 0 printSlice(\u0026quot;b\u0026quot;, b) //b len=2 cap=5 [0 0] c := b[2:5] //长度为 3，容量为 3，初始值为 0 printSlice(\u0026quot;c\u0026quot;, c) //c len=3 cap=3 [0 0 0] } func printSlice(str string, s []int) { fmt.Printf(\u0026quot;%s len=%d cap=%d %v\\n\u0026quot;, str, len(s), cap(s), s) }    slice 内存储 slice  slice 可以存储任何类型，包含其他 slice\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;strings\u0026quot; ) func main() { board := [][]string{ []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, []string{\u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;, \u0026quot;_\u0026quot;}, } board[0][0] = \u0026quot;X\u0026quot; board[0][2] = \u0026quot;X\u0026quot; board[1][0] = \u0026quot;O\u0026quot; board[1][2] = \u0026quot;X\u0026quot; board[2][2] = \u0026quot;O\u0026quot; for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026quot;%s\\n\u0026quot;, strings.Join(board[i], \u0026quot; \u0026quot;)) } }   内存优化  slice 是对底层数组的引用，因此只要 slice 在内存中，数组就不能被回收 当切片只引用了一小部分数组的数据来处理，可以使用func copy(dst, src []T) int来赋值切片，然后使用新切片就可以回收原始的较大的数组  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"86acb8ca47034b211325e47dccb9559c","permalink":"https://xueqing.github.io/blog/go/basic/go_slice/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_slice/","section":"blog","summary":"slice slice 长度和容量 append 追加到 slice copy 对 slice 拷贝 对 slice 切片 slice vs array 创建 array 和 slice 切片底层是数组 使用 make 函数创建 slice slice 内存储 slice 内存优化 slice 切片是对数组的抽象，是一种“动态","tags":["go"],"title":"go 切片","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  package 默认导入 导出包内标识符 导入包的重命名  Go 编译速度快  导入匿名包 包的初始化入口 init 内部包 包的文档化  package  package pkg_name定义程序属于哪个包，每个 go 文件第一行 package 用于组织 go 的源码改善可用性和易读性，提供代码的模块化 代码包的导入路径是相对于 Go 语言自身的源码目录（即 $GOROOT/src）或在环境变量 GOPATH 中指定的某个目录的 src 子目录下的子路径，使用 / 分隔路径 导入的包名使用双引号包围，习惯上将文件夹的最后一个元素命名与包名一致。例外的情况  如果某包定义一条命令(可执行的 Go 程序)，那么总是使用 main。这是告诉 go build 必须调用链接器生成可执行文件 目录中一些文件以 test.go 结尾，包名会以 _test 结尾，这是外部测试包。其他的文件是普通包。_test 后缀告诉 go test 两个包都需要构建，并指明文件属于哪个包 外部测试包用于避免测试所依赖的导入图中的循环依赖 一些依赖管理工具会在包导入路径末尾追加版本号，包名仍然不包含版本号后缀   默认导入  单行导入：import pkg_name 导入包 多行导入：导入多个包时，建议使用 () 将导入的包放在一起，即分组导入 包分组：导入的包之间通过添加空行分组。通常将来自不同组织的包独立分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列  导出包内标识符  导出名：首字母大写的名字是导出的名字，首字母小写只能包内使用。导入包之后只能使用包导出的名字  导入包的重命名  导入包后可以自定义引用的包名 导入包的重命名：如果同时导入两个名字相同的包，那么导入声明必须至少为一个同名包指定一个新的包名避免冲突\nimport ( \u0026quot;crypto/rand\u0026quot; mrand \u0026quot;math/rand\u0026quot; )  导入包的重命名只影响当前源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字\n 导入包重命名不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便\n 选择用简短名称重命名导入包时候最好统一，以避免包名混乱 选择另一个包名称还可以帮助避免和本地普通变量名产生冲突  每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误\n  Go 编译速度快  有三个主要原因  所有的导入必须在每一个源文件的开头进行显示列出，这样编译器不需要读取和处理整个文件来确定依赖性 包的依赖性形成有向无环图，因为没有环，包可以独立甚至并行编译 Go 包编译输出的目标文件不仅记录它自己的导出信息，也记录所依赖包的导出信息。当编译一个包时，编译器对于每一个导入必须读取一个目标文件，但是不需要超出这些文件   导入匿名包  go 导入一个包之后不在代码中使用是不合法的  导入包，只需要调用包中的 init 函数：在包名之前加下划线和空格import _ pkg_name 暂时导入包，之后才会需要，建议在 import 之后紧跟语句var _ = pkg_name.SomeFunc // error silencer，此语句可避免编译错误 在真正使用包中的代码之后就删掉此语句   包的初始化入口 init  init 函数用于执行初始化任务，或者在执行之前验证程序的正确性 init 函数的特性  每个源码可以使用 1 个 init 函数 init 函数会在程序执行前(main 函数执行前)被自动调用 调用顺序为 main 中引用的包，以深度优先顺序初始化 假设包的引用关系 main-\u0026gt;A-\u0026gt;B-\u0026gt;C，那么这些包的 init 函数调用顺序为 C.init-\u0026gt;B.init-\u0026gt;A.init-\u0026gt;main 同一个包中的多个 init 函数的调用顺序不可预期 init 函数不应有返回值，不应包括任何参数，不能在源码中显式调用  包的初始化顺序  初始化包级别的变量 调用 init 函数，如果有多个 init 函数（在一个或多个文件中），按照编译器接收顺序调用：go 会从 main 包开始检查其引用的所有包，每个包也可能包含其他的包。编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。在运行时，被最后导入的包会最先初始化并调用 init 函数 导入的包先初始化  每个包只初始化一次\n geometry.go\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;geometry/rectangle\u0026quot; \u0026quot;log\u0026quot; ) var recLen, recWidth float64 = 3, -4 func init() { fmt.Println(\u0026quot;Geometry init func\u0026quot;) if recLen \u0026lt; 0 { log.Fatal(\u0026quot;length is less than zero\u0026quot;) } if recWidth \u0026lt; 0 { log.Fatal(\u0026quot;width is less than zero\u0026quot;) } } func main() { fmt.Println(\u0026quot;Geometry main func\u0026quot;) fmt.Println(\u0026quot;rectangle area: %.2f\u0026quot;, rectangle.Area(recLen, recWidth)) fmt.Println(\u0026quot;rectangle diagonal: %.2f\u0026quot;, rectangle.Diagonal(recLen, recWidth)) }  rectangle.go\npackage rectangle import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) func init() { fmt.Println(\u0026quot;Rectangle init func\u0026quot;) } func Area(len, width float64) float64 { area := len * width return area } func Diagonal(len, width float64) float64 { diagonal := math.Sqrt(len*len + width*width) return diagonal }   内部包  内部包只能被另一个包导入。这个包位于以 internal 目录的父目录为根目录的树中 内部包可以不需要导出标识符就可以被满足条件的包访问 例如有下面的文件夹 net/http net/http/internal/chunked net/http/httputil net/url  net/http/httputil 和 net/http 可以导入 net/http/internal/chunked net/url 不可以导入 net/http/internal/chunked net/url 可以导入 net/http/httputil   包的文档化  文档注释是完整的语句，使用声明的包名作为开头的第一句注释通常是总结  可以出现在任何文件，但是必须只有一个 文件名通常是 doc.go  函数参数和其他的标识符不用括号或特别标注  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b487da9604b20d02e15b78a9dd0d1c48","permalink":"https://xueqing.github.io/blog/go/basic/go_package/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_package/","section":"blog","summary":"package 默认导入 导出包内标识符 导入包的重命名 Go 编译速度快 导入匿名包 包的初始化入口 init 内部包 包的文档化 package package pkg_name定义程序属于哪个包，每个 go 文","tags":["go"],"title":"go 包","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 变量声明使用关键字 var。可以用于包内或函数内 变量声明\n 指定类型不赋值，使用默认值 var vname vtype = value 提供初始化值时可省略类型，根据初始化值自行判定变量类型 var vname = value 省略 var，注意:=左侧的变量不应该是已经声明过的，否则会导致编译错误 vname := value，省略了变量类型 只能用于函数体内，建议使用。函数外的每个语句都是以关键字(var/func等)开头，因此不能使用 :=\nvar a int = 10 var b = 10 c := 10   多变量声明\n 使用 var 声明 可出现在包或函数级别 类型相同，非全局变量  var vname1 vname2 vname3 vtype = v1, v2, v3  不声明类型，自动推断  var vname1, vname2, vname3 = v1, v2, v3  短变量声明：使用:=，左侧的变量是未声明过的 vname1, vname2, vname3 := v1, v2, v3 只能在函数体中使用，建议使用 必须一次初始化所有的变量 左边至少有一个变量是未声明过的，否则编译错误no new variables on left side of := 因式分解关键字：一般用于声明全局变量，在一个语句中声明不同类型的变量，即“分组”成一个语法块\nvar ( vname1 vtype1 vname2 vtype2 )   注意\n 已声明的变量不能再使用:=赋值 定义变量之前使用会是编译错误undefined 在代码块定义局部变量未使用是编译错误declared but not used 全局变量运行只定义不使用  可以并行赋值/同时赋值a, b, c = 5, 7, \u0026quot;abc\u0026quot;\n 在实际更新变量前，右边所有的表达式被推演 如果表达式比较复杂，避免使用多重赋值形式  交换变量值，必须类型相同a, b = b, a\n 空白标识符_用于抛弃值\n 一个只写变量，不能得到值 可以接收函数返回值，但是只使用部分返回值  支持给变量赋值，该值在运行时计算\n c := math.Min(a, b)  go 是强类型语言，不支持隐式类型转换\nage := 20 age = \u0026quot;kiki\u0026quot; //error: cannot use \u0026quot;kiki\u0026quot; (type string) as type int in assignment   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e7e7736ccc11a4397206c06e41222d87","permalink":"https://xueqing.github.io/blog/go/basic/go_variables/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_variables/","section":"blog","summary":"变量声明使用关键字 var。可以用于包内或函数内 变量声明 指定类型不赋值，使用默认值 var vname vtype = value 提供初始化值时可省略类型，根据初始化值自行判定变量","tags":["go"],"title":"go 变量","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 函数内定义的变量是局部变量，只作用于函数体内，参数和返回值都是局部变量 函数外定义的变量是全局变量，全局变量可在整个包甚至外部包（导出后）使用  函数内的局部变量可以覆盖全局变量  函数定义中的变量是形式参数，形式参数作为函数的局部变量使用 变量默认值，即默认初始化的值  int 默认值 0 float32 默认值 0 pointer 默认值 nil   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f081a3fa0c96d50c7c91e61faacd1c74","permalink":"https://xueqing.github.io/blog/go/basic/go_scope_rule/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_scope_rule/","section":"blog","summary":"函数内定义的变量是局部变量，只作用于函数体内，参数和返回值都是局部变量 函数外定义的变量是全局变量，全局变量可在整个包甚至外部包（导出后）使用","tags":["go"],"title":"go 变量作用域","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 行分隔符：一行就是一个语句；多个语句放一行需要手动加;，但是不建议 注释不被编译，但是建议每个包一个注释 标识符：用于命名变量、类型等程序实体，以字母或下划线开头 关键字，25 个  break, case, chan, const, continue default, defer, else, fallthrough, for func, go, goto, if, import interface, map, package, range, return select, struct, switch, type, var  预定义标识符，36 个  append, bool, byte, cap, close, complex complex64, complex128, copy, false, float32, float64 imag, int, int8, int16, int32, int64 iota, len, make, new, nil, panic print, println, real, recover, string, true uint, uint8, uint16, uint32, unit64  空格：变量声明需要空格隔开；适当空格增加易阅读性  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d39bb780cf07235a7c35c9cee0a06970","permalink":"https://xueqing.github.io/blog/go/basic/go_basic_syntax/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_basic_syntax/","section":"blog","summary":"行分隔符：一行就是一个语句；多个语句放一行需要手动加;，但是不建议 注释不被编译，但是建议每个包一个注释 标识符：用于命名变量、类型等程序实体，","tags":["go"],"title":"go 基础语法","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  常量 数值常量  常量  定义类似于变量声明，但是需要 const 关键字  const vname [vtype] = value 显式类型定义const vname vtype = value 隐式类型定义const vname = value  不能使用 := 声明 相同类型声明 const vname1, vname2, vname3 = value1, value2, value3 用于枚举\nconst { Unknown = 0 Famale = 1 Male = 2 }  常量可使用 len(), cap(), unsafe.Sizeof() 函数计算表达式的值，函数必须是内置函数，否则编译错误\na = \u0026quot;abc\u0026quot; unsafe.Sizeof(a) //16，字符串类型在 go 中是个结构，包括指向数组的指针和长度，每部分都是 8 字节，所以是 16 个字节  iota: 特殊常量，一个可被编译器修改的常量\n 在 const 关键字出现时被重置为 0（const 内部的第一行之前） const 中每新增一行常量声明，iota 计数一次\nconst { a = iota //a=0 b = iota //b=1，也可写 b c = iota //c=2，也可写 c }   常量必须在编译时确定\n  数值常量  数值常量是高精度值，一个没有类型的常量根据上下文确定自身的类型\npackage main import \u0026quot;fmt\u0026quot; const ( Big = 1 \u0026lt;\u0026lt; 100 Small = Big \u0026gt;\u0026gt; 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needInt(Big)) //error: constant 1267650600228229401496703205376 overflows int fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"88398a61384484527c805cbfeb70a30c","permalink":"https://xueqing.github.io/blog/go/basic/go_constant/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_constant/","section":"blog","summary":"常量 数值常量 常量 定义类似于变量声明，但是需要 const 关键字 const vname [vtype] = value 显式类型定义const vname vtype = value 隐式类型定义const vname = value 不能使用 := 声明 相同类","tags":["go"],"title":"go 常量","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  for 循环 \u0026ldquo;while\u0026rdquo; 循环 循环嵌套 循环控制语句 无限循环  for 循环  go 循环只有 for 结构。包含 3 个组件  初始化语句：通常是短变量声明，声明的变量只对 for 循环可见 条件语句：条件为 false 时退出循环 后置语句  上述三个组件不需要小括号，但是需要大括号\npackage main import \u0026quot;fmt\u0026quot; func main() { sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) }   \u0026ldquo;while\u0026rdquo; 循环  初始化语句和后置语句是可选的，此时可以去掉两个分号，相当于 C 的 while\npackage main import \u0026quot;fmt\u0026quot; func main() { sum := 1 for sum \u0026lt; 1000 { //或 \u0026quot;for ; sum \u0026lt; 1000; {\u0026quot; sum += sum } fmt.Println(sum) }   循环嵌套 for 循环嵌套 for 循环\n循环控制语句  break continue goto  无限循环  省略条件语句，或设置循环条件为永真，就是无限循环\nfor { //或 \u0026quot;for true {\u0026quot; //... }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"dd4179689124859508f00044ed131c8d","permalink":"https://xueqing.github.io/blog/go/basic/go_loop/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_loop/","section":"blog","summary":"for 循环 \u0026ldquo;while\u0026rdquo; 循环 循环嵌套 循环控制语句 无限循环 for 循环 go 循环只有 for 结构。包含 3 个组件 初始化语句：通常是短变量声明，声明的变量只对 for 循环可见 条件语句：","tags":["go"],"title":"go 循环语句","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 指针变量指向一个值的内存地址：不是所有值都有地址，但是所有变量都有地址  每一个聚合类型变量的组成(结构体的成员或数组中的元素)都是变量，都有一个地址  先声明指针才可以使用指针 声明var ptr_name *ptr_type  ptr_type是指针类型 ptr_name是指针变量名 *用于指定变量是作为一个指针  通过 \u0026amp; 生成一个变量的指针变量\ni := 42 p = \u0026amp;i  *ptr在指针类型前加*获取指针所指向的内容，也就是“间接引用”或“重定向”\nfmt.Println(*p) *p = 21  和 C 不同，go 的指针没有数学运算\n 空指针 nil：指针定义后未分配到变量时值为 nil，类似其他语言的 null/None/nil/NULL\n 指针变量通常缩写为 ptr\n 指针数组，来存储地址，声明var ptr_name [len]*ptr_type\n 指向指针的指针，声明var pptr_name **pptr_type\n **pptr在指针的指针类型前加**获取指针所指向的内容  指针作为函数参数，通过引用或地址传参可在函数内部改变变量值\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f3731ca0187d9e800f933c4d071e6807","permalink":"https://xueqing.github.io/blog/go/basic/go_pointer/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_pointer/","section":"blog","summary":"指针变量指向一个值的内存地址：不是所有值都有地址，但是所有变量都有地址 每一个聚合类型变量的组成(结构体的成员或数组中的元素)都是变量，都有一","tags":["go"],"title":"go 指针","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  非侵入式设计 接口定义 接口实现 接口值  底层值为 nil 的接口值 接口值为 nil 空接口  类型断言(type assertion) 类型选择(type switch) 接口和类型的关系  一个类型可以实现多个接口 多个类型可以实现相同的接口   非侵入式设计  Go 语言的接口设计是非侵入式的，接口编写者无须知道接口被哪些类型实现。而接口实现者只需知道实现的是什么样子的接口，但无须指明实现哪一个接口。编译器知道最终编译时使用哪个类型实现哪个接口，或者接口应该由谁来实现 非侵入式设计是 Go 语言设计师经过多年的大项目经验总结出来的设计之道。只有让接口和实现者真正解耦，编译速度才能真正提高，项目之间的耦合度也会降低不少 传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。对于 Go 语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用 Go 语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么”，以及“我能实现什么”  接口定义  接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构 在面向对象中，接口定义了一个对象的行为 使用 type 和 interface 关键字定义接口\ntype interface_name interface { method_name1([param_list]) [return_type] method_name2([param_list]) [return_type] method_name3([param_list]) [return_type] ... method_namen([param_list]) [return_type] }   interface_name：接口类型名。使用 type 将接口定义为自定义的类型名。Go 语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等 method_name：方法名。当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包之外的代码访问 param_list return_type：参数列表和返回值列表中的参数变量名可以被忽略   接口实现  接口类型是由一组方法签名定义的集合，接口类型的变量可以保存任何实现了这些方法的值 接口把所有的具有共性的方法定义在一起，如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型 实现关系在 Go 语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go 语言中没有类似于 implements 的关键字。Go 编译器将自动在需要的时候检查两个类型之间的实现关系 接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用\n 接口的方法与实现接口的类型方法格式一致 接口中所有方法均被实现\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type abser interface { Abs() float64 } func main() { var a abser f := myFloat(-math.Sqrt2) v := vertex{3, 4} a = f // a myFloat 实现了 abser fmt.Println(a.Abs()) a = \u0026amp;v // a *vertex 实现了 abser fmt.Println(a.Abs()) // a = v // error: v 是一个 vertex(而不是 *vertex), 所以没有实现 abser } type myFloat float64 func (f myFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } type vertex struct { X, Y float64 } func (v *vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) }    接口值  接口也是值  接口值可用作函数的参数或返回值 在内部，接口值可看做包含值和具体类型的元组 (value, type) 通过 %v 和 %T 可以访问接口的值和类型  接口值保存了一个具体底层类型的具体值 接口值调用方法时会执行其底层类型的同名方法\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type myInterface interface { M() } type st struct { S string } func (t *st) M() { fmt.Println(t.S) } type myFloat float64 func (f myFloat) M() { fmt.Println(f) } func main() { var i myInterface i = \u0026amp;st{\u0026quot;Hello\u0026quot;} describe(i) i.M() i = myFloat(math.Pi) describe(i) i.M() } func describe(i myInterface) { fmt.Printf(\u0026quot;(%v, %T)\\n\u0026quot;, i, i) }   底层值为 nil 的接口值  接口内的具体值为 nil，方法仍然会被 nil 接收者调用。保存了 nil 具体值的接口本身并不为 nil\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type myInterface interface { M() } type st struct { S string } func (t *st) M() { if t == nil { fmt.Println(\u0026quot;\u0026lt;nil\u0026gt;\u0026quot;) return } fmt.Println(t.S) } func main() { var i myInterface i = \u0026amp;st{\u0026quot;Hello\u0026quot;} describe(i) i.M() var stp *st i = stp describe(i) i.M() } func describe(i myInterface) { fmt.Printf(\u0026quot;(%v, %T)\\n\u0026quot;, i, i) }   接口值为 nil  nil 接口值既不保存值也不保存具体类型 为 nil 接口调用方法会报运行时错误，因为接口的元组内并未包含可以指明该调用哪个具体方法的类型\npackage main import ( \u0026quot;fmt\u0026quot; ) type myInterface interface { M() } func main() { var i myInterface describe(i) i.M() // panic: runtime error: invalid memory address or nil pointer dereference } func describe(i myInterface) { fmt.Printf(\u0026quot;(%v, %T)\\n\u0026quot;, i, i) }   空接口  指定了零个方法的接口值称为 “空接口” interface{} 空接口可保存任何类型的值(因为每个类型都至少实现了零个方法) 空接口用于处理未知类型的值。如 fmt.Print 可接受类型为 interface{} 的任意数量的参数\npackage main import \u0026quot;fmt\u0026quot; func main() { var i interface{} describe(i) i = 42 describe(i) i = \u0026quot;hello\u0026quot; describe(i) } func describe(i interface{}) { fmt.Printf(\u0026quot;(%v, %T)\\n\u0026quot;, i, i) }   类型断言(type assertion)  类型断言提供了访问接口值底层具体值的方式 t := i.(T)  断言接口值 i 保存了具体类型 T，并将其底层类型为 T 的值赋予变量 t 若 i 未保存 T 类型的值，会触发一个 panic  类型断言可返回两个值：其底层值，一个布尔值判断断言是否成功 t, ok := i.(T)\npackage main import \u0026quot;fmt\u0026quot; func main() { var i interface{} = \u0026quot;hello\u0026quot; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // 报错(panic) fmt.Println(f) }   类型选择(type switch)  类型选择语句用于判断某个 interface 变量中实际存储的变量类型\npackage main import \u0026quot;fmt\u0026quot; func do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\u0026quot;Twice %v is %v\\n\u0026quot;, v, v*2) case string: fmt.Printf(\u0026quot;%q is %v bytes long\\n\u0026quot;, v, len(v)) default: fmt.Printf(\u0026quot;I don't know about type %T!\\n\u0026quot;, v) } } func main() { do(21) do(\u0026quot;hello\u0026quot;) do(true) }   接口和类型的关系 一个类型可以实现多个接口  接口间彼此独立，不知道对方的实现 Socket 结构的 Write() 方法实现了 io.Writer 以及 io.Closer 接口\ntype Socket struct { } func (s *Socket) Write(p []byte) (n int, err error) { return 0, nil } func (s *Socket) Close() error { return nil } func usingWriter( writer io.Writer){ writer.Write( nil ) // 使用io.Writer的代码, 并不知道Socket和io.Closer的存在 } func usingCloser( closer io.Closer) { closer.Close() // 使用io.Closer, 并不知道Socket和io.Writer的存在 } func main() { s := new(Socket) // 实例化Socket usingWriter(s) usingCloser(s) }   多个类型可以实现相同的接口  接口的方法可以通过在类型中嵌入其他类型或者结构体来实现 示例：\n Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()） 使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍 选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构\ntype Service interface { Start() // 开启服务 Log(string) // 日志输出 } type Logger struct { } func (g *Logger) Log(l string) { } type GameService struct { Logger // 嵌入日志器 } func (g *GameService) Start() { } func main() { var s Service = new(GameService) s.Start() s.Log(\u0026quot;hello\u0026quot;) }    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9f989049b46939699091f6abf9008015","permalink":"https://xueqing.github.io/blog/go/basic/go_interface/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_interface/","section":"blog","summary":"非侵入式设计 接口定义 接口实现 接口值 底层值为 nil 的接口值 接口值为 nil 空接口 类型断言(type assertion) 类型选择(type switch) 接口和类型的关系 一个类型可以实现","tags":["go"],"title":"go 接口","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" map定义和初始化  map 是一种无序的键值对的集合，可以通过 key 快速检索数据，使用 hash 表实现 定义集合  var map_name[key_type]val_type 使用 make 函数map_name := make(map[key_type]val_type)  不初始化 map，得到的是一个 nil map，不能用于存放键值对 map 文法：类似 struct，但是需要键名\n 当顶级类型是一个 type 的名字时，可以忽视\npackage main import \u0026quot;fmt\u0026quot; type vertex struct { Lat, Long float64 } var m = map[string]vertex{ \u0026quot;Bell lab\u0026quot;: vertex{ 40.68433, -74.39967, }, \u0026quot;Google\u0026quot;: vertex{ 37.42202, -122.08408, }, } var m1 = map[string]vertex{ \u0026quot;Bell lab\u0026quot;: { 40.68433, -74.39967}, \u0026quot;Google\u0026quot;: { 37.42202, -122.08408}, } func main() { fmt.Println(m) fmt.Println(m1) }    修改 map  使用 map_name[key] 查看元素在集合中是否存在  如果元素存在，返回的第一个元素是对应的键，第二个元素是 true 元素不存在，在返回第二个元素是 false  插入或更新元素 map_name[key] = val delete() 函数用于删除集合的元素delete(map_name, key)，指定元素名和对应的键\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { m := make(map[string]int) m[\u0026quot;answer\u0026quot;] = 42 fmt.Println(\u0026quot;The value:\u0026quot;, m[\u0026quot;answer\u0026quot;]) m[\u0026quot;answer\u0026quot;] = 48 fmt.Println(\u0026quot;The value:\u0026quot;, m[\u0026quot;answer\u0026quot;]) delete(m, \u0026quot;answer\u0026quot;) fmt.Println(\u0026quot;The value:\u0026quot;, m[\u0026quot;answer\u0026quot;]) val, ok := m[\u0026quot;answer\u0026quot;] fmt.Println(\u0026quot;The value:\u0026quot;, val, \u0026quot;Present?\u0026quot;, ok) }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8e41831543b9f0f48a1c7e36bd7eec05","permalink":"https://xueqing.github.io/blog/go/basic/go_map/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_map/","section":"blog","summary":"map定义和初始化 map 是一种无序的键值对的集合，可以通过 key 快速检索数据，使用 hash 表实现 定义集合 var map_name[key_type]val_type 使用 make 函数map_name := make(map[key_type]val_type) 不初始化 map，","tags":["go"],"title":"go 散列表","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  数据类型 数据类型默认初始化值 类型推导  数据类型  数据类型把数据分成所需内存大小不同的数据  布尔型：true 或 false 数字类型： 整型  有符号 int(int, int8, int16, int32, int64)，默认是 int int 是 32 或 64 位，取决于底层平台。建议使用 int 来表示整数，除非需要指定大小 32 位系统就是 32 位，64 位 系统就是 64 位 无符号 uint(uint, uint8, uint16, uint32, unit64) uint 32 或 64 位，同上  浮点型 float(float32, float64)，默认是 float64 复数 complex(complex64, complex128)  complex64 32 位实数和虚数 complex128 64 位实数和虚数 使用内置函数 complex 构造一个复数func complex(r, i FloatType) ComplexType 实部 r 和虚部 i 应该是同一类型，float32 或 float64，返回的复数类型是 complex64 或 complex128 也可直接生成复数c := 6 + 7i  byte 是 uint8 的别名 rune 是 int32 的别名，表示 Unicode code point uintptr 无符号整型，用于存放一个指针 字符串类型：字节使用 UTF-8 编码标识 Unicode 文本，是字节的集合 派生类型： 指针类型 pointer 数组类型 结构化类型 struct Channel 类型 函数类型 切片类型 接口类型 interface map 类型  可以使用 %T 格式化打印变量的类型，使用 %v 打印变量的值  数据类型默认初始化值  变量默认值，即默认初始化的值，对应各自的 “零” 值  int 默认值 0 boolean 默认值 false string 默认值 \u0026ldquo;\u0026rdquo; float32 默认值 0 pointer 默认值 nil   类型推导  当声明变量使用隐形类型(使用不带类型的 := 或 var =)，需要通过右值推导变量的类型 当右值的类型是声明过的，则新变量与其类型相同 当右值是一个没有类型的数值常量时，根据常量精度推导变量类型(int/float64/complex128)\ni := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"02a668500c8a072599a578395acca3df","permalink":"https://xueqing.github.io/blog/go/basic/go_data_type/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_data_type/","section":"blog","summary":"数据类型 数据类型默认初始化值 类型推导 数据类型 数据类型把数据分成所需内存大小不同的数据 布尔型：true 或 false 数字类型： 整型 有符号 int(int, int8, int16, int32, int6","tags":["go"],"title":"go 数据类型","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  array 数组初始化 多维数组 数组作为函数参数  array  数组是具有相同类型，长度固定，已编号的数据项序列 可通过索引来读写数组元素 声明数组需要指定类型和元素个数 var arr_name [size] arr_type 也可使用 [...] 让编译器统计数组字面值中元素的数目  数组初始化  数组不需要显式初始化，可以直接使用使用数组的零值，数组元素会自动初始化为对应类型的零值 var arr1 = [5]float32{1, 2.0, 3.1, 4, 5.4}，也可写成 var arr1 = [...]float32{1, 2.0, 3.1, 4, 5.4} {}中的元素个数不能大于[]的数字  多维数组  多维数组声明var arr_name [size1] [size2]...[sizen] arr_type  数组作为函数参数  传递数组的时候，会复制整个数组，为了避免复制，可以传递数组指针 未定义长度的数组只能传给不限制数组长度的函数 长度已定义的数组只能传给限制了相同数组长度的函数 形参设定数组大小\nfunc myFunc(arr [10] int) { //... }  形参未设定数组大小\nfunc myFunc(arr [] int) { //... }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4ae87f2f8280b262b6d3b298d3ddcec7","permalink":"https://xueqing.github.io/blog/go/basic/go_array/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_array/","section":"blog","summary":"array 数组初始化 多维数组 数组作为函数参数 array 数组是具有相同类型，长度固定，已编号的数据项序列 可通过索引来读写数组元素 声明数组需要指定类型和元素个数","tags":["go"],"title":"go 数组","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  方法 method  方法的接收者是 struct 方法的接收者是非结构体  指针接收者 vs 值接收者  使用指针接收者 使用值接收者  方法的匿名域  方法 method 方法的接收者是 struct  go 没有类，但是可以为 struct 类型定义方法 方法是一类带特殊的“接收者”参数的函数  方法接收者在参数列表内，位于 func 关键字和方法名之间 接收者可以是命名类型或者结构体类型的个值或一个指针 所有给定类型的方法属于该类型的方法集  语法格式\nfunc (v_name v_type) func_name() [return_type] { //func body }  示例\npackage main import \u0026quot;fmt\u0026quot; type Circle struct { radius float64 } func (c Circle) getArea() float64 { return 3.14 * c.radius * c.radius } func main() { var c1 Circle c1.radius = 10.00 fmt.Println(c1.getArea()) }   方法的接收者是非结构体  也可以为非 struct 类型声明方法，定义作用于一个类型的方法\n 接收者的类型定义和方法声明必须在同一个包内，不能为内建类型声明方法 可为内置类型起一个别名，然后基于别名作为接收者定义方法\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) }    指针接收者 vs 值接收者 使用指针接收者  使用指针接收者，在方法内部修改会影响调用者\n 场景 1：希望方法内部修改影响调用者 场景 2：拷贝数据结构的代价比较大\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(10) fmt.Println(v.Abs()) }   带指针参数的函数必须接受一个指针，而以指针为接收者的方法被调用时，接收者可以是值或者指针，go 会根据接收者类型自动调整\npackage main import ( \u0026quot;fmt\u0026quot; ) type vertex struct { X, Y float64 } func (v *vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func scaleFunc(v *vertex, f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := vertex{3, 4} v.Scale(2) scaleFunc(\u0026amp;v, 10) p := \u0026amp;vertex{4, 3} p.Scale(3) scaleFunc(p, 8) fmt.Println(v, p) }   使用值接收者  使用值接收者，类似于形参，方法内部的修改不影响调用者 接收一个值作为参数的函数必须接受一个指定类型的值，而以值作为接收者的方法被调用时，接收者可以是值或者指针  方法的匿名域  方法的接收者是一个结构体的匿名域（结构体中的结构体），可直接调用不指定匿名域\ntype address struct { city string state string } func (a address) fullAddress() { fmt.Println(\u0026quot;Full address: %s, %s\u0026quot;, a.city. a.state) } type person struct { firstName string lastName string address } func printPersonInfo(p person) { fmt.Println(\u0026quot;name: %s %s\u0026quot;, p.firstName, p.secondName) p.fullAddress()//p.address.fullAddress() }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8b791d0e5fe6e548bab941e6ce87be98","permalink":"https://xueqing.github.io/blog/go/basic/go_method/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_method/","section":"blog","summary":"方法 method 方法的接收者是 struct 方法的接收者是非结构体 指针接收者 vs 值接收者 使用指针接收者 使用值接收者 方法的匿名域 方法 method 方法的接收者是 struct go 没有类，但是可","tags":["go"],"title":"go 方法","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  if  if 语句 if\u0026hellip;else 语句 if 嵌套语句  switch select  if if 语句  类似于 for 循环，但是不需要小括号，需要大括号\nif x \u0026lt; 0 { return 0 }   if 语句可以在执行条件语句之前有一个简短的语句，在这个语句声明的变量的作用范围在 if 语句末尾结束\nfunc pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } return lim }    if\u0026hellip;else 语句  if 语句中声明的变量对于匹配的 else 代码块也是可见的\nfunc pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } else { fmt.Printf(\u0026quot;%g \u0026gt;= %g\\n\u0026quot;, v, lim) } return lim }   if 嵌套语句 if { //... if { //... } }  switch  每个 case 分支都是唯一的，从上到下测试直到匹配，只执行匹配项，匹配项后面不用加 break(每个测试项后面自动加上 break)，和 C++ 不同 另外一个区别是每个 case 不需要是常数，值也不必是整数\nswitch var1 { //case 的值必须是相同类型 case var1[, var11, var111]://可同时测试多个条件，用逗号分隔 //... case var2: //... default: //... }  switch 也有简短的声明语句，声明变量只对 switch 范围可见\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;runtime\u0026quot; ) func main() { switch os := runtime.GOOS; os { case \u0026quot;darwin\u0026quot;: fmt.Println(\u0026quot;OS X\u0026quot;) case \u0026quot;linux\u0026quot;: fmt.Println(\u0026quot;Linux\u0026quot;) default: fmt.Printf(\u0026quot;%s\\n\u0026quot;, os) } }  没有条件语句的 switch 和 switch true 相同。这个可以用于实现比较长的 if-then-else 链\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026quot;Good morning\u0026quot;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026quot;Good afternoon\u0026quot;) default: fmt.Println(\u0026quot;Good evening\u0026quot;) } }   select  select 语句使一个 goroutine 可以等待多个通信操作 类似于 switch 语句，会随机执行一个可允许的 case，如果没有 case 可以允许则阻塞到有 case 可以运行\nselect { case condition1: //... case condition2: //... default: //... }   case 必须是一个通信，所有 channel 表达式会被求值 所有发送的表达式会被求值 任意某个 channel 可以进行，就会执行，其他的被忽略 如果多个 case 可以执行，会随机公平选择一个执行，忽略其他 没有可以执行的 case 语句 如果有 default，则执行 default 否则阻塞至某个通信可以运行，go 不会重新对 channel 或值进行求值 为了在尝试发送或者接收时不发生阻塞，可使用 default 分支\npackage main import \u0026quot;fmt\u0026quot; func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c \u0026lt;- x: x, y = y, x+y case \u0026lt;-quit: fmt.Println(\u0026quot;quit\u0026quot;) return } } } func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() fibonacci(c, quit) }    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f410dbbe9427b083b2db1b9e1608a0fc","permalink":"https://xueqing.github.io/blog/go/basic/go_decision_making/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_decision_making/","section":"blog","summary":"if if 语句 if\u0026hellip;else 语句 if 嵌套语句 switch select if if 语句 类似于 for 循环，但是不需要小括号，需要大括号 if x \u0026lt; 0 { return 0 } if 语句可以在执行条件语句之前有一个简短的语句，","tags":["go"],"title":"go 条件语句","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 快速入门  1.1 新建工程 1.2 每日工作流  2 新概念  2.1 module 模块 2.2 go.mod 2.3 版本选择 2.4 语义导入版本控制  3 如何使用模块  3.1 如何安装和激活模块支持 3.2 定义一个模块 3.3 升级和降级依赖 3.4 准备发布模块 3.4.1 发行(release)所有版本模块 3.4.2 发行 v2+ 版本模块 3.4.3 发布一个发行版本  4 迁移到模块  4.1 迁移总结 4.2 迁移相关的话题 4.2.1 使用较早的依赖管理器自动迁移 4.2.2 提供依赖信息给旧版本的 Go 和非模块使用者 4.2.3 更新预先已有的安装指导 4.2.4 避免破坏已有的导入路径 4.2.5 当第一次采用模块且模块有 v2+ 的包时升级主版本号 4.2.6 v2+ 模块允许一次编译中有多个主版本号 4.2.7 非模块代码使用模块  4.2.7.1 非模块代码使用 v0/v1 模块 4.2.7.2 非模块代码使用 v2+ 模块  4.2.8 给预先已有的 v2+ 包作者使用的策略  4.2.8.1 要求客户使用 1.9.7+/1.10.3\u0026frasl;1.11+ 版本的 Go 4.2.8.2 允许客户使用更旧版本的 Go，如 Go1.8 4.2.8.3 等待选择模块   5 其他资源 6 初始 Vgo 建议之后的改变 7 Github issues 8 FAQs  8.1 如何标记版本是不兼容的 8.2 何时是旧行为 vs 新的基于模块的行为 8.3 为什么通过 go get 安装一个工具报错 cannot find main module 8.4 如何为一个模块跟踪工具依赖 8.5 模块支持的状态在 IDE，编辑器和标准工具(比如 goimport，gorename等) 是什么样的  9 FAQs-其他控制  9.1 在模块上工作时可用的社区工具 9.2 什么时候使用 replace 指令 9.3 能否完全在本地文件系统但在 VCS 之外工作 9.4 模块如何使用 vendor？是否不再需要 vendor 9.4.1 模块下载和验证 9.4.2 模块和目录 9.5 是否有 always on 的模块仓库和企业代理 9.6 能否控制何时更新 go.mod，go 工具何时使用网络满足依赖 9.6.1 GOFLAGS 环境变量 9.6.2 -mod=readonly 标识(如 go build -mod=readonly) 9.6.3 go mod vendor 命令 9.6.4 -mod=vendor 标识(如 go build -mod=vendor) 9.6.5 GO111MODULE=off 环境变量 9.6.6 GOPROXY=off 环境变量 9.6.7 GOPROXY=file:///filesystem/path 环境变量 9.6.8 开源的分布式模块仓库，如 Athens 工程 9.6.9 go mod download 命令 9.6.10 go.mod 中的 replace 指令 9.7 在 CI 系统(如 Travis 或 CircleCI) 中如何使用模块  10 FAQs-go.mod 和 go.sum  10.1 为什么 go mod tidy 记录 go.mod 的间接和测试依赖 10.2 go.sum 是否是锁文件？为什么 go.sum 包含不再使用的模块版本信息 10.3 是否应该提交 go.sum 和 go.mod 文件 10.4 如果没有任何依赖是否仍应该增加一个 go.mod 文件  11 FAQs-语义导入版本控制  11.1 为什么主版本号必须出现在导入路径 11.2 为什么主版本号 v0/v1 被导入路径忽视 11.3 使用主版本号 v0/v1 给项目打标签或使用 v2+ 标记破坏性的变化的影响是什么 11.4 模块能否使用没有选择加入模块的包 11.5 模块能否使用没有加入模块的 v2+ 包？ +incompatible 意味着什么 11.6 禁用模块支持时在编译中如何对待 v2+ 模块？最小模块兼容性在 Go1.9.7+/Go1.10.3+/Go1.11 中如何工作 11.7 如果创建一个 go.mod 但是仓库不使用 semver 标签会发生什么 11.8 一个模块能否依赖自身不同的版本  12 FAQs-多模块仓库  12.1 什么是多模块仓库 12.2 是否应该在一个仓库包含多个模块 12.3 能否给多模块仓库增加一个模块 12.4 能否从多模块仓库删除一个模块 12.5 模块能否依赖另一个模块的 internal/ 12.6 能否增加一个 go.mod 文件排除不需要的内容？模块是否有等价的 .gitignore 文件  13 FAQs-最小版本选择  13.1 最小版本选择是否会使开发者得到重要的更新  14 FAQs-可能的问题  14.1 如果发现问题，有哪些通用的东西可以定位检查 14.2 如果没有看到预期的依赖版本，可以检查什么 14.3 为什么得到错误 cannot find module providing package foo 14.4 为什么 go mod init 报错 cannot determine module path for source directory 14.5 有一个复杂的且没有加入模块的依赖出现问题。能否使用它目前的依赖管理器的信息 14.6 如何解决由于导入路径和声明模块身份不匹配导致的 parsing go.mod: unexpected module path 和 error loading module requirements 错误 14.6.1 出现问题的原因 14.6.2 场景示例 14.6.3 解决方法 14.7 为什么 go build 要求 gcc？为什么预编译包(如 net/http) 不用 14.8 模块能否在相对导入路径(如 import \u0026ldquo;./subdir\u0026rdquo;)正常工作 14.9 某些需要的文件可能不在定位的 vendor 目录  15 相关链接  1 快速入门 1.1 新建工程 # 1 在 GPOPATH 之外创建工程 mkdir -p /tmp/mygopro/repo # 2 切换到工程目录 cd /tmp/mygopro/repo # 3 初始化工程 git init # 4 添加远程仓库路径 git remote add origin https://github.com/my/repo # 5 初始化一个新模块, 会创建一个 go.mod 文件 go mod init github.com/my/repo # 6 写 go 源码 cat \u0026lt;\u0026lt;EOF \u0026gt; hello.go \u0026gt; package main \u0026gt; \u0026gt; import ( \u0026gt; \u0026quot;fmt\u0026quot; \u0026gt; \u0026quot;rsc.io/quote\u0026quot; \u0026gt; ) \u0026gt; \u0026gt; func main() { \u0026gt; fmt.Println(quote.Hello()) \u0026gt; } \u0026gt; EOF # 7 编译和运行 go build -o hello ./hello  1.2 每日工作流  添加 import 语句到 .go 代码 标准命令(go build 或 go test) 会自动增加新依赖的最高版本以满足导入(更新 go.mod 的 require 命令，并下载新的依赖) 需要时，可以使用命令(go get foo@v1.2.3 或 go get foo@master 或 go get foo@commitid 或 go get foo@master)或直接编辑 go.mod 选择依赖的具体版本 其他有用的命令  go list -m all: 查看编译会使用的所有的直接或间接依赖的最终版本 go list -u -m all: 查看可用的所有的直接或间接依赖的次级和补丁升级版本 go list -u ./... 或 go list -u=patch ./... (从模块根路径): 升级所有直接或间接依赖到最新的次级或补丁升级(忽视 pre-release) go build ./... 或 go test ./... (从模块根路径):编译或测试模块内的所有包 go mod tidy: 从 go.mod 删除不再需要的依赖，增加新依赖 replace gohack: 使用依赖的一个 fork 或本地拷贝或精确版本 go mod vendor: 可选的步骤，创建一个 vendor 目录   2 新概念 2.1 module 模块  模块是相关的 Go 包的集合，它们作为一个单一的单元被打上版本号 模块记录精确的依赖需求，创建可再复制的构建 最常见的是，一个版本控制仓库包含确切的一个模块，在仓库的根目录定义。(可在一个仓库支持多模块，但是通常导致在持续进行的基础上比一个仓库一个模块工作更多) 仓库、模块和包的关系：  一个仓库包含一个或多个 Go 模块 每个模块包含一个或多个 Go 包 每个包由一个单一的目录内的一个或多个 Go 源文件组成  模块必须根据 semver 打上版本号，通常是 v(major).(minor).(patch)，如 v0.1.0/v1.2.3/v1.5.0-rc.1  2.2 go.mod  有 4 个指令 module/require/replace/exclude  module: 声明模块身份，提供了模块路径。包的导入路径由模块路径和包目录与 go.mod 的相对路径决定 require: replace: 只作用于当前(主)模块 exclude: 只作用于当前(主)模块   2.3 版本选择  源码增加新的导入语句，且在 go.mod 的 require 指令未覆盖时，大多数命令会自动查找合适的模块，增加最高版本到 go.mod 的 require 指令 编译时使用最小版本选择算法  2.4 语义导入版本控制  导入兼容性规则(import compatibility rule)：如果一个旧包和新包又相同的导入路径，那么新包必须向后兼容旧包 semver 要求当向后不兼容时需要修改主版本号 语义导入版本控制(Semantic Import Versioning) 就是同时遵循导入兼容性规则和 semver的结果，即在导入路径添加主版本号——确保当主版本号因为兼容性破坏增加时导入路径也会改变  遵循 semver 对于 v0 或者 v1 版本，不要增加主版本号在模块路径或者导入路径 如果模块版本是 v2+，模块路径和包导入路径必须增加 /vN  上面适用于已经使用模块或者导入其他模块。下面是未使用模块的三个过渡异常  gopkg.in 当导入非模块的 v2+ 包时使用 +incompatible 当未启用模块模式时使用最小模块兼容性(Minimal module compatibility)   3 如何使用模块 3.1 如何安装和激活模块支持  安装方法  安装最新的 Go1.11 发行版 用 master 分支源码安装 Go 工具链  激活支持方法  在 $GOPATH/src 之外调用 go 命令，且在当前目录或任意父目录存在有效的 go.mod 文件且环境变量 GO111MODULE 未设置(或显式设置成 auto) 调用 go 命令设置 GO111MODULE=on   3.2 定义一个模块  为已有工程创建一个 go.mod\n# 1 切换到模块源码树的根路径($GOPATH 之外，可以不设置 GO111MODULE 来激活模块模式) cd \u0026lt;project path outside $GOPATH/src\u0026gt; ## 1.1 对于在 $GOPATH/src 目录之内的工程，需要手动激活 export GO111MODULE=on cd $GOPATH/src/\u0026lt;project path\u0026gt; # 2 创建初始模块定义，并从 dep 或其他依赖管理器转化依赖信息，增加 require 声明到 go.mod 以匹配现有配置 go mod init ## 2.1 可以指定模块路径(命令不能自动确定模块路径，或需要覆盖该路径) go mod init github.com/my/repo # 3 编译模块。在模块根路径执行，互编译当前模块的所有包。go build 会自动添加缺失或未转化的依赖 go build ./... # 4 按照配置测试模块，确认对于选中的版本是正常的 go test ./... # 5 可选。运行模块和所有直接或间接依赖的测试，检查兼容性 go test all  注意：当依赖包含 v2+ 版本，或者正在初始化一个 v2+ 模块，需要在运行 go mod init 之后，编辑 go.mod 和 .go 代码，添加 /vN 到导入路径。参考 Semantic Import Versioning\n 注意：执行 go build ./... 或类似命令成功之后才可以允许 go mod tidy\n  3.3 升级和降级依赖  直接编辑 go.mod 文件 go get: 对依赖升级或降级，此命令会自动更新 go.mod go build/go test/go list: 会自动增加新依赖以满足导入(更新 go.mod 的 require 命令，并下载新的依赖) go list -u -m all: 查看可用的所有的直接或间接依赖的次级和补丁升级版本 将当前模块的所有直接或间接依赖升级到最新版本，可在模块根目录执行下面的命令  go get -u ./...: 使用最新的次级或补丁发布(增加 -t 也会升级测试依赖) go get -u=patch ./...: 使用最新的补丁发布(增加 -t 也会升级测试依赖)  go get foo/go get foo@latest: 升级 foo 到最新版本 go get -u foo/go get -u foo@latest: 升级 foo 及其直接或间接依赖到最新版本 go get foo@v1.6.2/go get foo@e3702bed2/go get foo@'\u0026lt;v1.6.2': 升级或降级到具体版本，可以添加版本后缀或 module query  module query 不能得到一个 semver 标签，会在 go.mod 记录一个伪版本  go get foo@master: 使用分支名，获取分支的最新版本，不需要有 semver 标签 模块可以使用没有转成模块的包，包括记录可用的 semver 标签和使用这些标签升级或降级。模块也可以使用没有合适的 semver 标签的包，此时记录的是伪版本 go test all: 升级或降级所有依赖后，可以为所有包运行测试以检查兼容性  3.4 准备发布模块 3.4.1 发行(release)所有版本模块  去掉多余依赖，增加依赖 go mod tidy。go build 和 go test 不会从 go.mod 删除不需要的依赖 测试模块 go test all，包括测试直接或间接依赖，验证当前选择包版本的兼容性 确保 go.sum 文件和 go.mod 文件一起提交了  3.4.2 发行 v2+ 版本模块  将一个工程改成模块时，升级主版本号：使用的时候直接在导入路径添加新的主版本号更简单；也便于在旧版本上修改和完善 有两个可选机制发行 v2+ 版本的模块。当推送新的标签时，使用者可以知道新模块的发布。比如创建一个 v3.0.0 发行  主分支：更新 go.mod 文件在 module 命令的模块路径末尾添加 /v3;更新模块内的 import 语句；给本次发行添加标签 v3.0.0 主子目录：创建一个 v3 子目录；放一个新的 go.mod 文件在 v3 目录；更新模块内的 import 语句；给本次发行添加标签 v3.0.0 这个可以提供更好的向后兼容性   3.4.3 发布一个发行版本  通过推送一个标签到苍鹭发布新模块版本。标签包括两个字符串：前缀和版本号  前缀指明模块在仓库内定义的位置：如果定义在仓库根目录，前缀为空。标签就是版本号 在多模块仓库中，前缀区分不同模块的版本。前缀是仓库内定义模块的目录。如果仓库是主子目录形式，前缀不包含主版本号后缀  比如，有一个模块 example.com/repo/sub/v2，需要发布 v2.1.6，仓库主目录是 example.com/repo，模块在仓库内的 sub/v2/go.mod 定义，则模块的前缀是 sub/，这次发布完整的标签是 sub/v2.1.6  4 迁移到模块 4.1 迁移总结  设计模块系统是为了允许整个 Go 生态系统的不同包按不同比率选择性加入 v2+ 版本的包在迁移时因为 语义导入版本控制需要考虑更多 新包以及 v0/v1 的包在选择模块时考虑较少 Go1.11 定义的模块可被旧版本的 Go 使用(但是 Go 版本依靠主模块及其依赖使用的策略)  4.2 迁移相关的话题 4.2.1 使用较早的依赖管理器自动迁移  go mod init 自动将需要的信息翻译到 go.mod 如果创建 v2+ 的模块，确保 go.mod 中的 module 指令增加了 /vN 如果导入 v2+ 的模块，可能需要手动调整 go.mod 中的 require 指令增加了 /vN go mod init 不会修改源码文件的导入声明  4.2.2 提供依赖信息给旧版本的 Go 和非模块使用者  使用 vendor 目录 旧版本的 Go 以及禁用模块模式的 Go1.11/Go1.12+ 都可以使用 go mod vendor 生成的 vendor 目录  4.2.3 更新预先已有的安装指导  先前的模块，通常使用 go get -u 安装。如果是发布模块，基于模块的使用者考虑使用 go get  -u 指示 go 工具升级模块的所有直接或间接依赖 模块使用者之后可以选择使用 go get -u，但是一开始安装使用 go get 可以有更多好处。参考高保真的构建 go get -u 仍然有效，且对安装指令是有效选择  go get 对于基于模块的使用者不是严格必须的  简单的增加导入语句，后续的 go build/go test 会根据需求自动下载模块并更新 go.mod  基于模块的消费者默认不使用 vendor 目录  4.2.4 避免破坏已有的导入路径  当模块导入路径和对应模块的声明路径不匹配时会报 unexpected module path 错误。破坏的情况包括  模块导入路径发生变化：比如不再使用 gopkg.in 改变路径大小写：导入路径和对应模块路径是大小写敏感的 选择模块之后，修改模块路径   4.2.5 当第一次采用模块且模块有 v2+ 的包时升级主版本号  如果有 v2+ 包，在第一此采用模块时，建议升级主版本号  4.2.6 v2+ 模块允许一次编译中有多个主版本号  因为规则说明——“不同的导入路径包是不同的包” 此时，包级别状态会有多个拷贝，且每个主版本会运行自己的 init 函数  4.2.7 非模块代码使用模块 4.2.7.1 非模块代码使用 v0/v1 模块 4.2.7.2 非模块代码使用 v2+ 模块 4.2.8 给预先已有的 v2+ 包作者使用的策略 4.2.8.1 要求客户使用 1.9.7+/1.10.3\u0026frasl;1.11+ 版本的 Go 4.2.8.2 允许客户使用更旧版本的 Go，如 Go1.8 4.2.8.3 等待选择模块 5 其他资源 6 初始 Vgo 建议之后的改变 7 Github issues 8 FAQs 8.1 如何标记版本是不兼容的 8.2 何时是旧行为 vs 新的基于模块的行为  模块在 Go1.11 开始，因此按照设计旧行为会默认保留 什么时候是旧的 1.10 状态行为(查找 vendor 目录和 GOPATH 来寻找依赖)，什么时候是新的基于模块的行为  在 GOPATH 之内: 默认是旧的 1.10 行为，会忽视模块 在 GOPATH 之外且在文件树之内有一个 go.mod 文件: 默认是模块行为 GO111MODULE 环境变量 不设置或 auto: 上述默认行为 on: 强制支持模块，与目录位置无关 off: 强制不支持模块，与目录位置无关   8.3 为什么通过 go get 安装一个工具报错 cannot find main module  因为设置了 GO111MODULE=on，但是所在文件树没有 go.mod 主要原因是 go.mod 记录了依赖信息，但是设置了 GO111MODULE=on，而 go get 不能获取依赖信息 方法  最简单的方法设置 GO111MODULE=auto，或者不设置 临时使用 Go1.10 行为 GO111MODULE=off go get 创建一个临时的 go.mod 文件然后丢弃，这样可以避免报错 cannot use path@version syntax in GOPATH mode 使用 gobin：gobin 默认会安装/运行主包而不用先手动创建一个模块。也可以使用 -m 使用现有的模块解决依赖(由环境变量 GOMOD 指定) 为全局安装的工具创建 go.mod，比如 ~/global-tools/go.mod，然后切换到那个目录，再运行 go get/go install 安装全局工具 为每个工具在单独的目录创建 go.mod，比如 ~/tools/gorename/go.mod/~/tools/goimports/go.mod，然后切换到合适的目录，再运行 go get/go install 安装工具   8.4 如何为一个模块跟踪工具依赖  如果：  在模块中想要是有一个基于 go 的工具(比如 stringer) 想要在自己模块的 go.mod 中跟踪工具的版本，并确保每个人使用相同版本的工具  建议在模块添加一个 tools.go 文件，添加感兴趣的工具的导入语句(比如 import _ \u0026quot;golang.org/x/tools/cmd/stringer\u0026quot;)，并增加 // +build tools 编译限制。例子参考  导入语句允许 go 命令精确记录工具的版本信息到 go.mod 编译限制阻止正常的编译导入工具   8.5 模块支持的状态在 IDE，编辑器和标准工具(比如 goimport，gorename等) 是什么样的 9 FAQs-其他控制 9.1 在模块上工作时可用的社区工具  github.com/rogpeppe/gohack github.com/marwan-at-work/mod github.com/akyoto/mgit github.com/goware/modvendor github.com/psampaz/go-mod-outdated  9.2 什么时候使用 replace 指令  replace 允许提供另外一个导入路径，控制实际使用的依赖，而不用更新源码中的导入路径 replace 允许顶层模块控制依赖的实际版本：replace example.com/some/dependency =\u0026gt; example.com/some/dependency v1.2.3 replace 允许使用一个 fork 依赖：replace example.com/original/import/path =\u0026gt; /your/forked/import/path，当需要修改一些依赖时，可以有一个本地 fork，并修改顶层模块的 go.mod replace 可用于多模块项目中，告诉 go 工具一个模块在磁盘上的的相对和绝对路径：replace example.com/project/foo =\u0026gt; ../foo  9.3 能否完全在本地文件系统但在 VCS 之外工作  可以。VCS 不需要。如果再 VCS 之外，可以在 require 指令中使用版本号 v0.0.0  Go1.11 中必须手动在 require 指令中增加版本号 v0.0.0，Go1.12 之后不再需要手动添加   9.4 模块如何使用 vendor？是否不再需要 vendor  vgo 的初始系统建议完全丢掉 vendor。但是社区返回导致保留对 vendor 的支持 简单来说，模块使用 vendor  go mod vendor： 重置主模块的 vendor 目录一包含编译和测试主模块所有包所需的包(根据 go.mod 状态和 Go 源码)。目录不包含 vendored 包的测试代码 默认的，go build 等 go 命令在模块模式时会忽视 vendor 目录 -mod=vendor 标识指示 go 命令使用主模块顶层的 vendor 目录来满足依赖 GOFLAGS=-mod=vendor 可以设置使用 vendor 目录  当模块模式禁用时，旧版本的 Go 可以使用 vendor 目录。因此，vendor 是使得模块提供依赖给旧版本 Go 的模块使用  9.4.1 模块下载和验证  根据 GOPROXY，go 命令可以从一个代理或直连到源码控制服务拉取代码 GOPROXY 默认设置是 https://proxy.golang.org,direct，即尝试 Google 运行的 Go 模块代理，如果代理报告没有模块(HTTP 错误码 404 或 410)，会尝试直连 GOPROXY 为 off 时，不允许从任何源码下载模块。否则，GOPROXY 是逗号分隔的模块代理的 URL，go 命令会从这些代理拉取模块  对于每个请求，go 命令按顺序尝试代理，当代理返回 404 或 410 HTTP 状态码时，会继续尝试下个代理 direct 之后的代理都不会尝试  GOPRIVATE 和 GONOPPROXY 允许对指定的模块绕过代理 对于所有的模块，go 命令会根据已知的校验值检查下载，检测未预料的变化。检查先查询当前模块的 go.sum 文件，失败时检查 Go 的校验值数据库，后者由 GOSUMDB 和 GONOSUMDB 控制  9.4.2 模块和目录  使用模块时，go 命令会完全忽视 vendor 目录 默认的，go 命令通过从源码下载模块和使用这些下载的备份(在验证之后) 为了和旧版本的 Go 交互，或者保证编译使用的所有文件被存储在一个单独的目录树，go mod vendor 在当前主模块的根目录创建一个 vendor 目录，用于存储编译和测试主模块所需的依赖模块的所有包 go build -mod=vendor: 使用模块的顶层的 vendor 目录来编译以满足依赖(不使用通常的网络源码和本地缓存)。注意只有主模块的顶层 vendor 目录会使用，其他位置的 vendor 目录仍然忽略  9.5 是否有 always on 的模块仓库和企业代理  proxy.golang.org gocenter.io mirrors.aliyun.com/goproxy goproxy.cn goproxy.io Athens athens.azurefd.net Goproxy THUMBAI  9.6 能否控制何时更新 go.mod，go 工具何时使用网络满足依赖  默认的，类似于 go build 目录会忽视 vendor 目录，在需要的时候访问网络满足导入 go 工具提供了一些参数来支持一些行为 -mod=readonly/-mod=vendor/GOFLAGS/GOPROXY=off/GOPROXY=file:///filesystem/path/go mod vendor/go mod download  9.6.1 GOFLAGS 环境变量  允许设置特殊 go 命令的默认标识 对于 CI 和测试工作流有用，可用于定义每天开发的默认标识或行为，比如设置 GOFLAGS=-mod=vendor  9.6.2 -mod=readonly 标识(如 go build -mod=readonly)  禁止大多数 go 命令(除了go get/go mod)修改 go.mod，导致想要隐式更新 go.mod 的命令失败 用于检查 go.mod 不需要更新，比如集成或测试时  9.6.3 go mod vendor 命令  重置主模块的 vendor 目录一包含编译和测试主模块所有包所需的包(根据 go.mod 状态和 Go 源码) 不同团队对于 vendor 的哲学观点不同。vendor 可用于记录依赖到源码的版本控制，同事在外部源码出问题(宕机、消失或移动)时提供弹性 可为使用旧版本 Go 的用户提供相同的依赖 支持 CI 过程旧版本 Go(比如 Go1.9/Go1.10) 的测试  9.6.4 -mod=vendor 标识(如 go build -mod=vendor)  默认的，go build 等 go 命令在模块模式时会忽视 vendor 目录 -mod=vendor 标识指示 go 命令使用主模块顶层的 vendor 目录来满足依赖(j禁用网络资源和本地缓存) 想要一直使用设置 GOFLAGS=-mod=vendor  9.6.5 GO111MODULE=off 环境变量  go 命令不会支持新的模块。而是查找 vendor 目录和 GOPATH 来寻找依赖(遵循 pre-1.11 行为)  9.6.6 GOPROXY=off 环境变量  模块模式的 go 命令不允许使用网络依赖  9.6.7 GOPROXY=file:///filesystem/path 环境变量  go 命令会使用文件系统(本地或远程)解决依赖，不再有实际运行的代理进程 go 命令存储下载的依赖在本地缓存($GOPATH/pkg/mod)，而且缓存格式和代理的需求相同，因此缓存可当做内容被基于文件系统的 GOPROXY 或简单的用作 GOPROXY 的 web 服务使用 go mod download 定位到 $GOPATH/pkg/mod/cache/download，意味着这个命令可用于预先定位或更新 GOPROXY 的内容  9.6.8 开源的分布式模块仓库，如 Athens 工程  一个目标是提供 “always on” 的模块仓库 一个不同的目标是单独的代理服务器，可被一个组织部署和控制可用的模块  9.6.9 go mod download 命令  大多数每日工作不需要这个命令(因为通常 go命令会自动下载需要的模块) 主要用于在一些 CI 中，用于 docker 编译的缓存预热(pre-warming caches) 也可能被代理事宜作为缓存缺失时获取模块的一种方式  9.6.10 go.mod 中的 replace 指令  可以控制顶层的 go.mod 以满足 Go 源码或 go.mod 文件实际使用的依赖 一个用例：如果需要修改一个依赖的内容，可以有本地 fork，在顶层的 go.mod 使用 replace example.com/original/import/path =\u0026gt; your/forked/import/path，而不用更新代码中的导入路径。replace 指令允许提供另外一个导入路径(可能在 VCS 的另外一个模块，或者在本地文件系统) replace 也允许顶层模块实际使用依赖的具体版本，如 replace example.com/some/dependency =\u0026gt; example.com/some/dependency@v1.2.3  9.7 在 CI 系统(如 Travis 或 CircleCI) 中如何使用模块  最简单的方法就是设置 GO111MODULE=off，大部分 CI 系统都可以使用 对于 Go1.11 的 CI，无论模块启用还是禁用，假设用户还没有适用模块，可以考虑使用 vendor 参考  Using Go modules with vendor support on Travis CI by Fatih Arslan Go Modules and CircleCI by Todd Keech   10 FAQs-go.mod 和 go.sum 10.1 为什么 go mod tidy 记录 go.mod 的间接和测试依赖  模块系统在 go.mod 记录精确的依赖需求 go mod tidy 更新当前的 go.mod 以包含模块中测试所需的依赖——如果一个测试失败，必须知道使用的依赖以重复该失败 go mod tidy 同时确保当前的 go.mod 反映了对所有的操作系统、架构和编译标签的组合的依赖需求。相反的，其他的命令(如 go build/go test)只更新 go.mod 以提供当前的 GOOS，GOARCH 和编译标签被请求的包导入的包(这也是 go mod tidy 可能增加其他 go 命令没有增加的需求的原因之一) 如果你的模块的依赖本身没有一个 go.mod(比如因为依赖还没有选择加入模块)，或依赖的 go.mod 缺少一些依赖(比如因为模块的作者没有运行 go mod tidy)，那么缺失的依赖会加入到你的模块的需求，并带有一个 // indirect 注释表明依赖不是从你的模块直接导入的 注意：这也意味着你的模块的直接或间接依赖缺失的测试依赖也会被记录在当前的 go.mod。比如，go test all 运行你的模块所有的直接或间接依赖的测试，这是验证当前版本组合有效的一种方式。如果允许时某个依赖的一个测试失败，记录完整的测试依赖信息是很重要的，以便可以重复 go test all 行为 go.mod 有 // indirect 依赖的另外一个原因：当升级或降级一个间接依赖且超出直接依赖的需求时(比如运行 go get -u/go get foo@1.2.3)，go 工具需要在某个地方记录新版本信息，并且记录在 go.mod 文件(并且不会去更改依赖的 go.mod 文件) 一般的，上述是模块通过记录精确的依赖信息提供 100% 可重复编译和测试的一部分行为 相关命令  go mod why -m \u0026lt;module\u0026gt; 显示 go.mod 中指定模块出现的原因 go mod graph/go list -m all 检查需要的模块及其版本   10.2 go.sum 是否是锁文件？为什么 go.sum 包含不再使用的模块版本信息  不是。go.sum 在一次编译中提供足够的信息支持 100% 可重复的编译 出于验证的目的，go.sum 包含预期的对指定模块版本内容的加密校验值 在某种程度上，因为 go.sum 不是锁文件，它在停止使用一个模块或者模块的某个版本之后仍然为模块版本保留加密校验值。这允许在之后重新使用一些模块时提供校验，也提供了额外的安全性 go.sum 记录一次编译所有的直接或间接依赖的校验值(因此 go.sum 经常会比 go.mod 有更多的模块)  10.3 是否应该提交 go.sum 和 go.mod 文件  通常应该一起提交 go.sum 和 go.mod 文件  go.sum 包含预期的对指定模块版本内容的加密校验值 如果某人克隆仓库并使用 go 命令下载依赖，当他们下载的依赖拷贝和 go.sum 对应的条目不匹配时会报错 go mod verify 检查模块的磁盘缓存备份仍然和 go.sum 的条目匹配 注意，go.sum 不是一个锁文件(一些可选的依赖管理系统使用的锁文件)。go.mod 提供足够的信息支持可重复的编译   10.4 如果没有任何依赖是否仍应该增加一个 go.mod 文件  是的。  支持在 GOPATH 之外工作 有助于和模块生态圈沟通 其中的 module 指令可作为代码身份的明确声明   11 FAQs-语义导入版本控制 11.1 为什么主版本号必须出现在导入路径  为了遵循最小兼容原则，简化了系统其它部分  11.2 为什么主版本号 v0/v1 被导入路径忽视  忽视 v1 有两个原因  许多开发人员会创建一个包，该包在发布 v1 之后永远不会有破坏性的变化，这也是一开始鼓励的。当开发人员没有计划发布 v2 时，不应该强迫他们有显式的 v1。那样只会是干扰。当最终创建 v2 时，才需要加 v2 以便区分默认的 v1 大量已有的代码建议忽视 v1，而不是在每个地方都加上 v1  忽视 v0  根据 semver 规定，对于 v0 没有任何兼容性保证。因此要求显式的 v0 对于兼容性没有什么帮助；必须指明完全精确的类似 v0.1.2，而每次库更新时需要更新所有的导入路径。这是过犹不及的。相反的，我们希望开发人员会简单地查看依赖的模块列表，并适当地谨慎任何 v0.x.y 版本  忽视 v0/v1 的影响：将没办法从区分路径区分它们，但是 v0 通常是通向 v1 的一系列破坏性变化，因此将 v1 视为破坏性变化的最后阶段是有意义的 \u0026gt;\u0026gt;\u0026gt; 通过使用 v0.x，你正在接受 v0.(x+1) 可能迫使你修改代码。那么为什么 v0.(x+1) 叫做 v1.0 是一个问题呢？ 忽视 v0/v1 是强制性而非可选的，因此这是包的一个规范导入路径  11.3 使用主版本号 v0/v1 给项目打标签或使用 v2+ 标记破坏性的变化的影响是什么  和 API 兼容性相关  11.4 模块能否使用没有选择加入模块的包  可以。对于没有加入模块的仓库  但是具有有效的 semver 标签(包括要求的前导 v)：可使用 go get 获取这些标签，并记录对应 semver 版本到导入模块的 go.mod 没有有效的 semver 标签：使用伪版本(如 v0.0.0-20171006230638-a6e239ea1c69，包含时间戳，commit-id，如此设计以允许给版本排序)记录   11.5 模块能否使用没有加入模块的 v2+ 包？ +incompatible 意味着什么  可以。如果导入的 v2+ 包具有有效的 semver 标签，将会在记录时添加 +incompatible 后缀 当 go 工具在模块模式(如 GO111MODULE=on)操作时，下面的核心原则总为真  1 包的导入路径定义了包的身份 导入路径不同的包视为不同的包 导入路径相同的包视为相同的包(即使 VCS 标签表明二者主版本号不同) 2 没有 /vN 的导入路径视为 v0/v1 模块(即使导入包没有加入模块，且 VCS 标签表明主版本号大于 1) 3 模块的 go.mod 开始声明的模块路径(如 module foo/v2)是 该模块身份的确定性声明 该模块必须被使用代码如何导入的确定性声明  +incompatible 后缀表明上述原则 2 实际上在下面情况下为真  导入的包没有加入模块 且其 VCS 标签表明主版本号大于 1 且原则 2 会覆盖 VCS 标签——没有 /vN 的导入路径视为 v0/v1 模块(即使 VCS 标签主版本号大于 1)  即，当在模块模式操作时，go 工具将认为非模块的 v2+ 包不知道语义导入版本控制，并将其视作包 v1 版本系列的(非兼容的)扩展( +incompatible 后缀指示 go 工具这样做)  11.6 禁用模块支持时在编译中如何对待 v2+ 模块？最小模块兼容性在 Go1.9.7+/Go1.10.3+/Go1.11 中如何工作  主子目录方式：v2+ 模块会创建子目录(如mymodule/v2/mymodule/v3)，并将合适的包移动或拷贝到子目录，这种方式的包是可以被不支持或禁用模块的 Go 使用 主分支方式：通过 go.mod 和提交 semver 标签确定模块版本信息(经常在 master 分支)。由此引入了最小模块兼容性。主要目的是  允许旧版本 Go(1.9.7+/1.10.3+) 更容易编译使用语义导入版本控制的模块，并提供和 Go1.11 禁用模块时相同的行为 允许旧代码使用 v2+ 模块，而不用旧代码修改导入路径添加 /vN 不用依赖模块作者创建 /vN 子目录而实现上述两种行为   11.7 如果创建一个 go.mod 但是仓库不使用 semver 标签会发生什么 11.8 一个模块能否依赖自身不同的版本  可以。但是两个包不能循环依赖  12 FAQs-多模块仓库 12.1 什么是多模块仓库  多模块仓库是指一个仓库包含多个模块，每个模块有自己的 go.mod 文件 每个模块起始于包含它自己的 go.mod 的目录，并且包含此目录及其子目录下的所有包，不包含包含另外的 go.mod 文件的子树 每个模块有自己的版本信息。位于仓库跟木库下的模块的版本标签必须包含相关目录作为前缀  有一个文件 my-repo/foo/rop/go.mod，那么模块 my-repo/foo/rop 的 1.2.3 版本的标签是 foo/rop/v1.2.3  一个顶层模块的路径时另外一个模块路径的前缀  12.2 是否应该在一个仓库包含多个模块  相比一个仓库包含多个模块，一个仓库一个模块在增加模块、删除模块、给模块打版本号方面更简单  在仓库根路径执行 go test ./... 不会再测试仓库所有代码 需要用 replace 指令管理模块之间的关系  一个仓库包含多个模块的应用场景  有一个用法例子，且例子有复杂的依赖关系。这种情况可以创建一个 examples/_examples 目录包含自己的 go.mod 某个仓库有复杂的依赖集合，但是有一个客户端 API 只有少数依赖。在某些场景下，创建一个 api/clientapi 或类似的目录持有自己的 go.mod，或者将 clientapi 单独分出一个仓库比较好  上述两种场景，如果只是为了一个大量间接依赖的性能或者下载大小，建议首先尝试 GOPOROXY  12.3 能否给多模块仓库增加一个模块  可以。但是有两类问题  新增模块的包不在版本控制中。需要做的事情包括：增加包和 go.mod 在同一提交，给提交打标签，推送标签 增加的模块在版本控制，并且包含已有的一个或多个包。这种情况需要   12.4 能否从多模块仓库删除一个模块  可以。问题同上  12.5 模块能否依赖另一个模块的 internal/  可以。因为路径前缀是共享的  12.6 能否增加一个 go.mod 文件排除不需要的内容？模块是否有等价的 .gitignore 文件  一个目录中空的 go.mod 文件会导致该目录及其子目录不被顶层的 Go 模块包含 如果不想包含的目录不包含任何 .go 文件，只需要放一个空的 go.mod 文件  13 FAQs-最小版本选择 13.1 最小版本选择是否会使开发者得到重要的更新 14 FAQs-可能的问题 14.1 如果发现问题，有哪些通用的东西可以定位检查  检查启用了模块：运行 go env 查看 GOMOD 不为空  GOMOD 不能设置，是 go env 的输出 如果设置 GO111MODULE=on 以启用模块，检查不要是复数形式 GO111MODULES=on  如果预期使用 vendor，检查 -mod=vendor 被传递给相关的 go 命令，或者设置了 GOFLAGS=-mod=vendor  模块默认忽视 vendor 除非要求 go 工具使用  go list -m all 检查编译实际选择的版本列表  相比查看 go.mod 会给出更多详细信息  如果允许 go get foo 失败，或者 go build 在 foo 包失败。可使用 go get -v foo/go get -v -x foo 查看输出  一般的，go get 比 go build 提供更多详细的错误信息 -v 标识请求打印更多冗长细节，不过注意一些错误(比如 404)可能基于远程仓库的配置 go get -v -x foo 也会显示调用的 git 或其他 VCS 命令(如有必要，可以经常在 go 工具上下文之外执行相同的命令用于故障排除)  检查是否使用了旧的 git 版本  对于 vgo 原型和 Go1.11beta，使用旧的 git 是常见的错误源，但是在 GA1.11 中较少出现  Go1.11 的模块缓存有时候会导致错误，尤其是先前有网络错误或者同时执行多个 go 命令时。可以将 $GOPATH/pkg/mod 到一个备份目录，运行 go clean -modcache，然后检查之前的问题是否出现 如果使用 Docker，检查是否可以可以在 Docker 之外复制行为(且如果行为只出现在 Docker，上述条目可用于比较 Docker 内外的结果)  14.2 如果没有看到预期的依赖版本，可以检查什么  执行 go mod tidy。如果 go mod tidy 改变了没有预期的依赖版本，先查看go mod tidy 记录 go.mod 的间接和测试依赖。如果没有解释，可以尝试重置 go.mod，然后运行 go list -mod=readonly all，可以就要求修改版本给出更多信息 执行 go list -m all，查看编译实际选择的版本列表。go list -m all 显示最终选择的版本，包括间接依赖和解决共享依赖的版本。并显示了任何 replace 和 exclude 指令的结果 执行 go mod graph/go mod graph | grep \u0026lt;module-of-interest\u0026gt; 其他有用的命令包括 go mod why -m \u0026lt;module\u0026gt;/go list/go list -deps -f '{{with .Module}}{{.Path}} {{.Version}}{{end}}' ./... | sort -u(显示编译使用的精确版本，不包括只用于测试的依赖)  14.3 为什么得到错误 cannot find module providing package foo  可能是路径不对。首先可以检查错误信息中列举的路径 尝试 go get -v foo/go get -v -x foo。通常，go get 比 get build 提供更多的错误信息 其他可能原因  当前目录没有 go 源码文件，但是运行了 go build/go build .。可以尝试运行 go build ./...(./... 通配符匹配当前模块的所有包) Go1.11 的模块缓存在遇到网络问题或者同时允许多个 go 命令时会导致这个错误。在 Go1.12 已经接近。参考上面的问题   14.4 为什么 go mod init 报错 cannot determine module path for source directory  go mod init 不带参数是会基于不同的暗示(VCS 元数据等)尝试猜测合适的模块路。但是，命令不能总是猜测的预期的合适路径 如果 go mod init 报这类错，必须自己提供模块路径(go mod init module_path)  14.5 有一个复杂的且没有加入模块的依赖出现问题。能否使用它目前的依赖管理器的信息  可以。这需要一些手动步骤，但是在一些复杂场景是有用的 当运行 go mod init 初始化模块时，命令会从先前的依赖管理器通过翻译配置文件(如 Gopkg.lock/glide.lock/vendor.json)自动转换到 go.mod 文件，该文件包含了对应的 require 指令。先前的一些文件信息通畅描述了所有直接或间接依赖的版本信息 然而，当添加一个还没有加入模块的新依赖，新依赖不会有上述类似的自动转换过程。如果该新依赖本身有一些非模块依赖，且这些依赖有破坏性的变化，那么在某些场景下，会导致不兼容问题。换句话说，不会自动使用先前对于新依赖的依赖管理器，而这会在某些场景导致非间接依赖的问题 一个方法是在有问题的非模块直接依赖运行 go mod init 转化当前依赖管理器，然后使用生成的临时 go.mod 的 require 指令定位或更新你的模块的 go.mod\n 临时 go.mod 生成的 require 信息可手动移动到你的模块实际的 go.mod，或考虑使用 gomodmerge 工具。除此之外，可能会增加 require github.com/some/nonmodule v1.2.3 到你的模块实际的 go.mod 以匹配手动克隆的版本\ngit clone -b v1.2.3 https://github.com/some/nonmodule /tmp/scratchpad/nonmodule cd /tmp/scratchpad/nonmodule go mod init cat go.mod    14.6 如何解决由于导入路径和声明模块身份不匹配导致的 parsing go.mod: unexpected module path 和 error loading module requirements 错误 14.6.1 出现问题的原因  一般的，一个模块在 go.mod 中通过 module 指令声明它的身份。这个该模块的“模块路径”，并且 go 工具强制声明的模块路径和使用者的导入路径的一致性。如果一个模块的 go.mod 文件读到 module example.com/m，那么使用者必须使用导入语句从该模块导入包，且必须以模块路径开头(如 import \u0026quot;example.com/m\u0026quot; 或import \u0026quot;example.com/m/sub/pkg\u0026quot;) 如果使用者的导入路径和对应的声明模块路径出现不匹配，go 命令会报错 parsing go.mod: unexpected module path。此外，在某些场景下，go 命令会之后再报一个更一般的错误 error loading module requirements 这个错误最常见的原因是如果有一个名字变化(如 github.com/Sirupsen/logrus 到 github.com/sirupsen/logrus)，或者如果一个模块有时通过两个不同于先前模块的名字(如 github.com/golang/sync 和建议的 golang.org/x/sync) 如果有一个仍然使用旧的名字或不规范的名字导入的依赖，而该依赖之后采用模块并在 go.mod 声明规范的名字，就会出现问题。这个错误可以在一次升级时触发，当此模块的升级版本声明了一个规范的模块路径，但是该路径不匹配旧的导入路径  14.6.2 场景示例  当前有一个间接依赖 github.com/Quasilyte/go-consistent 此工程采用模块，然后将名字改成 github.com/quasilyte/go-consistent，这是一个破坏性的变化。GitHub 从旧名字导向新的名字 运行 go get -u，尝试升级所有的直接或间接依赖 github.com/Quasilyte/go-consistent 尝试升级，但是最新的 go.mod 发现现在读到的是 module github.com/quasilyte/go-consistent 整个升级操作会失败，错误是： \u0026gt; go: github.com/Quasilyte/go-consistent@v0.0.0-20190521200055-c6f3937de18c: parsing go.mod: unexpected module path \u0026ldquo;github.com/quasilyte/go-consistent\u0026rdquo; go get: error loading module requirements  14.6.3 解决方法  整个错误最常见的形式是 \u0026gt; go: example.com/some/OLD/name@vX.Y.Z: parsing go.mod: unexpected module path \u0026ldquo;example.com/some/NEW/name\u0026rdquo; 如果浏览 example.com/some/NEW/name 仓库，可以检查最新发布版或 master 查看 go.mod 文件，是否在第一行声明 module example.com/some/NEW/name。如果是，示意看到的 old module name 和 new module name 问题 解决步骤\n 1 检查自己的代码是否使用 example.com/some/OLD/name。如果是，更新代码使用 module example.com/some/NEW/name 2 如果再升级时遇到这个错误，应该尝试 Go 的 tip 版本。此版本有更多针对性的的升级逻辑，通常可以绕过这个问题，且经常对于这种情况有更好的错误信息。注意：tip/1.13 和 1.12 的 go get 参数不同。比如获取 tip 并使用 tip 更新依赖的命令如下。因为这个有问题的旧的导入经常是在间接依赖，使用 tip 升级然后运行 go mod tidy 经常会升级过去有问题的版本，并且从 go.mod 移除有问题的版本，然后可以使用 Go1.12\u0026frasl;1.11 进入正常状态\ngo get golang.org/dl/gotip \u0026amp;\u0026amp; gotip download gotip get -u all gotip mod tidy  3 如果在执行 go get -u foo/go get -u foo@latest 时遇到这个错误，尝试移除 -u。go get -u foo 不仅仅只更新 foo 到最新版本，也会更新 foo 的所有直接或间接依赖到最新版本。但是 foo 的一些直接或间接依赖可能没有使用 semver 或模块\n 4 如果上述步骤没有解决问题，下一个方法可能会比较复杂，但是大多数情况可以解决这类问题。这个方法只是有错误信息，以及简单浏览 VCS 历史\n 4.1 进入 example.com/some/NEW/name 仓库\n 4.2 确定何时引入 go.mod 文件(比如使用 git blame 或 git log 命令查看 go.mod 的修改历史)\n 4.3 选中 go.mod 被引入的前一次提交或发布\n 4.4 在你的 go.mod 增加一个 replace 语句，reolace 两边都使用旧名字：replace example.com/some/OLD/name =\u0026gt; example.com/some/OLD/name \u0026lt;version-just-before-go.mod\u0026gt;。\n 在前述的场景示例中，旧名字是 github.com/Quasilyte/go-consistent，新名字是 github.com/quasilyte/go-consistent，可以看到 go.mod 在 00c5b0cf371a 被引入 该仓库没有使用 semver 标签，因此我们必须选取前一次提交 00dd7fb039e，并且使用旧的大写 Quasilyte 到 replace 两侧：replace github.com/Quasilyte/go-consistent =\u0026gt; github.com/Quasilyte/go-consistent 00dd7fb039e  这个 replace 语句使我们可以通过有效地阻止旧名字升级到 go.mod 出现的新名字而越过新旧名字不匹配的问题实现升级。通常，现在通过 go get -u 或类似命令升级可以避免这样的错误。如果完成升级，可以检查是否仍有代码使用旧名字导入(如 go mod graph | grep github.com/Quasilyte/go-consistent)，如果没有，可以移除 repalce 指令。\n 这样经常生效的原因是如果使用有问题的旧导入路径，升级本身会失败。即使升级完成最后也不会使用这个路径  5 如果上述路径没有解决问题，可能因为某些当前依赖的最新版本中仍在使用有问题的旧导入路径。这种情况下，需要识别出谁仍在使用旧的路径，并且找出或者打开一个 issue 请求这个有问题的导入者修改代码使用规范路径。使用前述的 gotip 可能识别出有问题的导入者，但是并不是所有场景有用，尤其是升级的情况。如果不确定谁在使用旧路径导入，通常可以通过创建一个干净的模块缓存找出来，执行出问题的操作，然后在模块缓存中 grep 有问题的导入路径。比如\nexport GOPATH=$(mktemp -d) go get -u foo # peform operation that generates the error of interest cd $GOPATH/pkg/mod grep -R --include=\u0026quot;*.go\u0026quot; github.com/Quasilyte/go-consistent  6 如果这些步骤不足以解决问题，或者你是一个项目的维护者，且似乎因为循环引用不能移除旧路径的引用，可以参考\n  最后，上述步骤致力于如果解决一个底层的新旧名字问题。然而，如果 go.mod 被放置在错误的位置或简单的是因为错误的模块路径，这会出现相同的问题。在这种情况下，导入该模块总会失败。如果你正在导入你刚刚新建的模块，且之前从未成功导入过，你应当检查 go.mod 被正确放置且有对应的合适的模块路径。\n 最常见的方法是一个仓库一个 go.mod，且是在仓库根目录放置单一的 go.mod 文件。并且使用仓库名字作为文件中声明的 module 指令的模块路径   14.7 为什么 go build 要求 gcc？为什么预编译包(如 net/http) 不用  因为预编译包是非模块的(对 GOPATH 有效)，因此不能被重复使用。即在模块模式时需要重新编译标准库的包 这个问题只在加入模块时出现，对于 Go1.11 可以禁用 cgo(如 GO111MODULE=on CGO_ENABLED=0 go build) 或者安装 gcc  14.8 模块能否在相对导入路径(如 import \u0026ldquo;./subdir\u0026rdquo;)正常工作  不能。在模块中，子目录最终会有一个名字。如果当前目录是 module m，那么导入的子目录就是 m/subdir，不再是 ./subdir  14.9 某些需要的文件可能不在定位的 vendor 目录  go mod vendor 不会拷贝没有 .go 文件的目录到 vendor。设计如此 对于传统的 vendor：检查模块缓存  15 相关链接  Go module wiki Modules and vendoring List of go module knobs for controlling CI, vendoring, and when go commands access the network module 工具  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5a10894ba5637c1c59f8d0a3435f7fa7","permalink":"https://xueqing.github.io/blog/go/basic/go_module/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_module/","section":"blog","summary":"1 快速入门 1.1 新建工程 1.2 每日工作流 2 新概念 2.1 module 模块 2.2 go.mod 2.3 版本选择 2.4 语义导入版本控制 3 如何使用模块 3.1 如何安装和激活模块支持 3.2 定义一个模块 3.3 升级和","tags":["go"],"title":"go 模块","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  goroutine 创建一个 goroutine goroutine 优于线程  goroutine  goroutine 是和其他函数或方法并发运行的函数或方法 goroutine 可认为是轻量级的线程，比线程创建代价小  创建一个 goroutine  使用 go 可以开始一个 goroutine：go f(x, y, z)  f x y z 的求值发生在当前的 goroutine f 的执行发生在新的 goroutine- 启动一个 goroutine 时，go 立即返回，继续执行下一行代码，新启动的 goroutine 的返回值都会被忽略  main goroutine 应当启动其他 goroutine。因为 main goroutine 终止时，程序就会终止，不会再有 goroutine 运行 goroutine 在相同的地址空间运行，因此在访问共享的内存时必须同步\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(5000 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026quot;world\u0026quot;) say(\u0026quot;hello\u0026quot;) }   goroutine 优于线程  goroutine 更加轻量。只有几个 Kb 大小的栈，且可根据需求增长。但是线程的栈大小是固定的？？ goroutine 被复用到更少数量的线程。一个线程可能有很多 goroutine，当该线程的一个 goroutine 阻塞时，另外一个 OS 线程被创建，并将剩余的 goroutine 移到新的 OS 线程 goroutine 使用 channel 通信。channel 可以防止 goroutine 访问共享内存时竞争。channel 可认为是一个管道  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"83b5611bcea0318e9bf4f4c8444b5516","permalink":"https://xueqing.github.io/blog/go/basic/go_goroutine/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_goroutine/","section":"blog","summary":"goroutine 创建一个 goroutine goroutine 优于线程 goroutine goroutine 是和其他函数或方法并发运行的函数或方法 goroutine 可认为是轻量级的线程，比线程创建代价小 创建一个 goroutine 使用 go 可以开始一个 goro","tags":["go"],"title":"go 程","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 类型声明 type 声明定义一个新的命名类型，它和某个已有类型使用同样的底层类型。命名；类型提供了一种方式来区分底层类型的不同或不兼容使用，这样就不会在无意中混用他们。\n比如，把不同计量单位的温度值转换为不同的类型。即使使用的底层类型相同，二者是不是相同的类型，不能使用算术表达式进行比较和合并。\npackage main import \u0026quot;fmt\u0026quot; type celsius float64 type fahrenheit float64 const ( absoluteZeroC celsius = -273.15 freezingC celsius = 0 boilingC celsius = 100 ) func main() { fmt.Printf(\u0026quot;cToF(%2f) = (%2f)\\n\u0026quot;, absoluteZeroC, cToF(absoluteZeroC)) // error:cannot use boilingC (type celsius) as type fahrenheit in argument to fToC fmt.Printf(\u0026quot;fToC(%2f) = (%2f)\\n\u0026quot;, boilingC, fToC(boilingC)) fmt.Printf(\u0026quot;fToC(%2f) = (%2f)\\n\u0026quot;, boilingC, fToC(fahrenheit(boilingC))) } func cToF(c celsius) fahrenheit { return fahrenheit(c*9/5 + 32) } func fToC(f fahrenheit) celsius { return celsius((f - 32) * 5 / 9) }  类型转换 对于每个类型 T，都有一个对应的类型转换操作 T(x) 将值转化为类型 T。如果两个类型具有相同的底层类型或二者都是指向相同底层类型变量的未命名指针类型，则二者可以相互转化。类型转化不改变；类型值的表达方式，仅改变类型。如果 x 对于类型 T 是可赋值的，类型转化也是允许的，但是通常是不必要的。\n 类型转换用于将一种数据类型的变量转换为另一种类型的变量，go 不支持隐式类型转换\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) func main() { var x, y int = 3, 4 var f float64 = math.Sqrt(float64(x*x + y*y)) var z uint = f //error: cannot use f (type float64) as type uint in assignment fmt.Println(x, y, z) }  格式type_name(expression)\n type_name 是类型 expression 是表达式   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7a36350f4d1a205e097843b23dea0188","permalink":"https://xueqing.github.io/blog/go/basic/go_type_casting/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_type_casting/","section":"blog","summary":"类型声明 type 声明定义一个新的命名类型，它和某个已有类型使用同样的底层类型。命名；类型提供了一种方式来区分底层类型的不同或不兼容使用，这样就不会","tags":["go"],"title":"go 类型转换","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" package pkg_name定义包名，即程序属于哪个包，每个 go 文件第一行  package main表示一个可独立执行的程序 每个 go 的应用程序必须包含一个 main 包\n  import pkg_name表示程序需要使用的包，如 fmt 实现了格式化输入输出函数 func func_name(){}定义了程序的函数  main 函数是每一个可执行程序必须包含的，一般来说都是在启动后第一个执行的函数 有 init 函数的时候先执行 init 函数  /*...*/和//是注释 标识符（常量、变量、类型、函数名、结构字段等）  以大写字母开头，则该对象可以被外部包的代码使用，即导出（类比面向对象的 public） 以小写字母开头，则对外包不可见，只在包内部可见可用（类比面向对象的 protected）  执行程序  程序以.go结尾 执行go run filename.go可运行代码  编译程序  执行go install filename，会寻找filename文件夹下的包含 main 函数的文件，编译生成二进制文件filename放在对应的bin目录下  Note：go 语言不支持{放单独一行，和 C 和 C++ 不一样  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0ad8ab76e5641227a518a9696fbed532","permalink":"https://xueqing.github.io/blog/go/basic/go_structure/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_structure/","section":"blog","summary":"package pkg_name定义包名，即程序属于哪个包，每个 go 文件第一行 package main表示一个可独立执行的程序 每个 go 的应用程序必须包含一个 main 包 import pkg_n","tags":["go"],"title":"go 结构","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  定义结构体 访问结构体成员变量  定义结构体  struct 是域的集合 定义结构体需要使用 type 和 struct 关键字\npackage main import \u0026quot;fmt\u0026quot; type vertex struct { X int Y int } func main() { fmt.Println(vertex{1, 2}) }  声明结构体变量：结构体字面量代表使用列举的域给新分配的结构体赋值\n var_name := struct_name {var1, var2...,varn} var_name := struct_name {key1 : var1, key2 : val2..., keyn : varn} 使用 key: 可以仅列出部分字段，与字段名顺序无关\npackage main import \u0026quot;fmt\u0026quot; type vertex struct { X, Y int } var ( v1 = vertex{1, 2} v2 = vertex{X : 1} v3 = vertex{} p = \u0026amp;vertex{2, 3} ) func main() { fmt.Println(v1, v2, v3, p) //{1 2} {1 0} {0 0} \u0026amp;{2 3} }    访问结构体成员变量  访问结构体成员变量用 . 操作符 和 C++ 不一样，结构体指针访问结构体成员变量也用 . 操作符\npackage main import \u0026quot;fmt\u0026quot; type vertex struct { X int Y int } func main() { v := vertex{1, 2} fmt.Println(v) p := \u0026amp;v p.X = 1e9 fmt.Println(v) }  结构体作为函数参数\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"54e1006a6c88af649c84a614ee97208e","permalink":"https://xueqing.github.io/blog/go/basic/go_struct/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_struct/","section":"blog","summary":"定义结构体 访问结构体成员变量 定义结构体 struct 是域的集合 定义结构体需要使用 type 和 struct 关键字 package main import \u0026quot;fmt\u0026quot; type vertex struct { X int Y int } func main() { fmt.Println(vertex{1, 2}) } 声明结构体变量：结构体","tags":["go"],"title":"go 结构体","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" range 关键字用于 for 循环中迭代数组 array、切片 slice、通道 channel 或 集合 map 的元素 在数组和切片中返回元素的索引和索引对应的值的拷贝，在集合中返回 key-value 对的 key 值\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range pow { fmt.Printf(\u0026quot;2**%d = %d\\n\u0026quot;, i, v) } }  可以赋值给 _ 跳过索引或值\n for i, _ := range pow。如果只想要索引，可以忽视第二个参数 for i := range pow for _, val := range pow\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { pow := make([]int, 10) for i := range pow { pow[i] = 1 \u0026lt;\u0026lt; uint(i) //2**i } for _, val := range pow { fmt.Printf(\u0026quot;%d\\n\u0026quot;, val) } }    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4792c73a61af871a392d579809167f21","permalink":"https://xueqing.github.io/blog/go/basic/go_range/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_range/","section":"blog","summary":"range 关键字用于 for 循环中迭代数组 array、切片 slice、通道 channel 或 集合 map 的元素 在数组和切片中返回元素的索引和索引对应的值的拷贝，在集合中返回 key-value","tags":["go"],"title":"go 范围","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 算术运算符: +, -, *, /, %, ++, \u0026ndash; 关系运算符: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;= 逻辑运算符: \u0026amp;\u0026amp;, ||, ! 位运算符: \u0026amp;, |, ^(异或), \u0026lt;\u0026lt;, \u0026gt;\u0026gt; 赋值运算符: =, +=, -=, *=, /=, %=, \u0026lt;\u0026lt;=, \u0026gt;\u0026gt;=, \u0026amp;=, |=, ^= 其他运算符: \u0026amp;(返回变量存储地址), *(指针变量)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"bdf46f2849db93546dd3f4af449f758d","permalink":"https://xueqing.github.io/blog/go/basic/go_operator/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_operator/","section":"blog","summary":"算术运算符: +, -, *, /, %, ++, \u0026ndash; 关系运算符: ==, !=, \u0026gt;, \u0026lt;, \u0026gt;=, \u0026lt;= 逻辑运算符: \u0026amp;\u0026amp;, ||, ! 位运算符: \u0026amp;, |, ^(异或), \u0026lt;\u0026lt;, \u0026gt;\u0026gt; 赋值运算符: =, +=, -=, *=, /=, %=, \u0026lt;\u0026lt;=, \u0026gt;\u0026gt;=, \u0026amp;=, |=, ^= 其他运算","tags":["go"],"title":"go 运算符","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 定义\nfunc myRecursion() { //myRecursion() }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"14d4b3bc7d8cdb05b14c99708ddb86ec","permalink":"https://xueqing.github.io/blog/go/basic/go_recursive/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_recursive/","section":"blog","summary":"定义 func myRecursion() { //myRecursion() }","tags":["go"],"title":"go 递归函数","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" go 使用 error 值表示错误状态，通过内置的错误接口提供了非常简单的错误处理机制 error 是一个接口类型，定义\ntype error interface { Error() string }  可在编码中通过实现 error 接口类型生成错误信息\n 函数通常在最后一个返回值返回错误信息，使用 errors.New 可返回一个错误信息\n errors.new 接收一个字符串作为参数 如果有错误信息，则得到一个非 nil 的 error 对象，通常将返回值与 nil 比较\ni, err := strconv.Atoi(\u0026quot;42\u0026quot;) if err != nil { fmt.Printf(\u0026quot;couldn't convert number: %v\\n\u0026quot;, err) return } fmt.Println(\u0026quot;Converted integer:\u0026quot;, i)   打印 error 的时候，调用的是内部的Error() string方法\n 使用 fmt.Errorf 函数可以给 error 增加更多信息\n fmt.Errorf 接收参数和格式化字符串\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;math\u0026quot; ) type errNegativeSqrt float64 func (e errNegativeSqrt) Error() string { return fmt.Sprint(\u0026quot;cannot Sqrt negative number: \u0026quot;, float64(e)) } func mySqrt(x float64) (float64, error) { if x \u0026lt; 0 { return -1, errNegativeSqrt(x) } z := x / 2 tmp := 0.0 for math.Abs(z-tmp) \u0026gt;= 0.000000000001 { tmp = z z -= (z*z - x) / (2 * z) } return z, nil } func main() { fmt.Println(mySqrt(2)) fmt.Println(mySqrt(-2)) }    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f2061ad8617371734c4df2670e6fb6e2","permalink":"https://xueqing.github.io/blog/go/basic/go_error_handling/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_error_handling/","section":"blog","summary":"go 使用 error 值表示错误状态，通过内置的错误接口提供了非常简单的错误处理机制 error 是一个接口类型，定义 type error interface { Error() string } 可在编码中通过实现 error 接口类型生成错","tags":["go"],"title":"go 错误处理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 参考\n shell 风格指南  背景 shell 文件和解释器调用 环境 注释 格式 缩进 行的长度和长字符串 管道 循环 case 语句 变量扩展 引用 特性及错误 命令替换 [test,[和[[](#test%e5%92%8c) 测试字符串 文件名的通配符扩展 eval 管道导向 while 循环 命名约定 函数名 变量名 常量和环境变量名 源文件名 只读变量 使用本地变量 函数位置 主函数 main 调用命令  C++ 风格指南 Python 风格指南\n shell 风格指南\n C++ 风格指南\n Python 风格指南\n  shell 风格指南 背景  使用哪一种 shell  bash 是唯一被允许执行的 shell 脚本语言 可执行文件以#!/bin/bash开始 使用set设置 shell 的选项  什么时候使用 shell  仅被用于小功能或简单的包装脚本 如果在乎性能，不使用 shell 需要使用数据而不是变量赋值，如${PHPESTATUS}，使用 Python 脚本 脚本超过 100 行，尽可能使用 Python，以免之后花更多时间重写脚本   shell 文件和解释器调用  文件扩展名  可执行文件应该没有扩展名（强烈建议）或使用.sh扩展名 库文件使用.sh扩展名，且不可执行  SUID/SGID  禁止在脚本中使用 SUID(Set User ID) 和 SGID(Set Group ID) 如果需要较高权限使用sudo   环境  STDOUT vs STDERR\n 所有错误信息应导向 STDERR 便于从实际问题中分离出正常状态 推荐使用如下函数，打印错误信息和其他状态信息\nerr() { echo \u0026quot;[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $@\u0026quot; \u0026gt;\u0026amp;2 } if ! do_sth; then err \u0026quot;Unable to do_sth\u0026quot; exit \u0026quot;${E_DID_NOTHING}\u0026quot; fi    注释  文件头\n 文件必须包含一个顶层注释，简要概述内容。版权声明和作者信息可选 例如\n#!/bin/bash # # Perform hot bakeups of Oracle databases.   功能注释\n 除了明显简短的函数必须被注释 库函数都必须注释 注释包括 函数的描述 全局变量的使用和修改 使用的参数说明 返回值，而不是上一条命令运行后默认的退出状态 例如\n#!/bin/bash # # Perform hot bakeups of Oracle databases. export PATH='/usr/xpg4/bin:/usr/bin:/opt/csw/bin:/opt/goog/bin' ####################################### # Cleanup files from the backup dir # Globals: # BACKUP_DIR # ORACLE_SID # Arguments: # None # Returns: # None ####################################### cleanup() { #... }   实现部分的注释\n 注释代码中有技巧、不明显、有趣或重要的部分 不要注释所有代码，简单注释  TODO 注释\n 使用 TODO 注释临时的、短期解决方案的、或足够好但不完美的代码 应包含全部大写的字符串 TODO + 用户名，冒号可选，最好在后面加上 bug 或 ticket 的序号 例如# TODO(kiki): Handle the unlikely edge cases (bug ####)   格式 缩进  缩进两个空格，没有制表符 代码块直接使用空行提升可读性 对于已有文件，保持已有的缩进风格  行的长度和长字符串  行的最大长度为 80 个字符 使用 here document 或嵌入的换行符 例如\n# DO use 'here document's cat \u0026lt;\u0026lt;END; I am an exceptionally long string. END # Embedded newlines are ok too long_string=\u0026quot;I am an exceptionally long string.\u0026quot;   管道  如果一行容不下一个管道，将正哥管道操作分割成梅钢一个管道 管道操作的下一部分应放在新行且缩进两个空格 例如\n# All fits on one line command1 | command2 # Long commands command1 \\ | command2 \\ | command3 \\ | command4   循环  将; do，; then和while，for，if放在同一行 else单独成一行 结束语句单独一行并与开始语句垂直对齐 例如\nfor dir in ${dirs_to_cleanup}; do if [[ -d \u0026quot;${dir}/${ORACLE_SID}\u0026quot; ]]; then log_date \u0026quot;Cleaning up old files in ${dir}/${ORACLE_SID}\u0026quot; rm \u0026quot;${dir}/${ORACLE_SID}/\u0026quot;* if [[ \u0026quot;$?\u0026quot; -ne 0 ]]; then error_message fi else mkdir -p \u0026quot;${dir}/${ORACLE_SID}\u0026quot; if [[ \u0026quot;$?\u0026quot; -ne 0 ]]; then error_message fi fi done   case 语句  通过 2 个空格缩进可选项 同一行可选项的模式右圆括号知乎和结束符;;之前各一个空格 长可选项或多命令可选项应被拆成多行，模式、操作和结束符;;在不同的行\n# multi-lines case \u0026quot;${expression}\u0026quot; in a) variable=\u0026quot;...\u0026quot; some_command \u0026quot;${variable}\u0026quot; \u0026quot;${other_expr}\u0026quot; ... ;; absolute) actions=\u0026quot;relative\u0026quot; another_command \u0026quot;${actions}\u0026quot; \u0026quot;${other_expr}\u0026quot; ... ;; *) error \u0026quot;Unexpected expression '${expression}'\u0026quot; ;; esac # one-line verbose='false' aflag='' bflag='' files='' while getopts 'abf:v' flag; do case \u0026quot;${flag}\u0026quot; in a) aflag='true' ;; b) bflag='true' ;; f) files=\u0026quot;${OPTARG}\u0026quot; ;; v) verbose='true' ;; *) error \u0026quot;Unexpected option ${flag}\u0026quot; ;; esac done   变量扩展  按照优先级顺序  与现存代码发现的保持一致 阅读引用变量 推荐使用${var}而不是$var  例如\n# Section of recommended cases. # Preferred style for 'special' variables: echo \u0026quot;Positional: $1\u0026quot; \u0026quot;$5\u0026quot; \u0026quot;$3\u0026quot; echo \u0026quot;Specials: !=$!, -=$-, _=$_. ?=$?, #=$# *=$* @=$@ \\$=$$ ...\u0026quot; # Braces necessary: echo \u0026quot;many parameters: ${10}\u0026quot; # Braces avoiding confusion: # Output is \u0026quot;a0b0c0\u0026quot; set -- a b c echo \u0026quot;${1}0${2}0${3}0\u0026quot; # Preferred style for other variables: echo \u0026quot;PATH=${PATH}, PWD=${PWD}, mine=${some_var}\u0026quot; while read f; do echo \u0026quot;file=${f}\u0026quot; done \u0026lt; \u0026lt;(ls -l /tmp) # Section of discouraged cases # Unquoted vars, unbraced vars, brace-quoted single letter # shell specials. echo a=$avar \u0026quot;b=$bvar\u0026quot; \u0026quot;PID=${$}\u0026quot; \u0026quot;${1}\u0026quot; # Confusing use: this is expanded as \u0026quot;${1}0${2}0${3}0\u0026quot;, # not \u0026quot;${10}${20}${30} set -- a b c echo \u0026quot;$10$20$30\u0026quot;   引用  除非需要小心不带引用的扩展，否则总是引用包含变量、命令替换符、空格或 shell 元字符的字符串 推荐引用是单词的字符串(而不是命令选项或者路径名) 不要引用整数 注意[[中模式匹配的引用规则 请使用$@除非有特殊原因需要使用S*\n# 'Single' quotes indicate that no substitution is desired. # \u0026quot;Double\u0026quot; quotes indicate that substitution is required/tolerated. # Simple examples # \u0026quot;quote command substitutions\u0026quot; flag=\u0026quot;$(some_command and its args \u0026quot;$@\u0026quot; 'quoted separately')\u0026quot; # \u0026quot;quote variables\u0026quot; echo \u0026quot;${flag}\u0026quot; # \u0026quot;never quote literal integers\u0026quot; value=32 # \u0026quot;quote command substitutions\u0026quot;, even when you expect integers number=\u0026quot;$(generate_number)\u0026quot; # \u0026quot;prefer quoting words\u0026quot;, not compulsory readonly USE_INTEGER='true' # \u0026quot;quote shell meta characters\u0026quot; echo 'Hello stranger, and well met. Earn lots of $$$' echo \u0026quot;Process $$: Done making \\$\\$\\$.\u0026quot; # \u0026quot;command options or path names\u0026quot; # ($1 is assumed to contain a value here) grep -li Hugo /dev/null \u0026quot;$1\u0026quot; # Less simple examples # \u0026quot;quote variables, unless proven false\u0026quot;: ccs might be empty git send-email --to \u0026quot;${reviewers}\u0026quot; ${ccs:+\u0026quot;--cc\u0026quot; \u0026quot;${ccs}\u0026quot;} # Positional parameter precautions: $1 might be unset # Single quotes leave regex as-is. grep -cP '([Ss]pecial|\\|?characters*)$' ${1:+\u0026quot;$1\u0026quot;} # For passing on arguments, # \u0026quot;$@\u0026quot; is right almost everytime, and # $* is wrong almost everytime: # # * $* and $@ will split on spaces, clobbering up arguments # that contain spaces and dropping empty strings; # * \u0026quot;$@\u0026quot; will retain arguments as-is, so no args # provided will result in no args being passed on; # This is in most cases what you want to use for passing # on arguments. # * \u0026quot;$*\u0026quot; expands to one argument, with all args joined # by (usually) spaces, # so no args provided will result in one empty string # being passed on. # (Consult 'man bash' for the nit-grits ;-) set -- 1 \u0026quot;2 two\u0026quot; \u0026quot;3 three tres\u0026quot;; echo $# ; set -- \u0026quot;$*\u0026quot;; echo \u0026quot;$#, $@\u0026quot;) set -- 1 \u0026quot;2 two\u0026quot; \u0026quot;3 three tres\u0026quot;; echo $# ; set -- \u0026quot;$@\u0026quot;; echo \u0026quot;$#, $@\u0026quot;)   特性及错误 命令替换  使用${command}而不是反引号 嵌套的反引号要求用反斜杠转义内部的反引号，而${command}形式嵌套时不需要改变，易于阅读 例如\n# This is preferred: var=\u0026quot;$(command \u0026quot;$(command1)\u0026quot;)\u0026quot; # This is not: var=\u0026quot;`command \\`command1\\``\u0026quot;   test,[和[[  推荐使用[[ ... ]]，而不是[，test和/usr/bin [ 在[[ ... ]]之间不会有路径名称扩展或单词分割发生，且允许正则表达式匹配 例如\n# This ensures the string on the left is made up of characters in the # alnum character class followed by the string name. # Note that the RHS should not be quoted here. # For the gory details, see # E14 at http://tiswww.case.edu/php/chet/bash/FAQ if [[ \u0026quot;filename\u0026quot; =~ ^[[:alnum:]]+name ]]; then echo \u0026quot;Match\u0026quot; fi # This matches the exact pattern \u0026quot;f*\u0026quot; (Does not match in this case) if [[ \u0026quot;filename\u0026quot; == \u0026quot;f*\u0026quot; ]]; then echo \u0026quot;Match\u0026quot; fi # This gives a \u0026quot;too many arguments\u0026quot; error as f* is expanded to the # contents of the current directory if [ \u0026quot;filename\u0026quot; == f* ]; then echo \u0026quot;Match\u0026quot; fi   测试字符串  尽可能使用引用，而不是过滤字符串 使用空-z或非空-n字符串测试，而不是过滤字符串 例如\n# Do this: if [[ \u0026quot;${my_var}\u0026quot; = \u0026quot;some_string\u0026quot; ]]; then do_something fi # -z (string length is zero) and -n (string length is not zero) are # preferred over testing for an empty string if [[ -z \u0026quot;${my_var}\u0026quot; ]]; then do_something fi # This is OK (ensure quotes on the empty side), but not preferred: if [[ \u0026quot;${my_var}\u0026quot; = \u0026quot;\u0026quot; ]]; then do_something fi # Not this: if [[ \u0026quot;${my_var}X\u0026quot; = \u0026quot;some_stringX\u0026quot; ]]; then do_something fi # Use this if [[ -n \u0026quot;${my_var}\u0026quot; ]]; then do_something fi # Instead of this as errors can occur if ${my_var} expands to a test # flag if [[ \u0026quot;${my_var}\u0026quot; ]]; then do_something fi   文件名的通配符扩展  使用明确的路径 文件名可能以-开头，使用扩展通配符./*比*更安全 例如\n# Here's the contents of the directory: # -f -r somedir somefile # This deletes almost everything in the directory by force rm -v * #removed directory: `somedir' #removed `somefile' # As opposed to: rm -v ./* #removed `./-f' #removed `./-r' #rm: cannot remove `./somedir': Is a directory #removed `./somefile'   eval  避免使用 eval 当用于给变量赋值时，eval 解析输入，并能够设置变量，但无法检查变量是什么 例如\n# What does this set? # Did it succeed? In part or whole? eval $(set_my_variables) # What happens if one of the returned values has a space in it? variable=\u0026quot;$(eval some_function)\u0026quot;   管道导向 while 循环  使用过程替换或 for 虚幻，而不是管道导向 while 循环 在 while 循环中被修改的变量不能传递给父 shell，因为循环命令是在一个子 shell 中运行的\nlast_line='NULL' your_command | while read line; do last_line=\u0026quot;${line}\u0026quot; done # This will output 'NULL' echo \u0026quot;${last_line}\u0026quot;  如果确定输入中不包含空格或特殊符号，可使用一个 for 循环\ntotal=0 # Only do this if there are no spaces in return values. for value in $(command); do total+=\u0026quot;${value}\u0026quot; done  使用过程替换允许重定向输出，但是请将命令放入一个显式的子 shell 中，而不是 bash 为 while 循环创建的隐式子 shell\ntotal=0 last_file= while read count filename; do total+=\u0026quot;${count}\u0026quot; last_file=\u0026quot;${filename}\u0026quot; done \u0026lt; \u0026lt;(your_command | uniq -c) # This will output the second field of the last line of output from # the command. echo \u0026quot;Total = ${total}\u0026quot; echo \u0026quot;Last one = ${last_file}\u0026quot;  当不需要传递复杂的结果给父 shell 时可使用 while 循环，当不希望改变父 shell 的范围变量时也是有用的\n# Trivial implementation of awk expression: # awk '$3 == \u0026quot;nfs\u0026quot; { print $2 \u0026quot; maps to \u0026quot; $1 }' /proc/mounts cat /proc/mounts | while read src dest type opts rest; do if [[ ${type} == \u0026quot;nfs\u0026quot; ]]; then echo \u0026quot;NFS ${dest} maps to ${src}\u0026quot; fi done   命名约定 函数名  使用小写字符，用下划线分割单词，使用双冒号::分割库 函数名之后必须有圆括号。关键词function可选，但必须在一个项目中保持一致  函数名之后有括号时，关键词function是多余的，但是促进了函数的快速辨识  大括号和函数名位于同一行，且函数名和圆括号之间没有空格 例如\n# Single function my_func() { #... } # Part of a package mypackage::my_func() { #... }   变量名  如函数名 循环的变量名应该和循环的任何变量同样命名 例如\nfor zone in ${zones}; do something_with \u0026quot;${zone}\u0026quot; done   常量和环境变量名  全部大写，用下划线分割，声明在文件的顶部 有的第一次设置就变成了常量(如通过 getopts)，所以可以在 getopts 或基于条件来设定常量，但之后应立即设置为只读 在函数中declare不会对全局变量进行操作，所以推荐使用readonly和export\n# Constant readonly PATH_TO_FILES='/some/path' # Both constant and environment declare -xr ORACLE_SID='PROD' VERBOSE='false' while getopts 'v' flag; do case \u0026quot;${flag}\u0026quot; in v) VERBOSE='true' ;; esac done readonly VERBOSE   源文件名  小写，可使用下划线分割单词  只读变量  使用readonly或declare -r确保变量只读 因为全局变量在 shell 中广泛使用，所以在使用过程中捕获错误很重要。明确只读变量\nzip_version=\u0026quot;$(dpkg --status zip | grep Version: | cut -d ' ' -f 2)\u0026quot; if [[ -z \u0026quot;${zip_version}\u0026quot; ]]; then error_message else readonly zip_version fi   使用本地变量  使用local声明特定功能的变量，可以确保只在函数内部和子函数中可见，避免了污染全局命名空间 当赋值的值由命令替换提供时，声明和赋值需分开。因为内建的local命令不会从命令替换中传递退出码 例如\nmy_func2() { local name=\u0026quot;$1\u0026quot; # Separate lines for declaration and assignment: local my_var my_var=\u0026quot;$(my_func)\u0026quot; || return # DO NOT do this: $? contains the exit code of 'local', not my_func local my_var=\u0026quot;$(my_func)\u0026quot; [[ $? -eq 0 ]] || return }   函数位置  将文件中所有函数一起放在常量下面，不要在函数直接隐藏可执行代码 只有includes，set声明和常量设置可能在函数声明之前完成  主函数 main  对于包含至少一个其他函数的足够长的脚本，需要称为main的函数 便于查找程序的开始，同时允许定义更多变量为局部变量 文件中最后的非注释行应该是对main函数的调用main \u0026quot;$@\u0026quot;  调用命令  检查返回值\n 总是检查返回值，并给出信息返回值 对于非管道命令，使用$?或直接通过一个if语句来检查以保持简洁 例如\nif ! mv \u0026quot;${file_list}\u0026quot; \u0026quot;${dest_dir}/\u0026quot; ; then echo \u0026quot;Unable to move ${file_list} to ${dest_dir}\u0026quot; \u0026gt;\u0026amp;2 exit \u0026quot;${E_BAD_MOVE}\u0026quot; fi # Or mv \u0026quot;${file_list}\u0026quot; \u0026quot;${dest_dir}/\u0026quot; if [[ \u0026quot;$?\u0026quot; -ne 0 ]]; then echo \u0026quot;Unable to move ${file_list} to ${dest_dir}\u0026quot; \u0026gt;\u0026amp;2 exit \u0026quot;${E_BAD_MOVE}\u0026quot; fi  bash 也有PIPESTATUS变量，允许检查从管道所有部分返回的代码\n 如果仅仅检查整个管道成功还是失败，可用下面的方法\ntar -cf - ./* | ( cd \u0026quot;${dir}\u0026quot; \u0026amp;\u0026amp; tar -xf - ) if [[ \u0026quot;${PIPESTATUS[0]}\u0026quot; -ne 0 || \u0026quot;${PIPESTATUS[1]}\u0026quot; -ne 0 ]]; then echo \u0026quot;Unable to tar files to ${dir}\u0026quot; \u0026gt;\u0026amp;2 fi  只要运用任何其他命令，PIPESTATUS会被覆盖。如果需要机遇管道中发生的错误执行不同的操作，需要在运行命令后立即将PIPESTATUS赋值给另一个变量，[是一个会将PIPESTATUS擦出的命令\n 例如\ntar -cf - ./* | ( cd \u0026quot;${DIR}\u0026quot; \u0026amp;\u0026amp; tar -xf - ) return_codes=(${PIPESTATUS[*]}) if [[ \u0026quot;${return_codes[0]}\u0026quot; -ne 0 ]]; then do_something fi if [[ \u0026quot;${return_codes[1]}\u0026quot; -ne 0 ]]; then do_something_else fi   内建命令和外部命令\n 在调用 shell 内建命令和调用另外的程序之间选择，选择内建命令 例如在bash(1)中参数扩展函数，内建函数更强健和便携，尤其是跟sed这样的命令比较 例如\n# Prefer this: addition=$((${X} + ${Y})) substitution=\u0026quot;${string/#foo/bar}\u0026quot; # Instead of this: addition=\u0026quot;$(expr ${X} + ${Y})\u0026quot; substitution=\u0026quot;$(echo \u0026quot;${string}\u0026quot; | sed -e 's/^foo/bar/')\u0026quot;    C++ 风格指南 Python 风格指南 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"217360ab548081cea8c1545a10019209","permalink":"https://xueqing.github.io/blog/ubuntu/google_style_guide/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/google_style_guide/","section":"blog","summary":"参考 shell 风格指南 背景 shell 文件和解释器调用 环境 注释 格式 缩进 行的长度和长字符串 管道 循环 case 语句 变量扩展 引用 特性及错误 命令替换 [test,[和[[](#","tags":["ubuntu","linux"],"title":"Google 开源项目风格指南","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"当使用模块时，不再使用 GOPATH 来解决导入。但是，它仍被用于存储下载的源码(在 GOPATH/pkg/mod)和编译好的命令(在 GOPATH/bin)。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"69f52d251a5d0fb637cf0de1201c8fa5","permalink":"https://xueqing.github.io/translation/go-doc/command/gopath_and_module/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/gopath_and_module/","section":"translation","summary":"当使用模块时，不再使用 GOPATH 来解决导入。但是，它仍被用于存储下载的源码(在 GOPATH/pkg/mod)和编译好的命令(在 GOPATH/bin)","tags":["go-command"],"title":"GOPATH 和模块","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"Go 路径用于解决导入语句，它通过 go/build 包实现，并记录在 go/build 包。\nGOPATH 环境变量列举了寻找 Go 代码的位置。在 Unix 上，其值是一个冒号分隔的字符串。在 Windows 上，其值是一个分号分隔的字符串。在 Plan 9 上，其值是一个列表。\n如果环境变量未被设置，GOPATH 默认是用户主目录下的一个 “go” 子目录(Unix 下是 $HOME/go，Windows 下是 %USERPROFILE%\\go)，除非那个目录存在一个 Go 发行版本。运行 go env GOPATH 查看当前的 GOPATH。\n查看 SettingGOPATH 设置一个自定义的 GOPATH。\nGOPATH 下的每个目录必须有一个规定的结构：\n src 目录持有源码。src 下的目录确定了导入路径或可执行文件名字。 pkg 目录持有安装的包对象。在 Go 树中，每个目标操作系统和架构对有其自己的包的子目录(pkg/GOOS_ARCH). 如果 DIR 是GOPATH 下的一个目录，包的源码在 DIR/src/foo/bar，那么包可以导出为 “foo/bar”，且将其编译文件安装到 “DIR/pkg/GOOS_GOARCH/foo/bar.a”。 bin 目录持有编译的命令。每个命令命名为它的源码目录，但是只有最后一个元素，而不是整个路径。也就是说，一个命令的源码在 DIR/src/foo/quux，那么它被安装到 DIR/bin/quux。这个 “foo/” 前缀被除去以便你可以增加 DIR/bin 到你的 PATH 来获取安装的命令。如果设置了 GOBIN 环境变量，命令被安装到 GOBIN 命名的目录而不是 DIR/bin。GOBIN 必须是一个绝对路径。  这里是一个目录格式示例：\nGOPATH=/home/user/go /home/user/go/ src/ foo/ bar/ (包 bar 中的 go 代码) x.go quux/ (包 main 中的 go 代码) y.go bin/ quux (安装的命令) pkg/ linux_amd64/ foo/ bar.a (安装的包对象)  Go 搜索 GOPATH 列举的每个目录来查找源码，但是新包总是下载到列表中的第一个目录。\n查看如何编写 Go 代码的例子。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ae041917790b4f4539f9719057786175","permalink":"https://xueqing.github.io/translation/go-doc/command/gopath_env_var/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/gopath_env_var/","section":"translation","summary":"Go 路径用于解决导入语句，它通过 go/build 包实现，并记录在 go/build 包。 GOPATH 环境变量列举了寻找 Go 代码的位置。在 Unix 上，其值是一个冒号分隔的字符串。在 Windows 上，其值是一","tags":["go-command"],"title":"GOPATH 环境变量","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"class hash_map { hash_map() {set_load(); v.reserve(max_load*b.size());} // 表“太满”(如 75% 满)时性能会恶化 void set_load(float m=0.7, float g=1.6) {max_load=m; grow=g;} // 查找 mapped_type\u0026amp; operator[] (const key_type\u0026amp; k) { // 先计算散列值，查找表索引 size_type i = hash(k) % b.size(); // 找到之后遍历散列链匹配 for(Entry* p=b[i]; p; p=p-\u0026gt;next) { if(eq(k, p-\u0026gt;key)) { // 找到则插入表 if(p-\u0026gt;erased) { p-\u0026gt;erased = false; no_of_erased--; return p-\u0026gt;val = default_value; } return p-\u0026gt;val; } } // 找不到则插入散列表 // 若表已经“满”了，增大存储 if(size_tye(b.size() * max_load) \u0026lt;= v.size()) { resize(b.size() * grow); return operator[](k); } // 插入元素 v.push_back(Entry(k, default_value, b[i])); b[i] = \u0026amp;v.back(); return b[i]-\u0026gt;val; } // 调整散列表大小 void resize(size_type s) { // 计算 erased 元素数目，同时从存储中删除对应元素 size_type i = v.size() while(no_of_erased) { if(v[--i].erased) { v.erase(\u0026amp;v[i]); --no_of_erased; } } // 如果 b.size() \u0026gt;= s，返回 if(s \u0026lt;= b.size()) return; // 如果 b.size() \u0026lt; s，增大 b，b 全部清 0，重新计算 b.resize(s); fill(b.begin(), b.end(), 0); // 重新分配底层存储 v.reserve(s * max_load); // 重新计算元素散列值 for(size_type i=0; i\u0026lt;v.size(); i++) { size_type ii = hash(v[i].key) % b.size(); v[i].next = b[ii]; b[ii] = \u0026amp;v[i]; } } private: struct Entry { key_type key; mapped_type val; bool erased; Entry* next; // 散列链 }; vector\u0026lt;Entry\u0026gt; v; // 实际存储 vector\u0026lt;Entry*\u0026gt; b; // 散列表，保存实际存储的指针 float max_load; // 保持 v.size() \u0026lt;= b.size()*max_load float grow; // 接近太满时自动改变大小 resize(bucket_count() * grow) size_type no_of_erased; // erased 元素项的数目 Hasher hash; // 散列函数 key_equal eq; // 相等判断 const T default_value; // entry 默认值 };  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"72cea9697f7a972572e2d1f3a2428fbf","permalink":"https://xueqing.github.io/blog/cplusplus/hash_map/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/hash_map/","section":"blog","summary":"class hash_map { hash_map() {set_load(); v.reserve(max_load*b.size());} // 表“太满”(如 75% 满)时性能会恶化 void set_load(float m=0.7, float g=1.6) {max_load=m; grow=g;} // 查找 mapped_type\u0026amp; operator[] (const key_type\u0026amp; k) { // 先计算散列值，查找表索引 size_type i = hash(k) % b.size(); // 找到之后遍历散列链匹配","tags":["c++","STL"],"title":"hash map","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  HLS 概述 一些概念  media playlist master playlist  HLS 协议简介  输入视频或音频 服务器组件 文件切片器 媒体片段文件 索引文件(Playlists) 分布式组件 客户端软件 会话模式 内容加密 缓存和发送协议 流切换  ffmpeg 加密命令行 ffmpeg 源码解读  HLS 概述  HLS(HTTP Live Streaming)是 Apple 的动态码率自适应技术，主要用于 PC 端和移动端的音视频服务。包括一个 m3u(8) 的索引文件、TS 媒体分片文件和 key 加密串文件 HLS 是基于 HTTP 的流媒体网络传输协议。工作原理是把整个流分成一个个小的基于 HTTP 的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的 extended M3U (m3u8)playlist 文件，用于寻找可用的媒体流 HLS 只请求基本的 HTTP 报文，与实时传输协议(RTP)不同，HLS 可以穿过任何允许 HTTP 数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络来传输媒体流  一些概念  一个多媒体演示通过一个 playlist 的 URL (uniform resource identifier， 统一资源标识符) 指定。 一个 playlist 是一个 media playlist 或 master playlist。二者都是 UTF-8 的文本文件，包含 URI 和描述性标记。  media playlist 一个 media playlist 包含媒体片段的列表，当顺序播放时，会播放多媒体演示。\n想要播放这个 playlist，客户端首先下载 playlist 文件，然后下载和播放 playlist 文件内声明的媒体片段。客户端重新加载 playlist 以查找新增加的片段。数据应当使用 HTTP 下载。但是，一个 URI 通常可以指定任何协议，能够可靠地传输需要的指定资源。\nmaster playlist 一个 master playlist 提供 variant stream 的集合，每个描述了相同内容的不同版本。\n一个 variant stream 包含一个 media playlist，指定了以特定比特率、特定格式编码的媒体，包含视频的媒体包含特定的分辨率。\n一个 variant stream 也可以指定一个 rendition 的集合。rendition 是内容的可选版本，必须不同语言的音频或不同摄像角度录制的视频。\n客户端应该根据网络条件切换不同的 variant stream。客户端也应该根据用户偏好选择 rendition。\nHLS 协议简介  HLS 协议规定  视频的封装格式是 TS 视频的编码格式为 H264，音频编码格式为 MP3、AAC 或者 AC-3 除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件(文本文件)  HLS 方案如图  输入视频或音频  输入的音视频格式不限，与服务器的通信协议不限(如 RTMP)  服务器组件  媒体编码器：将输入的音视频编码成 HEVC 视频和 AC-3 音频，并且输出 MPEG-4(H.264 视频和 AAC 音频)文件碎片或 MPEG-2 传输流 流切片器(stream segmenter)：通过本地网络从上面的媒体编码器中读取数据，将 MPEG-2 传输流切片，分割成一组相等时间间隔的小媒体文件，保存为一个或多个系列的媒体文件和索引文件(m3u8)，防止在网络服务器上  视频是 .ts 文件；纯音频会被编码为一些音频小片段，通常为 ADTS 头的 AAC、MP3、或者 AC-3 格式 索引文件会包含这些切片文件的引用。每当一个切片文件生成后，索引文件都会进行更新。索引用于追踪切片文件的有效性和定位切片文件的位置 切片器也可以同时对媒体片段进行加密并且创建一个密钥文件作为整个过程的一部分 将索引文件的 URL 发布在网络服务器上。客户端软件读取索引，然后按序请求并展示列举的媒体文件，且媒体文件之间没有暂停或跳跃   文件切片器  如果已经有编码后的文件(而不是编码流)，可以使用文件切片器，通过它对编码后的媒体文件进行 MPEG-2 流的封装并且将它们分割为等长度的小片段 文件切片器允许使用已经存在的音视频库用于 HLS 服务。它和流切片器的功能相似，但是处理的源从流替换为文件  媒体片段文件  HLS 发送音频和视频为一系列的小文件，通常是 6 秒时长的文件，称为媒体片段文件 媒体片段是由切片器生成的，基于编码后的媒体源，是由一系列的 .ts 格式的文件组成，包含了通过 MPEG-2 传送流携带的 H.264 视频 和 AAC /MP3/AC-3 音频 对于纯音频的广播，切片器可以产生 MPEG 基础音频流，其中包含了 ADTS 头的 AAC、MP3、或者 AC3 等音频  索引文件(Playlists)  索引文件，或 playlist，提供媒体片段文件的 URL 的一个有序列表。HLS 的索引文件保存为 M3U8 playlist，是 MP3 playlist 使用的 M3U 的一个扩展 通常由切片器附带生成，保存为 .m3u8 格式，.m3u 一般用于 MP3 音频的索引文件 客户端访问索引文件的 URL，然后按序请求索引的文件 注意：如果你的扩展名是 .m3u，并且系统支持 .mp3 文件，那客户的软件可能要与典型的 MP3 playList 保持一致来完成流网络音频的播放  分布式组件  分布式系统是一个网络服务或者一个网络缓存系统，通过 HTTP 向客户端发送媒体文件和索引文件 不用自定义服务模块发送内容。通常仅仅需要很简单的网络配置即可使用。而且这种配置一般就是限制指定 .m3u8 文件和 .ts 文件的 MIME 类型 实际部署 HLS，你需要为浏览器创建一个 HTML 页面或创建一个作为接收者的客户端应用。你也需要使用网络服务器以及一种方式，将实时流编码为 MPEG-4 媒体文件碎片(包含 HEVC 或 H264 视频，AAC或 AC-3 音频)  客户端软件  客户端软件负责选择请求合适的媒体、下载媒体资源，并组装媒体资源以便可以向用户连续的流 客户端开始会抓取索引文件(.m3u8/.m3u)，用 URL 来标记不同的流  索引文件可以指定可用媒体文件的位置、解密的密钥，以及任何可以切换的流  对于选中的流，客户端会有序的下载每一个可获得的文件。每一个文件包含流的一个连续碎片。一旦下载到足够量的数据，客户端会开始向用户展示重新组装好的媒体资源 客户端负责抓取任何解密密钥、认证或者展示一个用于认证的用户界面，以及解密需要的文件 这个过程会一直持续直到索引文件出现标记 #EXT-X-ENDLIST。如果结束标记不出现，该索引就是持续广播的一部分。客户端会定期的加载一些新的索引文件。客户端会从新更新的索引文件中去查找新的媒体文件和密钥文件并且将关联的 URL 加入到请求队列  会话模式  通常包含 Live broadcasts (直播)和 VOD (video on demand, 点播)两种  点播 VOD 的特点就是当前时间点可以获取到所有 index 文件和 ts 文件，二级 index 文件中记录了所有 ts 文件的地址。这种模式允许客户端访问全部内容目录。除非客户端进行比特率切换，否则无需再下载任何 index 文件，只需顺序下载 ts 文件并播放 Live 会话是实时生成 m3u8 和 ts 文件。它的索引文件一直处于动态变化，播放的时候需要不断下载二级 index 文件然后移除旧的索引文件，以获得最新生成的 ts 文件播放视频。如果一个二级 index 文件的末尾没有 #EXT-X-ENDLIST 标志，说明它是一个 Live 视频流 这种类型通过向索引文件添加媒体地址可以很容易的转化为 VOD 类型。在转化时不要移除原来旧的源，而是通过添加一个 #ET-X-ENDLIST 标记来终止实时事件 转化时如果索引文件中包含 EXT-X-PLAYLIST-TYPE 标签，需要将值从 EVENT 改为 VOD   内容加密  如果内容需要加密，可以在索引文件中找到密钥的相关信息。如果索引文件中包含了一个密钥文件的信息，那接下来的媒体文件就必须使用密钥解密后才能解密打开 当前的 HLS 支持使用 16-octet 类型密钥的 AES-128 加密。这个密钥格式是一个用二进制格式中的 16 个八进制组的数组打包而成 加密的配置模式通常包含三种  模式一：允许在磁盘上制定一个密钥文件路径，切片器会在索引文件中插入存在的密钥文件的 URL。所有的媒体文件都使用该密钥进行加密 模式二：切片器会生成一个随机密钥文件，将它保存在指定的路径，并在索引文件中引用它。所有的媒体文件都会使用这个随机密钥进行加密 模式三：每 n 个片段生成一个随机密钥文件，并保存到指定的位置，在索引中引用它。这个模式的密钥处于轮流加密状态。每一组 n 个片段文件会使用不同的密钥加密  理论上，不定期的碎片个数生成密钥会更安全，但是定期的生成密钥不会对系统的性能产生太大的影响 可以通过 HTTP 或者 HTTPS 提供密钥。也可以选择使用基于会话的认证安排去保护发送的 key 密钥文件需要一个 initialization vector (IV) 去解码加密的媒体文件。IV 可以随着密钥定期的改变  缓存和发送协议  HTTPS 通常用于发送密钥，同时也可以用于平时的媒体片段和索引文件的传输 当扩展性更重要时，这样做是不推荐的：HTTPS 请求通常都是绕开网络服务缓存，导致所有内容请求都是通过服务进行转发，这有悖于分布式网络连接系统的目的 当处于实况广播模式时索引文件不会像分片媒体文件一样长时间的被缓存，而是动态不停地变化  流切换  如果视频具备流切换功能，这对于用户来说是一个非常棒的体验，处于不同的带宽、不同的网速播放不同清晰度的视频流，这样智能的流切换可以保证用户感觉到非常流畅的观影体验，同时不同的设备也可以作为选择的条件，比如视网膜屏可以再网速良好的情况下播放清晰度更高的视频流 这种功能的实现在于，索引文件的特殊结构   具备流热切换的索引通常由主索引和链接不同带宽速率的资源的子索引，由子索引再链接对应得到 .ts 视频切片文件 客户端播放 HLS 视频流的逻辑：先下载一级 Index file，它里面记录了二级索引文件(Alternate-A、Alternate-B、Alternate-C)的地址，然后客户端再去下载二级索引文件，二级索引文件中又记录了 ts 文件的下载地址，这样客户端就可以按顺序下载 ts 视频文件并连续播放  主索引文件和子索引文件都是 .m3u8 的 playlist 主索引文件只需下载一次，但对于直播节目子索引文件定期重新加载 通常会先使用主索引中列出的第一个子索引，之后才会根据当时的网络情况去动态切换合适的流 客户端可能会在任何时候改变到备用流，所有的切换都应该使用相同的音频文件   ffmpeg 加密命令行  ffmpeg -i input.mp4 -c copy -bsf:v h264_mp4toannexb -hls_time 10 -hls_key_info_file key_info playlist.m3u8\n hls_time seconds: 设置目标分片的长度，单位秒。默认值是 2 hls_key_info_file key_info_file: 使用 key_info_file 信息用于加密 key_info_file 文件格式如下：一共三行\n key URI: 指定写入播放列表的 key URI。它在回放时用于访问加密密钥 key file path: 指定加密过程获得密钥的文件路径。该密钥文件以二进制格式读取，长度为 16 个八进制字符数组 IV: 可选行。指定初始向量(initialization vector, IV)作为十六进制的字符串使用，加密时默认使用分片序列号\nkey URI key file path IV (optional)   key_info_file 实例\nhttp://server/file.key /path/to/file.key 0123456789ABCDEF0123456789ABCDEF  #!/bin/sh BASE_URL=${1:-'.'} openssl rand 16 \u0026gt; file.key echo $BASE_URL/file.key \u0026gt; file.keyinfo echo file.key \u0026gt;\u0026gt; file.keyinfo echo $(openssl rand -hex 16) \u0026gt;\u0026gt; file.keyinfo ffmpeg -f lavfi -re -i testsrc -c:v h264 -hls_flags delete_segments -hls_key_info_file file.keyinfo out.m3u8    ffmpeg 源码解读  文件 libavformat/hls.c  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e737de08cbdd2c6982993e0e9abd3183","permalink":"https://xueqing.github.io/blog/hls/hls/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/hls/hls/","section":"blog","summary":"HLS 概述 一些概念 media playlist master playlist HLS 协议简介 输入视频或音频 服务器组件 文件切片器 媒体片段文件 索引文件(Playlists) 分布式组件 客户端软件 会话模式 内容","tags":["hls"],"title":"HLS 学习","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"/* Exercise: Images Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of image.Image instead of a slice of data. Define your own Image type, implement the necessary methods, and call pic.ShowImage. Bounds should return a image.Rectangle, like image.Rect(0, 0, w, h). ColorModel should return color.RGBAModel. At should return a color; the value v in the last picture generator corresponds to color.RGBA{v, v, 255, 255} in this one. */ package main import ( \u0026quot;image\u0026quot; \u0026quot;image/color\u0026quot; \u0026quot;math\u0026quot; \u0026quot;golang.org/x/tour/pic\u0026quot; ) /* type Image interface { // ColorModel returns the Image's color model. ColorModel() color.Model // Bounds returns the domain for which At can return non-zero color. // The bounds do not necessarily contain the point (0, 0). Bounds() Rectangle // At returns the color of the pixel at (x, y). // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid. // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one. At(x, y int) color.Color } */ type myImage struct{} func (img myImage) ColorModel() color.Model { return color.NRGBAModel } func (img myImage) Bounds() image.Rectangle { return image.Rect(0, 0, 100, 100) } func (img myImage) At(x, y int) color.Color { val := float64(x ^ y) v := uint8(math.Abs(val)) return color.RGBA{v, v, 255, 255} } func main() { m := myImage{} pic.ShowImage(m) }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0fbedeec9b95bf2620a9075e37cfc5db","permalink":"https://xueqing.github.io/translation/go-doc/gotour/images/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/images/","section":"translation","summary":"/* Exercise: Images Remember the picture generator you wrote earlier? Let's write another one, but this time it will return an implementation of image.Image instead of a slice of data. Define your own Image type, implement the necessary methods, and call pic.ShowImage. Bounds should return a image.Rectangle, like image.Rect(0, 0, w, h). ColorModel should return color.RGBAModel. At should return a color; the value v in the last picture generator corresponds to color.","tags":["go-tour"],"title":"Images","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  概述 索引  参考 Golang 官网文档 学习。\n导入语句：import \u0026quot;testing/iotest\u0026quot;\n概述 iotest 包实现了主要用于 testing 的 Reader 和 Writer。\n索引 参考\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e1de4b2b5be747d2165e5a3ff7ea2bf6","permalink":"https://xueqing.github.io/translation/go-doc/golangpkg/iotest/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangpkg/iotest/","section":"translation","summary":"概述 索引 参考 Golang 官网文档 学习。 导入语句：import \u0026quot;testing/iotest\u0026quot; 概述 iotest 包实现了主要用于 testing 的 Reader 和 Writer。 索引 参考","tags":["golang-pkg"],"title":"iotest 包","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  IPFS 的优点 IPNS（去中心化命名系统） IPFS HTTP 网关 IPFS vs SC（Sia coin） 不可靠（Unreliable） VS 可靠（Reliable） 总结\n IPFS(InterPlanetary File Syatem，星际文件系统)是一个面向全球的、点对点的分布式版本文件系统，目标是为了补充甚至取代目前通知互联网的 HTTP（超文本传输协议），将所有具有相同文件系统的计算机设备连接在一起\n 永久的、去中心化保存、共享文件 内容可寻址：通过文件内容生成唯一哈希值来标识文件。相同内容的文件在系统中只存在一份，节约存储空间 版本化：可追溯文件修改历史 点对点超媒体分布式： P2P 保存各种类型的数据  原理用基于内容的地址替代基于域名的地址，也就是用户寻找的不是某个地址而是存储在某个地方的内容，不需要验证发送者的身份，而只需要验证内容的哈希，这样可以让网页的速度更快、更安全、更健壮、更持久。\n HTTP 的问题：互联网的数据交互模式使用的是 B/S 和 C/S 模式，即客户-服务器、浏览器-服务器模式\n 鼓励高度集中化：PFS 将 web 去中心化，可以降低极少数强大组织的延展性，提高所有站点的自由度和独立性，同时降低了由于服务器中断造成数据丢失的风险 低效：HTTP 协议从一台服务器一次只能下载一个文件，IPFS 可代替总是从数据中心获取内容的 HTTP，减少数据传输的费用 过度依赖于 Internet 主干网：Internet 主干网并不健全，易被攻击，同时一些重要的光纤线路被切断时服务容易遭受影响 服务器成本昂贵： HTTP 需要大量的重心服务器保存数据 历史文件被删除：网页平均使用寿命为 100 天，大量网站文件不能长期保存。重要的文件也会因操作不当而在互联网消失 中心化的网络限制了发展：中心化的网络易被控制，限制了互联网的良性发展   IPFS 的优点  IPFS 用户搜索的是内容。通过浏览器搜索文件时，先找到服务器的位置（IP 地址），然后使用路径名称在服务器查找文件  只有文件所有者可以判断是否是用户要找的文件 必须保证托管这不会通过移除文件或者关闭服务器而对文件做任何更改  当文件被添加到 IPFS 节点，得到一个加密哈希名字，是从文件内容计算得到，通过加密保证哈希只表示文件内容，文件内容修改，哈希都会不一样 向 IPFS 分布式网络询问哈希时，通过使用一个分布式哈希表，可以快速找到拥有数据的节点，从而检索该数据，并使用哈希验证是否正确 IPFS 是通用的，存储限制少。服务的文件可大可小。大的文件会自动切割为小块，是节点可以从数百台服务器同步下载 IPFS 网络是细粒度、不可靠、分布式、易联合的内容分发网络（CDN，Content Delivery Network）  IPFS 是静态 web 网站 (不可靠和可靠的区别)  IPFS 文件可以是特殊的目录对象，允许用户使用人类可读的文件名，透明地链接到其他哈希  用户可以通过默认方式加载目录中的 index.html，这也是标准的 HTTP 服务器采用的方式 使用目录对象，IPFS 可允许用户采用完全相同的方式生成静态网站  IPFS 通过网络删除具有相同哈希值的文件，通过计算可以判断哪些文件是冗余重复的 每个网络节点只存储感兴趣的内容，以及一些索引信息，记录节点存储的内容 提供文件的历史版本控制器，且让多节点使用保存不同版本的文件 通过使用代币（FileCoin）的激励作用，让各节点有动力去存储数据。代币一个由加密货币驱动的存储网络。矿工通过为网络提供开放的硬盘空间获得代币，用户则用代币来支付在去中心化网卡中存储加密文件的费用  IPNS（去中心化命名系统）  使用 IPNS，每个文件可以被协作命名为易读的名字 IPNS 允许用户使用一个私钥来对 IPFS 哈希附加一个引用，使用一个公钥哈希（pubkeyhash）表示用户网站的最新版本 如果链接不起作用，可以通过更改 pubkeyhash 指向的内容更新网站  IPFS HTTP 网关 通过一个 HTTP 网关，IPFS 可以实现从 HTTP 到 IPFS 的过渡。浏览器可以在完全实现 IPFS 之前，允许当前的浏览器访问 IPFS\nIPFS vs SC（Sia coin）  SC 是一条去中心化存储的公链，通过代币购买存储空间，将文件备份在互联网的多个节点上，提高文件的安全性 IPFS 是一个底层的互联网协议，跟 HTTP 一样是交换信息。IPFS 实现的是互联网各个节点的文件读取、分享、交换  不可靠（Unreliable） VS 可靠（Reliable）  可靠的：运行在可靠的协议的终端会一起工作检查传输的数据，以确保正确性和数据完整性  一个可靠的系统会建立一个连接并且验证所有传输的数据被控制是有序的，按照正确的顺序被接收并且是完好无损的 可靠的协议对于丢失数据，易出错的物理介质工作比较好 差错校验，排序和验证机制需要数据包的多余负载，增加了传输数据的总带宽 TCP（Transmision Control Protocol）是典型的可靠协议，数据包平均增加 42-63 字节 对于一个 Telnet 连接，单独传送每个击键，这样是非常低效的，因为传输一个有用的字节信息需要传输 64 个字节的数据包  不可靠的  不可靠的协议不会建立连接，不检查数据是否被接收，也不会提供数据来恢复错误或丢失的数据 不可靠的协议对于较少丢失数据和不易出错的物理介质工作较好 UDP（User Datagram Protocol）是不可靠的协议，不会检查数据到达终端或者是完好无损的 相比 TCP，UDP 增加了很小的数据负载，因此在高质量的物理介质上传输更快   总结  IPFS 协议：定义了基于内容寻址的文件系统；协调内容分发；合并了 Kademlia + BitTorrent + Git IPFS 文件系统：有目录和文件；可挂载的文件系统（通过 FUSE） IPFS 网络：像网络一样查看文件  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2c0cee5bfabacd4fb287d20ce7cc57ae","permalink":"https://xueqing.github.io/blog/p2p/ipfs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/p2p/ipfs/","section":"blog","summary":"IPFS 的优点 IPNS（去中心化命名系统） IPFS HTTP 网关 IPFS vs SC（Sia coin） 不可靠（Unreliable） VS 可靠（Reliable） 总结 IPFS(InterPlanetary File Sya","tags":["p2p"],"title":"IPFS 入门","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 只有导出的结构体成员对外部程序 (json) 可见 2 结构体必须解析的字段(required 标签)  2.1 结构体标签 2.2 json 解析嵌套域 2.3 json 编码时会对指针解引用，使用的是实际值 2.4 encoding/json.Unmarshal 实现 required 标签 2.5 当 json 和 stream 相关时，使用 Encoder/Decoder 2.6 定义成 json.RawMessage 的域可以延迟解析 2.7 使用 interface 和 json.RawMessage 解析动态 json 2.7.1 实现 MarshalJson/UnmarshalJSON 接口 2.7.2 将 json 解析成 interface 2.7.3 使用指针增加代码检查 3 gin/binding.Bind  4 相关链接  1 只有导出的结构体成员对外部程序 (json) 可见  下面的代码中无法解析 gender 域。且编码成 json 时，gender 域不会包含\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; ) // JSONStruct a struct to be used in json decode type myJSONStruct struct { Name string Age float64 gender string } var rawJSON = []byte(`{ \u0026quot;name\u0026quot;: \u0026quot;kiki\u0026quot;, \u0026quot;age\u0026quot;: 18, \u0026quot;gender\u0026quot;: \u0026quot;female\u0026quot; }`) func main() { var s myJSONStruct err := json.Unmarshal(rawJSON, \u0026amp;s) if err != nil { panic(err) } // [Name=kiki] [Age=18.000000] [gender=] fmt.Printf(\u0026quot;[Name=%s] [Age=%f] [gender=%s]\\n\u0026quot;, s.Name, s.Age, s.gender) buf, err := json.Marshal(s) if err != nil { panic(err) } // [buf={\u0026quot;Name\u0026quot;:\u0026quot;kiki\u0026quot;,\u0026quot;Age\u0026quot;:18}] fmt.Printf(\u0026quot;[buf=%s]\\n\u0026quot;, buf) }   2 结构体必须解析的字段(required 标签) 2.1 结构体标签  解析 json 到结构体时，不适用结构体的字段会被抛弃。json.Unmarshal 找到结构体对应值的流程。比如给定 json 的 key 是 name  1 查找标签名字为 name 的字段 2 查找名字为 name 的字段 3 查找名字为 Name 等大小写不敏感的匹配字段 4 如果都没有找到，就直接忽略这个 key，不会报错。当从众多数据中只选择部分使用时非常方便。  json 的 encode/decode 不支持 required 标签。支持的标签包括\n FieldName 指定实际要查找的值 omitempty 值为空时不要包含到 JSON 中。当丢弃空属性不想包含在输出时很方便 - 跳过一些域。当查找到值时会被解析，但是不会被输出\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; ) // JSONStruct a struct to be used in json decode type myJSONStruct struct { Name string `json:\u0026quot;nickname\u0026quot;` Age float64 `json:\u0026quot;-\u0026quot;` Gender string `json:\u0026quot;,omitempty\u0026quot;` } var rawJSON = []byte(`{ \u0026quot;nickname\u0026quot;: \u0026quot;kiki\u0026quot;, \u0026quot;age\u0026quot;: 18, \u0026quot;gender\u0026quot;: \u0026quot;\u0026quot; }`) func main() { var s myJSONStruct err := json.Unmarshal(rawJSON, \u0026amp;s) if err != nil { panic(err) } // [NickName=kiki] [Age=0.000000] [gender=] fmt.Printf(\u0026quot;[NickName=%s] [Age=%f] [gender=%s]\\n\u0026quot;, s.Name, s.Age, s.Gender) buf, err := json.Marshal(s) if err != nil { panic(err) } // [buf={\u0026quot;nickname\u0026quot;:\u0026quot;kiki\u0026quot;}] fmt.Printf(\u0026quot;[buf=%s]\\n\u0026quot;, buf) }    2.2 json 解析嵌套域 package main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; ) type myName struct { FirstName string `json:\u0026quot;fname\u0026quot;` LastName string `json:\u0026quot;lname\u0026quot;` } // JSONStruct a struct to be used in json decode type myJSONStruct struct { myName Age float64 `json:\u0026quot;-\u0026quot;` Gender string `json:\u0026quot;,omitempty\u0026quot;` } var rawJSON = []byte(`{ \u0026quot;fname\u0026quot;: \u0026quot;kiki\u0026quot;, \u0026quot;lname\u0026quot;: \u0026quot;kity\u0026quot;, \u0026quot;age\u0026quot;: 18, \u0026quot;gender\u0026quot;: \u0026quot;\u0026quot; }`) func main() { var s myJSONStruct err := json.Unmarshal(rawJSON, \u0026amp;s) if err != nil { panic(err) } // [FirstName=kiki] [LastName=kity] [Age=0.000000] [gender=] fmt.Printf(\u0026quot;[FirstName=%s] [LastName=%s] [Age=%f] [gender=%s]\\n\u0026quot;, s.FirstName, s.LastName, s.Age, s.Gender) buf, err := json.Marshal(s) if err != nil { panic(err) } // [buf={\u0026quot;fname\u0026quot;:\u0026quot;kiki\u0026quot;,\u0026quot;lname\u0026quot;:\u0026quot;kity\u0026quot;}] fmt.Printf(\u0026quot;[buf=%s]\\n\u0026quot;, buf) }  2.3 json 编码时会对指针解引用，使用的是实际值 2.4 encoding/json.Unmarshal 实现 required 标签 2.5 当 json 和 stream 相关时，使用 Encoder/Decoder 2.6 定义成 json.RawMessage 的域可以延迟解析 2.7 使用 interface 和 json.RawMessage 解析动态 json 2.7.1 实现 MarshalJson/UnmarshalJSON 接口  JSON 模块包含两个接口 Marshaler 和 Unmarshaler。两个接口都需要一个方法\n// Marshaler 接口定义了怎么把某个类型 encode 成 JSON 数据 type Marshaler interface { MarshalJSON() ([]byte, error) } // Unmarshaler 接口定义了怎么把 JSON 数据 decode 成特定的类型数据。如果后续还要使用 JSON 数据，必须把数据拷贝一份 type Unmarshaler interface { UnmarshalJSON([]byte) error }   如果将这两个接口增加到自定义类型，就可以被编码成 JSON 或者把 JSON 解析成自定义类型 一个很好的例子就是 time.Time 类型\ntype Month struct { MonthNumber int YearNumber int } func (m Month) MarshalJSON() ([]byte, error){ return []byte(fmt.Sprintf(\u0026quot;%d/%d\u0026quot;, m.MonthNumber, m.YearNumber)), nil } func (m *Month) UnmarshalJSON(value []byte) error { parts := strings.Split(string(value), \u0026quot;/\u0026quot;) m.MonthNumber = strconv.ParseInt(parts[0], 10, 32) m.YearNumber = strconv.ParseInt(parts[1], 10, 32) return nil }    2.7.2 将 json 解析成 interface  interface{} 在 Go 中意味着可以是任何东西，Go 在运行时会分配的合适的内存来存储\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; ) type myName struct { FirstName string `json:\u0026quot;fname\u0026quot;` LastName string `json:\u0026quot;lname\u0026quot;` } // JSONStruct a struct to be used in json decode type myJSONStruct struct { myName Age float64 `json:\u0026quot;-\u0026quot;` Gender string `json:\u0026quot;,omitempty\u0026quot;` } var rawJSON = []byte(`{ \u0026quot;fname\u0026quot;: \u0026quot;kiki\u0026quot;, \u0026quot;lname\u0026quot;: \u0026quot;kity\u0026quot;, \u0026quot;age\u0026quot;: 18 }`) func main() { var s map[string]interface{} err := json.Unmarshal(rawJSON, \u0026amp;s) if err != nil { panic(err) } fmt.Printf(\u0026quot;[map=%v]\u0026quot;, s) if s[\u0026quot;gender\u0026quot;] == nil { panic(\u0026quot;Gender is nil\u0026quot;) } }   2.7.3 使用指针增加代码检查  结构体字段使用指针，解析之后判断是否为 nil\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; ) // JSONStruct a struct to be used in json decode type JSONStruct struct { Name *string Age *float64 } var rawJSON = []byte(`{ \u0026quot;name\u0026quot;: \u0026quot;We do not provide a Age\u0026quot; }`) func main() { var s *JSONStruct err := json.Unmarshal(rawJSON, \u0026amp;s) if err != nil { panic(err) } if s.Name == nil { panic(\u0026quot;Name is missing or null!\u0026quot;) } if s.Age == nil { panic(\u0026quot;Age is missing or null!\u0026quot;) } fmt.Printf(\u0026quot;Name: %s Age: %f\\n\u0026quot;, *s.Name, *s.Age) }   3 gin/binding.Bind  使用 binding:\u0026quot;required\u0026quot; 指定某个域是必须的。当 binding 时该字段为空会返回错误\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;time\u0026quot; \u0026quot;net/http\u0026quot; \u0026quot;github.com/gin-gonic/gin\u0026quot; ) type myJSONStruct struct { Name string Age int `binding:\u0026quot;required\u0026quot;` } func addUser(c *gin.Context) { var response interface{} data := new(myJSONStruct) if err := c.Bind(data); err != nil { // [err=Key: 'myJSONStruct.Age' Error:Field validation for 'Age' failed on the 'required' tag] fmt.Printf(\u0026quot;addUser error [Bind error] [err=%s]\\n\u0026quot;, err) c.JSON(http.StatusBadRequest, response) return } fmt.Printf(\u0026quot;addUser success [data=%v]\\n\u0026quot;, data) c.JSON(http.StatusOK, response) } func main() { router := gin.New() api := router.Group(\u0026quot;/api/adduser\u0026quot;) api.POST(\u0026quot;\u0026quot;, addUser) httpServer := \u0026amp;http.Server{ Addr: \u0026quot;0.0.0.0:10300\u0026quot;, Handler: router, ReadHeaderTimeout: 5 * time.Second, } httpServer.ListenAndServe() }   4 相关链接  Go JSON encoding/json 增加 required 标签被拒绝 使用 json.Unmarshal 实现 required 标签 Go 的动态 JSON gin binding  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ea4c1dd33d2c0317b35adcb93646e5a7","permalink":"https://xueqing.github.io/blog/go/traps/json_struct/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/traps/json_struct/","section":"blog","summary":"1 只有导出的结构体成员对外部程序 (json) 可见 2 结构体必须解析的字段(required 标签) 2.1 结构体标签 2.2 json 解析嵌套域 2.3 json 编码时会对指针解引用，使用","tags":["go"],"title":"json 解析时用到的结构体标签","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 邮箱传书 通过下面的步骤将 mobi/pdf 等格式的书转化为 kindle 的格式 azw3\n 发送邮箱注册 Kindle注册 亚马逊添加信任发送邮箱 发送邮件并改主体为 Convert 在亚马逊云端选择 Kindle 进行推送  磁盘传书 下面的步骤为快速通道，不经过云端，即资料不会出现在云端 5G 里面，不方便误删之后的二度下载，慎用\n USB 连入 PC 读取 kindle 对应磁盘 双击进入 kindle 双击进入 Documents 粘贴要看的书籍 关闭窗口，弹出 USB，结束  公众号传书 参考  如何用好 kindle  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"687f9f994eabac112068a57509c7a134","permalink":"https://xueqing.github.io/blog/kindle/kindle/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/kindle/kindle/","section":"blog","summary":"邮箱传书 通过下面的步骤将 mobi/pdf 等格式的书转化为 kindle 的格式 azw3 发送邮箱注册 Kindle注册 亚马逊添加信任发送邮箱 发送邮件并改主体为 Convert 在亚马逊云端选择 Kindle","tags":["kindle"],"title":"kindle 使用技能","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  问题 解决方法 返回类型 \u0026ldquo;捕获\u0026rdquo;变量 使用 lambda 作为变量 参考  问题  C++ 包含一些有用的通用函数，比如 std::for_each 和 std::transform，用起来很方便。但是使用比较复杂，尤其是使用的仿函数(functor)是唯一的。\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; namespace { struct f { void operator()(int i) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl; } }; } void func(std::vector\u0026lt;int\u0026gt;\u0026amp; v) { f f; std::for_each(v.begin(), v.end(), f); } int main() { int arr[] = {1,10,9}; std::vector\u0026lt;int\u0026gt; v(arr,arr+3); func(v); return 0; }  如果只使用上述 f 一次，看起来写一个完整的类来完成一些微小的事情是过犹不及的。\n  解决方法  C++11 介绍了 lambda，支持写一个内联、匿名仿函数来替换 struct f。对于简单的例子代码会更易读，且易于维护 形式定义 []() {}\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; void func(std::vector\u0026lt;int\u0026gt;\u0026amp; v) { std::for_each(v.begin(), v.end(), [](int i) {std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; std::endl;}); } int main() { int arr[] = {1,10,9}; std::vector\u0026lt;int\u0026gt; v(arr,arr+3); func(v); return 0; }   返回类型  简单的例子中，lambda 的返回类型是编译器推断出来的\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; void func(std::vector\u0026lt;double\u0026gt; \u0026amp;v) { std::transform(v.begin(), v.end(), v.begin(), [](double d) {return d \u0026lt; 0.00001 ? 0 : d;} ); std::for_each(v.begin(), v.end(), [](double d) {std::cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl;}); } int main() { double arr[] = {0.000001,1.0,0.000009}; std::vector\u0026lt;double\u0026gt; v(arr,arr+3); func(v); return 0; }  但是当实现更加复杂的 lambda 时，会遇到一些情况，编译器不能推断返回类型。此时可以显式地指明lambda 函数的返回值，使用 -\u0026gt; T\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; void func(std::vector\u0026lt;double\u0026gt; \u0026amp;v) { std::transform(v.begin(), v.end(), v.begin(), [](double d) -\u0026gt; double { if(d \u0026lt; 0.00001) return 0; else return d; } ); std::for_each(v.begin(), v.end(), [](double d) {std::cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl;}); } int main() { double arr[] = {0.000001,1.0,0.000009}; std::vector\u0026lt;double\u0026gt; v(arr,arr+3); func(v); return 0; }   \u0026ldquo;捕获\u0026rdquo;变量  也可以使用 lambda 内部的变量。如果想要是有其他变量可以使用捕获语句 []\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; void func(std::vector\u0026lt;double\u0026gt; \u0026amp;v, const double \u0026amp;val) { std::transform(v.begin(), v.end(), v.begin(), [val](double d) -\u0026gt; double { if(d \u0026lt; val) return 0; else return d; } ); std::for_each(v.begin(), v.end(), [](double d) {std::cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; std::endl;}); } int main() { double arr[] = {0.000001,1.0,0.000009}; std::vector\u0026lt;double\u0026gt; v(arr,arr+3); double val = 0.000005; func(v, val); return 0; }  可以捕获引用和值，分别使用 \u0026amp; 和 =\n [\u0026amp;val] 捕获引用 [\u0026amp;] 捕获当前范围使用的所有变量的引用 [=] 捕获当前范围使用的所有变量的值 [\u0026amp;, val] 类似于 [\u0026amp;]，但是 val 捕获值 [=, \u0026amp;val] 类似于 [=]，但是 val 捕获引用  生成的操作符 () 默认是 const，捕获默认也是 const，使得每次相同的输入产生相同的结果\n 使用 []() mutable -\u0026gt; T {}，允许改变以值捕获的值   使用 lambda 作为变量  可以使用 functional 头文件  std::function\u0026lt;double(int, bool)\u0026gt; f = [](int a, bool b) -\u0026gt; double {//...} 通常可让编译器推断类型 auto f = [](int a, bool b) -\u0026gt; double {//...}   参考  What is a lambda expression in C++11?  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"eabf3c57f51f6ed7f98f215016b1aedf","permalink":"https://xueqing.github.io/blog/cplusplus/lambda/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/lambda/","section":"blog","summary":"问题 解决方法 返回类型 \u0026ldquo;捕获\u0026rdquo;变量 使用 lambda 作为变量 参考 问题 C++ 包含一些有用的通用函数，比如 std::for_each 和 std::transform","tags":["c++"],"title":"lambda 表达式","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  ldconfig  ldconfig 与 /etc/ld.so.conf 添加动态库路径 ldd   ldconfig 与 /etc/ld.so.conf  ldconfig 默认查找的路径包括 lib, /usr/lib, /etc/ld.so.conf 列举的目录和 LD_LIBRARY_PATH 如何将动态函数库加载到高速缓存  在 /etc/ld.so.conf 写入想要读入告诉缓存中的动态函数库所在的目录 利用 ldconfig 可执行文件将 /etc/ld.so.conf 的数据读入缓存 同时将数据记录一份在 /etc/ld.so.cache 文件   添加动态库路径  查找库路径 sudo find / -iname *library_name*.so* 方法 1  追加路径到 LD_LIBRARY_PATH 当前终端生效: 在终端执行 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/library 在 ~/.bashrc 或 ~/.bash_profile 中追加 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/library 执行 source ~/.bashrc 或 source ~/.bash_profile 执行 sudo ldconfig 更新缓存  方法 2  在 /etc/ld.so.conf.d/ 中创建一个新文件 your_lib.conf 在 /etc/ld.so.conf.d/your_lib.conf 中写入想要添加的路径 执行 sudo ldconfig 更新缓存  方法 3  将库移动到 /usr/lib 执行 sudo ldconfig 更新缓存   ldd  ldd filename 可以显示可执行文件 filename 所依赖的动态函数库  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c2552b1549ae4a23f469eec23e8a6e0e","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_ldconfig/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_ldconfig/","section":"blog","summary":"ldconfig ldconfig 与 /etc/ld.so.conf 添加动态库路径 ldd ldconfig 与 /etc/ld.so.conf ldconfig 默认查找的路径包括 lib, /usr/lib, /etc/ld.so.conf 列举的目录和 LD_LIBRARY_PATH 如何将动态函数库加载到高速缓存 在 /etc/ld.so.conf 写入想要读入告诉缓存中的动态函数库所","tags":["ubuntu","linux"],"title":"ldconfig","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" room: 一个 room 的 user 和 client 可以通过 Licode 共享 stream Server APP 通过 Nuve API 创建 room，user 通过 Erizo 连接到 room 通过 Erizo Controller 控制 rooms，通过 Erizo API 控制 stream     Client 的类 描述 类型     Erizo.Stream/Licode Event 表示库中一般的事件，被其他类继承 room-connected 等   Erizo.Room/Room Event 表示和 room 连接相关的事件 room-connected/room-error/room-disconnected   Erizo.Events/Stream Event 表示一个 room 内的 stream 相关的事件 access-accepted/access-denied/stream-added/stream-removed/stream-data/stream-attributes/update/bandwidth-alert/stream-failed/stream-ended       Server 的类 描述     Room 表示一个视频会议 room   Token 添加一个新的参与者到一个视频会议 room 的 key   User 一个 user 可以发布和订阅一个视频会议 room 的 stream    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c879827bbd16b8a0f6df3ecda6730174","permalink":"https://xueqing.github.io/blog/webrtc/licode/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/webrtc/licode/","section":"blog","summary":"room: 一个 room 的 user 和 client 可以通过 Licode 共享 stream Server APP 通过 Nuve API 创建 room，user 通过 Erizo 连接到 room 通过 Erizo Controller 控制 rooms，通过 Erizo API 控制 stream Client 的类 描述 类型 Erizo.Stream/Licode Event 表示","tags":["webrtc","licode"],"title":"licode","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  linux 下其他命令  其他 文件格式 ftp 压缩命令 tar   其他  添加可执行权限chmod a+x filename 修改本机 IP 地址ifconfig eth0 192.168.1.110 列举目录ls -lt按时间顺序显示 查看所有用户cat /etc/passwd 查看所有用户组cat /etc/group 添加用户到已存在的组：  sudo adduser user-name user-group sudo gpasswd -a user-name group-name  从用户组删除删除：sudo gpasswd -d user-name user-group` 安装 deb 文件缺少依赖库时继续执行sudo apt-get install -f即可自动安装依赖库并安装 deb 包 查看指定监听端口的服务lsof -i :3000  文件格式  /bin/sh^M: bad interpreter: No such file or directory脚本异常，转换为 UNIX 格式  windows：UE 或 EditPlus 转换编码为UNIX Linux： 可执行权限chmod a+x filename 改文件格式vi filename  查看文件格式 :set ff或:set fileformat Fileformat=dos或fileformat=unix 修改文件格式:set ff=unix或:set fieformat=unix 保存退出:wq  执行文件./filename   ftp  连接ftp ServerIP，输入用户名和密码 切换 ftp 所在目录cd DestDir 切换本地目录lcd DestDir 上传文件put FileName 下载文件mget FileName 退出exit  压缩命令 tar  查看压缩文件tar -tvf filename  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1e7f69436f43c83ca4870967e8a58979","permalink":"https://xueqing.github.io/blog/ubuntu/linux_other_cmd/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/linux_other_cmd/","section":"blog","summary":"linux 下其他命令 其他 文件格式 ftp 压缩命令 tar 其他 添加可执行权限chmod a+x filename 修改本机 IP 地址ifconfig eth0 192.168.1.110 列举目录ls -lt按时间顺序显示 查看所","tags":["ubuntu","linux"],"title":"linux 下其他命令","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":" 原文\n 概述 示例  EXTM3U EXT-X-PLAYLIST-TYPE EXT-X-TARGETDURATION EXT-X-VERSION EXT-X-MEDIA-SEQUENCE EXTINF  更新 playlist 文件  概述 在直播会话中，当生成新的媒体文件且可访问时，通过从文件中移除媒体 URL 来更新索引文件。EXT-X-ENDLIST 标记不会在 live playlist 中出现，表示当新的媒体文件可访问时会被追加到索引文件。\n示例 下面的代码是一个第一个出现在直播会话中的 live playlist 的示例：\n#EXTM3U #EXT-X-TARGETDURATION:10 #EXT-X-VERSION:4 #EXT-X-MEDIA-SEQUENCE:1 #EXTINF:10.0, fileSequence1.ts #EXTINF:10.0, fileSequence2.ts #EXTINF:10.0, fileSequence3.ts #EXTINF:10.0, fileSequence4.ts #EXTINF:10.0, fileSequence5.ts  live playlist 示例中使用的标记有：\nEXTM3U 表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。\nEXT-X-PLAYLIST-TYPE 提供了适用于整个 playlist 文件的易变信息。这个标记可能包含一个 EVENT 或 VOD 值。如果标记存在且值为 EVENT，服务器一定不能修改或删除 playlist 文件的任意部分(但是它可以追加行到 playlist 文件)。如果标记存在且值为 VOD，playlist 文件一定不能改变。\nEXT-X-TARGETDURATION 指定最大的媒体文件时长。\nEXT-X-VERSION 表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。\nEXT-X-MEDIA-SEQUENCE 表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。\n注意：对于每个从 playlist 文件移除的 URL，EXT-X-MEDIA-SEQUENCE 标记值必须加 1。媒体 URL 必须按照出现在 playlist 中的顺序移除。更新的索引文件展示了移动窗口为一个持续流。这种会话类型适用于持续的广播。\nEXTINF 一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。\n注意：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。\n更新 playlist 文件 下面的示例展示了使用新的媒体 URL 更新的同一 playlist：\n#EXTM3U #EXT-X-TARGETDURATION:10 #EXT-X-VERSION:4 #EXT-X-MEDIA-SEQUENCE:2 #EXTINF:10.0, fileSequence2.ts #EXTINF:10.0, fileSequence3.ts #EXTINF:10.00, fileSequence4.ts #EXTINF:10.00, fileSequence5.ts #EXTINF:10.0, fileSequence6.ts  当增加新的媒体 URL 时继续更新 playlist：\n#EXTM3U #EXT-X-TARGETDURATION:10 #EXT-X-VERSION:4 #EXT-X-MEDIA-SEQUENCE:4 #EXTINF:10.00, fileSequence4.ts #EXTINF:10.00, fileSequence5.ts #EXTINF:10.0, fileSequence6.ts, #EXTINF:10.0, fileSequence7.ts, #EXTINF:10.0, fileSequence8.ts, #EXTINF:10.0, fileSequence9.ts  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"01ce1dafe61f8c6bb59d453559898f41","permalink":"https://xueqing.github.io/translation/hls/live_playlist_sliding_window_construction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/hls/live_playlist_sliding_window_construction/","section":"translation","summary":"原文 概述 示例 EXTM3U EXT-X-PLAYLIST-TYPE EXT-X-TARGETDURATION EXT-X-VERSION EXT-X-MEDIA-SEQUENCE EXTINF 更新 playlist 文件 概述 在直播会话中，当生成新的媒体文件且可访问时，通过从文件中移除媒体 URL 来更新索引文件。EXT-X-ENDL","tags":["hls"],"title":"live playlist (滑动窗口)构造","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" 配置文件举例  默认位置是 /usr/local/logstash/config/logstash-sample.conf  匹配需求描述  先需要统计后台服务的日志, 主要有下面 4 类     日志类型 格式 举例     服务器日志 [localtime][log_level][module_name] {event_info} [2019-07-25 09:26:57.315][debug ][EasyRedis] {Connect Redis success}   设备认证日志 [localtime][log_level][module_name][dev_name][dev_id][dev_ip] {event_info} [2019-07-25 09:26:07.317][warn ][GbsipServerService][cam1][34020000001320000001][192.168.10.199] {ON}   用户认证日志 [localtime][log_level][module_name][user_id][user_ip] {event_info} [2019-07-25 09:26:14.049][warn ][GbsipClientService][34020000001110000001][192.168.1.160] {online}   用户操作日志 [localtime][log_level][module_name][user_id][user_ip][dev_id] {event_info} [2019-07-25 09:38:31.630][trace ][GbsipClientService][34020000001110000001][192.168.1.160][34020000001320000001] {Bye}     现在的需求包括  1 过滤掉不符合上述 4 类格式的日志 2 可以一键搜索上述 4 种日志, 即查看所有满足要求的日志 3 可以一键搜索上述任意一种日志  实现方法  统一日志格式 [type][localtime][log_level][module_name][user_id][user_ip][dev_name][dev_id][dev_ip] {event_info} 缺少的字段为空 filter 的正则匹配表达式为 \\[%{DATA:localtime}\\]\\[%{DATA:log_level}\\]\\[%{DATA:module_name}\\]\\[%{NUMBER:type}\\]\\[%{DATA:user_id}\\]\\[%{DATA:user_ip}\\]\\[%{DATA:dev_name}\\]\\[%{DATA:dev_id}\\]\\[%{DATA:dev_ip}\\]\\ \\{%{DATA:event_info}\\}, 可用于分割日志  统一后日志举例\n[2019-07-25 09:26:57.315][debug ][EasyRedis][1][][][][][] {Connect Redis success} [2019-07-25 09:26:07.317][warn ][GbsipServerService][2][][][cam1][34020000001320000001][192.168.10.199] {ON} [2019-07-25 09:26:14.049][warn ][GbsipClientService][3][34020000001110000001][192.168.1.160][][][] {online} [2019-07-25 09:38:31.630][trace ][GbsipClientService][4][34020000001110000001][192.168.1.160][][34020000001320000001][] {Bye}   日志收集架构  filebeat  轻量级日志收集工具, 用于搜集文件数据, 比 logstash 占用资源更少 在 filebeat.yml 中会配置指定的监听文件  logstash  用于日志收集, 具有 filter 功能, 可以过滤分析日志, 然后发送到消息队列  kibana  供前端的页面再进行搜索和图表可视化, 调用Elasticsearch的接口返回的数据进行可视化 用 Kibana 来搜索、查看, 并和存储在 ElasticSearch 索引中的数据进行交互  ElasticSearch  搜索服务器, 提供了一个分布式多用户能力的全文搜索引擎, 基于 RESTful web 接口   完整配置文件 # Sample Logstash configuration for creating a simple # Beats -\u0026gt; Logstash -\u0026gt; Elasticsearch pipeline. input { # 从日志文件中获取信息, 使用 filebeat 推送日志到 logstash beats { port =\u0026gt; 5044 } } filter { # 如果搜索不到 \u0026quot;] {\u0026quot; 关键字, 丢弃该消息 # 其他日志内容均保证不含 \u0026quot;] {\u0026quot; 关键字 if \u0026quot;] {\u0026quot; not in [message] { # drop 可以跳过某些不想统计的日志信息, 当某条日志信息符合 if 规则时 # 该条信息则不会在 out 中出现, logstash 将直接进行下一条日志的解析 drop { } } else { grok { # 自定义正则匹配 match =\u0026gt; {\u0026quot;message\u0026quot; =\u0026gt; \u0026quot;\\[%{DATA:localtime}\\]\\[%{DATA:log_level}\\]%{DATA:c1}\\[%{DATA:c2}\\[%{DATA:module_name}\\]\\[%{NUMBER:type}\\]\\[%{DATA:user_id}\\]\\[%{DATA:user_ip}\\]\\[%{DATA:dev_name}\\]\\[%{DATA:dev_id}\\]\\[%{DATA:dev_ip}\\]\\ \\{%{DATA:event_info}\\}\u0026quot;} } # 匹配服务器日志成功 if \u0026quot;[1]\u0026quot; in [message] { # mutate 是做转换用的 mutate { # 添加字段 _log_info_, 便于搜索所有日志 add_field =\u0026gt; { \u0026quot;_log_info_\u0026quot; =\u0026gt; \u0026quot;%{event_info}\u0026quot; } # 添加字段 _serv_log_, 便于搜索服务器日志 add_field =\u0026gt; { \u0026quot;_serv_log_\u0026quot; =\u0026gt; \u0026quot;%{event_info}\u0026quot; } } } # 匹配设备认证日志成功 if \u0026quot;[2]\u0026quot; in [message] { mutate { add_field =\u0026gt; { \u0026quot;_log_info_\u0026quot; =\u0026gt; \u0026quot;[%{dev_name}] [%{dev_id}] [%{dev_ip}] %{event_info}\u0026quot; } # 添加字段 _dev_log_, 便于搜索服务器日志 add_field =\u0026gt; { \u0026quot;_dev_log_\u0026quot; =\u0026gt; \u0026quot;[%{dev_name}] [%{dev_id}] [%{dev_ip}] %{event_info}\u0026quot; } } } # 匹配用户认证日志成功 if \u0026quot;[3]\u0026quot; in [message] { mutate { add_field =\u0026gt; { \u0026quot;_log_info_\u0026quot; =\u0026gt; \u0026quot;[%{user_id}] [%{user_ip}] %{event_info}\u0026quot; } # 添加字段 _user_log_, 便于搜索服务器日志 add_field =\u0026gt; { \u0026quot;_user_log_\u0026quot; =\u0026gt; \u0026quot;[%{user_id}] [%{user_ip}] %{event_info}\u0026quot; } } } # 匹配用户操作日志成功 if \u0026quot;[4]\u0026quot; in [message] { mutate { add_field =\u0026gt; { \u0026quot;_log_info_\u0026quot; =\u0026gt; \u0026quot;[%{user_id}] [%{user_ip}] [%{dev_id}] %{event_info}\u0026quot; } # 添加字段 _user_dev_log_, 便于搜索服务器日志 add_field =\u0026gt; { \u0026quot;_user_dev_log_\u0026quot; =\u0026gt; \u0026quot;[%{user_id}] [%{user_ip}] [%{dev_id}] %{event_info}\u0026quot; } } } } } output { # 将输出保存到 elasticsearch elasticsearch { hosts =\u0026gt; [\u0026quot;http://192.168.1.240:9200\u0026quot;] index =\u0026gt; \u0026quot;%{[@metadata][beat]}-%{[@metadata][version]}-%{+YYYY.MM.dd}\u0026quot; } }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"59a6801b47339ab2570a37386b71e500","permalink":"https://xueqing.github.io/blog/others/logstash/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/others/logstash/","section":"blog","summary":"配置文件举例 默认位置是 /usr/local/logstash/config/logstash-sample.conf 匹配需求描述 先需要统计后台服务的日志, 主要有下面 4 类 日志类型 格式 举例 服务器日志 [localtime][log_level][module_name] {event_info} [2019-07-25 09:26:57.315][debug ][EasyRedis] {Connect Redis success} 设备认证日志 [localtime][log_level][module_name][dev_name][dev_id][dev_ip] {event_info} [2019-07-25 09:26:07.317][warn ][GbsipServerService][cam1][34020000001320000001][192.168.10.199]","tags":["logstash"],"title":"logstash 配置文件学习","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"```go /* Exercise: Loops and Functions As a way to play with functions and loops, let\u0026rsquo;s implement a square root function: given a number x, we want to find the number z for which z² is most nearly x.\nComputers typically compute the square root of x using a loop. Starting with some guess z, we can adjust z based on how close z² is to x, producing a better guess:\nz -= (z*z - x) / (2*z) Repeating this adjustment makes the guess better and better until we reach an answer that is as close to the actual square root as can be.\nImplement this in the func Sqrt provided. A decent starting guess for z is 1, no matter what the input. To begin with, repeat the calculation 10 times and print each z along the way. See how close you get to the answer for various values of x (1, 2, 3, \u0026hellip;) and how quickly the guess improves.\nHint: To declare and initialize a floating point value, give it floating point syntax or use a conversion:\nz := 1.0 z := float64(1) Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small amount). See if that\u0026rsquo;s more or fewer than 10 iterations. Try other initial guesses for z, like x, or x/2. How close are your function\u0026rsquo;s results to the math.Sqrt in the standard library?\n(Note: If you are interested in the details of the algorithm, the z² − x above is how far away z² is from where it needs to be (x), and the division by 2z is the derivative of z², to scale how much we adjust z by how quickly z² is changing. This general approach is called Newton\u0026rsquo;s method. It works well for many functions but especially well for square root.) */\npackage main\nimport ( \u0026ldquo;fmt\u0026rdquo; \u0026ldquo;math\u0026rdquo; )\nfunc mySqrt(x float64) float64 { // z := x / 2 z := x tmp := 0.0 for math.Abs(z-tmp) \u0026gt;= 0.000000000001 { tmp = z z -= (z*z - x) / (2 * z) fmt.Println(z) } return z }\nfunc main() { fmt.Println(mySqrt(2)) fmt.Println(math.Sqrt(2)) }\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0f1e68fdc4f4002282f28d6379fda910","permalink":"https://xueqing.github.io/translation/go-doc/gotour/loops_and_functions/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/loops_and_functions/","section":"translation","summary":"```go /* Exercise: Loops and Functions As a way to play with functions and loops, let\u0026rsquo;s implement a square root function: given a number x, we want to find the number z for which z² is most nearly x.\nComputers typically compute the square root of x using a loop. Starting with some guess z, we can adjust z based on how close z² is to x, producing a better guess:","tags":["go-tour"],"title":"Loops and Functions","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"```go /* Exercise: Maps Implement WordCount. It should return a map of the counts of each “word” in the string s. The wc.Test function runs a test suite against the provided function and prints success or failure.\nYou might find strings.Fields helpful. */\npackage main\nimport ( \u0026ldquo;strings\u0026rdquo;\n\u0026quot;golang.org/x/tour/wc\u0026quot;  )\nfunc wordCount(s string) map[string]int { m := make(map[string]int) var ss []string ss = strings.Fields(s) for i := 0; i \u0026lt; len(ss); i++ { m[ss[i]]++ }\nreturn m  }\nfunc main() { wc.Test(wordCount) }\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"df7f056b21e2097422b7591ec7fb9aaf","permalink":"https://xueqing.github.io/translation/go-doc/gotour/maps/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/maps/","section":"translation","summary":"```go /* Exercise: Maps Implement WordCount. It should return a map of the counts of each “word” in the string s. The wc.Test function runs a test suite against the provided function and prints success or failure.\nYou might find strings.Fields helpful. */\npackage main\nimport ( \u0026ldquo;strings\u0026rdquo;\n\u0026quot;golang.org/x/tour/wc\u0026quot;  )\nfunc wordCount(s string) map[string]int { m := make(map[string]int) var ss []string ss = strings.Fields(s) for i := 0; i \u0026lt; len(ss); i++ { m[ss[i]]++ }","tags":["go-tour"],"title":"Maps","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  MD001 - Heading levels should only increment by one level at a time MD002 - First heading should be a top level heading MD003 - Heading style MD004 - Unordered list style MD005 - Inconsistent indentation for list items at the same level MD006 - Consider starting bulleted lists at the beginning of the line MD007 - Unordered list indentation MD009 - Trailing spaces MD010 - Hard tabs MD011 - Reversed link syntax MD012 - Multiple consecutive blank lines MD013 - Line length MD014 - Dollar signs used before commands without showing output MD018 - No space after hash on atx style heading MD019 - Multiple spaces after hash on atx style heading MD020 - No space inside hashes on closed atx style heading MD021 - Multiple spaces inside hashes on closed atx style heading MD022 - Headings should be surrounded by blank lines MD023 - Headings must start at the beginning of the line MD024 - Multiple headings with the same content MD025 - Multiple top level headings in the same document MD026 - Trailing punctuation in heading MD027 - Multiple spaces after blockquote symbol MD028 - Blank line inside blockquote MD029 - Ordered list item prefix MD030 - Spaces after list markers MD031 - Fenced code blocks should be surrounded by blank lines MD032 - Lists should be surrounded by blank lines MD033 - Inline HTML MD034 - Bare URL used MD035 - Horizontal rule style MD036 - Emphasis used instead of a heading MD037 - Spaces inside emphasis markers MD038 - Spaces inside code span elements MD039 - Spaces inside link text MD040 - Fenced code blocks should have a language specified MD041 - First line in file should be a top level heading MD042 - No empty links MD043 - Required heading structure MD044 - Proper names should have the correct capitalization MD045 - Images should have alternate text (alt text)  This document contains a description of all rules, what they are checking for, as well as an examples of documents that break the rule and corrected versions of the examples.\nMD001 - Heading levels should only increment by one level at a time Tags: headings, headers\nAliases: heading-increment, header-increment\nThis rule is triggered when you skip heading levels in a markdown document, for example:\n# Heading 1 ### Heading 3 We skipped out a 2nd level heading in this document  When using multiple heading levels, nested headings should increase by only one level at a time:\n# Heading 1 ## Heading 2 ### Heading 3 #### Heading 4 ## Another Heading 2 ### Another Heading 3  MD002 - First heading should be a top level heading Tags: headings, headers\nAliases: first-heading-h1, first-header-h1\nParameters: level (number; default 1)\n Note: MD002 has been deprecated and is disabled by default. MD041/first-line-heading offers an improved implementation.\n This rule is intended to ensure document headings start at the top level and is triggered when the first heading in the document isn\u0026rsquo;t an h1 heading:\n## This isn't an H1 heading ### Another heading  The first heading in the document should be an h1 heading:\n# Start with an H1 heading ## Then use an H2 for subsections  Note: The level parameter can be used to change the top level (ex: to h2) in cases where an h1 is added externally.\nMD003 - Heading style Tags: headings, headers\nAliases: heading-style, header-style\nParameters: style (\u0026ldquo;consistent\u0026rdquo;, \u0026ldquo;atx\u0026rdquo;, \u0026ldquo;atx_closed\u0026rdquo;, \u0026ldquo;setext\u0026rdquo;, \u0026ldquo;setext_with_atx\u0026rdquo;, \u0026ldquo;setext_with_atx_closed\u0026rdquo;; default \u0026ldquo;consistent\u0026rdquo;)\nThis rule is triggered when different heading styles (atx, setext, and \u0026lsquo;closed\u0026rsquo; atx) are used in the same document:\n# ATX style H1 ## Closed ATX style H2 ## Setext style H1 ===============  Be consistent with the style of heading used in a document:\n# ATX style H1 ## ATX style H2  The setext_with_atx and setext_with_atx_closed doc styles allow atx-style headings of level 3 or more in documents with setext style headings:\nSetext style H1 =============== Setext style H2 --------------- ### ATX style H3  Note: the configured heading style can be a specific style to use (atx, atx_closed, setext, setext_with_atx, setext_with_atx_closed), or simply require that the usage be consistent within the document.\nMD004 - Unordered list style Tags: bullet, ul\nAliases: ul-style\nParameters: style (\u0026ldquo;consistent\u0026rdquo;, \u0026ldquo;asterisk\u0026rdquo;, \u0026ldquo;plus\u0026rdquo;, \u0026ldquo;dash\u0026rdquo;, \u0026ldquo;sublist\u0026rdquo;; default \u0026ldquo;consistent\u0026rdquo;)\nThis rule is triggered when the symbols used in the document for unordered list items do not match the configured unordered list style:\n* Item 1 + Item 2 - Item 3  To fix this issue, use the configured style for list items throughout the document:\n* Item 1 * Item 2 * Item 3  The configured list style can be a specific symbol to use (asterisk, plus, dash), can require that usage be consistent within the document, or can require that each sublist have a consistent symbol that is different from its parent list.\nFor example, the following is valid for the sublist style because the outer-most indent uses asterisk, the middle indent uses plus, and the inner-most indent uses dash:\n* Item 1 + Item 2 - Item 3 + Item 4 * Item 4 + Item 5  MD005 - Inconsistent indentation for list items at the same level Tags: bullet, ul, indentation\nAliases: list-indent\nThis rule is triggered when list items are parsed as being at the same level, but don\u0026rsquo;t have the same indentation:\n* Item 1 * Nested Item 1 * Nested Item 2 * A misaligned item  Usually this rule will be triggered because of a typo. Correct the indentation for the list to fix it:\n* Item 1 * Nested Item 1 * Nested Item 2 * Nested Item 3  Sequentially-ordered list markers are usually left-aligned such that all items have the same starting column:\n... 8. Item 9. Item 10. Item 11. Item ...  This rule also supports right-alignment of list markers such that all items have the same ending column:\n... 8. Item 9. Item 10. Item 11. Item ...  MD006 - Consider starting bulleted lists at the beginning of the line Tags: bullet, ul, indentation\nAliases: ul-start-left\nThis rule is triggered when top level lists don\u0026rsquo;t start at the beginning of a line:\nSome text * List item * List item  To fix, ensure that top level list items are not indented:\nSome test * List item * List item  Rationale: Starting lists at the beginning of the line means that nested list items can all be indented by the same amount when an editor\u0026rsquo;s indent function or the tab key is used to indent. Starting a list 1 space in means that the indent of the first nested list is less than the indent of the second level (3 characters if you use 4 space tabs, or 1 character if you use 2 space tabs).\nNote: This rule is triggered for the following scenario because the unordered sublist is not recognized as such by the parser. Not being nested 3 characters as required by the outer ordered list, it creates a top-level unordered list instead.\n1. List item - List item - List item 1. List item  MD007 - Unordered list indentation Tags: bullet, ul, indentation\nAliases: ul-indent\nParameters: indent (number; default 2)\nThis rule is triggered when list items are not indented by the configured number of spaces (default: 2).\nExample:\n* List item * Nested list item indented by 3 spaces  Corrected Example:\n* List item * Nested list item indented by 2 spaces  Rationale (2 space indent): indenting by 2 spaces allows the content of a nested list to be in line with the start of the content of the parent list when a single space is used after the list marker.\nRationale (4 space indent): Same indent as code blocks, simpler for editors to implement. See https://www.cirosantilli.com/markdown-style-guide/#indentation-of-content-inside-lists for more information.\nIn addition, this is a compatibility issue with multi-markdown parsers, which require a 4 space indents. See http://support.markedapp.com/discussions/problems/21-sub-lists-not-indenting for a description of the problem.\nNote: This rule applies to a sublist only if its parent lists are all also unordered (otherwise, extra indentation of ordered lists interferes with the rule).\nMD009 - Trailing spaces Tags: whitespace\nAliases: no-trailing-spaces\nParameters: br_spaces, list_item_empty_lines (number; default 2, boolean; default false)\nThis rule is triggered on any lines that end with unexpected whitespace. To fix this, remove the trailing space from the end of the line.\nThe br_spaces parameter allows an exception to this rule for a specific number of trailing spaces, typically used to insert an explicit line break. The default value allows 2 spaces to indicate a hard break (\u0026lt;br\u0026gt; element).\nNote: You must set br_spaces to a value \u0026gt;= 2 for this parameter to take effect. Setting br_spaces to 1 behaves the same as 0, disallowing any trailing spaces.\nUsing spaces to indent blank lines inside a list item is usually not necessary, but some parsers require it. Set the list_item_empty_lines parameter to true to allow this:\n- list item text [2 spaces] list item text  MD010 - Hard tabs Tags: whitespace, hard_tab\nAliases: no-hard-tabs\nParameters: code_blocks (boolean; default true)\nThis rule is triggered by any lines that contain hard tab characters instead of using spaces for indentation. To fix this, replace any hard tab characters with spaces instead.\nExample:\nSome text * hard tab character used to indent the list item  Corrected example:\nSome text * Spaces used to indent the list item instead  You have the option to exclude this rule for code blocks. To do so, set the code_blocks parameter to false. Code blocks are included by default since handling of tabs by tools is often inconsistent (ex: using 4 vs. 8 spaces).\nMD011 - Reversed link syntax Tags: links\nAliases: no-reversed-links\nThis rule is triggered when text that appears to be a link is encountered, but where the syntax appears to have been reversed (the [] and () are reversed):\n(Incorrect link syntax)[https://www.example.com/]  To fix this, swap the [] and () around:\n[Correct link syntax](https://www.example.com/)  Note: Markdown Extra-style footnotes do not trigger this rule:\nFor (example)[^1]  MD012 - Multiple consecutive blank lines Tags: whitespace, blank_lines\nAliases: no-multiple-blanks\nParameters: maximum (number; default 1)\nThis rule is triggered when there are multiple consecutive blank lines in the document:\nSome text here Some more text here  To fix this, delete the offending lines:\nSome text here Some more text here  Note: this rule will not be triggered if there are multiple consecutive blank lines inside code blocks.\nNote: The maximum parameter can be used to configure the maximum number of consecutive blank lines.\nMD013 - Line length Tags: line_length\nAliases: line-length\nParameters: line_length, heading_line_length, code_blocks, tables, headings, headers (number; default 80, boolean; default true)\n If headings is not provided, headers (deprecated) will be used.\n This rule is triggered when there are lines that are longer than the configured line_length (default: 80 characters). To fix this, split the line up into multiple lines. To set a different maximum length for headings, use heading_line_length.\nThis rule has an exception where there is no whitespace beyond the configured line length. This allows you to still include items such as long URLs without being forced to break them in the middle.\nYou have the option to exclude this rule for code blocks, tables, or headings. To do so, set the code_blocks, tables, or headings parameter(s) to false.\nCode blocks are included in this rule by default since it is often a requirement for document readability, and tentatively compatible with code rules. Still, some languages do not lend themselves to short lines.\nMD014 - Dollar signs used before commands without showing output Tags: code\nAliases: commands-show-output\nThis rule is triggered when there are code blocks showing shell commands to be typed, and the shell commands are preceded by dollar signs ($):\n$ ls $ cat foo $ less bar  The dollar signs are unnecessary in the above situation, and should not be included:\nls cat foo less bar  However, an exception is made when there is a need to distinguish between typed commands and command output, as in the following example:\n$ ls foo bar $ cat foo Hello world $ cat bar baz  Rationale: it is easier to copy and paste and less noisy if the dollar signs are omitted when they are not needed. See https://www.cirosantilli.com/markdown-style-guide/#dollar-signs-in-shell-code for more information.\nMD018 - No space after hash on atx style heading Tags: headings, headers, atx, spaces\nAliases: no-missing-space-atx\nThis rule is triggered when spaces are missing after the hash characters in an atx style heading:\n#Heading 1 ##Heading 2  To fix this, separate the heading text from the hash character by a single space:\n# Heading 1 ## Heading 2  MD019 - Multiple spaces after hash on atx style heading Tags: headings, headers, atx, spaces\nAliases: no-multiple-space-atx\nThis rule is triggered when more than one space is used to separate the heading text from the hash characters in an atx style heading:\n# Heading 1 ## Heading 2  To fix this, separate the heading text from the hash character by a single space:\n# Heading 1 ## Heading 2  MD020 - No space inside hashes on closed atx style heading Tags: headings, headers, atx_closed, spaces\nAliases: no-missing-space-closed-atx\nThis rule is triggered when spaces are missing inside the hash characters in a closed atx style heading:\n#Heading 1# ##Heading 2##  To fix this, separate the heading text from the hash character by a single space:\n# Heading 1 # ## Heading 2 ##  Note: this rule will fire if either side of the heading is missing spaces.\nMD021 - Multiple spaces inside hashes on closed atx style heading Tags: headings, headers, atx_closed, spaces\nAliases: no-multiple-space-closed-atx\nThis rule is triggered when more than one space is used to separate the heading text from the hash characters in a closed atx style heading:\n# Heading 1 # ## Heading 2 ##  To fix this, separate the heading text from the hash character by a single space:\n# Heading 1 # ## Heading 2 ##  Note: this rule will fire if either side of the heading contains multiple spaces.\nMD022 - Headings should be surrounded by blank lines Tags: headings, headers, blank_lines\nAliases: blanks-around-headings, blanks-around-headers\nParameters: lines_above, lines_below (number; default 1)\nThis rule is triggered when headings (any style) are either not preceded or not followed by at least one blank line:\n# Heading 1 Some text Some more text ## Heading 2  To fix this, ensure that all headings have a blank line both before and after (except where the heading is at the beginning or end of the document):\n# Heading 1 Some text Some more text ## Heading 2  Rationale: Aside from aesthetic reasons, some parsers, including kramdown, will not parse headings that don\u0026rsquo;t have a blank line before, and will parse them as regular text.\nThe lines_above and lines_below parameters can be used to specify a different number of blank lines (including 0) above or below each heading.\nNote: If lines_above or lines_below are configured to require more than one blank line, MD012/no-multiple-blanks should also be customized.\nMD023 - Headings must start at the beginning of the line Tags: headings, headers, spaces\nAliases: heading-start-left, header-start-left\nThis rule is triggered when a heading is indented by one or more spaces:\nSome text # Indented heading  To fix this, ensure that all headings start at the beginning of the line:\nSome text # Heading  Rationale: Headings that don\u0026rsquo;t start at the beginning of the line will not be parsed as headings, and will instead appear as regular text.\nMD024 - Multiple headings with the same content Tags: headings, headers\nAliases: no-duplicate-heading, no-duplicate-header\nParameters: siblings_only, allow_different_nesting (boolean; default false)\nThis rule is triggered if there are multiple headings in the document that have the same text:\n# Some text ## Some text  To fix this, ensure that the content of each heading is different:\n# Some text ## Some more text  Rationale: Some markdown parses generate anchors for headings based on the heading name, and having headings with the same content can cause problems with this.\nIf the parameter siblings_only (alternatively allow_different_nesting) is set to true, heading duplication is allowed for non-sibling headings (common in change logs):\n# Change log ## 1.0.0 ### Features ## 2.0.0 ### Features  MD025 - Multiple top level headings in the same document Tags: headings, headers\nAliases: single-title, single-h1\nParameters: level, front_matter_title (number; default 1, string; default \u0026ldquo;^\\s*title:\u0026ldquo;)\nThis rule is triggered when a top level heading is in use (the first line of the file is an h1 heading), and more than one h1 heading is in use in the document:\n# Top level heading # Another top level heading  To fix, structure your document so that there is a single h1 heading that is the title for the document, and all later headings are h2 or lower level headings:\n# Title ## Heading ## Another heading  Rationale: A top level heading is an h1 on the first line of the file, and serves as the title for the document. If this convention is in use, then there can not be more than one title for the document, and the entire document should be contained within this heading.\nNote: The level parameter can be used to change the top level (ex: to h2) in cases where an h1 is added externally.\nIf YAML front matter is present and contains a title property (commonly used with blog posts), this rule treats that as a top level heading and will report a violation for any subsequent top level headings. To use a different property name in front matter, specify the text of a regular expression via the front_matter_title parameter. To disable the use of front matter by this rule, specify \u0026quot;\u0026quot; for front_matter_title.\nMD026 - Trailing punctuation in heading Tags: headings, headers\nAliases: no-trailing-punctuation\nParameters: punctuation (string; default \u0026ldquo;.,;:!?\u0026ldquo;)\nThis rule is triggered on any heading that has a punctuation character as the last character in the line:\n# This is a heading.  To fix this, remove any trailing punctuation:\n# This is a heading  Note: The punctuation parameter can be used to specify what characters class as punctuation at the end of the heading. For example, you can set it to \u0026quot;.,;:!\u0026quot; to allow headings with question marks in them, such as might be used in an FAQ.\nMD027 - Multiple spaces after blockquote symbol Tags: blockquote, whitespace, indentation\nAliases: no-multiple-space-blockquote\nThis rule is triggered when blockquotes have more than one space after the blockquote (\u0026gt;) symbol:\n\u0026gt; This is a block quote with bad indentation \u0026gt; there should only be one.  To fix, remove any extraneous space:\n\u0026gt; This is a blockquote with correct \u0026gt; indentation.  MD028 - Blank line inside blockquote Tags: blockquote, whitespace\nAliases: no-blanks-blockquote\nThis rule is triggered when two blockquote blocks are separated by nothing except for a blank line:\n\u0026gt; This is a blockquote \u0026gt; which is immediately followed by \u0026gt; this blockquote. Unfortunately \u0026gt; In some parsers, these are treated as the same blockquote.  To fix this, ensure that any blockquotes that are right next to each other have some text in between:\n\u0026gt; This is a blockquote. And Jimmy also said: \u0026gt; This too is a blockquote.  Alternatively, if they are supposed to be the same quote, then add the blockquote symbol at the beginning of the blank line:\n\u0026gt; This is a blockquote. \u0026gt; \u0026gt; This is the same blockquote.  Rationale: Some markdown parsers will treat two blockquotes separated by one or more blank lines as the same blockquote, while others will treat them as separate blockquotes.\nMD029 - Ordered list item prefix Tags: ol\nAliases: ol-prefix\nParameters: style (\u0026ldquo;one\u0026rdquo;, \u0026ldquo;ordered\u0026rdquo;, \u0026ldquo;one_or_ordered\u0026rdquo;, \u0026ldquo;zero\u0026rdquo;; default \u0026ldquo;one_or_ordered\u0026rdquo;)\nThis rule is triggered for ordered lists that do not either start with \u0026lsquo;1.\u0026rsquo; or do not have a prefix that increases in numerical order (depending on the configured style). The less-common pattern of using \u0026lsquo;0.\u0026rsquo; for all prefixes is also supported.\nExample valid list if the style is configured as \u0026lsquo;one\u0026rsquo;:\n1. Do this. 1. Do that. 1. Done.  Example valid list if the style is configured as \u0026lsquo;ordered\u0026rsquo;:\n1. Do this. 2. Do that. 3. Done.  Both examples are valid when the style is configured as \u0026lsquo;one_or_ordered\u0026rsquo;.\nExample valid list if the style is configured as \u0026lsquo;zero\u0026rsquo;:\n0. Do this. 0. Do that. 0. Done.  Example invalid list for all styles:\n1. Do this. 3. Done.  This rule supports 0-prefixing ordered list items for uniform indentation:\n... 08. Item 09. Item 10. Item 11. Item ...  MD030 - Spaces after list markers Tags: ol, ul, whitespace\nAliases: list-marker-space\nParameters: ul_single, ol_single, ul_multi, ol_multi (number; default 1)\nThis rule checks for the number of spaces between a list marker (e.g. \u0026lsquo;-\u0026rsquo;, \u0026lsquo;*\u0026rsquo;, \u0026lsquo;+\u0026rsquo; or \u0026lsquo;1.\u0026rsquo;) and the text of the list item.\nThe number of spaces checked for depends on the document style in use, but the default is 1 space after any list marker:\n* Foo * Bar * Baz 1. Foo 1. Bar 1. Baz 1. Foo * Bar 1. Baz  A document style may change the number of spaces after unordered list items and ordered list items independently, as well as based on whether the content of every item in the list consists of a single paragraph, or multiple paragraphs (including sub-lists and code blocks).\nFor example, the style guide at https://www.cirosantilli.com/markdown-style-guide/#spaces-after-list-marker specifies that 1 space after the list marker should be used if every item in the list fits within a single paragraph, but to use 2 or 3 spaces (for ordered and unordered lists respectively) if there are multiple paragraphs of content inside the list:\n* Foo * Bar * Baz  vs.\n* Foo Second paragraph * Bar  or\n1. Foo Second paragraph 1. Bar  To fix this, ensure the correct number of spaces are used after list marker for your selected document style.\nMD031 - Fenced code blocks should be surrounded by blank lines Tags: code, blank_lines\nAliases: blanks-around-fences\nThis rule is triggered when fenced code blocks are either not preceded or not followed by a blank line:\nSome text ``` Code block ``` ``` Another code block ``` Some more text  To fix this, ensure that all fenced code blocks have a blank line both before and after (except where the block is at the beginning or end of the document):\nSome text ``` Code block ``` ``` Another code block ``` Some more text  Rationale: Aside from aesthetic reasons, some parsers, including kramdown, will not parse fenced code blocks that don\u0026rsquo;t have blank lines before and after them.\nMD032 - Lists should be surrounded by blank lines Tags: bullet, ul, ol, blank_lines\nAliases: blanks-around-lists\nThis rule is triggered when lists (of any kind) are either not preceded or not followed by a blank line:\nSome text * Some * List 1. Some 2. List Some text  To fix this, ensure that all lists have a blank line both before and after (except where the block is at the beginning or end of the document):\nSome text * Some * List 1. Some 2. List Some text  Rationale: Aside from aesthetic reasons, some parsers, including kramdown, will not parse lists that don\u0026rsquo;t have blank lines before and after them.\nNote: List items without hanging indents are a violation of this rule; list items with hanging indents are okay:\n* This is not okay * This is okay  MD033 - Inline HTML Tags: html\nAliases: no-inline-html\nParameters: allowed_elements (array of string; default empty)\nThis rule is triggered whenever raw HTML is used in a markdown document:\n\u0026lt;h1\u0026gt;Inline HTML heading\u0026lt;/h1\u0026gt;  To fix this, use \u0026lsquo;pure\u0026rsquo; markdown instead of including raw HTML:\n# Markdown heading  Rationale: Raw HTML is allowed in markdown, but this rule is included for those who want their documents to only include \u0026ldquo;pure\u0026rdquo; markdown, or for those who are rendering markdown documents in something other than HTML.\nNote: To allow specific HTML elements, use the \u0026lsquo;allowed_elements\u0026rsquo; parameter.\nMD034 - Bare URL used Tags: links, url\nAliases: no-bare-urls\nThis rule is triggered whenever a URL is given that isn\u0026rsquo;t surrounded by angle brackets:\nFor more information, see https://www.example.com/.  To fix this, add angle brackets around the URL:\nFor more information, see \u0026lt;https://www.example.com/\u0026gt;.  Rationale: Without angle brackets, the URL isn\u0026rsquo;t converted into a link in many markdown parsers.\nNote: if you do want a bare URL without it being converted into a link, enclose it in a code block, otherwise in some markdown parsers it will be converted:\n`https://www.example.com`  MD035 - Horizontal rule style Tags: hr\nAliases: hr-style\nParameters: style (\u0026ldquo;consistent\u0026rdquo;, \u0026ldquo;\u0026mdash;\u0026rdquo;, \u0026ldquo;***\u0026ldquo;, or other string specifying the horizontal rule; default \u0026ldquo;consistent\u0026rdquo;)\nThis rule is triggered when inconsistent styles of horizontal rules are used in the document:\n--- - - - *** * * * ****  To fix this, ensure any horizontal rules used in the document are consistent, or match the given style if the rule is so configured:\n--- ---  Note: by default, this rule is configured to just require that all horizontal rules in the document are the same, and will trigger if any of the horizontal rules are different than the first one encountered in the document. If you want to configure the rule to match a specific style, the parameter given to the \u0026lsquo;style\u0026rsquo; option is a string containing the exact horizontal rule text that is allowed.\nMD036 - Emphasis used instead of a heading Tags: headings, headers, emphasis\nAliases: no-emphasis-as-heading, no-emphasis-as-header\nParameters: punctuation (string; default \u0026ldquo;.,;:!?\u0026ldquo;)\nThis check looks for instances where emphasized (i.e. bold or italic) text is used to separate sections, where a heading should be used instead:\n**My document** Lorem ipsum dolor sit amet... _Another section_ Consectetur adipiscing elit, sed do eiusmod.  To fix this, use markdown headings instead of emphasized text to denote sections:\n# My document Lorem ipsum dolor sit amet... ## Another section Consectetur adipiscing elit, sed do eiusmod.  Note: this rule looks for single line paragraphs that consist entirely of emphasized text. It won\u0026rsquo;t fire on emphasis used within regular text, multi-line emphasized paragraphs, and paragraphs ending in punctuation. Similarly to rule MD026, you can configure what characters are recognized as punctuation.\nMD037 - Spaces inside emphasis markers Tags: whitespace, emphasis\nAliases: no-space-in-emphasis\nThis rule is triggered when emphasis markers (bold, italic) are used, but they have spaces between the markers and the text:\nHere is some ** bold ** text. Here is some * italic * text. Here is some more __ bold __ text. Here is some more _ italic _ text.  To fix this, remove the spaces around the emphasis markers:\nHere is some **bold** text. Here is some *italic* text. Here is some more __bold__ text. Here is some more _italic_ text.  Rationale: Emphasis is only parsed as such when the asterisks/underscores aren\u0026rsquo;t completely surrounded by spaces. This rule attempts to detect where they were surrounded by spaces, but it appears that emphasized text was intended by the author.\nMD038 - Spaces inside code span elements Tags: whitespace, code\nAliases: no-space-in-code\nThis rule is triggered on code span elements that have spaces right inside the backticks:\n` some text ` `some text ` ` some text`  To fix this, remove the spaces inside the codespan markers:\n`some text`  Note: A single leading or trailing space is allowed if used to separate codespan markers from an embedded backtick:\n`` ` embedded backtick``  MD039 - Spaces inside link text Tags: whitespace, links\nAliases: no-space-in-links\nThis rule is triggered on links that have spaces surrounding the link text:\n[ a link ](https://www.example.com/)  To fix this, remove the spaces surrounding the link text:\n[a link](https://www.example.com/)  MD040 - Fenced code blocks should have a language specified Tags: code, language\nAliases: fenced-code-language\nThis rule is triggered when fenced code blocks are used, but a language isn\u0026rsquo;t specified:\n``` #!/bin/bash echo Hello world ```  To fix this, add a language specifier to the code block:\n```bash #!/bin/bash echo Hello world ```  MD041 - First line in file should be a top level heading Tags: headings, headers\nAliases: first-line-heading, first-line-h1\nParameters: level, front_matter_title (number; default 1, string; default \u0026ldquo;^\\s*title:\u0026ldquo;)\nThis rule is intended to ensure documents have a title and is triggered when the first line in the file isn\u0026rsquo;t a top level (h1) heading:\nThis is a file without a heading  To fix this, add a top level heading to the beginning of the file:\n# File with heading This is a file with a top level heading  Note: The level parameter can be used to change the top level (ex: to h2) in cases where an h1 is added externally.\nIf YAML front matter is present and contains a title property (commonly used with blog posts), this rule will not report a violation. To use a different property name in front matter, specify the text of a regular expression via the front_matter_title parameter. To disable the use of front matter by this rule, specify \u0026quot;\u0026quot; for front_matter_title.\nMD042 - No empty links Tags: links\nAliases: no-empty-links\nThis rule is triggered when an empty link is encountered:\n[an empty link]()  To fix the violation, provide a destination for the link:\n[a valid link](https://example.com/)  Empty fragments will trigger this rule:\n[an empty fragment](#)  But non-empty fragments will not:\n[a valid fragment](#fragment)  MD043 - Required heading structure Tags: headings, headers\nAliases: required-headings, required-headers\nParameters: headings, headers (array of string; default null for disabled)\n If headings is not provided, headers (deprecated) will be used.\n This rule is triggered when the headings in a file do not match the array of headings passed to the rule. It can be used to enforce a standard heading structure for a set of files.\nTo require exactly the following structure:\n# Head ## Item ### Detail  Set the headings parameter to:\n[ \u0026quot;# Head\u0026quot;, \u0026quot;## Item\u0026quot;, \u0026quot;### Detail\u0026quot; ]  To allow optional headings as with the following structure:\n# Head ## Item ### Detail (optional) ## Foot ### Notes (optional)  Use the special value \u0026quot;*\u0026quot; meaning \u0026ldquo;one or more unspecified headings\u0026rdquo; and set the headings parameter to:\n[ \u0026quot;# Head\u0026quot;, \u0026quot;## Item\u0026quot;, \u0026quot;*\u0026quot;, \u0026quot;## Foot\u0026quot;, \u0026quot;*\u0026quot; ]  When an error is detected, this rule outputs the line number of the first problematic heading (otherwise, it outputs the last line number of the file).\nNote that while the headings parameter uses the \u0026ldquo;## Text\u0026rdquo; ATX heading style for simplicity, a file may use any supported heading style.\nMD044 - Proper names should have the correct capitalization Tags: spelling\nAliases: proper-names\nParameters: names, code_blocks (string array; default null, boolean; default true)\nThis rule is triggered when any of the strings in the names array do not have the specified capitalization. It can be used to enforce a standard letter case for the names of projects and products.\nFor example, the language \u0026ldquo;JavaScript\u0026rdquo; is usually written with both the \u0026lsquo;J\u0026rsquo; and \u0026rsquo;S\u0026rsquo; capitalized - though sometimes the \u0026rsquo;s\u0026rsquo; or \u0026lsquo;j\u0026rsquo; appear in lower-case. To enforce the proper capitalization, specify the desired letter case in the names array:\n[ \u0026quot;JavaScript\u0026quot; ]  Set the code_blocks parameter to false to disable this rule for code blocks.\nMD045 - Images should have alternate text (alt text) Tags: accessibility, images\nAliases: no-alt-text\nThis rule is triggered when an image is missing alternate text (alt text) information. Alternate text is important for accessibility, describing the content of an image for people who may not be able to see it.\nAlternate text is commonly specified inline as:\n![Alternate text](image.jpg)  Or with reference syntax as:\n![Alternate text][ref] ... [ref]: image.jpg \u0026quot;Optional title\u0026quot;  Guidance for writing alternate text is available from the W3C, Wikipedia, and other locations.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7351de3bbd485947fecd79515c5dd561","permalink":"https://xueqing.github.io/blog/markdown/markdownlint_rules/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/markdown/markdownlint_rules/","section":"blog","summary":"MD001 - Heading levels should only increment by one level at a time MD002 - First heading should be a top level heading MD003 - Heading style MD004 - Unordered list style MD005 - Inconsistent indentation for list items at the same level MD006 - Consider starting bulleted lists at the beginning of the line MD007 - Unordered list indentation MD009 - Trailing spaces MD010 - Hard tabs MD011 - Reversed link syntax MD012 - Multiple consecutive blank lines MD013 - Line length MD014 - Dollar signs used before commands without showing output MD018 - No space after hash on atx style heading MD019 - Multiple spaces after hash on atx style heading MD020 - No space inside hashes on closed atx style heading MD021 - Multiple spaces inside hashes on closed atx style heading MD022 - Headings should be surrounded by blank lines MD023 - Headings must start at the beginning of the line MD024 - Multiple headings with the same content MD025 - Multiple top level headings in the same document MD026 - Trailing punctuation in heading MD027 - Multiple spaces after blockquote symbol MD028 - Blank line inside blockquote MD029 - Ordered list item prefix MD030 - Spaces after list markers MD031 - Fenced code blocks should be surrounded by blank lines MD032 - Lists should be surrounded by blank lines MD033 - Inline HTML MD034 - Bare URL used MD035 - Horizontal rule style MD036 - Emphasis used instead of a heading MD037 - Spaces inside emphasis markers MD038 - Spaces inside code span elements MD039 - Spaces inside link text MD040 - Fenced code blocks should have a language specified MD041 - First line in file should be a top level heading MD042 - No empty links MD043 - Required heading structure MD044 - Proper names should have the correct capitalization MD045 - Images should have alternate text (alt text)  This document contains a description of all rules, what they are checking for, as well as an examples of documents that break the rule and corrected versions of the examples.","tags":["md"],"title":"Markdownlint Rules","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  Mingw  MinGW-w64 MSYS MSYS2  Cygwin MinGW vs 区别：Cygwin MSVC MinGW 和 MSVC 的二进制兼容性  不同编译器生成的库的互操作性  参考  Mingw  MinGW(Minimalist GNU for Windows)，用于开发原生(32 位) MS-Windows 应用的最小化的开发环境。它提供了一个完整的开源编程工具链，用于开发原生 MS-Windows 应用，且不依赖任何第三方 C-运行时 DLL  它确实依赖一些 MS 提供的 DLL，比如 MSVCRT.DLL(MS 的 C 运行时库)  MinGW 编译器支持访问 MS 的 C 和 和一些其他语言的运行时函数 MinGW 不会尝试为 MS-Windows 上的 POSIX 应用部署提供 POSIX 运行时环境 MinGW 能够替代 cl 用于编译不包含 MFC 的、以 WinSDK 为主的 Windows 应用，并且编译出来的应用不依赖于第三方的模拟层支持 MinGW 包含  一些 GCC(GNU Compiler Collection)，包括 C/C++/ADA/Fortran 编译器 针对 Windows 的 GNU Binutils(汇编器、链接器、归档管理器) 一个命令行安装工具，带有可选的 GUI 前后端(mingw-get),用于 MS-Windows 上的 MinGW 和 MSYS 部署 一个 GUI 初始安装工具(mingw-get-setup)，用于安装和运行 mingw-get  总结：MinGW 是用于 MS-Windows 应用开发的 GNU 工具链(开发环境)，它的编译产物一般是原生 MS-Windows 应用，虽然它本身不一定非要运行在 Windows 系统下(MinGW 工具链也存在于 Linux、BSD 甚至 Cygwin 下)  MinGW-w64  前面提到的 MinGW，是针对 32 位 Windows 应用开发的。而且由于版本问题，不能很好的支持较新的 Windows API。MinGW-W64 则是新一代的 MinGW，支持更多的 API，支持 64 位应用开发，甚至支持 32 位 host 编译 64 位应用以及反过来的“交叉”编译。除此之外，它本身也有 32 位和 64 位不同版本，其它与 MinGW 相同  MSYS  MSYS(Minimal SYStem)，是一个 Bourne Shell 命令行解释器系统。可取代 MS 的 cmd.exe，提供了统一的命令行环境，尤其适用于 MinGW MSYS 是 Cygwin-1.3 的一个轻量级的 fork，是用于辅助 Windows 版 MinGW 进行命令行开发的配套软件包，包含了一小部分 Unix 工具以使得 MinGW 的工具使用起来方便一些 由于 MinGW 本身仅代表工具链，而在 Windows 下，由于 cmd 以及配套的命令行工具不够齐全(也不舒服)，因此，MinGW 开发者从曾经比较旧的 Cygwin 创建了一个分支，也用于提供类 Unix 环境 与 Cygwin 的大而全不同，MSYS 是冲着小巧玲珑的目标去的，所以整套 MSYS 以及 MinGW，主要以基本的 Linux 工具为主，大小在 200M 左右，并且没有多少扩展能力  MSYS2  由于 MinGW 和 MSYS 更新慢，Cygwin 的许多新功能 MSYS 没有同步过来，于是 Alex 等人建立了新一代的 MSYS 项目。仍然是 fork 了 Cygwin(较新版)，但有个更优秀的包管理器 pacman，有活跃的开发者跟用户组，有大量预编译的软件包(没有 Cygwin 多)  Cygwin  Cygwin 是一个运行于 Windows 平台的类 Unix 模拟环境(以 GNU 工具为代表) Cygwin 提供了一套抽象层 dll，用于将部分 POSIX 调用转换成 Windows 的 API 调用，实现相关功能。其中最典型、最基本的模拟层是 cygwin1.dll。除此之外，随着 Linux 系统的发展壮大，目前 Cygwin 不仅提供 POSIX 兼容，也多了更多模拟层的依赖关系 Cygwin 的目录结构基本照搬了 Linux 的样子，但同时也兼容了 Windows 的许多功能  大部分应用使用 Unix 风格的路径，Windows 的盘符通过类似挂载点的方式提供给 Cygwin 使用 Cygwin 中既可以运行 Cygwin 的应用(依赖模拟层)，又可以运行 Windows 应用，而传递给应用的路径会经过它的模拟层变换，以此保证程序运行不会出错  由于它的模拟层实现了相当良好的 POSIX 兼容，人们试着将许多重要的 Linux/BSD 应用移植到 Cygwin 下，使得 Cygwin 越来越大，功能也越来越丰富，以至于目前很多人直接把将 Linux 应用移植到 Windows 平台的任务都交给了Cygwin(这种移植并非原生) 总结：Cygwin 是运行于 Windows 平台的 POSIX “子系统”，提供 Windows 下的类 Unix 环境，并提供将部分 Linux 应用“移植”到 Windows 平台的开发环境的一套软件  MinGW vs 区别：Cygwin  区别：Cygwin 是模拟 POSIX 系统，源码移植 Linux 应用到 Windows 下；MinGW 是用于开发 Windows 应用的开发环境。如果希望部署 POSIX 应用，考虑 Cygwin 联系：均提供了部分 Linux 下的应用，多跑在 Windows 上；MinGW 作为 Cygwin 下的软件包，可以在 Cygwin 上运行  MSVC  MSVC(Microsoft Visual C++)，是用于 C 和 C++ 编程的一个 IDE。是用于编写和调试 C/C++/C# 代码的工具，大部分代码是为了 MS-Windows/.NET 框架或 DirectX 编写的。最新的版本也支持 JavaScript 和 F#  MinGW 和 MSVC 的二进制兼容性  MinGW 编译的软件使用 QT 框架，也依赖 Apache 可移植运行库，即 Apache Portable Runtime, APR。一些预编译好的 Windows 开发包(如 MySQL 客户端库)使用 MSVC 编译 MSVC 和 MinGW 对标准调用函数(stdcall function) 使用不同的命名惯例：MSVC 导出函数为 _name@ordinal，但是 MinGW 导出为 _name。因此，MinGW 当调用来自 MSVC 库的 stdcall 函数时会报 undefined reference 编译错误 解决方案参考 Linking MSVC Libraries With MinGW Projects 和 MSVC and MinGW DLLs  不同编译器生成的库的互操作性  不同编译器，甚至相同编译器的不同发布版本生成的目标文件和静态库文件，通常不能一起链接。所以尽量使用相同编译器的相同版本编译源码 DLL 文件稍微有些不同。有时候可以在应用中链接另一个编译器生成的 DLL 文件  当 DLL 使用 C 编写兼容性通常很好。比如 MinGW C++ 程序通常链接 Windows 提供的 C 运行时库 使用 C++ 编写的 DLL，只要通过一个使用extern \u0026quot;C\u0026quot;声明的 C 接口就可以 否则，会报链接错误。因为不同编译器使用不同的 C++ 名称重整(name-mangling)  真正的链接间通信要求一个通用的应用二进制接口(Application Binary Interface)，名称重整只是其中一个原因，而且一个编译器会提供 3200 个不同的 ABI 虽然 GNU g++ 可以链接 MSVC C++ 库，可以生成 MSVC++ 兼容的 库/DLL 文件，但是由于 C++ 的动态特性，在运行时并不会正常工作。可能的原因包括  名称重整：可能通过显式的 .def 文件绕过去 不同的结构对齐规则：需要正确的编译器选项(-mms-bitfields\u0026hellip;) 底层的异常和内存模型冲突 MSVC DLL 的 new/delete 或 malloc/free 和 Cygwin 的 new/delete 或 malloc/free 不一致。在一个函数中使用不同的 new/malloc 申请的内存，其它地方不能释放 MSVC DLL 抛出的异常不能被 Cygwin 的可执行程序捕获，反之亦然   参考  MinGW 官网 Cygwin 官网 MSVC Interoperability of Libraries Created by Different Compiler Brands Binary-compatible C++ Interfaces  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"65e4c1428d5838f5bdadde4ab67aa58d","permalink":"https://xueqing.github.io/blog/vs/mingw_cygwin_msvc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vs/mingw_cygwin_msvc/","section":"blog","summary":"Mingw MinGW-w64 MSYS MSYS2 Cygwin MinGW vs 区别：Cygwin MSVC MinGW 和 MSVC 的二进制兼容性 不同编译器生成的库的互操作性 参考 Mingw MinGW(Minimalist GNU for Windows)，用于开发原生(32 位) MS-Windows 应用","tags":["vs","mingw","cygwin","msvc"],"title":"MinGW vs Cygwin vs MSVC","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  旧行为 vs 基于模块的行为 在 GOPATH 之外工作 VSCode 对模块的支持  保存文件时不再自动导入  相关链接  旧行为 vs 基于模块的行为  模块在 Go1.11 开始，因此按照设计旧行为会默认保留。因此需要注意什么时候是旧的 1.10 状态行为(查找 vendor 目录和 GOPATH 来寻找依赖)，什么时候是新的基于模块的行为  在 GOPATH 之内: 默认是旧的 1.10 行为，会忽视模块 在 GOPATH 之外且在文件树之内有一个 go.mod 文件: 默认是模块行为 GO111MODULE 环境变量 不设置或 auto: 上述默认行为 on: 强制支持模块，与目录位置无关 off: 强制不支持模块，与目录位置无关   在 GOPATH 之外工作  如果对于一个给定的导入路径，有多个包的版本，那么要求包的开发版本放在一个指定的位置是没有意义的。如果需要同时在 v1.3 和 v1.4 版本上修改 bug，显然需要在不同的位置切换模块。实际上，这种情况下，没有必要在 GOPATH 目录工作 GOPATH 做了三件事  定义依赖的版本(现在在 go.mod) 保存这些依赖的源码(现在在分别的 cache) 提供一种方式来推测特定目录(去掉先导的 $GOPATH/src)代码内的导入路径(现在有机制来确定当前目录代码的导入路径，可以停止要求程序猿在 GOPATH 工作) 此机制位于 go.mod 文件的 module 命令。比如当前目录是 buggy，且 ../go.mod 包含 module \u0026quot;rsc.io/quote\u0026quot;，那么当前目录的导入路径就是 rsc.io/quote/buggy  vgo 原型支持在 GOPATH 之外工作。比如下面的例子，即使 Upspin 没有引入 go.mod 文件也可以工作\ncd $HOME git clone https://github.com/upspin/upspin cd upspin # vgo 从 导入注释推测模块名字是 upsin.io，并且从 Gopkg.loc 推测需要的依赖版本 vgo test -short ./...   VSCode 对模块的支持  新的语言服务 gopls 支持模块，设置 \u0026quot;go.useLanguageServer\u0026quot;: true  保存文件时不再自动导入  如果不使用语言服务，插件默认使用 goreturns 工具格式化文件，并自动导入缺失的包。但是 goreturns 工具不支持模块，因此存文件时自动导入的特性不生效 增加设置 \u0026quot;go.formatTool\u0026quot;: \u0026quot;goimports\u0026quot;，然后使用 Go: Install/Update Tools 安装或更新 goimports，因为 goimports 已经增加对模块的支持  相关链接  Go module wiki When do I get old behavior vs. new module-based behavior Versioned Go Commands Working outside GOPATH Go modules support in Visual Studio Code  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4bbefa715ab344049b22ff149005de70","permalink":"https://xueqing.github.io/blog/go/traps/mod_workspace/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/traps/mod_workspace/","section":"blog","summary":"旧行为 vs 基于模块的行为 在 GOPATH 之外工作 VSCode 对模块的支持 保存文件时不再自动导入 相关链接 旧行为 vs 基于模块的行为 模块在 Go1.11 开始，因此按照设计旧行为会默认保","tags":["go"],"title":"module 不要在 vscode 工作区打开工程","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  mongodb 环境搭建  1 apt 安装 2 命令 2.1 启动 MongoDB 2.2 查看状态 MongoDB 2.3 重新启动 MongoDB 2.4 停止 MongoDB 3 卸载 MongoDB 4 设置开机自启动 5 开启远程访问 6 故障问题   1 apt 安装 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4 echo \u0026quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.0 multiverse\u0026quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list sudo apt-get update sudo apt-get install -y mongodb-org echo \u0026quot;mongodb-org hold\u0026quot; | sudo dpkg --set-selections echo \u0026quot;mongodb-org-server hold\u0026quot; | sudo dpkg --set-selections echo \u0026quot;mongodb-org-shell hold\u0026quot; | sudo dpkg --set-selections echo \u0026quot;mongodb-org-mongos hold\u0026quot; | sudo dpkg --set-selections echo \u0026quot;mongodb-org-tools hold\u0026quot; | sudo dpkg --set-selections  2 命令 2.1 启动 MongoDB sudo service mongod start  2.2 查看状态 MongoDB sudo service mongod status  2.3 重新启动 MongoDB sudo service mongod restart  2.4 停止 MongoDB sudo service mongod stop  3 卸载 MongoDB sudo service mongod stop sudo apt-get purge mongodb-org* sudo rm -r /var/log/mongodb sudo rm -r /var/lib/mongodb  4 设置开机自启动 sudo systemctl enable mongod  5 开启远程访问 sudo vim /etc/mongod.conf # 把 bindIp:127.0.0.1 修改为 bindIp:0.0.0.0 # 之后重启服务 sudo service mongod restart  6 故障问题  遇到连接拒绝问题 Failed to connect to 127.0.0.1:27017, in(checking socket for error after poll), reason: Connection refused，执行下面命令可解决\nsudo rm /var/lib/mongodb/mongod.lock sudo service mongod restart   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"edb30e90948866876cb0076d2737e463","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_mongodb/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_mongodb/","section":"blog","summary":"mongodb 环境搭建 1 apt 安装 2 命令 2.1 启动 MongoDB 2.2 查看状态 MongoDB 2.3 重新启动 MongoDB 2.4 停止 MongoDB 3 卸载 MongoDB 4 设置开机自启动 5 开启远程访问 6 故障问题 1 apt 安装 sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4 echo \u0026quot;deb [","tags":["ubuntu","linux"],"title":"mongodb 环境搭建","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 ubuntu 安装和配置 mysql 2 mysql命令  1 ubuntu 安装和配置 mysql  执行sudo apt-get insall mysql-server mysql-client 修改配置运行远程连接  sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 注释或删除bind-address = 127.0.0.1 修改数据库的授权 mysql -uroot -p输入密码 use mysql GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION; flush privileges; 重启数据库服务sudo service mysql restart   2 mysql命令  导出数据库mysqldump -uroot -p bmi_nvr \u0026gt; bmi_nvr.sql 导出数据库表mysqldump -uroot -p bmi_nvr sip_info\u0026gt; bmi_nvr_sipinfo.sql 导入数据表:进入 mysql 命令行后use bmi_nvr;source /home/kiki/bmi_nvr.sql mysql source 防止乱码  备份mysqldump -uroot -p --default-character-set=utf8 bmi_nvr \u0026gt; bmi_nvr.sql 导入mysqldump -uroot -p --default-character-set=utf8 bmi_nvr sip_info\u0026gt; bmi_nvr_sipinfo.sql 进入 mysql 命令行use bmi_nvr;source /home/kiki/bmi_nvr.sql   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7760e6bc6d0521d7ac5d2a462711283f","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_mysql/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_mysql/","section":"blog","summary":"1 ubuntu 安装和配置 mysql 2 mysql命令 1 ubuntu 安装和配置 mysql 执行sudo apt-get insall mysql-server mysql-client 修改配置运行远程连接 sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 注释或删除bind-address = 127.0.0.1 修改数据","tags":["ubuntu","linux"],"title":"mysql","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 版本要求 2 提供以下四种方式安装(PS: 建议第四种方式安装)  2.1 调用官网脚本自动安装 2.2 使用二进制包文件 2.2.1 设置文件路径 2.2.2 建立软连接 2.3 apt 安装  3 查看nodejs的版本 4 查看npm的版本  1 版本要求  node \u0026gt;= 8.x 目前稳定版本为 10.x npm \u0026gt;= 5.x  2 提供以下四种方式安装(PS: 建议第四种方式安装) 2.1 调用官网脚本自动安装  参考\ncurl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash - sudo apt-get install -y nodejs   2.2 使用二进制包文件 2.2.1 设置文件路径 # 按下载版本修改 VERSION VERSION=v10.15.1 DISTRO=linux-x64 sudo mkdir -p /usr/local/lib/nodejs sudo tar -xJvf node-$VERSION-$DISTRO.tar.xz -C /usr/local/lib/nodejs  2.2.2 建立软连接 VERSION=v10.15.1 DISTRO=linux-x64 sudo ln -s /usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin/node /usr/bin/node sudo ln -s /usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin/npm /usr/bin/npm sudo ln -s /usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin/npx /usr/bin/npx  2.3 apt 安装 安装版本较低，需手动更新\n# 安装 nodejs sudo apt install node # 安装 nodejs 的依赖库管理工具 npm sudo apt install npm # 安装 nodejs 版本管理工具 n sudo npm install n -g # 升级 nodejs 的版本 sudo n stable  或者\nsudo apt install node sudo apt install npm # 升级 npm sudo npm install npm@latest -g # 升级 node sudo npm install -g n sudo n stable  3 查看nodejs的版本 node # 或 node -v  4 查看npm的版本 npm -v  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"cf8d3ee9b1d3c40b86d34389b8f67863","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_nodejs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_nodejs/","section":"blog","summary":"1 版本要求 2 提供以下四种方式安装(PS: 建议第四种方式安装) 2.1 调用官网脚本自动安装 2.2 使用二进制包文件 2.2.1 设置文件路径 2.2.2 建立软连接 2.3 apt 安装 3 查看","tags":["ubuntu","linux"],"title":"Node.js 环境搭建","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  概念 发展历程 核心技术 应用价值 经营模式 主要难题  盈利模式 平衡模式   概念  O2O(online to offline, 在线离线/线上到线下)，指将线下的商务机会与互联网结合，让互联网称为线下交易的平台  发展历程  1.0 阶段：O2O 线上线下初步对接，主要利用线上推广的便捷性将相关用户集中起来，然后把线上流量转到线下。主要领域集中在以美团为代表的线上团购和促销等领域  特点：单向性、粘性较低 平台和用户互动较少，基本上以交易的完成未终结点 用户更多受价格等因素驱动，购买和消费频率相对较低  2.0 阶段：最主要的特色是升级为服务型电商模式，包括商品(服务)、下单、支付等流程。把简单的电商模块转移到更加高频和生活化场景中来  移动终端、微信支付、数据算法等环节的成熟，加上资本的催化，用户数目、使用频率和忠诚度开始上升 O2O 开始和用户的日常生活融合 由于资本的大量补贴，这其中有很多看似繁荣的需求，如按摩、洗车等  3.0 阶段：出现明显的分化  一个是真正的垂直细分领域的一些公司开始凸显：如专注于快递物流的速递易，专注于高端餐厅排位的美味不用等，专注于白领快速取餐的速位 一个是垂直细分领域的平台化模式发展：由原来的细分领域的解决某个痛点的模式开始横向扩张，覆盖整个行业。如饿了么从早先的外卖到后来开放的蜂鸟系统，开始正式对接第三方团队和众包物流   核心技术  O2O 营销模式的核心是在线支付：通过 O2O 模式，将线下商品及服务进行展示，并提供在线支付“预约消费”，对消费者不仅扩宽了选择余地，消费者还可通过线上对比选择最令人期待的服务，以及依照消费者的区域性享受商家提供的更合适的服务 也有一些商家使用比线下支付更为优惠的手段吸引客户在线支付，为消费者节约了不少的支出  应用价值  O2O 优势在于把线上和线下优势完美结合：通过网购导购机，把互联网和实体店完美对接，实现互联网落地；让消费者享受线上优惠价格的同事，可享受线下贴身的服务；O2O 模式还可实现不同商家的联盟  O2O 模式充分利用了互联网跨地域、无边界、海量信息、海量用户的优势，同时充分挖掘线下资源，进而促成线上用户与线下商品与服务的交易。如团购 O2O 模式可对商家的营销效果进行直观的统计和追踪评估，规避了传统营销模式的推广效果的不可预测性。O2O 将线上订单和线下消费结合，所有的消费行为均可准确统计，进而吸引更多的商家，为消费者提供更多优质的产品和服务 O2O 在服务中具有价格便宜、购买方便、且能及时获知折扣信息等优势 OO 将拓宽电子商务的发展方向，由规模化走向多元化 O2O 模式打通了线上线下的信息和体验环节，让线下消费者避免了因信息不对称遭受的“价格蒙蔽”，同时实现线上消费者的“售前体验”  整体看 O2O 会达成“三赢”的效果  本地商家 O2O 模式要求消费者网站支付，支付信息会成为商家了解消费者购物信息的渠道，方便商家搜集消费者购买数据，进而达到精准营销的目的，更好地维护和拓展用户 通过线上资源增加的顾客不会给商家带来太多的成本，反而增加更多利润 O2O 模式在一定程度上降低了商家对店铺地理位置的依赖，减少了租金方面的支出 消费者 O2O 提供丰富、全面、及时的商家折扣信息，能快捷筛选并订购适宜的商品或服务，且价格实惠 服务提供商 O2O 模式可带来大规模高粘度的消费者，进而可争取更多的商家资源 掌握庞大的消费者数据资源，且本地化程度较高的垂直网站借助 O2O 模式，还能为商家提供其他增值服务   经营模式  与传统的消费者在商家直接消费的模式不同，O2O 平台商业模式中，整个消费过程由线上和线下两部分构成  线上：平台为消费者提供消费指南、优惠信息、便利服务(预订、在线支付、地图等)和分享平台 线下：商户专注于提供服务  O2O 模式中消费者的消费流程可分为 5 个阶段  引流：线上拼台作为线下消费决策的入口，可汇聚大量有消费需求的消费者，或引发消费者的线下消费需求。常见的 O2O 平台引流入口包括消费点评类网站(大众点评)、电子地图(百度、高德)、社交类网站或应用(微信、人人) 转化：线上平台向消费者提供商铺的详细信息、优惠(团购、优惠券)、便利服务，方便消费者搜索、对比商铺，并最终帮助消费者选择线下商户、完成消费决策 消费：消费者利用线上获得的信息到线下商户接受服务、完成消费 反馈：消费者将自己的消费体验反馈到线上平台，有助于其他消费者做出消费决策。线上平台通过梳理和分析消费者的反馈，形成更加完整的本地商铺信息群，可吸引更多的消费者使用在线平台 存留：线上平台为消费者和本地商户建立沟通渠道，可帮助本地商户维护消费者管理，使消费者重复消费，成为商家的回头客   主要难题 盈利模式  O2O 现在多被投资方看好的原因在于它的前景不确定性，也表明其机会成本和沉淀成本的不确定 O2O 目前分为垂直血缘行业链和平行优势产业链。两种模式都处于试水阶段  垂直模式是以某个点作为突破口，然后建立从上游到下游的产业链；平行模式是以某个点作为切入点，然后建立闭环生态链，共享信息 垂直模式需要强大的资源整合能力，而现在是一个高度分工的社会，协调资源和信息需要强大的人力物力；平行模式需要的是数据处理能力，需要的不仅是公司自身实力的体现，还需要整合社会的配合，比前者更难 垂直模式是关爱一个家庭的幸福，平行模式是关爱全人类的幸福 上述因素导致 O2O 整体盈利模式未知，但小规模盈利可行   平衡模式  如何与消费者处理好平衡关系，怎么调节服务与体验的关系  外卖多长时间送，临走需要说什么让顾客下次还点自己 洗衣上门，是不是可以答应顾客所有要求   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"31bd3190725cbe06c1debb051a08e48f","permalink":"https://xueqing.github.io/blog/o2o/o2o/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/o2o/","section":"blog","summary":"概念 发展历程 核心技术 应用价值 经营模式 主要难题 盈利模式 平衡模式 概念 O2O(online to offline, 在线离线/线上到线下)，指将线下的商务机会与互联网结合，让互联网称为线","tags":["o2o"],"title":"O2O","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# git 命令失败 ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by ssh) ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by ssh) OpenSSL version mismatch. Built against 1000207f, you have 1000103f # ssh 可执行文件链接库 ldd /usr/bin/ssh /usr/bin/ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by /usr/bin/ssh) /usr/bin/ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by /usr/bin/ssh) linux-vdso.so.1 =\u0026gt; (0x00007fff3fdc1000) libselinux.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f30e3f81000) libcrypto.so.1.0.0 =\u0026gt; /usr/local/lib/libcrypto.so.1.0.0 (0x00007f30e3b96000)# this line is differeent libdl.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f30e3992000) libz.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f30e3778000) libresolv.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f30e355d000) libgssapi_krb5.so.2 =\u0026gt; /usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2 (0x00007f30e3313000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f30e2f49000) libpcre.so.3 =\u0026gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f30e2cd9000) /lib64/ld-linux-x86-64.so.2 (0x00007f30e4453000) libkrb5.so.3 =\u0026gt; /usr/lib/x86_64-linux-gnu/libkrb5.so.3 (0x00007f30e2a07000) libk5crypto.so.3 =\u0026gt; /usr/lib/x86_64-linux-gnu/libk5crypto.so.3 (0x00007f30e27d8000) libcom_err.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libcom_err.so.2 (0x00007f30e25d4000) libkrb5support.so.0 =\u0026gt; /usr/lib/x86_64-linux-gnu/libkrb5support.so.0 (0x00007f30e23c9000) libpthread.so.0 =\u0026gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f30e21ac000) libkeyutils.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libkeyutils.so.1 (0x00007f30e1fa8000) # 正常情况下查看 ssh 可执行文件链接库 ldd /usr/bin/ssh linux-vdso.so.1 =\u0026gt; (0x00007fff59ca9000) libselinux.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f324fa4d000) libcrypto.so.1.0.0 =\u0026gt; /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007f324f608000)# this line is differeent libdl.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f324f404000) libz.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f324f1ea000) libresolv.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f324efcf000) libgssapi_krb5.so.2 =\u0026gt; /usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2 (0x00007f324ed85000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f324e9bb000) libpcre.so.3 =\u0026gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f324e74b000) /lib64/ld-linux-x86-64.so.2 (0x00007f324ff1f000) libkrb5.so.3 =\u0026gt; /usr/lib/x86_64-linux-gnu/libkrb5.so.3 (0x00007f324e479000) libk5crypto.so.3 =\u0026gt; /usr/lib/x86_64-linux-gnu/libk5crypto.so.3 (0x00007f324e24a000) libcom_err.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libcom_err.so.2 (0x00007f324e046000) libkrb5support.so.0 =\u0026gt; /usr/lib/x86_64-linux-gnu/libkrb5support.so.0 (0x00007f324de3b000) libpthread.so.0 =\u0026gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f324dc1e000) libkeyutils.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libkeyutils.so.1 (0x00007f324da1a000)   原因  在 ubuntu 编译了一个 OpenSSL 的源码，并执行了sudo make install。 Ubuntu 自带的 OpenSSL 版本带有额外的补丁，包含版本信息等，但是标准的 OpenSSL 库(1.1.0 之前)是没有版本信息的。OpenSSH 在运行时链接到源码编译的 OpenSSL 库，没有这些版本信息符号 OpenSSH 和 OpenSSL 的安装顺序是有一定限制的，可单独升级 OpenSSH，但升级了 OpenSSL 之后，需要重新编译 OpenSSH 或升级，否则不能使用 OpenSSH  解决方法  删除/usr/local/include/openssl 删除/usr/local/lib/libcrypto.* 删除/usr/local/lib/libssl.*   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"beb3606b54035a153f6fc7b3f44765d4","permalink":"https://xueqing.github.io/blog/ubuntu/openssl_version_mismatch/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/openssl_version_mismatch/","section":"blog","summary":"# git 命令失败 ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by ssh) ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by ssh) OpenSSL version mismatch. Built against 1000207f, you have 1000103f # ssh 可执行文件链接库 ldd /usr/bin/ssh /usr/bin/ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by /usr/bin/ssh) /usr/bin/ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by /usr/bin/ssh) linux-vdso.so.1 =\u0026gt; (0x00007fff3fdc1000) libselinux.so.1 =\u0026gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f30e3f81000)","tags":["ubuntu","linux","openssl"],"title":"OpenSSL 版本不兼容","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  分布式哈希表 DHT Kademlia\n Kademlia: A Peer-to-Peer Information System Based on the XOR Metric 论文阅读 异或度量 节点状态 KAD 协议 路由表 有效的 key re-publishing 优化 DHT 中 KAD 的应用  P2P(peer-to-peer) 技术的应用：文件分享、即时通信、协同处理、流媒体通信等\n P2P 文件分享网络的发展阶段：\n 包含 tracker 服务器的网络 无任何服务器的纯 DHT 网络 混合型 P2P 网络   分布式哈希表 DHT  分布式哈希表(DHT， Distributed Hash Table)，一种分布式存储方法，一类可由键值来唯一标识的信息按照某种约定/协议被分散地存储在多个节点上 不需要服务器，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现正哥 DHT 网络的寻址和存储 可以有效地避免“中央集权式”的服务器(如 tracker)的单一故障而带来整个网络瘫痪 实现 DHT 的算法常用的有 Chord，Pastry，Kademlia  最直接的目标是以最快的速度定位到期望的节点 计算的是某种逻辑上的距离，因为地理距离的计算很复杂   Kademlia Kademlia: A Peer-to-Peer Information System Based on the XOR Metric 论文阅读  特点  最小化节点发送的配置消息：可以通过 key lookup 流程展开配置信息 节点通过低延迟的路径来路由查询 KAD 使用并行、异步查询来避免离线节点的超时   异或度量  每个 KAD 节点有一个 160 比特长的 ID，节点 ID 是随机值  节点发送的每个消息包含自身的节点 ID，允许接收者记录发送者的存在性  键(Key)也是 160 比特的标识符 Kademlia 采用简单的异或计算衡量两节点之间的距离，与地理距离无关：d(x,y)=xor(x,y) 具备几何公式的多数特征  节点和本身的异或距离是 0：d(x,x)=0 异或距离是对称的：d(x,y)=d(y,x) 异或距离符合三角不等式：给定三个顶点 A B C，若 AC 之间的异或距离最大，则 AC 之间的异或必小于等于 AB 异或距离和 BC 异或距离之和 d(x,y)+d(y,z)\u0026gt;=d(x,z) 证明：xor(d(x,y), d(y,z))=d(x,z),且 a+b\u0026gt;=xor(a,b) 对于给定的一个距离，距离 A 只存在唯一的一个节点 B，也即单向性，在查找路径上也是单向的，这个和地理距离不同 已知 x 和 dis, 求 y 使得 dis=xor(x,y)：xor(dis,x)=xor(xor(x,y),x)=y   节点状态  KAD 节点存储其他节点的信息来路由请求消息 每个节点保存一张三元组\u0026lt;IP_addr, UDP_port, Node_ID\u0026gt;链表，记录距离自身2^i到2^(i+1)的节点，称之为k-bucket(k 桶)  k-bucket 存储策略是least-recently seen eviction：最少最近访问的节点放在链表头，最多最近访问的节点放在链表尾 关于 k 值  对于较小的 i，k-bucket 可能为空，即不存在合适的距离较近的节点 对于较大的 i，链表的长度可以增加到 k k 是一个系统范围的参数，是指任意 k 个节点在一个小时内不会全部掉线  关于 k-bucket 的更新  当一个 KAD 节点收到其他节点的消息（请求或者回复）时，节点会更新发送者节点 ID 对应的 k-bucket 信息 如果发送节点已经存在 k-bucket，接收者将其移到链表尾部 如果发送节点不在 k-bucket k-bucket 的元素数目小于 k，接收者将发送节点插入链表尾部 k-bucket 已满，接收者将会 ping 最近最少访问的节点决定如何做  如果最近最少访问的节点没有回复，接收者将该节点从 k-bucket 移除，并将之前的发送者节点插入链表尾部 如果收到最近最少访问的节点的回复，接收者将该节点移到链表尾部，并丢弃之前的发送者节点的信息   k-bucket 不会将 live 的节点从链表移除  在线时间长的节点更值得信任，即下一段时间保持在线的可能性比新访问的节点更大 k-bucket 在某种程度上可以抵制 DOS 攻击，因为节点的路由状态不会被新访问的节点刷新，当旧的节点没有离开系统时，k-bucket 不会插入新的节点    KAD 协议  KAD 协议包括四个 RPC  ping：探测一个节点是否在线 store：指导节点存储一个\u0026lt;key,value\u0026gt;对便于之后的检索 find_node：取一个 160 比特的 ID 作为参数，发送给 k-bucket 的节点，接收者返回已知的距离目标 ID 最近的节点的三元组\u0026lt;IP_addr, UDP_port, Node_ID\u0026gt; 三元组可以来自一个 k-bucket 当最近的 k-bucket 不满时，三元组来自多个 k-bucket RPC 接收者必须返回 k 个元素，当接收者所有的 k-bucket 加起来不到 k 个 节点，则返回它知道的所有节点 find_value：类似于 find_node，当 RPC 接收者收到一个关于 key 的 store RPC，则返回存储的 value 接收者若存储了 key 对应的 value，则返回 value 否则返回距离 key 最近的 k 个节点的信息  node lookup：每个 KAD 的参与者执行的一个最重要的操作就是对于给定的节点 ID，定位 k 个最近的节点  KAD 使用递归的算法查找节点 查找的发起者从它最近的非空 k-bucket 中选择 α 个节点(当 bucket 中节点少于 α，则选择已知的最近的 α 个节点)  α 是系统范围的并发参数 假设发起者是节点 x，x 先计算距离 d=xor(x, ID) x 从第 log2(d)个 k-bucket 中选择 α 个节点，不足 α 个节点时，从附近多个 bucket 中选择距离最接近 d 的一共 α 个节点  查找的发起者发送并行、异步的 find_node RPC 到这 α 个节点 接收者如果发现自己就是 ID，则回答自己是最接近的，否则计算自己和 ID 的距离，从中自己的 k-bucket 中选择 α 个节点返回 发起者收到接收者回复的 k 个节点，再选择未发送过请求的 α 个节点，再次发送 find_node 请求到这 α 个节点  没有回复的节点直接被移除  当所有的 find_node 不再返回比已知的节点更近的节点，查找的发起者发送重新发送 find_node 给所有最近且未查询过的 k 个节点 当发起者查询并且收到 k 个最近的节点的回复，查询终止  存储\u0026lt;key,value\u0026gt;对  参与者定位距离 key 最近的 k 个节点，并发送 store RPC 每个节点间隔一段时间(如 24h)重新发布\u0026lt;key,value\u0026gt;对来保持 alive  查找一个\u0026lt;key,value\u0026gt;对  一个节点先执行 lookup 找到 k 个距离 key 最近的节点 ID 查找 value 使用 find_value RPC 当任意节点返回此 value 时，此流程终止 当查询成功时，发送请求的节点会存储\u0026lt;key,value\u0026gt;对到已知的距离最近且未返回 value 的节点 由于拓扑的无方向性，查询相同的 key 可能会在找到最近的节点之前找到缓存的条目 为了避免对常查找的 key 的\u0026rdquo;over-caching\u0026rdquo;，对于所有节点数据库的\u0026lt;key,value\u0026gt;对设置过期时间，过期时间与当前节点和距离 key 最近的节点之间的节点数成指数反比关系，即越远的节点过期时间越短 数字可以通过当前节点的 bucket 结构推算出来  通常通过请求在节点之间的转发更新 bucket。为了避免某些节点范围不被查询，每个在一小时之内未执行查询节点的节点会更新其所有的 bucket。  刷新意味着从 bucket 中随机选择一个 ID，并且对该 ID 执行一次节点查询  新加入的节点 u 更新自己的 k-bucket  u 选择一个已经加入网络的节点 w 到自己的对应 k-bucket u 对自己的节点 ID 执行一次节点查询 最终，u 更新自己所有的 k-bucket，同时插入自身到其他的一些节点的 k-bucket   路由表  KAD 的路由表是一个二叉树，叶子节点是 k-bucket  每个 k-bucket 包含和 ID 有一些共同前缀的节点，前缀是 k-bucket 在二叉树中的位置 每个 k-bucket 覆盖了 ID 空间的某个范围，所有的 k-bucket 刚好覆盖了整个 160 比特的 ID 空间  路由树的节点根据需要动态分布  一开始，一个节点 u 的路由表有一个节点，一个 k-bucket 覆盖整个 ID 空间 当 u 得到新的联系信息，尝试插入到适合的 k-bucket 当该 bucket 不满，则插入新的联系信息 否则，如果 k-bucket 范围包含节点自身，则将 bucket 分为两个 bucket，再尝试插入适合的 bucket 如果不同范围的 k-bucket 已满，则丢弃新的联系信息   有效的 key re-publishing  之前缓存了\u0026lt;key,value\u0026gt;对的节点可能会掉线，新加入的节点可能比缓存了\u0026lt;key,value\u0026gt;的节点距离 key 更近，因此持有\u0026lt;key,value\u0026gt;的节点需要重复发布 KAD 每隔一个小时会重复发布所有的\u0026lt;key,value\u0026gt;对，以避免缓存过的节点掉线  re-publishing 过程的优化： 每个收到 store RPC 的节点会假定消息已经发送到另外 k-1 个最近的节点，所以接收者不会发布这个消息。因此，当 re-publication 的间隔没有完全同步，每个小时，只有一个节点会 republish 指定的\u0026lt;key,value\u0026gt;对 在 republish 之前避免查找节点。这样，一个节点对所有 k-bucket 的刷新可以分摊到许多的节点的重复发布过程中 每个节点只会在自己的 ID 比其他节点距离 key 更近的情况下发布 store RPC   优化  采用 LRU 策略维持 k-bucket 的联系信息时，为了避免发送过多的 ping 请求阻塞网络， KAD 增加一个替换缓存(Replacement cache)保存新得到的联系信息，当持有有用的信息才会发送 ping 信息给链表中的节点，如果节点没有回复，则从链表中删除该节点，并从替换缓存中找一个最近最多访问的节点插入链表头 因为 KAD 使用 UDP，当网络阻塞的时候，网卡会丢掉一些包。 KAD 会锁住没有回复的联系信息，并不会再给这些联系节点发送 RPC 当一个联系节点连续 5 次没有回复 RPC，其他节点会认为此联系节点是 stale（过时，失去时效），当节点的 k-bucket 不满或者替换缓存为空的时候， KAD 不会从 k-bucket 移除这个联系节点，而是将其置为 stale。这样保证了一个节点自身的网络连接暂时断掉的时候，不会将自身所有的 k-bucket 置为无效。（什么时候再置为有效呢？？？） 减少查找节点的跳跃数：增加路由表的 size，即每次根据 b 个比特位来查找临近节点发送请求。但是这样会增加维护难度  DHT 中 KAD 的应用  每个节点的 ID 和种子文件的 info_hash 采用 sha-1 算法，节点和种子(\u0026lt;key,value\u0026gt;)的距离就是节点 ID 和 info_hash 的异或距离 每个节点按照距离自己的异或远近将所有的节点划分成 160 棵子树，表示其他节点 ID 和自身 ID 的共同前缀的比特数的范围 0-159  每个节点的各个 k-bucket 记录了每个子树中的 k 个节点信息  每个新加入 DHT 网络的节点更新路由表的步骤  如本节点曾经启动过，则从保存的“路由表”文件中直接读取然后刷新“路由表” 如果节点第一次启动，且节点有“超级节点”，则通过这些“超级节点”来间接地生成自己的“路由表” 如果节点第一次启动且没有“超级节点”，则路由表生成过程需要推迟到 download 文件过程。节点从获取到的种子文件提取 nodes 字段，通过这些 nodes 字段中的节点来间接生成自己的路由表 该 nodes 字段是做种子（支持 DHt 网络的种子）的时候生成的 一般 nodes 字段设置为原始种子的 ip 和 port，或者是做种子的节点离该种子的 info-hash 最近的 k 个节点 动态建立过程：节点经过初始化后，在下载、上传或无任务过程中收到任何节点发送的消息，都会检查当前的“路由表”并尝试按照一定的规则去建立/刷新路由表  tracker：对每一个分享文件（种子）维护一个 peers 列表，告诉需要下载的询问者 client DHT 查找类型包括  find_nodes：是为了建立路由表。节点 x 查找节点 y 的过程 x 从 xor(x,y) 对应的本地 k-bucket 中得到 k 个比较近的节点 x 向上面找到的 k 个节点发送消息查找节点 y 收到请求的节点从自己的 k-bucket 中找到更近的 k 个节点返回给 x x 从收到的回复中选择 k 个最近的节点再次发送请求 当 x 收到的回复的节点中没有更近的节点停止查找  x 最后得到 k 个距离 y 最近的节点 在此过程中，x 会尝试将得到的节点插到自己的路由表中  get_peers：与 find_nodes 类似，但是查找的参数不是节点 ID，而是 info_hash 在查找过程中，收到任意\u0026lt;info_hash, peers_list\u0026gt;回复就停止查找 得到 peers_list之后，节点会试图给每个 peer 主动发起 TCP 的连接，之后开始下载，同时会把自己的 peer 信息发送给 k 个距离自己最近的节点存储 \u0026lt;info_hash, peers_list\u0026gt;信息  k 个节点保存该信息 24 小时，期间没有收到 x 的更新消息则信息失效    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"89c51f13504cd044fb81014dcc9fa4b9","permalink":"https://xueqing.github.io/blog/p2p/p2p%E5%8F%8Adht/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/p2p/p2p%E5%8F%8Adht/","section":"blog","summary":"分布式哈希表 DHT Kademlia Kademlia: A Peer-to-Peer Information System Based on the XOR Metric 论文阅读 异或度量 节点状态 KAD 协议 路由表 有效的 key re-publishing 优化 DHT 中 KAD 的应用 P2P(peer-to-peer) 技术的应用：文件分享、即时通信、协同处理","tags":["p2p"],"title":"P2P 中 DHT 网络介绍","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 1 使用模块 XML::Simple。XML::Simple 能够解析一个 XML 文件并在以一个 Perl 哈希引用返回数据。在这个哈希中，来自原始 XML 文件的元素作为键，而它们之间的 CDATA 作为值。一旦XML::Simple 处理完一个 XML 文件，XML 文件的内容就可以使用标准 Perl 数组表示法检索。 2 安装步骤，进入命令行执行：  1 perl -MCPAN -e shell 2 install XML::Simple  3 脚本内容\n#!/usr/bin/perl # use module use XML::Simple; if($#ARGV \u0026lt; 1) { print \u0026quot;Usage: ./parsexml.pl filename parseparam\\n\u0026quot;; exit(0); } $filename = $ARGV[0]; $parseparam = $ARGV[1]; #print \u0026quot;Input param [filename=$filename] [parseparam=$parseparam]\\n\u0026quot;; # create object $xml = new XML::Simple; # read XML file my $doc = $xml-\u0026gt;XMLin($filename); # access XML data print \u0026quot;$doc-\u0026gt;{$parseparam}\\n\u0026quot;;  4 执行脚本\n 1 添加可执行权限：chmod +x parsexml.pl 2 执行：./parsexml.pl filename parseparam   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1eea58fbd511e2029562fc2f7184559a","permalink":"https://xueqing.github.io/blog/shell/perl/perl%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/shell/perl/perl%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/","section":"blog","summary":"1 使用模块 XML::Simple。XML::Simple 能够解析一个 XML 文件并在以一个 Perl 哈希引用返回数据。在这个哈希中，来自原始 XML 文件的元素作","tags":["shell","perl"],"title":"perl 脚本解析 xml 文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  QtCreator pro 文件参数 QtCreator 帮助文档 QtCreator 使用  QtCreator pro 文件参数    参数 含义     TARGET 应用程序名.默认是跟工程文件名一样 (根据不同的平台后缀名会自动添加)   TEMPLATE 模板变量指定生成 makefile (app: 应用程序; lib:库)   QT 使用到的 Qt 定义的类 (core/gui/widgets\u0026hellip;)   CONFIG 指定项目配置和编译器选项   DESTDIR 指定位置放目标文件   DEFINES 程序编译时候需要的预定义的宏列表   HEADERS 程序中需要编译的头文件列表   SOURCES 程序中需要编译的源文件列表   FORMS 由 Qt Designer 为程序创建的 ui 文件列表   RESOURCES 工程中包含的资源文件   INCLUDEPATH 程序需要的头文件的目录列表   LIBS 引入的其他的库, -L: 引入路径   QMAKE_CFLAGS 设置 c 编译器 flag 参数   QMAKE_CXXFLAGS 设置 c++ 编译器 flag 参数   QMAKE_LFLAGS 设置链接器 flag 参数    备注\n 路径不要有空格和中文  QtCreator 帮助文档  qmake Manual \u0026gt; Variables  QtCreator 使用  Manage Kits build/run qml environment 添加文件到工程 新建类 find/replace compile output  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"118d1bb4936ee950636de4a1673fc4e3","permalink":"https://xueqing.github.io/blog/qt/qtcreator/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/qt/qtcreator/","section":"blog","summary":"QtCreator pro 文件参数 QtCreator 帮助文档 QtCreator 使用 QtCreator pro 文件参数 参数 含义 TARGET 应用程序名.默认是跟工程文件名一样 (根据不同的平台后缀名会自动添加) TEMPLATE 模板变量指定生成 makefile (app:","tags":["qt"],"title":"QtCreator 一些基本的配置参数说明","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  概述 索引  参考 Golang 官网文档 学习。\n导入语句：import \u0026quot;testing/quick\u0026quot;\n概述 quick 包实现了帮辅助黑盒测试的工具函数。\ntesting/quick 包被冻结，且不再接受新特性。\n索引 参考\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"083c90316707ced2ed6b4ab3d70dcff3","permalink":"https://xueqing.github.io/translation/go-doc/golangpkg/quick/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangpkg/quick/","section":"translation","summary":"概述 索引 参考 Golang 官网文档 学习。 导入语句：import \u0026quot;testing/quick\u0026quot; 概述 quick 包实现了帮辅助黑盒测试的工具函数。 testing/quick 包被冻结，且不再接受新特性。 索引 参考","tags":["golang-pkg"],"title":"quick 包","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  1 安装依赖 2 安装 RabbitMQ 3 启用 RabbitMQ 管理控制台  3.1 创建用户并设置角色  4 RabbitMQ 服务命令 5 修改服务配置文件  1 安装依赖 # 添加 erlang 源到 apt 仓库 wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb sudo dpkg -i erlang-solutions_1.0_all.deb # 更新安装 sudo apt-get update sudo apt-get install erlang  2 安装 RabbitMQ # 调用官方安装脚本 curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.deb.sh | sudo bash # 添加 RabbitMQ 签名 (会出现 403 错误，可忽略不运行) wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add - # 更新并安装 sudo apt-get update #（可忽略不运行） sudo apt-get install rabbitmq-server  3 启用 RabbitMQ 管理控制台 启用管理插件和 STOMP 插件:\nsudo rabbitmq-plugins enable rabbitmq_management rabbitmq_stomp # 重启服务器 sudo systemctl restart rabbitmq-server  登录 http://localhost:15672 web管理页面 默认提供 guest 账号(密码：guest)，但是该账号只提供 localhost 登录，所以需要单独创建用户，使用 rabbitmqctl。 用户相关命令如下：\n$ sudo rabbitmqctl help | grep user add_user \u0026lt;username\u0026gt; \u0026lt;password\u0026gt; # 创建用户 delete_user \u0026lt;username\u0026gt; # 删除用户 change_password \u0026lt;username\u0026gt; \u0026lt;newpassword\u0026gt; # 修改密码 clear_password \u0026lt;username\u0026gt; # 清楚密码，直接登录 authenticate_user \u0026lt;username\u0026gt; \u0026lt;password\u0026gt; # 测试用户认证（我也不知道2333） set_user_tags \u0026lt;username\u0026gt; \u0026lt;tag\u0026gt; ... # 设置用户权限 [] list_users set_permissions [-p \u0026lt;vhost\u0026gt;] \u0026lt;user\u0026gt; \u0026lt;conf\u0026gt; \u0026lt;write\u0026gt; \u0026lt;read\u0026gt; clear_permissions [-p \u0026lt;vhost\u0026gt;] \u0026lt;username\u0026gt; list_user_permissions \u0026lt;username\u0026gt;  3.1 创建用户并设置角色 创建管理员用户，负责整个 MQ 的运维：\n# 添加用户 sudo rabbitmqctl add_user admin admin # 赋予其 administrator 角色 sudo rabbitmqctl set_user_tags admin administrator # 为用户赋权 sudo rabbitmqctl set_permissions -p / admin '.*' '.*' '.*' # 查看权限 sudo rabbitmqctl list_user_permissions admin  4 RabbitMQ 服务命令 # 启动服务 # sudo service rabbitmq-server start sudo systemctl start rabbitmq-server # 停止服务 sudo systemctl stop rabbitmq-server # 重启服务 sudo systemctl restart rabbitmq-server # 检查服务状态 sudo systemctl status rabbitmq-server  5 修改服务配置文件 # 如果需要管理最大连接数，修改配置文件 sudo vim /etc/default/rabbitmq-server  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2b26f17b9f0578bba9ecef9cd2b94da1","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_mq/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_mq/","section":"blog","summary":"1 安装依赖 2 安装 RabbitMQ 3 启用 RabbitMQ 管理控制台 3.1 创建用户并设置角色 4 RabbitMQ 服务命令 5 修改服务配置文件 1 安装依赖 # 添加 erlang 源到 apt 仓库 wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb sudo dpkg -i erlang-solutions_1.0_all.deb # 更新安装 sudo apt-get","tags":["ubuntu","linux"],"title":"RabbitMQ 环境搭建","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  概念 使用 RAII 例子 标准库 注解 参考  概念 资源获取即初始化（Resource Acquisition Is Initialization），或称 RAII，是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期绑定与一个对象的生存期相绑定。\n使用 RAII  RAII 保证资源可用于任何会访问该对象的函数（资源可用性是一种类不变式，这会消除冗余的运行时测试）。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性（对象生存期、退出作用域、初始化顺序以及栈回溯）以消除内存泄漏并保证异常安全。根据 RAII 对象的生存期在退出作用域时结束这一基本状况，此技术的另一名称是作用域界定的资源管理（ Scope-Bound Resource Management，SBRM）。\n RAII 可总结如下:\n 将每个资源封装入一个类，其中 构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常 析构函数释放资源并决不抛出异常 始终经由 RAII 类的实例使用满足要求的资源，该资源 自身拥有自动存储期或临时生存期，或 具有与自动或临时对象的生存期绑定的生存期  移动语义使得在对象间、跨作用域，以及在线程内外安全地移动所有权，而同时维护资源安全成为可能。\n  例子 拥有 open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy() 成员函数的类是非 RAII 类的典型的例子\nstd::mutex m; void bad() { m.lock(); // 请求互斥体 f(); // 若 f() 抛异常，则互斥体永远不被释放 if(!everything_ok()) return; // 提早返回，互斥体永远不被释放 m.unlock(); // 若 bad() 抵达此语句，互斥才被释放 } void good() { std::lock_guard\u0026lt;std::mutex\u0026gt; lk(m); // RAII类：互斥体的请求即是初始化 f(); // 若 f() 抛异常，则释放互斥体 if(!everything_ok()) return; // 提早返回，互斥体被释放 } // 若 good() 正常返回，则释放互斥体  标准库  C++ 标准库遵循 RAII 管理其自身的资源：std::string、std::vector、std::thread，以及多数其他类在构造函数中获取其资源（错误时抛出异常），并在其析构函数中释放之（决不抛出），而不要求显式清理。 另外，标准库提供几种 RAII 包装器以管理用户提供的资源：  std::unique_ptr 及 std::shared_ptr 用于管理动态分配的内存，或以用户提供的删除器管理任何以普通指针表示的资源 std::lock_guard、std::unique_lock、std::shared_lock 用于管理互斥体   注解 RAII 不适用于并非在使用前请求的资源：CPU 时间、核心，以及缓存容量、熵池容量、网络带宽、电力消费、栈内存等。\n参考  RAII  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1775799c6d24e8f867cab3ad896a9a24","permalink":"https://xueqing.github.io/blog/cplusplus/raii/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/raii/","section":"blog","summary":"概念 使用 RAII 例子 标准库 注解 参考 概念 资源获取即初始化（Resource Acquisition Is Initialization），或称 RAII，是一种 C++ 编程技术，它将必","tags":["c++"],"title":"RAII 资源获取即初始化","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"```go /* Exercise: Readers Implement a Reader type that emits an infinite stream of the ASCII character \u0026lsquo;A\u0026rsquo;. */\npackage main\nimport \u0026ldquo;golang.org/x/tour/reader\u0026rdquo;\ntype myReader struct{}\nfunc (r myReader) Read(c []byte) (int, error) { i := 0 for ; i \u0026lt; len\u0026copy;; i++ { c[i] = \u0026lsquo;A\u0026rsquo; } for ; i \u0026lt; cap\u0026copy;; i++ { c = append(c, \u0026lsquo;A\u0026rsquo;) }\nreturn cap(c), nil  }\nfunc main() { reader.Validate(myReader{}) }\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"abf0cd1a172a86b8bb76a4459b3a9fcc","permalink":"https://xueqing.github.io/translation/go-doc/gotour/reader/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/reader/","section":"translation","summary":"```go /* Exercise: Readers Implement a Reader type that emits an infinite stream of the ASCII character \u0026lsquo;A\u0026rsquo;. */\npackage main\nimport \u0026ldquo;golang.org/x/tour/reader\u0026rdquo;\ntype myReader struct{}\nfunc (r myReader) Read(c []byte) (int, error) { i := 0 for ; i \u0026lt; len\u0026copy;; i++ { c[i] = \u0026lsquo;A\u0026rsquo; } for ; i \u0026lt; cap\u0026copy;; i++ { c = append(c, \u0026lsquo;A\u0026rsquo;) }\nreturn cap(c), nil  }\nfunc main() { reader.Validate(myReader{}) }","tags":["go-tour"],"title":"Readers","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  1 安装 redis-server 2 命令  2.1.1 关于 key 的命令 2.1.2 关于 hash 的命令  3 开启远程访问并加密访问 4 参考  1 安装 redis-server sudo apt-get install redis-server  2 命令 # 查看 redis 的版本 redis-server -v # 重启 redis 服务 sudo service redis-server restart # 进入 redis redis-cli auth admin # 查看 redis 内存，即获取 redis 中所有的 key keys * # 退出 redis exit  2.1.1 关于 key 的命令 # 查找所有符合给定模式 pattern 的 key keys pattern # del 命令用于删除已存在的键。不存在的 key 会被忽略 del key_name  2.1.2 关于 hash 的命令 # hgetall 命令用于返回哈希表中，所有的字段和值 # 在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍 # 若 key 不存在，返回空列表 hgetall key_name # hget 命令用于返回哈希表中指定字段的值 # 如果给定的字段或 key 不存在时，返回 nil hget key_name field_name  3 开启远程访问并加密访问 sudo vim /etc/redis/redis.conf # 开启远程访问 # 注释掉 bind 127.0.0.1 # 如果有其他 bind 语句也注释 ## 配置外网访问需要修改 Linux 防火墙(iptables)，开启 redis 端口 # -A INPUT -m state -state NEW -m tcp -p tcp -dport 6379 -j ACCEPT # ... # -A INPUT -j REJECT -reject-with icmp-host-prohibited # 执行 service iptables restart # 加密访问 # 打开注释 requirepass xxxxx，并且把密码 xxxx 改为 admin   不建议在公网访问 redis，因为 redis 处理速度非常快。所以如果密码简单，外部用户可通过暴力破解密码  4 参考  Redis 教程  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e2b06ba9a808ac20e90856df841ca559","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_redis/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_redis/","section":"blog","summary":"1 安装 redis-server 2 命令 2.1.1 关于 key 的命令 2.1.2 关于 hash 的命令 3 开启远程访问并加密访问 4 参考 1 安装 redis-server sudo apt-get install redis-server 2 命令 # 查看 redis 的版本 redis-server -v # 重启 redis 服务 sudo service redis-server restart # 进入 redis","tags":["ubuntu","linux"],"title":"redis 环境搭建","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"原文\nreStructuredText 入门 ====================== :作者: kiki :日期: 2019/11/6 翻译 原文__。 __ http://docutils.sourceforge.net/docs/user/rst/quickstart.html :作者: Richard Jones :修订: 5801 :版权: 此文档放置在公共域。 .. contents:: 目录 下面的文本包含看似 “(快速参考__)” 的链接。这些是指向 `快速学习 reStructuredText`_ 用户手册的相对链接。如果这些链接不生效，请参考 主快速参考_ 文档。 __ .. _快速学习 reStructuredText: http://docutils.sourceforge.net/docs/user/rst/quickref.html .. _主快速参考: http://docutils.sourceforge.net/docs/user/rst/quickref.html .. Note:: 此文档是对 reStructuredText 的一个非正式介绍。下面的章节 `下一步是什么?`_ 包含一些进一步的资源的链接，包含一个正式的参考。 结构 ----- 一开始，让我说一下“结构化的文本”可能有一点用词不当。它更像使用一些一致模式的“松散的文本”。这些模式被一个 HTML 转换器解释生成“非常结构化的文本”，且能被 web 浏览器使用。 识别的最基本模式是 **段落** (快速参考__)。段落是使用空行(一个就足够)分隔的文本块。段落必须有相同的缩进——也就是说，同一段落的行左边是对齐的。开始缩进的段落会生成缩进的引用段。比如:: 这是一个段落。它非常 短。 这一段会生成一个缩进的文本块，通常用来引用其他文本。 这是另一个段落。 生成: 这是一个段落。它非常短。 这一段会生成一个缩进的文本块，通常用来引用其他文本。 这是另一个段落。 __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#paragraphs 文本风格 -------- (快速参考__) __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#inline-markup 在段落和其他文本体内，你可以增加标记文本：使用 “``*斜体*``” 表示 *斜体*；使用 “``**粗体**``” 表示 **粗体**。这叫做“内联标记”。 如果你想使一些内容显示为固定空格的字面量，使用 “````双反引号````”。注意双反引号内部不支持进一步标记——因此星号 “``*``” 等不会被解释。 如果你发现 你想要在文本中使用其中一个“特殊的”字符，它通常是可以的—— reStructuredText 非常智能。比如，这个单独的星号 * 处理的很好，正如这个等式的星号：5*6=30。如果你想要 \\*被星号包围的* 文本 **不要** 显示为斜体，那么你需要指明这个星号不是特殊的。你通过在星号之前放置一个反斜线实现，比如 “``\\*``” (快速参考__)，或者通过使用双反斜线(内联标记)包围它，像这样:: ``*`` __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#escaping .. Tip:: 将内联标记视作 (括号) 的一种形式，并按相同的方式使用它：在被标记的文本前后立即使用。内联标记本身(使用空格包围)或在一个单词中间的内联标记不会被解释。查看 标记规范__ 获取更多细节。 __ http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#inline-markup 列表 ---- 列表项有三种主要形式：**枚举的**、**符号的** 和 **定义**。在所有列表情形中，你可以有任意多的段落、子列表等，只要段落或其他内容和该列表项的第一行文本左对齐。 列表必须总是以新段落开始——也就是说，它们必须出现在一个空行之后。 **枚举** 列表(数字、字母或罗马数字；快速参考__)。 __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#enumerated-lists 开始一行，一个数字或字母，跟一个英文句号 “.”，或者右括号 “)”，或者使用括号 “()” 包围——选择你喜欢的。下面所有的格式都可以识别:: 1. 数组 A. 大写字母 且它可以跨很多行 也可以有两个段落 a. 小写字母 3. 用一个不同的数字开始一个子列表 4. 但是确保数字是正确的顺序 I. 大写罗马数字 i. 小写罗马数字 (1) 又是数字 1) 又是数字 生成(注意：不同的枚举列表风格并不总是被每种 web 浏览器支持，因此你可能不会得到下面这样完全的效果)： 1. 数组 A. 大写字母 且它可以跨很多行 也可以有两个段落 a. 小写字母 3. 用一个不同的数字开始一个子列表 4. 但是确保数字是正确的顺序 I. 大写罗马数字 i. 小写罗马数字 (1) 又是数字 1) 又是数字 **符号** 列表(快速参考__) __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#bullet-lists 正如枚举列表，使用一个符号字符—— “-”、“+” 或 “*”:: * 使用 “*” 的一个符号 - 使用 “-” 的一个子列表 + 另外一个子列表 - 另一个项目 导致: * 使用 “*” 的一个符号 - 使用 “-” 的一个子列表 + 另外一个子列表 - 另一个项目 **定义** 列表(快速参考__) __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#definition-lists 和其他两个列表不同，定义列表由术语和术语的定义组成。一个定义列表的格式如下:: 什么 定义列表关联一个术语和一个定义。 *如何* 这个术语是一个单行短于，且定义是一个或多个 段落或文档元素，相对术语进行缩进。 空行不允许出现在术语和定义中间。 生成: 什么 定义列表关联一个术语和一个定义。 *如何* 这个术语是一个单行短语，且定义是一个或多个 段落或文档元素，相对术语进行缩进。 空行不允许出现在术语和定义中间。 预格式化(代码示例) ------------------ (快速参考__) __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#literal-blocks 只想要包含一个预格式化的、永远不会被摆弄的文本块，使用 “``::``” 结束前一段。当文本和被预格式化块的前一段落缩进相同时，预格式化块结束。比如:: 一个例子:: 空格、换行、空行和所有类型的标记 (比如 *这个* 或 \\这个) 按照字面块保留。 看这，我已经减少了一个缩进等级 (但是不够远) 没有其他例子 生成: 一个例子:: 空格、换行、空行和所有类型的标记 (比如 *这个* 或 \\这个) 按照字面块保留。 看这，我已经减少了一个缩进等级 (但是不够远) 没有其他例子 注意如果一个段落只包含 “``::``” ，那么它在输出时被删除:: :: 这是一个预格式化文本，且 最后的 \u0026quot;::\u0026quot; 段被移除 生成: :: 这是一个预格式化文本，且 最后的 \u0026quot;::\u0026quot; 段被移除 章节 ---- (快速参考__) __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#section-structure 想要将较长的文本分为整洁，你使用 **章节标题**。有一个单行的文本(一个或多个单词)带有修饰符：只有下换线，或者一个下划线和一个上划线一起，用破折号 “``-----``”、等号“``=====``”、波形号“``~~~~~``” 或任一你喜欢的非字母表字符 ``= - ` : ' \u0026quot; ~ ^ _ * + # \u0026lt; \u0026gt;``。一个只有下划线的修饰符和使用同一字符的上划线加下划线修饰符不同。下划线/上划线必须不短于标题文本。一致起见，因为所有使用同一个修饰符风格标记的章节被认为是同一等级:: 章 1 标题 =========== 节 1.1 标题 ----------- 子节 1.1.1 标题 ~~~~~~~~~~~~~~~ 节 1.2 标题 ----------- 章 2 标题 ========== 这会生成下面的结构，用一个简单的伪 XML 示意:: \u0026lt;节\u0026gt; \u0026lt;标题\u0026gt; 章 1 标题 \u0026lt;节\u0026gt; \u0026lt;标题\u0026gt; 节 1.1 标题 \u0026lt;节\u0026gt; \u0026lt;标题\u0026gt; 子节 1.1.1 标题 \u0026lt;节\u0026gt; \u0026lt;标题\u0026gt; 节 1.2 标题 \u0026lt;节\u0026gt; \u0026lt;标题\u0026gt; 章 2 标题 (伪 XML 使用缩进表示嵌套，且没有结束标记。不可能像其他例子一样展示实际的处理输出，因为章节不能再块引用中存在。对于一个抽象的自理，比较这个文档的源文本章节结构和处理的输出。) 注意章节标题可当做链接目标使用，只需要使用它们的名字。要链接到 列表_ 标题，我写入 “``列表_``”。如果标题中有一个空格，我们需要使用 “```列 表`_``” 引用标题。 文档标题/子标题 ~~~~~~~~~~~~~~~ 整个文档的标题和其他章节标题不同，且可能被不同地格式化(比如，HTML 默认显示为一个居中的标题)。 想要在 reStructuredText 中指明文档标题，在文档开头使用一个唯一的修饰符风格。需要指明文档的子标题，在文档标题之后立即使用另外一种唯一的修饰符风格。比如:: ======== 文档标题 ======== ------ 子标题 ------ 章节标题 ======== ... 注意上述的 “文档标题” 和 “章节标题” 都是要等号标记，但是是不同且不相关的风格。可出于美学插入上划线和下划线文本标题(而不是只有下划线)。 图像 ----- (快速参考__) __ http://docutils.sourceforge.net/docs/user/rst/quickref.html#directives 想要在你的文档中包含一个图像，你使用 ``图像`` 指令__。比如:: .. image:: images/biohazard.png 生成: .. image:: images/biohazard.png ``images/biohazard.png`` 部分 指示你希望出现在文本中的图像的文件名。对于图像(格式、大小等)没有限制。如果图像要出现在 HTML 中且你希望提供足够多的信息，你可以:: .. image:: images/biohazard.png :height: 100 :width: 200 :scale: 50 :alt: 可选文本 查看完整的 图像指令文档__ 获取更多信息 __ http://docutils.sourceforge.net/docs/ref/rst/directives.html __ http://docutils.sourceforge.net/docs/ref/rst/directives.html#images 下一步是什么? ------------- 这篇入门介绍了 reStructuredText 最常见的特性，但是还有很多要探索。`快速学习 reStructuredText`_ 用户手册是下一步学习的好地方。获取完整的细节，去查看 `reStructuredText 标记规范`_ [#]_。 关于 Docutils 或 reStructuredText 有疑问或者需要帮助的用户应该提交一个信息到 `Docutils 用户`_ 邮件列表。 .. [#] 如果相关链接不生效，尝试主文档: http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html。 .. _reStructuredText 标记规范: http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html .. _Docutils 用户: http://docutils.sourceforge.net/docs/user/mailing-lists.html#docutils-users  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e3ee6024bf3b5958f8b5329afc406fcf","permalink":"https://xueqing.github.io/blog/rest/quickstart/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/rest/quickstart/","section":"blog","summary":"原文 reStructuredText 入门 ====================== :作者: kiki :日期: 2019/11/6 翻译 原文__。 __ http://docutils.sourceforge.net/docs/user/rst/quickstart.html :作者: Richard Jones :修订: 5801 :版权: 此文档放置在公共域。 .. contents:: 目录 下面的文本包含看似 “(快速参考_","tags":["rest"],"title":"reStructuredText 入门","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" INFO 消息的目的是沿着 SIP 信令通路携带应用层信息。INFO 不用来改变 SIP 呼叫的状态，也不改变 SIP 初始化的会话的状态 信息可以放在 INFO 消息的头或者作为消息体的一部分 如果找不到对应的会话，UAS 必须回复 481 如果接收 INFO 请求的服务可以理解消息体，但是没有处理规则，应当回复 200，可以将消息体展示给用户 如果接收 INFO 请求的服务不能理解消息体，也没有处理规则，应当回复 415 INFO 请求可以被取消。收到 CANCEL 一个 INFO 的请求，UAS 如果还没有回复 INFO，应当返回 487，并不再处理对应的 INFO 请求  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d2a151698bc328ff989528e5dc0d1ce0","permalink":"https://xueqing.github.io/blog/sip/rfc2976_the_sip_info_method_reading/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/rfc2976_the_sip_info_method_reading/","section":"blog","summary":"INFO 消息的目的是沿着 SIP 信令通路携带应用层信息。INFO 不用来改变 SIP 呼叫的状态，也不改变 SIP 初始化的会话的状态 信息可以放在 INFO 消息的头或者作为消息体","tags":["sip"],"title":"rfc2976: The SIP INFO Method","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  请求的消息头 回复的消息头 消息 处理应答 Invite 客户事务 应答代码  请求的消息头  举例：以 Alice 向 Bob 发起会话为例\nINVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhds Max-Forwards: 70 To: Bob \u0026lt;sip:bob@biloxi.com\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.com\u0026gt;;tag=1928301774 Call-ID: a84b4c76e66710@pc33.atlanta.com CSeq: 314159 INVITE Contact: \u0026lt;sip:alice@pc33.atlanta.com\u0026gt; Content-Type: application/sdp Content-Length: 142 (Alice’s SDP not shown)      名称 描述     Method name 位于第一行(INVITE sip:bob@biloxi.com SIP/2.0)   Via 描述当前请求经历的路径，表示了应答所应当经过的路径。包含请求发起者期待收到回复的地址(pc33.atlanta.com)。包含一个 branch 参数标识会话(branch=z9hG4bK776asdhds)，branch 必须以 \u0026ldquo;z9hG4bK\u0026rdquo; 开头。缩写是 v   To 包含一个展示名(Bob)和一个 SIP 或 SIPS URI(sip:bob@biloxi.com)，标识请求原本要发送的目的地。缩写是 t   From 包含一个展示名(Alice)和一个 SIP 或 SIPS URI(sip:alice@atlanta.com)，指示请求的发起者。也包含一个 tag 参数，包含一个随机的字符串。用于身份目的。简写是 f   Call-ID 包含此会话的一个全局唯一标识符，由一个随机字符串和这个 softphone 的主机名或 IP 地址联合生成   CSeq Command Sequence，包含一个整数和一个方法名。在一个会话中，每一个新的请求，CSeq 会加 1   Contact 包含一个 SIP 或 SIPS URI，表示直接路由到此请求发起者，通常是一个 FQDN(fully qualified domain name) 上的一个用户名。如果没有注册域名，可以使用 IP 地址   Max-Forwards 限制一个请求到达目的地的转发次数。每跳一次数目减 1   Content-Type 描述请求的消息体，简写是 c   Content-Length 请求的消息体的十进制字节数，简写是 I     To tag，From tag 和 Call-ID 完全定义了一个端到端的 SIP 关系，称为一个会话 Via 告诉其它元素回复发送到哪里；Contact 告诉其它元素未来的请求发送到哪里 回复和请求包含一样的 To，From，Call-ID，CSeq，Via 的 branch 代理服务：atlanta.com SIP server 是一个代理服务。代理服务接收 SIP 请求，代表请求者转发请求  100 (Trying)：表示代理服务已经收到请求，正在代表请求者路由请求到目的地 代理服务器路由之前，会在 Via 加上或者删掉自己的地址信息   其他头域\n   名称 描述     Route 用于强制一个请求经过一个 proxy 路由列表，保证正确路由   Record-Route proxy 在请求中增加的，包含解析代理主机名或 IP 地址的 URI，用于强制会话中的后续请求经过本 proxy   Content-Encoding 如果消息正文通过某种形式的编码，如压缩等，必须在此头域指明，简写是 e   Content-Language 消息正文的语言   Content-Disposition 指明消息体部分并非可选的消息体，描述消息体，或者消息的多个部分，或者消息体的一部分应被 UAC 或 UAS 怎样解释   Supported 包含了一个 option tag 的列表，列举了 UAC 或 UAS 支持的 SIP 扩展，必须是 RFCs 的标准扩展。缩写是 k   Require 说明处理本特定请求需要什么样的 option tags，以便 UAS 可以处理 UAC 的特定请求   Proxy-Require 说明需要 proxy 支持什么样的 option tag 扩展   Unsupported UAS 回复中，表明不支持的扩展   Accept UAS 指明支持的媒体类别   Accept-Encoding UAS 指明支持的编码方法   Accept-Language UAS 指明支持的语言   Allow UAS 列举支持的方法   expires 有效时间，以秒为单位的整数，非法值视为 3600   Retry-After 可用于 500 或 503 应答，标识大约服务还会处于不可用状态多久；在 404,413,480,486,600,603 应答标识何时被叫方会恢复正常，以秒为单位   Warning UAS 回复中，表明拒绝服务的原因，包括一个 3 位的警告代码，主机名和警告正文   In-Reply-To 列举了本次呼叫相关的或者返回的 Call-ID   Min-Expires 包含了一个服务器所支持的内部状态(soft-state)的最小的刷新时间间隔，包括被注册服务器所注册的 Contact 头域   Organization 包含了发出请求或者应答的 SIP 节点所属的组织名字。可以用于让客户端软件过滤呼叫   Priority 标识了客户端请求的紧急程度，描述了 SIP 应当处理人工或者 UA 发过来的请求的优先级   Proxy-Authenticate 认证使用   Proxy-Authorization 允许客户端向一个要求认证的 proxy 证明自己(或证明它的使用者)的身份   WWW-Authenticate 包含了认证信息   Server 包含了关于 UAS 处理请求所使用的软件信息   Subject 提供了呼叫的一个概览，允许呼叫不用分析会话描述就可以大致过滤。缩写是 s   Timestamp 描述了 UAC 发送请求到 UAS 的时间戳   User-Agent 包含了发起请求的 UAC 信息    回复的消息头  举例：以 Bob 回复 Alice 为例\nSIP/2.0 200 OK Via: SIP/2.0/UDP server10.biloxi.com ;branch=z9hG4bKnashds8;received=192.0.2.3 Via: SIP/2.0/UDP bigbox3.site3.atlanta.com ;branch=z9hG4bK77ef4c2312983.1;received=192.0.2.2 Via: SIP/2.0/UDP pc33.atlanta.com ;branch=z9hG4bK776asdhds ;received=192.0.2.1 To: Bob \u0026lt;sip:bob@biloxi.com\u0026gt;;tag=a6c85cf From: Alice \u0026lt;sip:alice@atlanta.com\u0026gt;;tag=1928301774 Call-ID: a84b4c76e66710@pc33.atlanta.com CSeq: 314159 INVITE Contact: \u0026lt;sip:bob@192.0.2.4\u0026gt; Content-Type: application/sdp Content-Length: 131 (Bob’s SDP not shown)      名称 描述     响应码和原因短语 位于第一行，如 200 和 OK   Via 和请求相同，多的两个是二者的代理服务分别添加的   To 和请求相同，添加了 tag 参数，会话双方在未来的通讯中会用这两个 tag   From 和请求相同   Call-ID 和请求相同   CSeq 和请求相同   Contact 包含回复一方可以直接到达的 URI   Content-Type 描述回复的消息正文，包括消息的媒体类别   Content-Length 回复的消息正文的十进制字节数    消息  SIP 协议基于文本，使用 utf-8 字符集 每个消息包括一个起始行，一个或多个头域，一个空行标识头域的结束，一个可选的消息体\n CRLF：carriage-return(回车) line-feed(换行) SP: space，空格 请求的开始行是 Request-Line 回复的开始行是 Status-Line 客户端不要求检查或显示 reason-phrase HCOLON = *(SP/HTAB) \u0026quot;:\u0026quot; SWS允许在冒号之前有空白，但是不允许有行分隔符，并且允许在冒号之后有空白，或者行分隔符 推荐冒号之前无空格，冒号之后有一个空格 HTAB 水平制表符，即 Tab 键 LWS = [*WSP CRLF] 1*WSP 线性空白 SWS = [LWS] 线性空白可选 不同的 header-name 的顺序是无关的，但是建议将代理处理流程相关的域放在前面；相同的 header-name 的顺序是有关的\ngeneric-message = start-line *message-header CRLF [ message-body ] start-line = Request-Line / Status-Line Request-Line = Method SP Request-URI SP SIP-Version CRLF Status-Line = SIP-Version SP Status-Code SP Reason-Phrase CRLF message-header = \u0026quot;header-name\u0026quot; HCOLON header-value *(COMMA header-value)    处理应答  UAC 对于不能识别的最终响应，必须将其视为对应的 x00 类的响应代码，且 UAC 必须能够处理所有的 x00 响应代码 UAC 必须能够处理 100 和 183 (会话进行) 响应 在应答中，有不止一个 Via 头域值存在，UAC 应该丢弃这个消息。包含超过一个 Via 头域值的消息是因为被错误的路由或者消息被破坏  Invite 客户事务  T1：是一个估计的循环时间（round-trip time，RTT），缺省设置为 500ms  应答代码  临时应答 1xx：标志了对方服务器正在处理请求，还没有决定最后应答。如果服务需要 200ms 以上才可产生最终应答，应发送一个 1xx 应答。1xx 不是可靠传输的，不会导致客户端发送 ACK。可以包含消息体，描述会话     应答码 描述     100 Trying 表示下一个节点的服务器以及接收到请求且还未执行这个请求。和其他临时应答的不同点在于，它永远不会被有状态 proxy 转发到上行流   180 Ringing UA 收到 Invite 请求并尝试提示客户   181 Call is Being Forwarded 表示呼叫正在转发到另一个目的地集合   182 Queued 当呼叫的对方暂时不能接收呼叫，且服务器决定将呼叫排队等候，而不是拒绝呼叫   183 Session Progress 用于提示建立对话的进度信息。Reason-Phrase (表达原因的句子)、头域或消息体可用于提示呼叫进度的更详细的信息     成功信息 2xx：表示请求是成功的     应答码 描述     200 OK 请求已经处理成功。应答的信息取决于请求的方法     转发请求 3xx： 用于提示用户的新位置信息，或为了满足呼叫转发的可选服务地点     应答码 描述     300 Multiple Choices 请求的地址有多个选择，每个选择都有自己的地址，用户或 UA 可选择合适的通讯终端，并且转发请求到这个地址   301 Moved Permanently 不能在 Request-URI 指定的地址找到用户，请求的客户端应使用 Contact 头域所指出的新地址重新尝试   302 Moved Temporarily 请求方应把请求重新发到这个 Contact 所指出的新地址   305 Use Proxy 请求的资源必须通过 Contact 头域中指出的 proxy 来访问。接收到这个应答的对象应通过这个 proxy 重新发送这个请求   380 Alternative Service 呼叫不成功，但是可以尝试可选的服务     请求失败 4xx：定义了特定服务响应的请求失败的情况     应答码 描述     400 Bad Request 请求语法错误。Reason-Phrase 应当标识这个详细的语法错误   401 Unauthorized 请求需要用户认证，应答是由 UAS 和 注册服务器产生的，407 是 proxy 服务器产生的   402 Payment Required 预留，之后使用   403 Forbidden 服务器支持这个请求，但是拒绝执行请求。增加验证信息是没有必要的，并且请求不应该被重试   404 Not Found 用户在 Request-URI 指定的域不存在。当 Request-URI 的 domain 和 接收这个请求的 domain 不匹配时，也会产生这个应答   405 Method Not Found 服务器支持 Request-Line 的方法，但是这个 Request-URI 的地址不允许使用这个方法。应答应包含一个 Allow 头域，包含了指定地址允许的方法列表   406 Not Acceptable 请求的资源只能产生回复实体包含的内容不被请求的 Accept 域接收   407 Proxy Authentication Required 标志了客户端应首先在 proxy 上通过认证   408 Request Timeout 在一段时间内，服务器不能产生一个终结应答。客户端可稍后不更改请求内容重试请求   410 Gone 请求的资源在服务器上已经不存在了，且不知道应把请求转发到哪里   413 Request Entity Too Large 请求实体超过了服务器期望或可以处理的大小   414 Request-URI Too Long Request-URI 超过了服务器可以处理的长度   415 Unsupported Media Type 服务器不支持请求的消息体格式，服务器必须根据内容的故障类型返回一个 Accept，Accept-Encoding 或 Accept-Language   416 Unsupported URI Scheme 服务器不支持 Request-URI 的 URI 方案   420 Bad Extension 服务器不知道请求的 Proxy-Require 或 Require 指出的协议扩展。在应答的 Unsupported 头域中列出不支持的扩展   421 Extension Required UAS 需要特定的扩展来处理请求，但是请求的 Supported 头域没有列出。应答的 Require 头域应列出所需扩展   423 Interval Too Brief 请求设置的资源刷新时间(或有效时间)过短而被服务器拒绝。比如注册服务器拒绝 Contact 头域中有效期过短的注册请求   480 Temporarily Unavailable 请求到达被叫方，但被叫方当前不可用。应增加一个 Retry-After 告诉呼叫方多久可以重试呼叫，Reason-Phrase 应当有详细信息   481 Call/Transaction Does Not Exist UAS 收到请求，但是没有和现存的对话或事务匹配   482 Loop Detected 服务器检测到循环   483 Too Many Hops 请求的 Max-Forwards 头域是 0   484 Address Incomplete Request-URI 不完整，Reason-Phrase 应当有附加信息   485 Ambiguous Request-URI 是不明确的   486 Busy Here 成功联系到被叫方的终端系统，但是被叫方在当前终端不能接听，应增加一个 Retry-After 告诉呼叫方多久可以重试呼叫。其它终端(如电话、邮箱)可能有效。如果知道没有其他终端系统可以接受呼叫，返回 600   487 Request Terminated 请求被 BYE 或 CANCEL 终止   488 Not Acceptable Here 和 606 相同，但只应用于 Request-URI 所指出的特定资源不能接受，在其它地方请求可能可以接受   491 Request Pending 同一对话中，UAS 收到的请求有一个依赖的请求正在处理   493 Undecipherable UAS 收到的请求包含了一个加密的 MIME，且不知道或没有提供合适的解密密钥     服务错误 5xx：服务器本身故障的时候给出的失败应答     应答码 描述     500 Server Internal Error 服务器遇到未知的情况，不能继续处理请求   501 Not Implemented 服务器没有实现相关请求功能   502 Bad Gateway 服务器作为 gateway 或 proxy，从下行服务器收到一个非法应答   503 Service Unavailable 由于临时过载或服务器管理导致的服务器暂时不可用。可增加一个 Retry-After 告诉呼叫方多久可以继续呼叫   504 Server Time-out 服务器在一个外部服务器上没有收到及时的应答。如果从上行服务器收到的请求中 Expires 超时，则返回 408   505 Version Not Supported 服务器不支持对应的 SIP 版本   513 Message Too Large 消息长度超过服务器可以处理的长度     全局错误 6xx：服务给特定用户有一个最终的信息，并不只是在 Request-URI 的特定实例有最终信息     应答码 描述     600 Busy Everywhere 成功连到到被叫方的终端系统，但是被叫方处于忙的状态，不打算接听电话。可增加一个 Retry-After 告诉呼叫方多久可以继续呼叫   603 Decline 成功访问到被叫方的设备，但是用户明确的不行应答。可增加一个 Retry-After 告诉呼叫方多久可以继续呼叫   604 Does Not Exist Anywhere Request-URI 中的用户信息验证失败   606 Not Acceptable 成功联系到 UA，但是会话描述的一部分(如请求的媒体、带宽或地址类型)不被接受    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"786983758d8734bbd67beaa0eabbe74c","permalink":"https://xueqing.github.io/blog/sip/rfc3261_sip_reading/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/rfc3261_sip_reading/","section":"blog","summary":"请求的消息头 回复的消息头 消息 处理应答 Invite 客户事务 应答代码 请求的消息头 举例：以 Alice 向 Bob 发起会话为例 INVITE sip:bob@biloxi.com SIP/2.0 Via: SIP/2.0/UDP pc33.atlanta.com;branch=z9hG4bK776asdhds Max-Forwards: 70 To: Bob \u0026lt;sip:bob@biloxi.com\u0026gt; From: Alice \u0026lt;sip:alice@atlanta.com\u0026gt;;tag=1928301774 Call-ID: a84b4c76e66710@pc33.atlanta.com CSeq: 314159 INVITE Contact: \u0026lt;sip:alice@pc33.atlanta.com\u0026gt; Content-Type: application/sdp Content-Length:","tags":["sip"],"title":"rfc3261: SIP","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  answer/offer 协议操作 生成初始 offer 生成 answer offerer 处理 answer 修改会话 表明能力  answer/offer  agent：一个 agent 是 offer/answer 交换中的一个协议实现。offer/answer 交换包括两种代理：offerer 和 answerer offerer：会话一方，创建或者修改一个会话。发送的 SDP 消息包含了 offerer 希望使用的媒体流和编解码器的集合，以及 offerer 接收媒体流希望使用的地址和端口 offer：offerer 发送的 SDP 消息 answerer：会话的另一方参与者。answerer 为接收到的 offer 生成一个回复的 SDP 消息。消息对应 offer 每个流有一个媒体流，指出这个流是否被接收，以及使用的编解码器和 answerer 接收媒体流希望使用的地址和端口 answer：answerer 发送的用于回复 offer 的 SDP 消息  协议操作  在任何时候，代理可以生成一个新的 offer 来更新会话。但是  answerer 不能在收到一个 offer 之后，回复或者拒绝之前生成一个新的 offer offerer 不能发送一个 offer 之后，在收到回复或拒绝之前生成一个新的 offer  “glare”：一个代理在发送一个 offer 之后，还没有回复这个 offer 就收到一个新的 offer  上层协议应该解决这种冲突   生成初始 offer  忽视 e 和 p 字段 没有 m 字段表示 offerer 希望通讯，但是通过后续的修改 offer 来增加会话的流信息 单播流  sendonly：offerer 只想发送媒体流 inactive：offerer 希望通讯，但是不希望发送或接收媒体流 sendrecv：offerer 想发送和接收媒体流，这个是默认选项 recvonly：offerer 只想接收媒体流 RTCP 仍然会在 sendonly/inactive/recvonly 流中发送。媒体流的方向性不影响 RTCP 的使用 sendrecv/recvonly：offer 中的地址和端口表示 offerer 想要接收媒体流的信息 sendonly：offer 中的地址和端口表示 offerer 想要接收 RTCP 包的信息  如果没有明确说明 RTCP 的地址和端口，RTCP 包将会发送到比指定的端口大 1 的端口  offer 中的地址和端口和 offerer 发送媒体流的地址和端口无关 offer 中的端口为 0 表示提供流但是不会使用流，比如回复中的端口为 0 表示拒绝流，或者设置端口为 0 终止已存在的流 如果 SDP 中包含多个媒体格式(应当按照倾向顺序排列)，表示 answerer 在会话中间可能会修改格式为媒体格式列表中的任一一个，同时不会发送一个新的 offer 带宽为 0 不被建议，表示不应当发送任何媒体流，包括 RTP 的 RTCP 信息 offer 中不同类型的媒体流信息表示 offerer 同时希望使用的流；相同类型的媒体流信息表示 offerer 希望同时发送和/或接收指定类型的多个媒体流  多播流  sendonly：只想发送媒体流 recvonly：只想接收媒体流   生成 answer  对于 offer 中的每一个 “m=”，answer 中必须有对应的 “m=”。这便于基于顺序匹配流 answer 的 “t=” 必须和 offer 的相等 如果拒绝一个流，可以将对应的流的端口设置为 0，其他的格式信息被忽略 单播流  offer 的流为 sendonly，对应的流必须是 recvonly/sendrecv offer 的流为 recvonly，对应的流必须是 sendonly/sendrecv offer 的流为 sendrecv(没有的话默认为 sendrecv)，对应的流必须是 sendonly/recvonly/sendrecv/inactive offer 的流为 inactive，对应的流必须是 inactive answer 中标记流为 recvonly，“m=” 中必须包含 offer 中至少一个媒体格式 answer 中标记流为 sendonly，“m=” 中必须包含 offer 中至少一个媒体格式 answer 中标记流为 sendrecv，“m=” 中必须包含 offer 中至少一个媒体格式 answer 中标记流为 inactive offer 的流为 sendonly，媒体格式按照 recvonly 构造 offer 的流为 recvonly，媒体格式按照 sendonly 构造 offer 的流为 sendrecv，媒体格式按照 sendrecv 构造 offer 的流为 inactive，媒体格式按照 sendrecv 构造 尽量按照 offer 的优先顺序排列媒体格式 如果对于提供的媒体没有通用的媒体格式，answer 将设置端口为 0 来拒绝该媒体流 如果对于所有的流都没有通用的格式，整个会话被拒绝 answerer 发送媒体流的格式应该是 offer 中最优先且在 answer 中列举的媒体格式。对于 RTP，即使和 answer 不同，也必须使用 offer 中指定的负载类型  多播流  多播 offer 的 answer 通常涉及修改一个流的某些方面 如果接受多播流，answer 的地址和端口信息必须和 offer 中的对应，且流的方向信息必须和 offer 的一致 answer 中的媒体格式必须和 offer 中的相同或者是 offer 的一个子集。移除一个格式表示 answerer 不支持该格式 如果 offer 中有 ptime 和带宽属性，answer 必须和其一样。否则，answer 可以添加一个非 0 的 ptime 属性    offerer 处理 answer  如果 answer 是 sendrecv/recvonly，offerer 收到 answer 时可以发送媒体流  offerer 必须使用 answer 中列举的媒体格式发送，且应该(不是必须)使用 answer 中第一个媒体格式 offerer 应该根据 answer 中的 ptime 和带宽来发送媒体 offerer 可以立即停止监听 offer 中列举但是 answer 中未显示的媒体格式   修改会话  在会话期间，任意一方可以发起一个新的 offer 来修改会话属性 先前的 SDP：包括 offer 或 answer 中提供的 SDP 新 offer 的 SDP 的 “o=” 必须和先前的 SDP 一样，版本号加 1  新 offer 的 SDP 和先前的 SDP 一致的话，answerer 必须可以处理，可以返回和之前处理过程相同的 SDP  新 offer 的 SDP 的媒体属性必须和之前的 SDP 的每个媒体对应，即 offer 中的媒体数目不会减少。之前的 SDP 删除的媒体流不能在新的 SDP 中移除，可以不显示流的属性 添加一个媒体流  可以复用之前拒绝的媒体流的位置，即端口设置为 0 的媒体 在已有的媒体下面添加新的媒体描述  移除一个媒体流  将媒体所在位置的端口设置为 0，可以忽视之前的其他属性，只留下媒体格式 可以释放与其相关的资源  修改一个媒体流  修改地址，端口或协议 offerer 一发送 offer，就必须为接收旧的和新的端口做准备。直到收到 answer 和媒体到达新的端口，offerer 才可以停止监听旧端口。此举避免在传送过程中丢掉媒体数据 answerer 对端口修改的处理和 offerer 如果提供的流被拒绝，收到拒绝的时候就可以停止监听 修改地址类比修改端口，不过更新的是连接，而不是端口 修改协议和修改端口一样处理 修改媒体格式集 修改媒体类型：比起添加新媒体，建议修改媒体类型 修改属性  暂停一个单播流  之前标记为 sendrecv 的流，应改成 sendonly 之前标记为 recvonly 的流，应改成 inactive   表明能力  代理构造一个用于表明媒体能力的 SDP  必须是有效的，忽视 e 和 p 字段 关于时间属性t= 0 0 代理支持的每个媒体类型必须有对应的媒体描述 o 字段的会话 ID 必须是唯一的 端口是 0(确保不会建立媒体流)，连接地址是任意的 “m=” 的传输表明媒体类型的传输   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"774783f6497d6a8404d081f719fcdb8f","permalink":"https://xueqing.github.io/blog/sip/rfc3264_an_offer_answer_model_with_the_sdp_reading/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/rfc3264_an_offer_answer_model_with_the_sdp_reading/","section":"blog","summary":"answer/offer 协议操作 生成初始 offer 生成 answer offerer 处理 answer 修改会话 表明能力 answer/offer agent：一个 agent 是 offer/answer 交换中的一个协议实现。offer/answer 交换包括两种代理：o","tags":["sip"],"title":"rfc3264: An Offer/Answer Model with the SDP","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  介绍 节点行为  订阅者 通知者 通知者 NOTIFY 行为 订阅者 NOTIFY 行为  事件包  介绍  网络中的实体可以订阅网络中的资源或不同资源的呼叫状态或呼叫，当这些状态改变的时候，这些实体可以发送通知 订阅是有时效性的，必须通过后续的 SUBSCRIBE 消息刷新  节点行为  SUBSCRIBE 方法是一个用来请求远端节点的当前状态和后续状态变化的请求方法 SUBSCRIBE 请求有 “Expires” 头域显示请求有效期，之后通过新的 SUBSCRIBE 请求来刷新有效期  SUBSCRIBE 回复的 200 中也必须包含一个 “Expires” 头域，必须比请求的有效期长 “Contact” 头域中的 “expires” 和订阅的有效期无关 当 SUBSCRIBE 请求的 “Expires” 值为 0，表示取消订阅一个事件。成功的取消订阅也会触发一个 NOTIFY 消息   订阅者  订阅者必须在 SUBSCRIBE 请求包含有且仅有一个 “Event” 头域，表示订阅的事件或事件类 订阅者想要订阅一个资源的一个指定的状态，构造并发送一个 SUBSCRIBE 请求  200 回复表示接受订阅请求，用户被鉴权订阅请求的资源 “Expires” 头域，必须比请求的有效期短，定义了这个订阅的实际有效期 202 回复表示理解订阅请求，但是用户未被授权 489 回复表示不理解订阅消息的 “Event” 头域指定的事件或事件类 423 回复表示过期时间太短，即过期时间大于 0，小于 1 小时，且小于通知者配置的最小时间。回复的头域应包含 “Min-Expires” 头域指明最小时间  刷新订阅：发送一个 SUBSCRIBE 请求，“Event” 头域的 “id” (如果存在)必须和之前的订阅请求一致  481 回复表示订阅被终止，订阅者不会收到通知。如果订阅者仍希望订阅这个状态，必须重新发送一个和之前的订阅无关的初始化订阅请求 其它的非 481 的回复，订阅仍被认为是有效的，但是通常是网络问题或者通知者的问题，订阅者不会接收到 NOTIFY 消息   通知者  通知者需要保存订阅的事件包的名称， “Event” 头域以及 “id” 参数(如果存在) 通知者接收或者刷新一个订阅，即发送一个 200 回复之后，必须立即发送一个 NOTIFY 消息告知订阅者当前的状态  如果当前资源的状态对于处理的订阅请求没有意义，NOTIFY 的消息体可以为空或者 “neutral” 通知者对订阅者身份的认证，是通过一个 401 回复还不是 407 回复，即通知者在接受订阅和通知事件的时候是作为一个用户代理存在的 代理节点通常使用 407 来认证身份 认证失败，通知者返回 “403 Forbidden” 或 “603 Decline” 如果通知者通过交互的方式决定是否允许一个订阅，应立即给出一个 “202 Accept” 应答 如果通知者延迟认证，且认证失败，应构造一个 NOTIFY 消息，包含 “Subscription-State” 头域，且该头域包含一个 “terminated” 值及一个原因短语 “rejected” 如果通知者过期未收到更新订阅消息，应该移除订阅，发送一个 NOTIFY 消息，包含 “Subscription-State” 头域，且该头域包含一个 “terminated” 值及一个原因短语 “reason=timeout”  如果不支持 PINT，且 SUBSCRIBE 请求不包含 “Accept-Event” 头域，通知者返回 “489 Vad Event”  通知者 NOTIFY 行为  如果收到 NOTIFY 消息的节点没有订阅，回复 481 发送一个 NOTIFY 请求，“Event” 头域的 “id” (如果存在)必须和之前的订阅请求一致 如果 NOTIFY 的回复超时，或者回复是非 200，则 NOTIFY 请求失败，通知者移除对应的订阅 如果 NOTIFY 请求的回复是 481，通知者移除对应的订阅，表示无论是什么情况，取消对应的订阅 NOTIFY 请求必须包含 “Subscription-State” 头域，取值范围是 “active/pending/terminated”  当取值 “active/pending”，NOTIFY 的 “Subscription-State” 头域应该包含一个 “expires” 参数 active：表示接受订阅，且订阅通过认证 如果有 “expires” 参数，订阅者应该当做认证订阅的时长，并且根据时长调整认证 “reason” 和 “retry-after” 参数无意义 pending：表示收到订阅，但是当前的策略信息不足以决定接受或者拒绝这个订阅 如果有 “expires” 参数，订阅者应该当做认证订阅的时长，并且根据时长调整认证 “reason” 和 “retry-after” 参数无意义 terminated：表示订阅不是 active “Subscription-State” 头域可以包含一个 “retry-after” 参数  表示多久之后订阅者可以尝试重新订阅。如果没有 “retry-after” 参数，可以在任意时刻尝试重新订阅  “expires” 参数无意义 “Subscription-State” 头域应该包含一个 “reason” 参数。取值应该是下面的范围  deactivated：终止订阅，但是订阅者应该立即用新的订阅重试。比如允许节点之间的订阅迁移。“retry-after” 参数无意义 rejected：认证策略的变化而终止订阅。订阅者不应该重新订阅。“retry-after” 参数无意义 timeout：过期之前未刷新而终止订阅。订阅者可以立即重试订阅。“retry-after” 参数无意义 noresource：监视的资源状态不存在而终止订阅。订阅者不应该重试订阅。“retry-after” 参数无意义 probation：终止订阅，但是订阅者应该在一段时间之后重试。如果指定 “retry-after” 参数，则至少等待指定的时间之后重试订阅 giveup：通知者不能获得认证信息而终止订阅。如果指定 “retry-after” 参数，则至少等待指定的时间之后重试订阅；否则应立即重试订阅，但是很可能变成 “pending” 状态   如果订阅者认为通知式可接受的，应立即回复 200。一般，通知的回复不会包含消息体。但是如果 NOTIFY 请求包含 “Accept” 头域，回复可以包含消息体  订阅者 NOTIFY 行为  关于订阅的回复：回复和 SUBSCRIBE 请求包含相同的 “Call-ID”、“CSeq” 和“From” 头域的 “tag” 参数 判断 NOTIFY 和订阅是否一致：  NOTIFY 请求和 SUBSCRIBE 请求的有相同的 “Call-ID”，前者的 “To” 头域的 “tag” 参数和后者的 “From” 头域的 “tag” 参数相同 NOTIFY 请求和 SUBSCRIBE 请求的 “Event” 头域相同 “Event” 类型相同，且如果一方的 “Event” 头域有 “id”，二者必须都有且相同  如果订阅者不支持 NOTIFY 的 “Event” 头域，返回 “489 Bad Event” 订阅者发送一个“Expires” 值为 0 的 SUBSCRIBE 请求，表示取消订阅一个事件  只有收到一个 “Subscription-State” 为 “terminated” 的 NOTIFY 消息才认为是订阅被取消或终止，“reason” 参数是 “timeout”   事件包  传递事件包的两种机制  传递完整状态信息：事件包需要传递的状态信息比较小，或者仅仅传递当前状态对于特定的事件类型不是足够的 增量传递信息：需要传递的状态比较大，可以使用包含增量状态的 NOTIFY 消息传递状态 立即给 SUBSCRIBE 请求的 NOTIFY 消息包含全部的状态信息。后续由于状态变化传递的 NOTIFY 消息只包含改变的状态。订阅者将资源状态合并到已知的当前状态 支持增量传递的事件包必须包含一个版本号，每次 NOTIFY 通信时加 1，此版本号在消息体，而不是 SIP 头 第一个 NOTIFY 的版本号应该和上次最后一个 NOTIFY 的版本号响应，即第一个 NOTIFY 不增加版本号 如果到达的 NOTIFY 的版本号增加大于 1，说明订阅者错过了一个增量。应当忽视这个 NOTIFY 消息，保存版本号用户检测消息丢失。然后重新发送一个 SUBSCRIBE 强制 NOTIFY 包含一个完整的状态  出于安全性考虑，通知者受到 SUBSCRIBE 请求，不应返回具体的 220/4xx/6xx 而暴露敏感的策略信息，而是统一返回 202。202 表示理解订阅请求，但是用户未被授权。可在后续的 NOTIFY 中表示接受或拒绝该订阅  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f5433e283daa2ec172ce06dcab4d2409","permalink":"https://xueqing.github.io/blog/sip/rfc3265_sip_specific_event_notification_reading/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/rfc3265_sip_specific_event_notification_reading/","section":"blog","summary":"介绍 节点行为 订阅者 通知者 通知者 NOTIFY 行为 订阅者 NOTIFY 行为 事件包 介绍 网络中的实体可以订阅网络中的资源或不同资源的呼叫状态或呼叫，当这些状态改变的时候，","tags":["sip"],"title":"rfc3265: SIP Specific Event Notification","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"   术语 描述     会议 一个多媒体会议是一个集合，这个集合包含两个或更多的通信用户以及用于通信的软件   会话 一个多媒体会话是一个集合，这个集合包含发送者和接受者，以及他们之间所通信的媒体流。多媒体会议是多媒体会话的一个例子   会话描述 定义良好的格式，用于传送足够的信息来发现和参与一个多媒体会话     两个目的\n 通讯一个会话的存在性 传递足够的信息使能连接和参加到存在的会阿虎\nv= (protocol version) o= (owner/creator and session identifier) s= (session name) i=* (session information) u=* (URI of description) e=* (email address) p=* (phone number) c=* (connection information - not required if included in all media) b=* (bandwidth information) One or more time descriptions (see below) z=* (time zone adjustments) k=* (encryption key) a=* (zero or more session attribute lines) Zero or more media descriptions (see below) # Time description t= (time the session is active) (t=\u0026lt;start time\u0026gt; \u0026lt;stop time\u0026gt;) r=* (zero or more repeat times) (r=\u0026lt;repeat interval\u0026gt; \u0026lt;active duration\u0026gt; \u0026lt;list of offsets from start-time\u0026gt;) # Media description m= (media name and transport address) (m=\u0026lt;media\u0026gt; \u0026lt;port\u0026gt;/\u0026lt;number of ports\u0026gt; \u0026lt;transport\u0026gt; \u0026lt;fmt list\u0026gt;) i=* (media title) c=* (connection information - optional if included at session-level) b=* (bandwidth information) k=* (encryption key) a=* (zero or more media attribute lines)   不能解析的属性可以忽略\n a=* (zero or more session attribute lines)非标准格式的名字以X-为前缀，但是不推荐使用X-前缀的参数\n m=\u0026lt;media\u0026gt; \u0026lt;port\u0026gt;/\u0026lt;number of ports\u0026gt; \u0026lt;transport\u0026gt; \u0026lt;fmt list\u0026gt;\n media 可以是 audio/video/application/text/message (data/control 弃用) port 1024~65535 (udp 限制)，偶数 (RTP 兼容性，大一位的奇数是 RTCP 端口)  检验 sdp 的信息和媒体流的链路信息是否一致(包括接收地址端口和发送地址端口)\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"be04e3c5062773851996140558ffbbd5","permalink":"https://xueqing.github.io/blog/sip/rfc4566_sdp_reading/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/rfc4566_sdp_reading/","section":"blog","summary":"术语 描述 会议 一个多媒体会议是一个集合，这个集合包含两个或更多的通信用户以及用于通信的软件 会话 一个多媒体会话是一个集合，这个集合包含发送者和接","tags":["sip"],"title":"rfc4566: SDP","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c690ffec13b04d0a93981cc0296198d6","permalink":"https://xueqing.github.io/blog/sip/rfc6665_sip_specific_event_notification_reading/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/rfc6665_sip_specific_event_notification_reading/","section":"blog","summary":"","tags":["sip"],"title":"rfc6665: SIP Specific Event Notification","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"```go /* Exercise: rot13Reader A common pattern is an io.Reader that wraps another io.Reader, modifying the stream in some way.\nFor example, the gzip.NewReader function takes an io.Reader (a stream of compressed data) and returns a *gzip.Reader that also implements io.Reader (a stream of the decompressed data).\nImplement a rot13Reader that implements io.Reader and reads from an io.Reader, modifying the stream by applying the rot13 substitution cipher to all alphabetical characters.\nThe rot13Reader type is provided for you. Make it an io.Reader by implementing its Read method. */\npackage main\nimport ( \u0026ldquo;io\u0026rdquo; \u0026ldquo;os\u0026rdquo; \u0026ldquo;strings\u0026rdquo; )\ntype rot13Reader struct { r io.Reader }\nfunc rot13(b byte) byte { if b \u0026gt;= \u0026lsquo;a\u0026rsquo; \u0026amp;\u0026amp; b \u0026lt;= \u0026rsquo;m\u0026rsquo; { return b + 13 } if b \u0026gt;= \u0026lsquo;n\u0026rsquo; \u0026amp;\u0026amp; b \u0026lt;= \u0026lsquo;z\u0026rsquo; { return b - \u0026lsquo;n\u0026rsquo; + \u0026lsquo;a\u0026rsquo; } if b \u0026gt;= \u0026lsquo;A\u0026rsquo; \u0026amp;\u0026amp; b \u0026lt;= \u0026rsquo;M\u0026rsquo; { return b + 13 } if b \u0026gt;= \u0026lsquo;N\u0026rsquo; \u0026amp;\u0026amp; b \u0026lt;= \u0026lsquo;Z\u0026rsquo; { return b - \u0026lsquo;N\u0026rsquo; + \u0026lsquo;A\u0026rsquo; } return b }\nvar rot13Map = make(map[byte]byte)\nfunc initializeRot13Map() { s1 := \u0026ldquo;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\u0026rdquo; s2 := \u0026ldquo;NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\u0026rdquo; for i := 0; i \u0026lt; len(s1); i++ { rot13Map[s1[i]] = s2[i] } }\nfunc rot13ByMap(b byte) byte { val, ok := rot13Map[b] if ok { return val } return b }\nfunc (rot rot13Reader) Read(c []byte) (int, error) { b := make([]byte, 8) n, err := rot.r.Read(b) initializeRot13Map() for i := 0; i \u0026lt; n; i++ { // b[i] = rot13(b[i]) b[i] = rot13ByMap(b[i]) } if err == io.EOF { return n, err } copy(c, b) return n, nil }\nfunc main() { s := strings.NewReader(\u0026ldquo;Lbh penpxrq gur pbqr!\u0026rdquo;) r := rot13Reader{s} io.Copy(os.Stdout, \u0026amp;r) }\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9e3b955c5865480af365f8048bd70668","permalink":"https://xueqing.github.io/translation/go-doc/gotour/rot_reader/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/rot_reader/","section":"translation","summary":"```go /* Exercise: rot13Reader A common pattern is an io.Reader that wraps another io.Reader, modifying the stream in some way.\nFor example, the gzip.NewReader function takes an io.Reader (a stream of compressed data) and returns a *gzip.Reader that also implements io.Reader (a stream of the decompressed data).\nImplement a rot13Reader that implements io.Reader and reads from an io.Reader, modifying the stream by applying the rot13 substitution cipher to all alphabetical characters.","tags":["go-tour"],"title":"rot13Reader","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" 批量替换  在一个文件中替换字符串  sed -i \u0026quot;s/original_str/replace_str/g\u0026quot; filename可查找filename中的original_str替换成replace_str filename可用通配符  在一个文件夹中替换字符串  批量查找文件夹中的文件grep \u0026quot;original_str\u0026quot; -rl dirname 批量替换文件sed -i s/original_str/replace_str/g `grep \u0026quot;original_str\u0026quot; -rl dirname` 遍历当前文件夹所有文件find ./ -type f 批量替换当前文件夹下所有文件的字符串sed -i s/original_str/replace_str/g `find ./ type f`  批量替换文件、文件夹名字  查找文件名find ./ -name original_str* 替换输出find ./ -name original_str* | sed 's/\\(.*\\)\\(original_str\\)\\(.*\\)/mv \\1\\2\\3 \\replace_str\\3/' | sh  文件夹查找文件，将文件名转换为mv orifile newfile模式，最后应用管道命令  查找文件夹find ./ -name original_str* -type d 替换输出find ./ -name original_str* -type d | sed 's/\\(.*\\)\\(original_str\\)\\(.*\\)/mv \\1\\2\\3 \\replace_str\\3/' | sh  文件夹查找文件，将文件夹名转换为mv orifile newfile模式，最后应用管道命令     按行删除  不加-i打印删除之后的文本内容，并没有真正删除文件文本内容；加-i不打印，但是会真正删除对应内容  sed nd filename删除第n行 sed n~md filename从第n行开始，每隔m-1行删除 sed m,nd filename删除第m行到第n行 sed 'm,n'd filename sed 'm,nd' filename sed '$'d filename删除最后一行 sed '$d' filename sed /pattern/d filename删除匹配pattern所在行 sed '/pattern/d' filename sed '/pattern/'d filename sed '/pattern/,+2d' filename删除匹配pattern所在行和之后m行 sed '/pattern/,+2'd filename sed '/^$/d' filename删除空行   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"96182f7b86bdba546f7e5c16f2611b50","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_sed/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_sed/","section":"blog","summary":"批量替换 在一个文件中替换字符串 sed -i \u0026quot;s/original_str/replace_str/g\u0026quot; filename可查找filename中的original_str替换成replace_str filen","tags":["ubuntu","linux"],"title":"sed","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  在 shell 脚本中调用另一个脚本 shell 命令行选项解析  getopts getopt  shell 获取脚本的进程 ID shell 脚本获取当前时间 shell 执行多个命令的方法 shell test 命令  数值测试 字符串测试 文件测试 连接测试条件  shell 变量 shell 脚本上传 ftp  上传单个文件脚本  shell if shell 操作符  算术操作符 关系操作符 布尔操作符 string 操作符 文件测试运算符 C Shell 操作符 Korn Shell 操作符  字符串截取 here document 参考网站  在 shell 脚本中调用另一个脚本  fork：直接调用script_path/filename.sh(有可执行权限)或者sh script_path/filename.sh(没有可执行权限)  运行时终端会新开一个子 shell 执行脚本，子 shell 执行的时候，父 shell 仍在。子 shell 执行完毕返回父 shell，但是父 shell 不能继承子 shell 的环境变量。  exec：exec script_path/filename.sh  exec 不需要新开一个子 shell 来执行被调用的脚本，而是在同一个 shell 执行。但是父脚本中exec行之后的内容不会被执行。  source：source script_path/filename.sh\n source 不需要新开一个子 shell 来执行被调用的脚本，而是在同一个 shell 执行。即父脚本可以获取和使用子脚本中声明的变量和环境变量。\n#!/bin/bash A=1 echo \u0026quot;before exec/source/fork: PID for parent.sh = $$\u0026quot; export A echo \u0026quot;In parent.sh: var A=$A\u0026quot; case $1 in --exec) echo -e \u0026quot;==\u0026gt; using exec..\\n\u0026quot; exec ./child.sh ;; --source) echo -e \u0026quot;==\u0026gt; using source...\\n\u0026quot; source ./child.sh ;; *) echo -e \u0026quot;==\u0026gt; using fork by default...\\n\u0026quot; ./child.sh ;; esac echo \u0026quot;after exec/source/fork: PID for parent.sh = $$\u0026quot; echo -e \u0026quot;In parent.sh: var A=$A\u0026quot;  #!/bin/bash echo \u0026quot;PID for child.sh = $$\u0026quot; echo \u0026quot;In child.sh: get var A=$A from parent.sh\u0026quot; A=2 export A echo -e \u0026quot;In child.sh: var A=$A\\n\u0026quot;    shell 命令行选项解析  getopts是 shell 内建命令，getopt是一个独立外部工具 getopts语法简单，getopt语法较复杂 getopts不支持长参数(如 -dir, \u0026ndash;dir)，getopt支持 getopts不会重排所有参数顺序，getopt会重排参数顺序 getopts是为了代替getopt较快捷的执行参数分析工作  getopts  语法getopts optstring name [args]\n optstring代表可使用的选项列表，每个字母代码一个选项 带:意味着除了定义之外，还会带一个参数作为选项的值 不带:是一个开关型选项，不需要指定参数的值 命令行中包含了没有在getopts列表中的选项会有警告，在optstring前加上:可以消除警告 getopts中有个相对固定的常量OPTARG和OPTIND OPTARG代表当前选项的值 OPTIND代表当前选项在参数列表中的位置 出现不认识的选项参数为?，case中最后一个?用于处理这种情况，因此选项中不应包含?和, getopts解析完参数后，可以使用shift把选项参数进行移位操作，左边的参数就丢失了 shift $(($OPTIND-1))，参数从 1 开始编号，处理一个开关型选项OPTIND加 1，处理一个带值的选项参数OPTIND加 2 选项参数的格式是-d val，中间需要一个空格 选项参数必须放在其他参数前面，因为遇到非-开头的参数或者选项参数结束标记--就终止了 中间遇到非选项的命令行参数，后面的选项参数取不到\n#!/bin/bash # echo \u0026quot;usage: ./`basename $0` [-d dir_name] [-f file_name] [-c commit_id] [-s service_name] [-N]\u0026quot; # echo \u0026quot;initial index $OPTIND\u0026quot; while getopts 'd:f:c:s:N' opt; do case ${opt} in d) echo \u0026quot;directory name: $OPTARG\u0026quot; ;; f) echo \u0026quot;file name: $OPTARG\u0026quot; ;; c) echo \u0026quot;commit id: $OPTARG\u0026quot; ;; s) echo \u0026quot;service name: $OPTARG\u0026quot; ;; N) echo \u0026quot;use new rep url\u0026quot; ;; ?) echo \u0026quot;usage: ./`basename $0` [-d dir_name] [-f file_name] [-c commit_id] [-s service_name] [-N]\u0026quot; exit 1; ;; esac echo \u0026quot;opt is $opt, arg is $OPTARG, index is $OPTIND\u0026quot; done echo \u0026quot;After process arguments: OPTIND=$OPTIND\u0026quot; echo \u0026quot;Remove processed arguments: number=$(($OPTIND-1))\u0026quot; shift $(($OPTIND-1)) echo \u0026quot;Arguments index: OPTIND=$OPTIND\u0026quot; echo \u0026quot;Remaing arguments: $@\u0026quot;    getopt  语法支持三种  getopt optstring parameters getopt [options] [--] optstring parameters getopt [options] -o|--options optstring [options] [--] parameters -o表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，中间没有空格 -l|--longoptions表示长选项 \u0026quot;$@\u0026quot;将命令行参数展开分别的单词 -n出错时打印的信息   shell 获取脚本的进程 ID  参数$$获取进程 ID 参数$PID获取父 shell 的进程 ID 参数$UID获取执行当前的当前用户 ID  shell 脚本获取当前时间  获取当前时间date +%Y%m%d或date +%F或date +%y%m%d  Y 年，如 2018 y 年的最后两位，如 2018 显示 18 m 月(01..12) d 每个月第几天(01..31) F 完整的日志(%Y-%m-%d)  输出另外一个时区的时间env TZ=timezone date或env TZ=timezone date +%Y%m%d\n timezone 是指定的时区，比如America/Los_Angeles或Asia/Shanghai\nstarttime=`date +%s` sleep 10 #sleep 10 sec endtime=`date +%s` difftime=$(( endtime - starttime ))    shell 执行多个命令的方法  |：命令之间用|隔开，将前一个命令的标准输出(stdout)作为下一个命令的标准输入  标准错误(stderr)仍在默认的地方  |\u0026amp;：命令之间用|\u0026amp;隔开，将前一个命令的标准输出和标准错误都作为下一个命令的标准输入  bash 版本不小于 4  ;：命令之间用;隔开，各命令执行结果不影响，即各个命令都会执行 \u0026amp;\u0026amp;：命令之间用\u0026amp;\u0026amp;隔开，只有前面的命令执行成功，才会执行后面的命令，保证执行过程都是成功的 ||：命令之间用||隔开，只有前面的命令执行失败，才会执行后面的命令，直到执行成功\n 可用于捕获子 shell 的错误码，比如output=\u0026quot;$( (cd \u0026quot;$FOLDER\u0026quot;; eval \u0026quot;$@\u0026quot;) 2\u0026gt;\u0026amp;1 )\u0026quot; || errcode=\u0026quot;$?\u0026quot; 重要的命令失败时退出自定义错误码，比如output=\u0026quot;$( (cd \u0026quot;$FOLDER\u0026quot;; eval \u0026quot;$@\u0026quot;) 2\u0026gt;\u0026amp;1 )\u0026quot; || exit 12 可以定义函数在||之后调用\nhandle_error() { #do staff } output=\u0026quot;$( (cd \u0026quot;$FOLDER\u0026quot;; eval \u0026quot;$@\u0026quot;) 2\u0026gt;\u0026amp;1 )\u0026quot; || handle_error    shell test 命令  test 命令用于检查某个条件是否成立，可以进行数值、字符和文件三个方面的测试  数值测试  运算符：-eq，-ne，-gt，-ge，-lt，-le\nn1=1 n2=2 test $[n1] -eq $[n2] \u0026amp;\u0026amp; echo '两个数相等！' test $[n1] -eq $[n2] || echo '两个数不相等！'  []内执行基本的算术运算\nn1=1 n2=2 n3=$[n1+n2]   字符串测试  运算符： =，!=， -z(字符串长度是否为0)， -n(字符串长度是否不为0)\ns1=\u0026quot;s1\u0026quot; s2=\u0026quot;s2\u0026quot; test $s1 = $s2 \u0026amp;\u0026amp; echo '两个字符串相等！' test $s1 = $s2 || echo '两个字符串不相等！'   文件测试  运算符：-e，-r，-w，-x，-s，-d，-f，-c，-b\n -r/w/x：如果文件存在且可读/可写/可执行 -s：如果文件存在且至少有一个字符 -f/c/b：如果文件存在且是普通文件/字符型特殊文件/块特殊文件\ntest -e filename \u0026amp;\u0026amp; echo \u0026quot;文件已存在！\u0026quot; test -e filename || echo \u0026quot;文件不存在！\u0026quot;    连接测试条件  可用逻辑操作符将测试条件连接起来：与(-a)，huo(-o)，非(!)\ntest -e filename -o -e anotherfile \u0026amp;\u0026amp; echo \u0026quot;至少存在一个文件！\u0026quot; test -e filename -o -e anotherfile || echo \u0026quot;两个文件都不存在！\u0026quot;   shell 变量  定义变量是变量名和等号之间不能有空格 使用时在前面加上$即可 删除变量：unset $VAR 设置变量只读：readonly $VAR 测试变量是否定义\n if (set -u; : $VAR) ; then echo \u0026quot;set\u0026quot; ; else echo \u0026quot;unset\u0026quot; ; fi set -u用于设置 shell 选项，u 是 nounset， 表示当使用未定义的变量时，输出错误并强制退出 : 是不做任何事只是展开参数，单不会试图去执行 没有:则将变量解释成 shell 命令，并试图去执行 使用-z或-n判断 -z：字符串长度是否为0 -n：字符串长度是否不为0\necho \u0026quot;********************************set KK\u0026quot; export KK=\u0026quot;kiki\u0026quot; echo KK=$KK if [ -z $KK ] ; then echo \u0026quot;unset\u0026quot; ; else echo \u0026quot;set\u0026quot; ; fi if ( set -u; : $KK ) ; then echo \u0026quot;set\u0026quot; ; else echo \u0026quot;unset\u0026quot; ; fi echo KK=$KK echo \u0026quot;********************************unset KK\u0026quot; unset KK echo KK=$KK if [ -z $KK ] ; then echo \u0026quot;unset\u0026quot; ; else echo \u0026quot;set\u0026quot; ; fi if ( set -u; : $KK ) ; then echo \u0026quot;set\u0026quot; ; else echo \u0026quot;unset\u0026quot; ; fi echo KK=$KK    shell 脚本上传 ftp 上传单个文件脚本 #!/bin/bash FILENAME=$1 ftp -n -p\u0026lt;\u0026lt;! ## ftp server ip open ftpIp ## ftp username and password user ftpUser ftpPwd ## transfer type binary ## upload path cd /VDMSSoftware/cppci ## interactive mode prompt ## upload filename put $FILENAME close ## close connection bye !   传输文件类型包括：  ascii：默认值。网络 ASCII binary：二进制映像，需要使用二进制方式的文件类型包括 ISO 文件、可执行文件、压缩文件、图片等。此方式比 ascii 更有效 ebcdic： image： local M：本地类型。M 参数定义每个计算机字位的十进制数 tenex：  交互式提示：使用 mget 或 mput 时，prompt命令让 ftp 在文件传输前进行提示，防止覆盖已有的文件。若发出 prompt 命令时已经启动了提示，ftp 将关掉提示，此时再传输所有的文件则不会有任何提示  shell if  shell 支持 3 中 if 语句\n if...fi if...else...fi if...elif...else...fi\nif [ $useEncryption != \u0026quot;false\u0026quot; ] \u0026amp;\u0026amp; [ $softEncryption != \u0026quot;false\u0026quot; ] then # do sth elif [ $useEncryption != \u0026quot;false\u0026quot; ] \u0026amp;\u0026amp; [ $softEncryption == \u0026quot;false\u0026quot; ] then # do sth elif [ $useEncryption == \u0026quot;false\u0026quot; ] \u0026amp;\u0026amp; [ $softEncryption != \u0026quot;false\u0026quot; ] then # do sth elif [ $useEncryption == \u0026quot;false\u0026quot; ] \u0026amp;\u0026amp; [ $softEncryption == \u0026quot;false\u0026quot; ] # or else then # do sth fi    shell 操作符  讨论 Bourne shell（默认的 shell） 支持的操作符  算术操作符  Bourne shell 不支持运算符，但是可以使用awk或者expr外部程序，例如res=`expr 2 + 2`; echo $res 运算符和表达式之间必须有空格 Bourne shell 支持的算术运算符包括：（假如a=10; b=20）  加法+，例如expr $a + $b，结果是 30 减法-，例如expr $a - $b，结果是 -10 乘法*，例如expr $a \\* $b，结果是 200 除法/，例如expr $b / $a，结果是 2 取模%，例如expr $a % $b，结果是 0 赋值=，例如a = $b，结果是 a 被赋值 20 等于==，例如[$a == $b]，结果是 false 不等于！=，例如[$a != $b]，结果是 true  条件表达式必须在方括号中，且两端有空格隔开  关系操作符  只对数值生效，string 作为操作数是无效的，例如对10和20或者\u0026quot;10\u0026quot;和\u0026quot;10\u0026quot;生效，但是对ten和twenty无效  无效的 string 是指 string 中包含非数字的字符  Bourne shell 支持的关系型操作符包括：（假如a=10; b=20）  等于-eq，例如[ $a -eq $b ]，结果是 false 不等于-ne，例如[ $a -ne $b ]，结果是 true 大于-gt，例如[ $a -gt $b ]，结果是 false 小于-lt，例如[ $a -lt $b ]，结果是 true 大于等于-ge，例如[ $a -ge $b ]，结果是 false 小于等于-le，例如[ $a -le $b ]，结果是 true  条件表达式必须在方括号内，且两端有空格分开 其他 shell 可能支持的操作  等于==，例如(( $a == $b ))，结果是 false 不等于!=，例如[ $a != $b ]，结果是 true 大于\u0026gt;，例如(( $a \u0026gt; $b ))，结果是 false 小于\u0026lt;，例如(( $a \u0026lt; $b ))，结果是 true 大于等于\u0026gt;=，例如(( $a \u0026gt;= $b ))，结果是 false 小于等于\u0026lt;=，例如(( $a \u0026lt;= $b ))，结果是 true   布尔操作符  Bourne shell 支持的布尔操作符包括：（假如a=10; b=20）  逻辑取否!，例如[ ! false ]，结果是 true 逻辑或-o，例如[ $a -lt 20 -o $b -gt 100 ]，结果是 true 逻辑与-a，例如[ $a -lt 20 -a $b -gt 100 ]，结果是 false   string 操作符  Bourne shell 支持的字符串操作符包括：（假如a=\u0026quot;abc\u0026quot;; b=\u0026quot;efg\u0026quot;）  等于=，例如[ $a = $b ]，结果是 false 不等于!=，例如[ $a != $b ]，结果是 true 字符串为 null，即长度为 0 -z，例如[ -z $a ]，结果是 false -z的字符串可以不被双引号引用 字符串不为 null，即长度不为 0 -n，例如[ -n $a ]，结果是 true -n的字符串建议用双引号引用，不加双引号可以使用! -z 字符串是否不是空串str，例如[ $a ]，结果是 true  其他 shell 可能支持的操作  大于\u0026gt;，例如[[ $a \u0026gt; $b ]]或[ $a \\\u0026gt; $b ]，结果是 false 小于\u0026lt;，例如[[ $a \u0026lt; $b ]]或[ $a \\\u0026lt; $b ]，结果是 true   文件测试运算符  假设文件test的大小是 100 Bytes，且有读写和可执行权限，file=\u0026quot;test\u0026quot; -b file是否是块文件，例如[ -b $file ]，结果是 false -c file是否是字符文件，例如[ -c $file ]，结果是 false -d file是否是文件夹，例如[ -d $file ]，结果是 false -f file是否是普通文件（不是块/字符文件，也不是文件夹），例如[ -f $file ]，结果是 true -g file是否设置了group ID 位，即 SGID，例如[ -g $file ]，结果是 false -k file是否设置了 sticky 位，例如[ -k $file ]，结果是 false -p file是否是一个命名的管道，例如[ -p $file ]，结果是 false -t file文件描述符是否打开且和一个终端相关，例如[ -t $file ]，结果是 false -u file是否设置了 user ID 位，即 SUID，例如[ -u $file ]，结果是 false -r file是否可读，例如[ -r $file ]，结果是 true -w file是否可写，例如[ -w $file ]，结果是 true -x file是否可执行，例如[ -x $file ]，结果是 true -s file文件大小是否大于 0，例如[ -s $file ]，结果是 true -e file文件是否存在，如果是一个存在的文件夹也返回 true，例如[ -e $file ]，结果是 true  C Shell 操作符 Korn Shell 操作符 字符串截取  按指定长度截取\n ${str:n1:n2}从左边第 n1+1 个字符串开始，长度为 n2 ${str:0-n1:n2}从右边第 n1 个字符串开始，长度为 n2 ${str:n1}从左边第 n1+1 个字符串开始到最后\nvar=\u0026quot;aa1c10e139bf750b3335e896f366665cfa40d95f\u0026quot; echo ${var:1:3} #a1c echo ${var:0-1:3} #f echo ${var:0-4:3} #d95 echo ${var:1} #a1c10e139bf750b3335e896f366665cfa40d95f    here document  here document 是一种重定向方式，基本形式如下\n 将两个 delimiter 直接的内容传递给 cmd 作为输入参数 \u0026gt;是终端产生的提示输入信息的标识符\ncmd \u0026lt;\u0026lt; delimiter here document content delimiter   例如在终端向一个文件写入多行\ncat \u0026lt;\u0026lt; EOF \u0026gt; output.sh echo \u0026quot;hello\u0026quot; echo \u0026quot;world\u0026quot; EOF  内容可以包括普通字符，也可以使用变量\n 执行脚本sh output.sh haha，$1被替换为haha 不想展开变量，则在起始的 delimiter 前后添加引号实现cat \u0026lt;\u0026lt; \u0026quot;EOF\u0026quot; \u0026gt; output.sh\ncat \u0026lt;\u0026lt; EOF \u0026gt; output.sh echo \u0026quot;hello\u0026quot; echo $1 EOF   使用\u0026lt;\u0026lt;-而不是\u0026lt;\u0026lt;，可以将 here document 的内容每行前面的制表符删掉，便于编写的时候将内容部分缩进\n  参考网站  Bash Reference Manual  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"184dabd21a637248a64c19e82c3bae1f","permalink":"https://xueqing.github.io/blog/shell/shell_script/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/shell/shell_script/","section":"blog","summary":"在 shell 脚本中调用另一个脚本 shell 命令行选项解析 getopts getopt shell 获取脚本的进程 ID shell 脚本获取当前时间 shell 执行多个命令的方法 shell test 命令 数值测试 字符串测试 文件测试 连接测","tags":["shell"],"title":"shell 脚本","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  对称密码算法 非对称密码算法 密码杂凑算法 签名算法 随机数生成算法 算法总结对比 算法在国标中的应用  对称密码算法  对称，即采用这种加密方法的双发使用相同的密钥加密和解密  发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，将复杂的加密密文发送出去 接收方收到密文，使用加密密钥及相同算法的逆算法解密密文，恢复成可读明文  国标要求  用于加密任意大小的数据块或数据流的内容，包括消息、文件、加密密钥和口令 使用 SM1、SM4 分组密码算法 OFB 模式，用于视频数据的加密保护 使用 SM4 分组密码算法 ECB 模式，用于密钥协商数据的加密保护   非对称密码算法  需要两个密钥  公开密钥(public key，简称公钥)，对数据进行加密之后只有对应私钥可以解密 私有密钥(private key，简称私钥)，对数据进行加密之后只有对应公钥可以解密  具体流程  乙方生成一对密钥(公钥和私钥)，并将公钥公开 甲方得到公钥，使用公钥对信息加密后发给乙方 乙方用自己的私钥解密密文  国标要求  用于加密小的数据块，如加密密钥或数字签名中使用的 Hash 函数值 使用 SM2 椭圆曲线密码算法，用于身份认证、数字签名、密钥协商等   密码杂凑算法  杂凑函数  输出串称为消息的杂凑值 杂凑函数公开，对处理过程不保密  安全的杂凑函数需要满足的条件  输入长度任意 输出长度固定，根据目前的计算技术应至少取 128 bit 长，以便抵抗生日攻击 对每一个给定的输入，计算输出即杂凑值是容易的 给定杂凑函数的描述，找到两个不同的输入消息杂凑到同一个值是计算上不可行的，或给定杂凑函数的描述和一个随机选择的消息，找到另一个与该消息不同的消息使得它们杂凑到同一个值是计算上不可行的  国标要求  使用 SM3 密码杂凑算法，用于完整性校验   签名算法  数字签名式通过一个单向函数，对要传送的信息进行处理得到的一个字母数字串，用以认证信息来源，并核实信息在传送过程中是否发生变化 数字签名功能：  保证信息传输的完整性。因为数字签名代表了文件的特征，如果文件改变，数字摘要也会变化 确保发送者的身份认证。因为别人不能假冒发送方的签名 防止交易中的抵赖发生。在密文背景下，抵赖指的是不承认与消息有关的举动(即声称消息来自第三方)。消息的接收方可通过数字签名来防止所有后续的抵赖行为，因为接收方可以出示签名来证明信息的来源  具体流程  发送报文时，发送方用一个杂凑函数从报文文本中生成报文摘要 将摘要信息用发送者的私钥加密作为报文的数字签名，与原文一起传送给接收者 接收者只有用发送者的公钥解密被加密的摘要信息，然后用相同的杂凑函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。相同则说明收到的信息是完整的，否则说明信息被修改过  数字签名式加密过程，数字签名验证是解密过程  随机数生成算法  随机数：随机数是专门的随机试验的结果  随机数发生器：产生随机数的方法 随机数的特征：后面产生的随机数和前面生成的随机数没有关系 根据密码学原理，随机数的随机性检验可分为三个标准： 统计学伪随机性：指的是在给定的随机比特流样本中，1 的数量大致等于 0 的数量 密码学安全伪随机性：给定随机样本的一部分和随机算法，不能有效的演算出随机样本的剩余部分 真随机性：即随机样本不可重现。实际上只要给定边界条件，真随机数并不存在。可是如果产生一个真随机数样本的边界条件十分复杂且难以捕捉，可认为用这个方法演算出了真随机数 随机数分类： 伪随机数：满足第一个条件的随机数 密码学安全的伪随机数：同时满足前两个条件的随机数。可以通过密码学安全伪随机数生成器计算得出 真随机数：同时满足三个条件的随机数  国标要求  生成的随机数应能通过 GM/T 0005-2012 中规定的方法进行检测   算法总结对比    算法 描述 优点 缺点 常见算法 应用     对称加密 也称为单密钥加密或密钥加密，同一个密钥可以同时用作信息的加密和解密 算法公开、计算量小、加密速度快、加密效率高 数据传送前，收发双方需商定好密钥，然后双方需要保存好密钥，否则导致加密信息不安全；每对用户每次使用时需要使用其他人不知道的唯一密钥。使得收发双发拥有的密钥数量巨大，密钥管理成为负担 DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK 通常用于发送方需要加密大量数据时使用   非对称加密 需要两个密钥进行加密和解密，分别是公开密钥和私有密钥 安全性高，减轻了密钥管理的负担 加密和解密时间长、速度慢 RSA、Elgamal、背包算法、Rabin、D-H、ECC(椭圆曲线加密算法) 适合对少量数据进行加密   杂凑算法 也称为 Hash 函数(杂凑/哈希/消息摘要函数)，是把任意长的输入消息串变化成固定长的输出串的一种函数 单向过程，逆向操作难以完成，碰撞的几率非常小 —— HAVAL、MD2、MD4、MD5、SHA-0、SHA-1、SHA-256/224、SHA-512/384、SM3 一般用于产生信息摘要、密钥加密等，用于完整性校验以及提高数字签名的有效性   签名算法 指数字签名的算法。数字签名，是只有信息的发送者才能产生的别人无法伪造的一段数字串，这段数字串也是对发送的信息真实性的一个有效证明 —— —— Rabin、DSS、RSA 个人安全邮件证书   随机算法 产生随机数 —— —— 蒙特卡罗算法、随机 K 选择法、随机快排序、素性判定的随机算法、二阶段随机路由算法 ——    算法在国标中的应用    分类 算法 国标应用 长度     非对称密码算法 SM2 椭圆曲线密码算法 用于用户身份认证、数字签名、密钥协商 公钥至少 256 位   对称密码算法 SM1、SM4 分组密码算法 OFB 模式 用于视频数据的加密保护    - SM4 分组密码算法 ECB 模式 用于密钥协商数据的加密保护    密码杂凑算法 SM3 密码杂凑算法 用于完整性校验    随机数生成算法  生成随机数，应能通过 GM/T 0005-2012 中规定的方法进行检测     ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"af94ab3f96e1e1c06364396fd43cce40","permalink":"https://xueqing.github.io/blog/sip/algo/sip_algorithm/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/algo/sip_algorithm/","section":"blog","summary":"对称密码算法 非对称密码算法 密码杂凑算法 签名算法 随机数生成算法 算法总结对比 算法在国标中的应用 对称密码算法 对称，即采用这种加密方法的双发使用相同","tags":["sip"],"title":"SIP 相关算法总结","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 术语 2 简介 3 sipML5 源码分析  3.1 注册 3.1.1 建立 WebSocket 连接 3.1.2 生成 SIP 头 3.1.3 发送注册的 SIP 信息(用 session 管理) 3.1.4 收到 200 OK 3.2 呼叫 3.2.1 呼叫过程中的 SDP 与流 3.2.2 双向(默认) 3.2.3 单向(可扩充)  4 API  4.1 类图 4.2 初始化引擎 4.3 创建 SIP 栈 4.4 注册/登录 4.5 创建/接收音频/视频会话 4.6 共享屏幕/桌面 4.7 发送/接收 SIP MESSAGE(类似 SMS) 4.8 发布存在状态 4.9 订阅存在状态  5 浏览器、webrtc2sip 与服务器的信令交互流程  5.1 注册流程 5.2 主叫流程 5.3 被叫流程 5.4 终端挂断流程 5.5 MCU 挂断流程 5.6 注销流程  6 问题  6.1 安全机制 6.2 信令兼容  7 源码发布  7.1 安装 java 7.2 发布  8 参考  1 术语    缩写 定义 术语     RTC real-time communication 实时通信   SIP session initiation protocol 会话初始协议   SMS short message service 短信服务   ICE Internet communication engine 互联网通讯引擎   DTLS datagram transport layer security 数据报传输层安全   SRTP secure real-time transport protocol 安全实时传输协议   WSS secure websocket -   MCU multi conference unit -   NGN next generation network 下一代网络    2 简介  sipML5 是开源的 HTML5 SIP 客户端 媒体栈依赖于 WebRTC，建议使用 Chrome 和 Firefox Nightly 测试  Safari，Firefox，Opera 和 IE 需要安装 webrtc-everywhere 扩展 主要功能包括生成 SDP、采集本机摄像头和麦克风的音视频数据、传输媒体数据、处理接收到的音视频数据等  SIP 和 SDP 栈由 JavaScript 实现，网络传输使用 WebSocket  SIP 协议栈：生成和解析 SIP 信令 SDP 协议栈：生成和解析 SDP 信令   3 sipML5 源码分析  主要包括 3 个模块  media：主要是会话管理和媒体处理(包括 SDP 的生成和修改) SDP：实现 SDP 协议栈，包括 SDP 的修改和解析函数 SIP：实现 SIP 协议栈(包括 SIP 的修改和解析函数)和与多媒体网关进行信令交互(WebSocket)  一般而言，需要进行功能扩充和修改的地方包括：  界面入口：call.htm 媒体处理模块：tmedia_session_jsep.js WebSocket 发送和接收的数据：tsip_transport.js   3.1 注册  在生成 SIP 头文件时进行修改和添加 如果收到的 SIP 协议格式不支持，将收到的进行修改 将发出的 SIP 协议进行修改  3.1.1 建立 WebSocket 连接 3.1.2 生成 SIP 头 // call.htm: function sipRegister() // create SIP stack oSipStack = new SIPml.Stack({ realm: txtRealm.value, impi: txtPrivateIdentity.value, impu: txtPublicIdentity.value, password: txtPassword.value, display_name: txtDisplayName.value, websocket_proxy_url: (window.localStorage ? window.localStorage.getItem('org.doubango.expert.websocket_server_url') : null), outbound_proxy_url: (window.localStorage ? window.localStorage.getItem('org.doubango.expert.sip_outboundproxy_url') : null), ice_servers: (window.localStorage ? window.localStorage.getItem('org.doubango.expert.ice_servers') : null), enable_rtcweb_breaker: (window.localStorage ? window.localStorage.getItem('org.doubango.expert.enable_rtcweb_breaker') == \u0026quot;true\u0026quot; : false), events_listener: { events: '*', listener: onSipEventStack }, enable_early_ims: (window.localStorage ? window.localStorage.getItem('org.doubango.expert.disable_early_ims') != \u0026quot;true\u0026quot; : true), // Must be true unless you're using a real IMS network enable_media_stream_cache: (window.localStorage ? window.localStorage.getItem('org.doubango.expert.enable_media_caching') == \u0026quot;true\u0026quot; : false), bandwidth: (window.localStorage ? tsk_string_to_object(window.localStorage.getItem('org.doubango.expert.bandwidth')) : null), // could be redefined a session-level video_size: (window.localStorage ? tsk_string_to_object(window.localStorage.getItem('org.doubango.expert.video_size')) : null), // could be redefined a session-level sip_headers: [ { name: 'User-Agent', value: 'IM-client/OMA1.0 sipML5-v1.2016.03.04' }, { name: 'Organization', value: 'Doubango Telecom' } ] }  3.1.3 发送注册的 SIP 信息(用 session 管理) // src/tinySIP/src/transports/tsip_transport.js tsip_transport.prototype.send = function (s_branch, o_message, s_dest_ip, i_dest_port) { var o_data = null; if (o_message.is_request() \u0026amp;\u0026amp; (!o_message.is_ack() || (o_message.is_ack() \u0026amp;\u0026amp; !o_message.o_hdr_firstVia)) \u0026amp;\u0026amp; !o_message.is_cancel()) { this.message_addvia(s_branch, o_message); /* should be done before tsip_transport_o_message_update() which could use the Via header */ this.message_update_aor(o_message); /* AoR */ this.message_update(o_message); /* IPSec, SigComp, ... */ } else if (o_message.is_response()) { /* AoR for responses which have a contact header (e.g. 183/200 INVITE) */ if (o_message.o_hdr_Contact) { this.message_update_aor(o_message); } if (o_message.o_hdr_firstVia.i_rport == 0) { o_message.o_hdr_firstVia.i_rport = o_message.o_hdr_firstVia.i_port; } } o_data = o_message.toString(); tsk_utils_log_info(\u0026quot;SEND: \u0026quot; + o_data); return this.__send(o_data, o_data.length); }  3.1.4 收到 200 OK // src/tinySIP/src/transports/tsip_transport.js function __tsip_transport_ws_onmessage(evt) { tsk_utils_log_info(\u0026quot;__tsip_transport_ws_onmessage\u0026quot;); var o_ragel_state = tsk_ragel_state_create(); if(typeof(evt.data) == 'string'){ tsk_ragel_state_init_str(o_ragel_state, evt.data); } else{ tsk_ragel_state_init_ai(o_ragel_state, evt.data); } var o_message = tsip_message.prototype.Parse(o_ragel_state, true); if (o_message) { tsk_utils_log_info(\u0026quot;recv=\u0026quot; + o_message); o_message.o_socket = this; return this.o_transport.get_layer().handle_incoming_message(o_message); } else { tsk_utils_log_error(\u0026quot;Failed to parse message: \u0026quot; + evt.data); return -1; } }  3.2 呼叫  下面关联文件主要是 src/tinyMEDIA/src/tmedia_session_jsep.js  3.2.1 呼叫过程中的 SDP 与流 sequenceDiagram participant A as ClientA participant stu as STUN Server participant sig as Signal Server participant B as ClientB A -\u0026gt;\u0026gt; sig: 1. connect B -\u0026gt;\u0026gt; sig: 2. connect Note right of A: 3. Create PeerConnection Note right of A: 4. Add Streams Note right of A: 5. CreateOffer A -\u0026gt;\u0026gt; sig: 6. Send Offer SDP sig -\u0026gt;\u0026gt; B: 7. Relay Offer SDP Note right of B: 8. CreateAnswer B -\u0026gt;\u0026gt; sig: 9. Send Answer SDP sig -\u0026gt;\u0026gt; A: 10. Relay Answer SDP A -\u0026gt;\u0026gt; stu: 11. Ask my IP stu -\u0026gt;\u0026gt; A: 12. OnIceCandidate A -\u0026gt;\u0026gt; sig: 13. Send candidate sig -\u0026gt;\u0026gt; B: 14. Relay candidate Note right of B: 15. AddIceCandidate B -\u0026gt;\u0026gt; stu: 16. Ask my IP stu -\u0026gt;\u0026gt; B: 17. OnIceCandidate B -\u0026gt;\u0026gt; sig: 18. Send candidate sig -\u0026gt;\u0026gt; A: 19. Relay candidate A --\u0026gt; B: 20. P2P channel Note right of B: 21. OnAddStream   Add Streams：添加本地流，对应函数onGetUserMediaSuccess  如果本地不推流，则注释掉 This.o_pc.addStream(o_stream);  __get_lo：生成 SDP，在onGetUserMediaSuccess调用This.o_pc.createOffer会发送 SDP __set_ro：获得远端 SDP 后在此函数处理 subscribe_stream_events：接收远端发送的流，在此函数中调用this.o_pc.onaddstream  3.2.2 双向(默认)  音频(默认)：直接发送带音频的 SDP 音视频(默认)：直接发送带音视频的 SDP 视频：验证可以扩充视频功能  3.2.3 单向(可扩充)  音频：web 端对流只接收不发送，SDP 修改成 sendonly 音视频：web 端对流只接收不发送，SDP 修改成 sendonly 视频：验证可以扩充视频功能  4 API // initialize the engine, start the stack and make video call from bob to alice SIPml.init( function(e){ var stack = new SIPml.Stack({realm: 'example.org', impi: 'bob', impu: 'sip:bob@example.org', password: 'mysecret', events_listener: { events: 'started', listener: function(e){ var callSession = stack.newSession('call-audiovideo', { video_local: document.getElementById('video-local'), video_remote: document.getElementById('video-remote'), audio_remote: document.getElementById('audio-remote') } ); callSession.call('alice'); } } }); stack.start(); } );  4.1 类图 4.2 初始化引擎 // initialize the media and signaling engines var readyCallback = function(e){ createSipStack(); // see next section }; var errorCallback = function(e){ console.error('Failed to initialize the engine: ' + e.message); } SIPml.init(readyCallback, errorCallback);  4.3 创建 SIP 栈 // created before any attempt to make/receive calls, send messages or manage presence var sipStack; var eventsListener = function(e){ if(e.type == 'started'){ login(); } else if(e.type == 'i_new_message'){ // incoming new SIP MESSAGE (SMS-like) acceptMessage(e); } else if(e.type == 'i_new_call'){ // incoming audio/video call acceptCall(e); } } function createSipStack(){ sipStack = new SIPml.Stack({ realm: 'example.org', // mandatory: domain name impi: 'bob', // mandatory: authorization name (IMS Private Identity) impu: 'sip:bob@example.org', // mandatory: valid SIP Uri (IMS Public Identity) password: 'mysecret', // optional display_name: 'Bob legend', // optional websocket_proxy_url: 'wss://sipml5.org:10062', // optional outbound_proxy_url: 'udp://example.org:5060', // optional enable_rtcweb_breaker: false, // optional events_listener: { events: '*', listener: eventsListener }, // optional: '*' means all events sip_headers: [ // optional { name: 'User-Agent', value: 'IM-client/OMA1.0 sipML5-v1.0.0.0' }, { name: 'Organization', value: 'Doubango Telecom' } ] } ); } sipStack.start(); // asynchronous function  4.4 注册/登录 var registerSession; var eventsListener = function(e){ console.info('session event = ' + e.type); if(e.type == 'connected' \u0026amp;\u0026amp; e.session == registerSession){ makeCall(); sendMessage(); publishPresence(); subscribePresence('johndoe'); // watch johndoe's presence status change } } var login = function(){ registerSession = sipStack.newSession('register', { events_listener: { events: '*', listener: eventsListener } // optional: '*' means all events }); registerSession.register(); }  4.5 创建/接收音频/视频会话 var callSession; var eventsListener = function(e){ console.info('session event = ' + e.type); } var makeCall = function(){ callSession = sipStack.newSession('call-audiovideo', { video_local: document.getElementById('video-local'), video_remote: document.getElementById('video-remote'), audio_remote: document.getElementById('audio-remote'), events_listener: { events: '*', listener: eventsListener } // optional: '*' means all events }); callSession.call('johndoe'); } // to accept incoming audio/video call var acceptCall = function(e){ e.newSession.accept(); // e.newSession.reject() to reject the call }  4.6 共享屏幕/桌面  类比上述创建视频会话，区别在于会话类型(call-screenshare而不是call-audiovideo) 屏幕/桌面共享会话不包括音频流，所以在需要增加 SDP 的m类型来发送音频 关于浏览器设置  4.7 发送/接收 SIP MESSAGE(类似 SMS) var messageSession; var eventsListener = function(e){ console.info('session event = ' + e.type); } var sendMessage = function(){ messageSession = sipStack.newSession('message', { events_listener: { events: '*', listener: eventsListener } // optional: '*' means all events }); messageSession.send('johndoe', 'Pêche à la moule', 'text/plain;charset=utf-8'); } // To accept incoming SIP MESSAGE var acceptMessage = function(e){ e.newSession.accept(); // e.newSession.reject(); to reject the message console.info('SMS-content = ' + e.getContentString() + ' and SMS-content-type = ' + e.getContentType()); }  4.8 发布存在状态 var publishSession; var eventsListener = function(e){ console.info('session event = ' + e.type); } var publishPresence = function(){ publishSession = sipStack.newSession('publish', { events_listener: { events: '*', listener: eventsListener } // optional: '*' means all events }); var contentType = 'application/pidf+xml'; var content = '\u0026lt;?xml version=\\\u0026quot;1.0\\\u0026quot; encoding=\\\u0026quot;UTF-8\\\u0026quot;?\u0026gt;\\n' + '\u0026lt;presence xmlns=\\\u0026quot;urn:ietf:params:xml:ns:pidf\\\u0026quot;\\n' + ' xmlns:im=\\\u0026quot;urn:ietf:params:xml:ns:pidf:im\\\u0026quot;' + ' entity=\\\u0026quot;sip:bob@example.com\\\u0026quot;\u0026gt;\\n' + '\u0026lt;tuple id=\\\u0026quot;s8794\\\u0026quot;\u0026gt;\\n' + '\u0026lt;status\u0026gt;\\n'+ ' \u0026lt;basic\u0026gt;open\u0026lt;/basic\u0026gt;\\n' + ' \u0026lt;im:im\u0026gt;away\u0026lt;/im:im\u0026gt;\\n' + '\u0026lt;/status\u0026gt;\\n' + '\u0026lt;contact priority=\\\u0026quot;0.8\\\u0026quot;\u0026gt;tel:+33600000000\u0026lt;/contact\u0026gt;\\n' + '\u0026lt;note xml:lang=\\\u0026quot;fr\\\u0026quot;\u0026gt;Bonjour de Paris :)\u0026lt;/note\u0026gt;\\n' + '\u0026lt;/tuple\u0026gt;\\n' + '\u0026lt;/presence\u0026gt;'; // send the PUBLISH request publishSession.publish(content, contentType,{ expires: 200, sip_caps: [ { name: '+g.oma.sip-im' }, { name: '+sip.ice' }, { name: 'language', value: '\\\u0026quot;en,fr\\\u0026quot;' } ], sip_headers: [ { name: 'Event', value: 'presence' }, { name: 'Organization', value: 'Doubango Telecom' } ] }); }  4.9 订阅存在状态 var subscribeSession; var eventsListener = function(e){ console.info('session event = ' + e.type); if(e.type == 'i_notify'){ console.info('NOTIFY content = ' + e.getContentString()); console.info('NOTIFY content-type = ' + e.getContentType()); if (e.getContentType() == 'application/pidf+xml') { if (window.DOMParser) { var parser = new DOMParser(); var xmlDoc = parser ? parser.parseFromString(e.getContentString(), \u0026quot;text/xml\u0026quot;) : null; var presenceNode = xmlDoc ? xmlDoc.getElementsByTagName (\u0026quot;presence\u0026quot;)[0] : null; if(presenceNode){ var entityUri = presenceNode.getAttribute (\u0026quot;entity\u0026quot;); var tupleNode = presenceNode.getElementsByTagName (\u0026quot;tuple\u0026quot;)[0]; if(entityUri \u0026amp;\u0026amp; tupleNode){ var statusNode = tupleNode.getElementsByTagName (\u0026quot;status\u0026quot;)[0]; if(statusNode){ var basicNode = statusNode.getElementsByTagName (\u0026quot;basic\u0026quot;)[0]; if(basicNode){ console.info('Presence notification: Uri = ' + entityUri + ' status = ' + basicNode.textContent); } } } } } } } } var subscribePresence = function(to){ subscribeSession = sipStack.newSession('subscribe', { expires: 200, events_listener: { events: '*', listener: eventsListener }, sip_headers: [ { name: 'Event', value: 'presence' }, // only notify for 'presence' events { name: 'Accept', value: 'application/pidf+xml' } // supported content types (COMMA-sparated) ], sip_caps: [ { name: '+g.oma.sip-im', value: null }, { name: '+audio', value: null }, { name: 'language', value: '\\\u0026quot;en,fr\\\u0026quot;' } ] } ); // start watching for entity's presence status (You may track event type 'connected' to be sure that the request has been accepted by the server) subscribeSession.subscribe(to); }  5 浏览器、webrtc2sip 与服务器的信令交互流程 5.1 注册流程  浏览器和 webrtc2sip 基于 HTTP 协议进行一次握手，建立 WebSocket 通道 浏览器和 webrtc2sip 通过 WebSocket 通道进行 SIP 消息交互 webrtc2sip 和 MCU 通过 UDP 进行 SIP 信息交互\nsequenceDiagram participant wb as Web Browser participant w2s as webrtc2sip participant MCU wb -\u0026gt;\u0026gt; w2s: 1. WebSocket 请求 (HTTP) w2s -\u0026gt;\u0026gt; wb: 2. WebSocket 回复 (HTTP) wb --\u0026gt; w2s: 建立 WebSocket 通道 wb -\u0026gt;\u0026gt; w2s: 3. Register (WS) w2s -\u0026gt;\u0026gt; MCU: 4. Register (UDP) MCU -\u0026gt;\u0026gt; w2s: 5. 100 Trying (UDP) w2s -\u0026gt;\u0026gt; wb: 6. 100 Trying (WS) MCU -\u0026gt;\u0026gt; w2s: 7. 401 Unauthorized (UDP) w2s -\u0026gt;\u0026gt; wb: 8. 401 Unauthorized (WS) wb -\u0026gt;\u0026gt; w2s: 9. Register (WS) w2s -\u0026gt;\u0026gt; MCU: 10. Register (UDP) MCU -\u0026gt;\u0026gt; w2s: 11. 100 Trying (UDP) w2s -\u0026gt;\u0026gt; wb: 12. 100 Trying (WS) MCU -\u0026gt;\u0026gt; w2s: 13. 200 OK (UDP) w2s -\u0026gt;\u0026gt; wb: 14. 200 OK (WS)   5.2 主叫流程 sequenceDiagram participant wb as Web Browser participant w2s as webrtc2sip participant MCU wb --\u0026gt; w2s: 建立 WebSocket 通道 wb -\u0026gt;\u0026gt; w2s: 1. INVITE (WS) w2s -\u0026gt;\u0026gt; MCU: 2. INVITE (UDP) MCU -\u0026gt;\u0026gt; w2s: 3. 100 Trying (UDP) w2s -\u0026gt;\u0026gt; wb: 4. 100 Trying (WS) w2s -\u0026gt;\u0026gt; wb: 5. 180 Ringing (WS) MCU -\u0026gt;\u0026gt; w2s: 6. 200 OK (UDP) w2s -\u0026gt;\u0026gt; wb: 7. 200 OK (WS) wb -\u0026gt;\u0026gt; w2s: 8. ACK (WS) w2s -\u0026gt;\u0026gt; MCU: 9. ACK (UDP)  5.3 被叫流程 sequenceDiagram participant wb as Web Browser participant w2s as webrtc2sip participant MCU wb --\u0026gt; w2s: 建立 WebSocket 通道 MCU -\u0026gt;\u0026gt; w2s: 1. INVITE (UDP) w2s -\u0026gt;\u0026gt; wb: 2. INVITE (WS) wb -\u0026gt;\u0026gt; w2s: 3. 100 Trying (WS) w2s -\u0026gt;\u0026gt; MCU: 4. 100 Trying (UDP) wb -\u0026gt;\u0026gt; w2s: 5. 180 Ringing (WS) w2s -\u0026gt;\u0026gt; MCU: 6. 180 Ringing (UDP) wb -\u0026gt;\u0026gt; w2s: 7. 200 OK (WS) w2s -\u0026gt;\u0026gt; MCU: 8. 200 OK (UDP) MCU -\u0026gt;\u0026gt; w2s: 9. ACK (UDP) w2s -\u0026gt;\u0026gt; wb: 10. ACK (WS)  5.4 终端挂断流程 sequenceDiagram participant wb as Web Browser participant w2s as webrtc2sip participant MCU wb --\u0026gt; w2s: 建立 WebSocket 通道 wb -\u0026gt;\u0026gt; w2s: 1. BYE (WS) w2s -\u0026gt;\u0026gt; MCU: 2. BYE (UDP) MCU -\u0026gt;\u0026gt; w2s: 3. 100 Trying (UDP) MCU -\u0026gt;\u0026gt; w2s: 4. 200 OK (UDP) w2s -\u0026gt;\u0026gt; wb: 5. 200 OK (WS)  5.5 MCU 挂断流程 sequenceDiagram participant wb as Web Browser participant w2s as webrtc2sip participant MCU wb --\u0026gt; w2s: 建立 WebSocket 通道 MCU -\u0026gt;\u0026gt; w2s: 1. BYE (UDP) w2s -\u0026gt;\u0026gt; wb: 2. BYE (WS) wb -\u0026gt;\u0026gt; w2s: 3. 200 OK (WS) w2s -\u0026gt;\u0026gt; MCU: 4. 200 OK (UDP)  5.6 注销流程 类比注册流程，但是 Contact 头域的 expires 设置为 0\n6 问题 6.1 安全机制  sipML5 基于 WebRTC 和 WebSocket，所以需要浏览器支持二者 sipML5 在进行呼叫业务需要借助 WebRTC 访问本地摄像头，所以涉及到安全机制  一般需要 https 部署访问 如果没有 https，只能用 localhost 呼叫业务，或者用 Firefox 浏览器呼叫业务(Firefox 解除了 https 的安全机制)。但是 Firefox 不同版本对于 sipML5 的支持可能存在一些问题   6.2 信令兼容  SDP 的描述需要兼容  webrtc2sip 中，INVITE 携带的 SDP 的 m 字段必须与 200 OK 所携带的 SDP 的 m 字段一一对应，否则建立会话但不会处理流  webrtc2sip 与 SIP 网关的 SIP 信令存在差异，可在二者之间添加 SIP 代理 webrtc2sip 中，如果 SDP 的端口对应 sendrecv，根据 RFC 规范，对于 SIP 客户端发过来的 RTP 和 RTCP 流会进行端口重设，之后 webrtc2sip将流推送到重新设置的端口，即把流推送到 SIP 客户端的发送端口，可注释重设端口的代码 播放音频没有声音：可能是音频采样率的原因，在代码中重设音频采样率 会话建立后，SIP 客户端可能 20s 后才显示画面：会话没完全建立时，I 帧已经发生但是未与 SIP 客户端成功建立会话导致 I 帧丢失，要在编码单元设置 I 帧间隔  7 源码发布  环境：ubuntu16.04  7.1 安装 java # 在终端输入 java, 如果未安装会提示可选择的安装包 sudo apt-get install openjdk-8-jre-headless  7.2 发布 # 执行工程中的脚本文件 release.sh ./release.sh  8 参考  sipML5 web浏览器无插件播放实时音视频技术\u0026mdash;sipML5(二) web浏览器无插件播放实时音视频技术\u0026mdash;webrtc2sip 与 第三方 SIP 网关对接(五)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d79895a7c9bcda0773af63f5c8c51df2","permalink":"https://xueqing.github.io/blog/webrtc/sip/sipml5/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/webrtc/sip/sipml5/","section":"blog","summary":"1 术语 2 简介 3 sipML5 源码分析 3.1 注册 3.1.1 建立 WebSocket 连接 3.1.2 生成 SIP 头 3.1.3 发送注册的 SIP 信息(用 session 管理) 3.1.4 收到 200 OK 3.2 呼叫 3.2.1 呼叫过程中的 SDP 与流 3.2.2 双向(默认) 3.2.3 单向(","tags":["webrtc","sip"],"title":"sipML5","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  sizeof strlen 总结 参考  sizeof  sizeof 是编译时一元运算符，可用于计算运算元的大小 sizeof 作用于 unsigned int 时，结果一般表示为 size_t sizeof 可用于任何数据类型，包括基本类型(比如整型、浮点型、指针类型)或符合数据类型(比如结构体、联合体等) sizeof 计算结构体的大小时，并不一定等于结构体每个成员 sizeof 计算结果之和\n 原因：编译器因为对齐问题会给结构体增加填充。不同编译器的对齐约束可能不同，所以填充大小也不确定。当结构体的一个成员之和有一个更大的成员，或者在结构体最后时，前者可能会被填充 C 编译器不允许编译器重排结构体的成员来减小填充。为了最下滑填充，结构体的成员必须按照从大到小的顺序排列\n#include \u0026lt;stdio.h\u0026gt; int main() { struct A { int x; //sizeof(int)=4, Padding of 4 bytes double z; //sizeof(double)=8 short int y;//sizeof(short int)=2, Padding of 6 bytes }; printf(\u0026quot;Size of struct: %d\u0026quot;, sizeof(struct A));//24 struct B { double z; //sizeof(double)=8 int x; //sizeof(int)=4 short int y;//sizeof(short int)=2, Padding of 2 bytes }; printf(\u0026quot;Size of struct: %d\u0026quot;, sizeof(struct B));//16 struct C { double z; //sizeof(double)=8 short int y;//sizeof(short int)=2, Padding of 2 bytes int x; //sizeof(int)=4 }; printf(\u0026quot;Size of struct: %d\u0026quot;, sizeof(struct C));//16 return 0; }    strlen  strlen 是 C 语言预定义的函数，包含在头文件 string.h 中 strlen 接受指向数组的指针作为参数，并在运行时从该地址开始遍历查找 NULL 字符，然后计算在找到 NULL 字符钱经过的内存大小 strlen 的主要用于计算一个数组或字符串的长度\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char ch[]={'g', 'e', 'e', 'k', 's', '\\0'}; printf(\u0026quot;Length of string is: %d\u0026quot;, strlen(ch));//5 char str[]= \u0026quot;geeks\u0026quot;; printf(\u0026quot;Length of string is: %d\u0026quot;, strlen(str));//5 char *str1 = \u0026quot;geeks\u0026quot;; printf(\u0026quot;Length of string is: %d\u0026quot;, strlen(str1));//5 return 0; }   总结    差异 sizeof strlen     原型 - size_t strlen(const char * str);   类型 一元运算符 C 预定义的函数   支持的数据类型 返回任何数据(分配的)的实际大小，单位是 Byte，包含 null 值 返回字符串或字符数组的长度   计算大小 sizeof 是编译时表达式，返回一个类型或变量的大小，并不关心变量的值 strlen 是运行时计算，返回一个 C 风格的以 NULL 结尾的字符串的长度   C++ 中 sizeof 常用作 malloc/memcpy/memset 的参数，C++ 可用 new/std::copy/std::fill 或构造函数替换 C 风格的字符串使用 char_traits::length 获取长度，也可用 std::string 类型保存计算    #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { char str[] = \u0026quot;November\u0026quot;; printf(\u0026quot;Length of String is %d\\n\u0026quot;, strlen(str));//8 printf(\u0026quot;Size of String is %d\\n\u0026quot;, sizeof(str));//9 } // 字符串以 NULL 字符，即 '\\0' 结束，strlen 计算找到 NULL 字符经过的内存大小，不会计算 NULL。而 sizeof 返回为运算元实际分配的内存，也会计算 NULL  #include \u0026lt;iostream\u0026gt; #include \u0026lt;string.h\u0026gt; using namespace std; int main() { char a[] = {\u0026quot;Geeks for\u0026quot;}; char b[] = {'G','e','e','k','s',' ','f','o','r'}; cout \u0026lt;\u0026lt; \u0026quot;sizeof(a) = \u0026quot; \u0026lt;\u0026lt; sizeof(a);//10 cout \u0026lt;\u0026lt; \u0026quot;\\nstrlen(a) = \u0026quot;\u0026lt;\u0026lt; strlen(a);//9 cout\u0026lt;\u0026lt; \u0026quot;\\nsizeof(b) = \u0026quot; \u0026lt;\u0026lt; sizeof(b);//9 cout\u0026lt;\u0026lt; \u0026quot;\\nstrlen(b) = \u0026quot; \u0026lt;\u0026lt; strlen(b);//18，不确定 return 0; } // strlen 找不到 NULL 字符，返回结果是不确定的  参考  Difference between strlen() and sizeof() for string in C Sizeof vs Strlen  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"bd8f5c440e147317a2330d5a30e8cb9b","permalink":"https://xueqing.github.io/blog/cplusplus/sizeof_strlen/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/sizeof_strlen/","section":"blog","summary":"sizeof strlen 总结 参考 sizeof sizeof 是编译时一元运算符，可用于计算运算元的大小 sizeof 作用于 unsigned int 时，结果一般表示为 size_t sizeof 可用于任何数据类型，包括基本类型(比如整型、浮点","tags":["c++"],"title":"sizeof vs strlen","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"/* Exercise: Slices Implement Pic. It should return a slice of length dy, each element of which is a slice of dx 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values. The choice of image is up to you. Interesting functions include (x+y)/2, x*y, and x^y. (You need to use a loop to allocate each []uint8 inside the [][]uint8.) (Use uint8(intValue) to convert between types.) */ package main import \u0026quot;golang.org/x/tour/pic\u0026quot; func myPic(dx, dy int) [][]uint8 { pic := make([][]uint8, dx) for i := 0; i \u0026lt; dx; i++ { pic[i] = make([]uint8, dy) } for i := 0; i \u0026lt; dx; i++ { for j := 0; j \u0026lt; dy; j++ { pic[i][j] = uint8((i ^ j)) } } return pic } func main() { pic.Show(myPic) }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3b0e279c2e5225f6603e4d0a3b8affc4","permalink":"https://xueqing.github.io/translation/go-doc/gotour/slices/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/slices/","section":"translation","summary":"/* Exercise: Slices Implement Pic. It should return a slice of length dy, each element of which is a slice of dx 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values. The choice of image is up to you. Interesting functions include (x+y)/2, x*y, and x^y. (You need to use a loop to allocate each []uint8 inside the [][]uint8.","tags":["go-tour"],"title":"Slices","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" 算法描述  SM2 密码算法, 密钥长度为 256 比特 (私钥 256 比特, 公钥 512 比特) SM3 杂凑算法, 输出长度为 256 比特 私钥：整数, 大于等于 1, 小于 n-1 (n 为 SM2 算法的阶), 简记 k 公钥：点 (x, y), x y 两个分量的长度为 256 比特, 简记 Q SM2 算法的密文和明文等长     分类 描述 数据格式     SM2-1 椭圆曲线数字签名算法 ASN.1 包括签名值的两个部分   SM2-2 椭圆曲线密钥协商协议 ASN.1 包括对称密码算法标识, 对称密钥密文, SM2 公钥, SM2 私钥密文 (分组算法运算模式为 ECB)   SM2-3 椭圆曲线加密算法 ASN.1 包括 x y 分量, SM3 杂凑值和密文    参考  GMT 0003.1/2/3/4-2012 SM2椭圆曲线公钥密码算法 GMT 0009-2012 SM2密码算法使用规范 GMT 0010-2012 SM2密码算法加密签名消息语法规范 GMT 0014-2012 数字证书认证系统密码协议规范 GMT 0015-2012 基于SM2密码算法的数字证书格式 GMT 0034-2014 基于SM2密码算法的证书认证系统密码及其相关安全技术规范  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"286d30aa7e185af3a02fb00c5875db97","permalink":"https://xueqing.github.io/blog/sip/algo/sm2/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/algo/sm2/","section":"blog","summary":"算法描述 SM2 密码算法, 密钥长度为 256 比特 (私钥 256 比特, 公钥 512 比特) SM3 杂凑算法, 输出长度为 256 比特 私钥：整数, 大于等于 1, 小于 n-1 (n 为 SM2 算法的阶), 简记","tags":["sip"],"title":"SM2","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 算法描述  长度 len (len \u0026lt; 2^64) 比特的消息 message, 经过填充、迭代压缩、输出选裁, 输出 256 比特 (64 byte) 的杂凑值  应用  数字签名和验证 消息认证码的生成与验证 随机数的生成  参考  GMT 0004-2012 SM3密码杂凑算法  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7c8ecf5c17fe259c5f1a54ff32f6bcaa","permalink":"https://xueqing.github.io/blog/sip/algo/sm3/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/algo/sm3/","section":"blog","summary":"算法描述 长度 len (len \u0026lt; 2^64) 比特的消息 message, 经过填充、迭代压缩、输出选裁, 输出 256 比特 (64 byte) 的杂凑值 应用 数字签名和验证 消息认证码的生成与验证 随机数的生成 参考","tags":["sip"],"title":"SM3 密码杂凑算法","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 算法描述  SM4 是分组算法，分组长度 128 比特，密钥长度 128 比特 加密算法和密钥扩展算法采用 32 轮非线性迭代结果 数据加密和数据解密的算法结果相同，只是轮密钥的使用顺序相反，解密密钥是加密密钥的逆序  轮密钥是 32 比特，由加密密钥生成   参考  GMT 0002-2012 SM4分组密码算法  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"69bcfbfa7b14db72321bdccd7b13f499","permalink":"https://xueqing.github.io/blog/sip/algo/sm4/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/algo/sm4/","section":"blog","summary":"算法描述 SM4 是分组算法，分组长度 128 比特，密钥长度 128 比特 加密算法和密钥扩展算法采用 32 轮非线性迭代结果 数据加密和数据解密的算法结果相同，只是轮密钥","tags":["sip"],"title":"SM4 分组密码算法","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"# 安装 chocolatey，类似于 OS X 的 Homebrew # 管理员打开 powershell Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) # 测试 choco，在终端输入 choco 或 choco -? choco -? # 查看帮助文档 # 安装 python choco install python # 安装 setuptools 和 pip python -m ensurepip --default-pip # 如果上述命令不生效，使用源码安装 ## 下载 [get-pip.py](https://bootstrap.pypa.io/get-pip.py) ## 使用源码安装和升级 pip。且会确定 setuptools 和 wheel 的环境 python get-pip.py [--prefix=/usr/local/] # 更新 pip/setuptools/wheel python -m pip install -U pip setuptools wheel # 查看可执行文件路径。可能需要将可执行文件路径加入系统 PATH python -m site --user-base ## Unix：修改 ~/.profile，添加 BIN_DIR/bin，执行 source 生效 ## windows：添加 BIN_DIR/../Scripts，执行 source 生效 # 创建虚拟环境 python3 -m venv \u0026lt;DIR\u0026gt; python3 -m venv for_sphinx # 激活虚拟环境 ## Unix：source \u0026lt;DIR\u0026gt;/bin/activate source for_sphinx/bin/activate ## windows：\u0026lt;DIR\u0026gt;\\Scripts\\activate for_sphinx\\Scripts\\activate # 取消激活 deactivate # 删除一个虚拟环境，只需要删除对应目录 rm -rf for_sphinx # 安装 pipenv，是 Python 项目的依赖管理器。方便管理多个虚拟环境 pip install --user pipenv # 使用 pipenv 安装包 pipenv install package_name # 运行 pipenv run python filename.py  Installing Chocolatey Installing Packages Managing Application Dependencies\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d27b118e4d2499a487458e134e38ae8a","permalink":"https://xueqing.github.io/blog/others/sphinx/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/others/sphinx/","section":"blog","summary":"# 安装 chocolatey，类似于 OS X 的 Homebrew # 管理员打开 powershell Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) # 测试 choco，在终端输入 choco 或 choco -? choco -? # 查看帮助文档 # 安装 python choco install python","tags":["sphinx"],"title":"Sphinx 安装和配置","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  介绍 算法  头文件 algorithm 排序 搜索 重要的 STL 算法  未加工算法 加工算法  有用的 Array 算法 划分操作 头文件 valarray  容器  顺序容器 array vector deque forward_list list 容器适配器 stack queue priority_queue 关联容器 set multiset map multimap 无序关联容器 unordered_set unordered_multiset unordered_map unordered_multimap  仿函数 迭代器 参考  介绍  STL(Standard Template Library，标准模板库)是 C++ 模板类集合，提供了统一的编程书籍结构和函数。 STL 是容器类、算法和迭代器的库，是一个通用的库，组件都是参数化的。 STL 有 4 个组件：算法、容器、函数和迭代器。  算法  定义了 STL 的基础性的算法(均为函数模板)，用于给定范围的元素。 C++98 中有 70 个算法模板函数，C++11 增加了 20 个算法模板函数，其中有 5 个定义在 numeric 头文件，其他定义在 algorithm 中 numeric 头文件包含的算法模板函数  accumulate：累加序列值 adjacent_difference：计算相邻两项的差值 inner_product：计算输入序列的内积 partial_sum：计算序列的部分累加值 iota：保存增加的连续值序列   头文件 algorithm 排序  函数原型：  template \u0026lt;class RandomAccessIterator\u0026gt; void sort (RandomAccessIterator first, RandomAccessIterator last); template \u0026lt;class RandomAccessIterator, class Compare\u0026gt; void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);  底层使用快排实现。 算法复杂度： O(N*lgN)。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; void show(int a[]) { for(int i=0; i\u0026lt;10; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; } int main() { int a[10]={1, 5, 8, 9, 6, 7, 3, 4, 2, 0}; cout \u0026lt;\u0026lt; \u0026quot;\\n The array before sorting is : \u0026quot;; show(a); sort(a,a+10); cout \u0026lt;\u0026lt; \u0026quot;\\n The array after sorting is : \u0026quot;; show(a); return 0; }   搜索  广泛使用的搜索算法是二分搜索，前提是数组已经排好序。 函数原型：\n template \u0026lt;class ForwardIterator, class T\u0026gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026amp; val); template \u0026lt;class ForwardIterator, class T, class Compare\u0026gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026amp; val, Compare comp);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; void show(int a[], int arraysize) { for(int i=0; i\u0026lt;arraysize; ++i) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; endl; } int main() { int a[] = { 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 }; int asize = sizeof(a) / sizeof(a[0]); cout \u0026lt;\u0026lt; \u0026quot;The array is : \u0026quot;; show(a, asize); cout \u0026lt;\u0026lt; \u0026quot;Let's say we want to search for 2 in the array\u0026quot; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;So, we first sort the array\u0026quot; \u0026lt;\u0026lt; endl; sort(a, a + asize); cout \u0026lt;\u0026lt; \u0026quot;The array after sorting is : \u0026quot;; show(a, asize); cout \u0026lt;\u0026lt; \u0026quot;Now, we do the binary search for 2\u0026quot; \u0026lt;\u0026lt; endl; if(binary_search(a, a + 10, 2)) cout \u0026lt;\u0026lt; \u0026quot;Element found in the array\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026quot;Element not found in the array\u0026quot; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;Now, say we want to search for 10\u0026quot; \u0026lt;\u0026lt; endl; if(binary_search(a, a + 10, 10)) cout \u0026lt;\u0026lt; \u0026quot;Element found in the array\u0026quot; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; \u0026quot;Element not found in the array\u0026quot; \u0026lt;\u0026lt; endl; return 0; }    重要的 STL 算法 未加工算法  排序  template \u0026lt;class RandomAccessIterator\u0026gt; void sort (RandomAccessIterator first, RandomAccessIterator last); template \u0026lt;class RandomAccessIterator, class Compare\u0026gt; void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);  逆序  template \u0026lt;class BidirectionalIterator\u0026gt; void reverse (BidirectionalIterator first, BidirectionalIterator last);  返回序列中最大值的迭代器  template \u0026lt;class ForwardIterator\u0026gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last); template \u0026lt;class ForwardIterator, class Compare\u0026gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last, Compare comp);  返回序列中最小值的迭代器  template \u0026lt;class ForwardIterator\u0026gt; ForwardIterator min_element (ForwardIterator first, ForwardIterator last); template \u0026lt;class ForwardIterator, class Compare\u0026gt; ForwardIterator min_element (ForwardIterator first, ForwardIterator last, Compare comp);  计算序列元素的累加值\n template \u0026lt;class InputIterator, class T\u0026gt; T accumulate (InputIterator first, InputIterator last, T init); template \u0026lt;class InputIterator, class T, class BinaryOperation\u0026gt; T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; //For accumulate operation using namespace std; int main() { int arr[] = {10, 20, 5, 23 ,42 , 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vect(arr, arr+n); cout \u0026lt;\u0026lt; \u0026quot;Vector is: \u0026quot;; for(int i=0; i\u0026lt;n; i++) cout \u0026lt;\u0026lt; vect[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; sort(vect.begin(), vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nVector after sorting is: \u0026quot;; for(int i=0; i\u0026lt;n; i++) cout \u0026lt;\u0026lt; vect[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; reverse(vect.begin(), vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nVector after reversing is: \u0026quot;; for(int i=0; i\u0026lt;6; i++) cout \u0026lt;\u0026lt; vect[i] \u0026lt;\u0026lt; \u0026quot; \u0026quot;; cout \u0026lt;\u0026lt; \u0026quot;\\nMaximum element of vector is: \u0026quot;; cout \u0026lt;\u0026lt; *max_element(vect.begin(), vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nMinimum element of vector is: \u0026quot;; cout \u0026lt;\u0026lt; *min_element(vect.begin(), vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nThe summation of vector elements is: \u0026quot;; cout \u0026lt;\u0026lt; accumulate(vect.begin(), vect.end(), 0); cout\u0026lt;\u0026lt; endl; return 0; }   计算给定元素出现的次数\n template \u0026lt;class InputIterator, class T\u0026gt; typename iterator_traits\u0026lt;InputIterator\u0026gt;::difference_type count (InputIterator first, InputIterator last, const T\u0026amp; val);  返回指向第一个等于给定元素的指针\n template \u0026lt;class InputIterator, class T\u0026gt; InputIterator find (InputIterator first, InputIterator last, const T\u0026amp; val);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int arr[] = {10, 20, 5, 23 ,42, 20, 15}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vect(arr, arr+n); cout \u0026lt;\u0026lt; \u0026quot;Occurrences of 20 in vector : \u0026quot;; cout \u0026lt;\u0026lt; count(vect.begin(), vect.end(), 20) \u0026lt;\u0026lt; endl; find(vect.begin(), vect.end(), 5) != vect.end()? cout \u0026lt;\u0026lt; \u0026quot;Element 5 found\\n\u0026quot; : cout \u0026lt;\u0026lt; \u0026quot;Element 5 not found\\n\u0026quot;; return 0; }   二分查找指定元素\n template \u0026lt;class ForwardIterator, class T\u0026gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026amp; val); template \u0026lt;class ForwardIterator, class T, class Compare\u0026gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T\u0026amp; val, Compare comp);  返回指向第一个不小于指定元素的迭代器(序列有序)\n template \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val); template \u0026lt;class ForwardIterator, class T, class Compare\u0026gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val, Compare comp);  返回指向第一个大于指定元素的迭代器(序列有序)\n template \u0026lt;class ForwardIterator, class T\u0026gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val); template \u0026lt;class ForwardIterator, class T, class Compare\u0026gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T\u0026amp; val, Compare comp);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int arr[] = {5, 10, 15, 20, 20, 23, 42, 45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vect(arr, arr+n); sort(vect.begin(), vect.end()); for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; endl; auto q = lower_bound(vect.begin(), vect.end(), 20); cout \u0026lt;\u0026lt; \u0026quot;The lower bound for 20 is at position: \u0026quot;; cout \u0026lt;\u0026lt; q-vect.begin() \u0026lt;\u0026lt; endl; auto p = upper_bound(vect.begin(), vect.end(), 20); cout \u0026lt;\u0026lt; \u0026quot;The upper bound for 20 is at position: \u0026quot;; cout \u0026lt;\u0026lt; p-vect.begin() \u0026lt;\u0026lt; endl; return 0; }    加工算法  过滤连续相等的元素\n template \u0026lt;class ForwardIterator\u0026gt; ForwardIterator unique (ForwardIterator first, ForwardIterator last); template \u0026lt;class ForwardIterator, class BinaryPredicate\u0026gt; ForwardIterator unique (ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int arr[] = {5, 10, 15, 20, 20, 23, 42, 45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vect(arr, arr+n); for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); vect.erase(vect.begin()+1); cout \u0026lt;\u0026lt; \u0026quot;\\nVector after erasing the second element: \u0026quot;; for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); sort(vect.begin(), vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nVector before removing duplicate occurrences: \u0026quot;; for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); vect.erase(unique(vect.begin(),vect.end()),vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nVector after deleting duplicates: \u0026quot;; for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); return 0; }   返回下一个置换\n template \u0026lt;class BidirectionalIterator\u0026gt; bool next_permutation (BidirectionalIterator first, BidirectionalIterator last); template \u0026lt;class BidirectionalIterator, class Compare\u0026gt; bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);  返回前一个置换\n template \u0026lt;class BidirectionalIterator\u0026gt; bool prev_permutation (BidirectionalIterator first, BidirectionalIterator last ); template \u0026lt;class BidirectionalIterator, class Compare\u0026gt; bool prev_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int arr[] = {5, 10, 15, 20, 20, 23, 42, 45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vect(arr, arr+n); cout \u0026lt;\u0026lt; \u0026quot;Given Vector is: \u0026quot;; for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); next_permutation(vect.begin(), vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nVector after performing next permutation: \u0026quot;; for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); prev_permutation(vect.begin(), vect.end()); cout \u0026lt;\u0026lt; \u0026quot;\\nVector after performing prev permutation: \u0026quot;; for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); return 0; }   计算迭代器之间的距离。用于查找下标\n 包含在头文件 iterator template\u0026lt;class InputIterator\u0026gt; typename iterator_traits\u0026lt;InputIterator\u0026gt;::difference_type distance (InputIterator first, InputIterator last);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { int arr[] = {5, 10, 15, 20, 20, 23, 42, 45}; int n = sizeof(arr)/sizeof(arr[0]); vector\u0026lt;int\u0026gt; vect(arr, arr+n); cout \u0026lt;\u0026lt; \u0026quot;Given Vector is: \u0026quot;; for_each(vect.begin(), vect.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; \u0026quot;\\nDistance between first to max element: \u0026quot; \u0026lt;\u0026lt; distance(vect.begin(), max_element(vect.begin(), vect.end())) \u0026lt;\u0026lt; endl; return 0; }    有用的 Array 算法  以下算法在 C++11 开始支持 测试序列是否都满足某个条件  template \u0026lt;class InputIterator, class UnaryPredicate\u0026gt; bool all_of (InputIterator first, InputIterator last, UnaryPredicate pred);  测试序列是否存在一个元素满足某个条件  template \u0026lt;class InputIterator, class UnaryPredicate\u0026gt; bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);  测试序列是否都不满足某个条件  template \u0026lt;class InputIterator, class UnaryPredicate\u0026gt; bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);  拷贝序列元素  template \u0026lt;class InputIterator, class Size, class OutputIterator\u0026gt; OutputIterator copy_n (InputIterator first, Size n, OutputIterator result);  存储增加的序列\n template \u0026lt;class ForwardIterator, class T\u0026gt; void iota (ForwardIterator first, ForwardIterator last, T val);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int arr1[] = {1, 2, 3, 4, 5, -6}; all_of(arr1, arr1+6, [](int x) {return x\u0026gt;0;}) ? cout \u0026lt;\u0026lt; \u0026quot;All are positive elments\\n\u0026quot; : cout \u0026lt;\u0026lt; \u0026quot;Not all are positive elments\\n\u0026quot;; any_of(arr1, arr1+6, [](int x) {return x\u0026lt;0;}) ? cout \u0026lt;\u0026lt; \u0026quot;There exists a negative element\\n\u0026quot; : cout \u0026lt;\u0026lt; \u0026quot;All are positive elments\\n\u0026quot;; int arr2[] = {1, 2, 3, 4, 5, 6}; none_of(arr2, arr2+6, [](int x) {return x\u0026lt;0;}) ? cout \u0026lt;\u0026lt; \u0026quot;No negative elements\\n\u0026quot; : cout \u0026lt;\u0026lt; \u0026quot;There exists a negative element\\n\u0026quot;; int arrc[6]; copy_n(arr2, 6, arrc); cout \u0026lt;\u0026lt; \u0026quot;Copyed array: \u0026quot;; for_each(arrc, arrc+6, [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; endl; int arr3[6] = {0}; iota(arr3, arr3+6, 20); cout \u0026lt;\u0026lt; \u0026quot;Assigned array: \u0026quot;; for_each(arr3, arr3+6, [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; endl; return 0; }    划分操作  根据条件重排序列，返回第一个不满足条件的迭代器  template \u0026lt;class ForwardIterator, class UnaryPredicate\u0026gt; ForwardIterator partition (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);  根据条件重排序列，且两组元素内部的相对顺序保持不变。一般是用临时缓冲区实现  template \u0026lt;class BidirectionalIterator, class UnaryPredicate\u0026gt; BidirectionalIterator stable_partition (BidirectionalIterator first, BidirectionalIterator last, UnaryPredicate pred);  判断序列是否是根据条件划分的  template \u0026lt;class InputIterator, class UnaryPredicate\u0026gt; bool is_partitioned (InputIterator first, InputIterator last, UnaryPredicate pred);  输入队列已经是分割过的，二分查找分界点  template \u0026lt;class ForwardIterator, class UnaryPredicate\u0026gt; ForwardIterator partition_point (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);  输入序列中满足条件和不满足条件的分别拷贝到两个序列中\n template \u0026lt;class InputIterator, class OutputIterator1, class OutputIterator2, class UnaryPredicate pred\u0026gt; pair\u0026lt;OutputIterator1,OutputIterator2\u0026gt; partition_copy (InputIterator first, InputIterator last, OutputIterator1 result_true, OutputIterator2 result_false, UnaryPredicate pred);\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; vect1 = { 2, 1, 5, 6, 8, 7 }; cout \u0026lt;\u0026lt; \u0026quot;The vector is: \u0026quot;; for_each(vect1.begin(), vect1.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); is_partitioned(vect1.begin(), vect1.end(), [](int i) {return i%2==0;}) ? cout \u0026lt;\u0026lt; \u0026quot;\\nVector is partitioned\u0026quot; : cout \u0026lt;\u0026lt; \u0026quot;\\nVector is not partitioned\u0026quot;; partition(vect1.begin(), vect1.end(), [](int i){return i%2==0;}); cout \u0026lt;\u0026lt; \u0026quot;\\nThe partitioned vector is: \u0026quot;; for_each(vect1.begin(), vect1.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); is_partitioned(vect1.begin(), vect1.end(), [](int i) {return i%2==0;}) ? cout \u0026lt;\u0026lt; \u0026quot;\\nNow, vector is partitioned after partition operation\u0026quot;: cout \u0026lt;\u0026lt; \u0026quot;\\nVector is still not partitioned after partition operation\u0026quot;; vector\u0026lt;int\u0026gt; vect2 = { 2, 1, 5, 6, 8, 7 }; cout \u0026lt;\u0026lt; \u0026quot;\\n\\nThe vector is: \u0026quot;; for_each(vect2.begin(), vect2.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); stable_partition(vect2.begin(), vect2.end(), [](int i) {return i%2==0;}); cout \u0026lt;\u0026lt; \u0026quot;\\nThe stable partitioned vector is: \u0026quot;; for_each(vect2.begin(), vect2.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); auto it = partition_point(vect2.begin(), vect2.end(), [](int i) {return i%2==0;}); cout \u0026lt;\u0026lt; \u0026quot;\\nBefore the partition point: \u0026quot;; for_each(vect2.begin(), it, [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; \u0026quot;\\nAfter the partition point: \u0026quot;; for_each(it, vect2.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); vector\u0026lt;int\u0026gt; vect3 = { 2, 1, 5, 6, 8, 7 }; cout \u0026lt;\u0026lt; \u0026quot;\\n\\nThe vector is: \u0026quot;; for_each(vect3.begin(), vect3.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); vector\u0026lt;int\u0026gt; vecteven, vectodd; int n = count_if(vect3.begin(), vect3.end(), [](int i) {return i%2==0;}); vecteven.resize(n); vectodd.resize(vect3.size()-n); partition_copy(vect3.begin(), vect3.end(), vecteven.begin(), vectodd.begin(), [](int i) {return i%2==0;}); cout \u0026lt;\u0026lt; \u0026quot;\\nThe elements that return true for condition are : \u0026quot;; for_each(vecteven.begin(), vecteven.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; \u0026quot;\\nThe elements that return false for condition are : \u0026quot;; for_each(vectodd.begin(), vectodd.end(), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; endl; return 0; }    头文件 valarray  valarray 类：C++98 引入的特殊容器，用于保存和提供对 array 的高效算术操作 应用操作到所有的元素，返回一个新的 valarray  valarray apply (T func(T)) const; valarray apply (T func(const T\u0026amp;)) const;  返回所有元素的和  T sum() const;  返回元素的最小值  T min() const;  返回元素的最大值  T max() const;  将 valarray 的元素移位，返回新的 valarray。如果参数为正数，左移；否则右移  valarray shift (int n) const;  将 valarray 的元素循环移位，返回新的 valarray。如果参数为正数，循环左移；否则循环右移  valarray cshift (int n) const;  和另外一个 valarray 交换\n void swap (valarray\u0026amp; x) noexcept;\n#include \u0026lt;valarray\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { valarray\u0026lt;int\u0026gt; varr1 = { 10, 2, 20, 1, 30 }; cout \u0026lt;\u0026lt; \u0026quot;The varr1 is: \u0026quot;; for_each(begin(varr1), end(varr1), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; \u0026quot;\\nThe sum of varr1 is: \u0026quot; \u0026lt;\u0026lt; varr1.sum(); cout \u0026lt;\u0026lt; \u0026quot;\\nThe max of varr1 is: \u0026quot; \u0026lt;\u0026lt; varr1.max(); cout \u0026lt;\u0026lt; \u0026quot;\\nThe min of varr1 is: \u0026quot; \u0026lt;\u0026lt; varr1.min(); valarray\u0026lt;int\u0026gt; varr2; varr2 = varr1.apply([](int i){return i=i+5;}); cout \u0026lt;\u0026lt; \u0026quot;\\nThe varr2 (varr1 add 5 for each element) is: \u0026quot;; for_each(begin(varr2), end(varr2), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); valarray\u0026lt;int\u0026gt; varr3; varr3 = varr1.shift(2); cout \u0026lt;\u0026lt; \u0026quot;\\nThe varr3 (varr1 shift 2) is: \u0026quot;; for_each(begin(varr3), end(varr3), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); varr3 = varr1.shift(-2); cout \u0026lt;\u0026lt; \u0026quot;\\nThe varr3 (varr1 shift -2) is: \u0026quot;; for_each(begin(varr3), end(varr3), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); varr3 = varr1.cshift(2); cout \u0026lt;\u0026lt; \u0026quot;\\nThe varr3 (varr1 cshift 2) is: \u0026quot;; for_each(begin(varr3), end(varr3), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); varr3 = varr1.cshift(-2); cout \u0026lt;\u0026lt; \u0026quot;\\nThe varr3 (varr1 cshift -2) is: \u0026quot;; for_each(begin(varr3), end(varr3), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); valarray\u0026lt;int\u0026gt; varr4 = {2, 4, 6, 8}; cout \u0026lt;\u0026lt; \u0026quot;\\nThe varr4 is: \u0026quot;; for_each(begin(varr4), end(varr4), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); varr1.swap(varr4); cout \u0026lt;\u0026lt; \u0026quot;\\nThe varr4 after swap with varr1 is: \u0026quot;; for_each(begin(varr4), end(varr4), [](int i) {cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot; \u0026quot;;}); cout \u0026lt;\u0026lt; \u0026quot;\\n\u0026quot;; return 0; }    容器  容器是一个对象，保存了其他对象或对象元素的集合 容器自己管理元素的存储空间，并且提供成员函数来访问元素，直接访问或通过迭代器访问 容器类模板：包括顺序容器、容器适配器、关联容器和无序关联容器  顺序容器  实现的数据结构可以按顺序访问  array  C++11 引入，替换 C 风格数组。相比 C 风格数组的优点包括  array 知道自己的大小，因此传递参数时不需要单独传递 array 的大小 C 风格的数组会有退化成指针的风险，但是 array 不会 相比 C 风格数组，array 更加高效、轻量和可靠  方法  at： get：不是 array 的类成员函数，而是重载 tuple 类的函数 []: 类似于 C 风格的数组访问 front/back：返回第一个/最后一个元素 size/max_size：返回 array 的元素数目/可以承载的最大元素数目。二者返回值相同 swap：和另外一个 array 交换元素 empty：array 的大小是否是 0 fill：使用指定值填充正哥 array  固定大小数组，顺序连续存储，可使用偏移量访问 大小为 0 是有效的，但是不能间接引用，比如 front，back，data 交换是按顺序交换每个元素，效率低 可以当做 tuple（可以存储不同类型的元素的集合），重载了 get 接口等 访问快，可使用偏移量访问，常数时间  vector  大小可变数组，顺序连续存储，可使用偏移量访问 一开始分配额外的存储空间，容量一般不等于实际大小 使用动态分配数组存储元素，插入元素时可能需要重新分配数组，将所有元素移到新的数组，效率低 访问快，和 array 一样，在尾部插入和删除也快。删除元素是常数时间，不会重新调整大小 在其他位置插入和删除低效，需要线性时间。没有随机访问迭代器  deque  双端队列，顺序存储，可在两端增加或减小大小 可用随机访问迭代器直接访问单个元素 vs vector  存储可以是不连续的块，在容器增加或减小时内存分配效率更高   forward_list  C++11 引入 顺序存储，在任意位置插入和删除都是常数时间 单向链表，存储位置可以是不同的没有关系的 vs array/vector/deque  list 和 forward_list 的插入、删除更有效，对于排序算法也更快（交换更快） list 和 forward_list 没有根据位置直接访问元素的方法，同时每个节点需要额外的存储存储链接的相关信息 list 和 forward_list 遍历较慢 list 和 forward_list 没有 size 方法，因为很耗时，可以使用 distance 算法（包含在头文件\u0026lt;iterator\u0026gt;）计算 begin 和 end 之间的距离，消耗时间是线性的   list  双向链表 forward_list vs list： 前者只存储一个指向后面对象的链接，后者存储两个链接分别指向前一个和后一个对象，因此两个方向的迭代都比较搞笑，但同时每个节点需要额外的存储，且插入和删除也有额外的时间负载  容器适配器  不完全是容器类，而是依赖某一个容器类提供特定的接口，封装之后提供不同于顺序容器的接口  stack  后进先出（LIFO），使用标准的容器（vector/deque/list）类模板实现接口，如果初始化未指定容器类，则使用 deque 实现相关接口 如std::stack\u0026lt;int, std::vector\u0026lt;int\u0026gt; \u0026gt; mystack使用 vector 实现的空的 stack  queue  先进先出（FIFO）队列，使用标准的容器（deque/list）类模板实现接口，默认使用 deque 如std::queue\u0026lt;int, std::list\u0026lt;int\u0026gt; \u0026gt; myqueue使用 list 实现的空的 queue  priority_queue  依据严格的弱排序（strict weak ordering）标准第一个元素总是最大的元素，所有元素是非增序的 使用标准的容器（vector/deque）类模板实现接口，，默认是 vector C++ 默认为 priority_queue 创建最大堆\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; void showpq(priority_queue\u0026lt;int\u0026gt; \u0026amp;gq) { priority_queue\u0026lt;int\u0026gt; g = gq; while (!g.empty()) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; g.top(); g.pop(); } cout \u0026lt;\u0026lt; endl; } int main () { priority_queue\u0026lt;int\u0026gt; gquiz; gquiz.push(10); gquiz.push(30); gquiz.push(20); gquiz.push(5); gquiz.push(1); cout \u0026lt;\u0026lt; \u0026quot;The priority queue gquiz is: \u0026quot;; showpq(gquiz); cout \u0026lt;\u0026lt; \u0026quot;gquiz.size(): \u0026quot; \u0026lt;\u0026lt; gquiz.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;gquiz.top(): \u0026quot; \u0026lt;\u0026lt; gquiz.top() \u0026lt;\u0026lt; endl; gquiz.pop(); cout \u0026lt;\u0026lt; \u0026quot;after gquiz.pop(): \u0026quot;; showpq(gquiz); return 0; }  为 priority_queue 创建最小堆 priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; g=gq;\n 下面的语法难记，因此对于数字的值，可以给每个元素乘以 -1，然后使用最大值堆达到最小值堆的效果\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; void showpq(priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; \u0026amp;gq) { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; g = gq; while(!g.empty()) { cout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; g.top(); g.pop(); } cout \u0026lt;\u0026lt; endl; } int main () { priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; gquiz; gquiz.push(10); gquiz.push(30); gquiz.push(20); gquiz.push(5); gquiz.push(1); cout \u0026lt;\u0026lt; \u0026quot;The priority queue gquiz is: \u0026quot;; showpq(gquiz); cout \u0026lt;\u0026lt; \u0026quot;gquiz.size(): \u0026quot; \u0026lt;\u0026lt; gquiz.size() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026quot;gquiz.top(): \u0026quot; \u0026lt;\u0026lt; gquiz.top() \u0026lt;\u0026lt; endl; gquiz.pop(); cout \u0026lt;\u0026lt; \u0026quot;after gquiz.pop(): \u0026quot;; showpq(gquiz); return 0; }    关联容器  实现排好序的数据结构，可以达到快速查询的时间复杂度 O(logn)  set  保存的值都是唯一的，不能修改，只能插入或删除，key 和 value 相同 存储的元素总是依照严格的弱排序标准排序，通过内部的比较对象 在通过 key 访问单个元素的时候通常比 unordered_set 慢，但是可以访问有序集合的一个子集 通常实现为二分搜索树  multiset  可以存储相同值的元素 在通过 key 访问的那个元素的时候比 unordered_multiset 慢  map  关联容器，存储的对象包括一个 key 和映射的 value 通过 key 排序和标记唯一元素，存储的元素总是依照严格的弱排序标准排序，通过内部的比较对象 在通过 key 访问单个元素的时候通常比 unordered_map 慢，但是可以访问有序集合的一个子集 通常实现为二分搜索树  multimap 无序关联容器  实现无序数据结构，可以快速查询  unordered_set unordered_multiset unordered_map unordered_multimap 仿函数 迭代器 参考  C++ STL Tutorial The C++ Standard Template Library (STL) C++/STL/Algorithm C++/Numeric  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f5a59d7aa9c3c87853d13b51ac76aad4","permalink":"https://xueqing.github.io/blog/cplusplus/stl/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/stl/","section":"blog","summary":"介绍 算法 头文件 algorithm 排序 搜索 重要的 STL 算法 未加工算法 加工算法 有用的 Array 算法 划分操作 头文件 valarray 容器 顺序容器 array vector deque forward_list list 容器适配器 stack queue priority_queue 关联容器 set multiset map multimap 无序","tags":["c++","STL"],"title":"STL","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  前言 std::queue::emplace  std::deque::emplace_back std::allocator_traits::construct std::allocator std::deque::allocator  std::queue::push  std::deque::push_back  std::vector 的 emplace_back 和 push_back  产生时间 类型的构造函数不止 1 个 效率  std::map 的 emplace 和 insert 其他参考  前言  下面的说明以 STL 的 queue 为实例，其他 STL 还有 push_back/emplace_back 等，各自的影响不尽相同  deque: emplace/emplace_back/emplace_front/insert/push_back/push_front forward_list: emplace_after/emplace_front/insert_after/push_front list: emplace/emplace_back/emplace_front/insert/push_back/push_front map: emplace/emplace_hint/insert queue: emplace/push set: emplace/emplace_hint/insert stack: emplace/push vector: emplace/emplace_back/insert/push_back   std::queue::emplace  参考 std::queue::emplace 函数原型： template \u0026lt;class... Args\u0026gt; void emplace (Args\u0026amp;\u0026amp;... args);  args：被传递作为新元素构造函数的参数  功能：构造并插入一个元素。增加新元素到 queue 的末尾，即当前最后一个元素之后。将传入的参数作为新元素的构造函数的参数。 底层容器对象调用 emplace_back，并传递参数。  std::deque::emplace_back  参考 std::deque::emplace_back 函数原型：template \u0026lt;class... Args\u0026gt; void emplace_back (Args\u0026amp;\u0026amp;... args);  args：被传递作为新元素构造函数的参数  功能：构造并在末尾插入一个元素。增加新元素到 deque 的末尾，即当前最后一个元素之后。将传入的参数作为新元素的构造函数的参数。 这个操作将容器大小高效增加 1 元素通过调用 std::allocator_traits::construct 和参数构造。  新元素的存储通过 allocator_traits\u0026lt;allocator_type\u0026gt;::construct() 分配，失败时可能会抛异常(对于默认的 std::allocator，分配失败会抛 bad_alloc 异常)。  迭代器有效性：容器相关的所有迭代器无效，但是指针和引用是有效的，和调用函数之前指向的元素相同。 异常安全性：强保证。如果抛出异常，则容器没有改变。如果 std::allocator_traits::construct 对于传递的参数不支持，会导致未定义的行为。  std::allocator_traits::construct  参考 std::allocator_traits::construct 静态成员函数 函数原型：template \u0026lt;class T, class... Args\u0026gt; static void construct (allocator_type alloc, T* p, Args\u0026amp;\u0026amp;... args ); 功能：构造一个元素。在指针 p 指向的位置传递参数给构造函数构造一个元素对象。 注意：对象被 in-place 构造，而不用为元素分配存储。如果不可行，则调用 ::new (static_cast\u0026lt;void*\u0026gt;(p)) T (forward\u0026lt;Args\u0026gt;(args)...)  std::allocator  参考 std::allocator 函数原型：template \u0026lt;class T\u0026gt; class allocator;  T：对象分配的元素类型  功能：默认分配器。  分配器：定义内存模型的类，被标准库的一些部分使用，大多数情况是被 STL 容器使用。 allocator 是默认分配器模板，这是所有标准容器未指定最后一个(可选的)模板参数时会使用的分配器，也是标准库中唯一一个预定义的分配器。   std::deque::allocator  参考std::deque::get_allocator 函数原型：allocator_type get_allocator() const noexcept;  allocator_type：是容器使用的分配器的类型  功能：返回和 deque 对象相关的分配器对象的拷贝。 异常安全性：保证没有异常。拷贝默认分配器的任何实例也保存不会抛异常  std::queue::push  参考 std::queue::push 函数原型：void push (const value_type\u0026amp; val);或void push (value_type\u0026amp;\u0026amp; val);  val：经过初始化的新插入元素的值 value_type：是容器元素的类型  功能：插入一个新元素到 queue 末尾，即当前最后一个元素之后。新元素的内容被初始化为 val。 底层容器对象调用 push_back  std::deque::push_back  参考 std::deque::push_back 函数原型：void push_back (const value_type\u0026amp; val);或void push_back (value_type\u0026amp;\u0026amp; val);  val：将要拷贝或移动给新对象的值 value_type：是容器元素的类型  新元素的存储通过容器的 allocator 分配，失败时可能会抛异常(对于默认的std::allocator，分配失败会抛 bad_alloc 异常) 迭代器有效性：容器相关的所有迭代器无效，但是指针和引用是有效的，和调用函数之前指向的元素相同。 异常安全性：强保证。如果抛出异常，则容器没有改变。如果 std::allocator_traits::construct 对于传递的参数不支持，会导致未定义的行为。  std::vector 的 emplace_back 和 push_back 产生时间  push_back 是标准 C++ 创建之初就有的；emplace_back 是在 C++11 特性前提下增加的  类型的构造函数不止 1 个  当类型的构造函数不止 1 个时：push_back 只接收类型的对象，emplace_back 接收类型构造函数的参数 C++ 11 支持从参数构造对象，因此当类型的构造函数参数只有一个时，push_back 可以传入构造函数参数，C++ 11 会构造对象，并传递对象给容器\nclass OneParam { int m_i; public: OneParam(int ii) : m_i(ii) { cout \u0026lt;\u0026lt; \u0026quot;OneParam::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } OneParam(const OneParam \u0026amp;copy) : m_i(copy.m_i) { cout \u0026lt;\u0026lt; \u0026quot;OneParam::copy::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } ~OneParam( ) { cout \u0026lt;\u0026lt; \u0026quot;~OneParam::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } int get() const { return m_i; } }; class MoreThanOneParam { int m_i; string m_s; public: MoreThanOneParam(int ii, string s) : m_i(ii), m_s(s) { cout \u0026lt;\u0026lt; \u0026quot;MoreThanOneParam::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } MoreThanOneParam(const MoreThanOneParam \u0026amp;copy) : m_i(copy.m_i), m_s(copy.m_s) { cout \u0026lt;\u0026lt; \u0026quot;MoreThanOneParam::copy::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } ~MoreThanOneParam( ) { cout \u0026lt;\u0026lt; \u0026quot;~MoreThanOneParam::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } int getInt() const { return m_i; } string getString() const { return m_s; } }; int main( ) { vector\u0026lt;OneParam\u0026gt; vec1={ 21 , 45 }; //对于每个元素，构造一次，拷贝一次，析构一次 vec1.push_back( OneParam(34) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】 vec1.push_back( 901 ); //构造一次，拷贝一次，析构一次 vec1.emplace_back( OneParam(7889) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】 vec1.emplace_back( 4156 ); //构造一次 //21; 45; 34; 901; 7889; 4156; for( auto \u0026amp;elem:vec1 ) { cout \u0026lt;\u0026lt; elem.get() \u0026lt;\u0026lt; \u0026quot;; \u0026quot;; } //21; 45; 34; 901; 7889; 4156; cout \u0026lt;\u0026lt; endl; vector\u0026lt;MoreThanOneParam\u0026gt; vec2={ {21,\u0026quot;String\u0026quot;} , MoreThanOneParam{45 , \u0026quot;tinger\u0026quot;} }; //对于每个元素，构造一次，拷贝一次，析构一次 vec2.push_back( MoreThanOneParam(34 , \u0026quot;Happy\u0026quot; ) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】 // vec2.push_back( 901 , \u0026quot;Doer\u0026quot; ); //Error!! vec2.emplace_back( MoreThanOneParam(78 , \u0026quot;Gomu gomu\u0026quot; )); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】 vec2.emplace_back( 41 , \u0026quot;Shanks\u0026quot; ); //构造一次 //21 String; 45 tinger; 34 Happy; 78 Gomu gomu; 41 Shanks; for( auto \u0026amp;elem:vec2 ) { cout \u0026lt;\u0026lt; elem.getInt( ) \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; elem.getString( ) \u0026lt;\u0026lt; \u0026quot;; \u0026quot;; } cout \u0026lt;\u0026lt; endl; cin.get( ); return 0; }   效率  这里的效率指的是：代码工作更快，生成的负载更小 当 vector 的类型是内置类型时，push_back 和 emplace_back 没有区别 当 vector 的类型是用户自定义类型时，emplace_back 比 push_back 更高效  当尝试直接添加对象 (在对象被创建之前) 到 vector，使用 push_back 的流程是 调用构造函数创建临时对象 在 vector 中创建临时对象的拷贝 拷贝对象完成之后，调用析构函数销毁临时对象 使用 emplace_back 将不会创建临时对象，而是直接在 vector 中创建对象。因此提高了性能   std::map 的 emplace 和 insert  insert 需要先创建临时对象，然后拷贝到 std::pair\u0026lt;key, val\u0026gt; 中，再将 pair 拷贝到 map 中\nclass Complicated { int m_i; double m_d; string m_s; public: Complicated(int i, double d, string s) : m_i(i), m_d(d), m_s(s) { cout \u0026lt;\u0026lt; \u0026quot;Complicated::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } Complicated(const Complicated \u0026amp;copy) : m_i(copy.m_i), m_d(copy.m_d), m_s(copy.m_s) { cout \u0026lt;\u0026lt; \u0026quot;Complicated::copy::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } ~Complicated() { cout \u0026lt;\u0026lt; \u0026quot;~Complicated::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } }; int main() { map\u0026lt;int, Complicated\u0026gt; m; m.insert( make_pair(4, Complicated(4, 4.0, \u0026quot;C++4\u0026quot;)) ); //构造一次，拷贝两次，析构两次 m.insert( 5, {5, 5.0, \u0026quot;C++5\u0026quot;} ); //构造一次，拷贝两次，析构两次 m.insert( pair\u0026lt;int, Complicated\u0026gt;(7, {7, 7.0, \u0026quot;C++7\u0026quot;}) ); //构造一次，拷贝两次，析构两次 m.emplace( piecewise_construct, forward_as_tuple(6), forward_as_tuple(6, 6.0, \u0026quot;C++6\u0026quot;) ); //构造一次 //4; 5; 6; 7; for( auto \u0026amp;elem:m ) cout \u0026lt;\u0026lt; elem.first \u0026lt;\u0026lt; \u0026quot;; \u0026quot;; cout \u0026lt;\u0026lt; endl; cin.get(); return 0; }   其他参考  C++ difference between emplace_back and push_back function https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d054bc79d43f2d4d30576ae2b88f84a8","permalink":"https://xueqing.github.io/blog/cplusplus/stl_push_emplace/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/stl_push_emplace/","section":"blog","summary":"前言 std::queue::emplace std::deque::emplace_back std::allocator_traits::construct std::allocator std::deque::allocator std::queue::push std::deque::push_back std::vector 的 emplace_back 和 push_back 产生时间 类型的构造函数不止 1 个 效率 std::map 的 emplace 和 insert 其他参考 前言 下面的说明以 STL 的 queue 为实例，其他 STL 还有 push_back/emplace_back 等，各自的影响不尽","tags":["c++","STL"],"title":"STL 的 push 和 emplace","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" find vs find_first_of  find 函数原型\n// c++11 string (1) size_t find (const string\u0026amp; str, size_t pos = 0) const noexcept; c-string (2) size_t find (const char* s, size_t pos = 0) const; buffer (3) size_t find (const char* s, size_t pos, size_type n) const; character (4) size_t find (char c, size_t pos = 0) const noexcept;  find_first_of 函数原型\n// c++11 string (1) size_t find_first_of (const string\u0026amp; str, size_t pos = 0) const noexcept; c-string (2) size_t find_first_of (const char* s, size_t pos = 0) const; buffer (3) size_t find_first_of (const char* s, size_t pos, size_t n) const; character (4) size_t find_first_of (char c, size_t pos = 0) const noexcept;  对比\n find：匹配查找整个字符串 find_first_of：匹配查找指定参数的任意一个字符   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a844b2c63b93f024683bd7c8adeb84e2","permalink":"https://xueqing.github.io/blog/cplusplus/string/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/string/","section":"blog","summary":"find vs find_first_of find 函数原型 // c++11 string (1) size_t find (const string\u0026amp; str, size_t pos = 0) const noexcept; c-string (2) size_t find (const char* s, size_t pos = 0) const; buffer (3) size_t find (const char* s, size_t pos, size_type n) const; character (4) size_t find (char c, size_t pos = 0) const noexcept; find_first_of 函数原型 // c++11 string (1) size_t find_first_of","tags":["c++"],"title":"string","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"/* Exercise: Stringers Make the IPAddr type implement fmt.Stringer to print the address as a dotted quad. For instance, IPAddr{1, 2, 3, 4} should print as \u0026quot;1.2.3.4\u0026quot;. */ package main import ( \u0026quot;fmt\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;strings\u0026quot; ) type iPAddr [4]byte func (ip iPAddr) String() string { arr := []string{\u0026quot;0\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;0\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;0\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;0\u0026quot;} for i := 0; i \u0026lt; 4; i++ { arr[i\u0026lt;\u0026lt;1] = strconv.Itoa(int(ip[i])) } sip := strings.Join(arr, \u0026quot;\u0026quot;) return sip } func main() { hosts := map[string]iPAddr{ \u0026quot;loopback\u0026quot;: {127, 0, 0, 1}, \u0026quot;googleDNS\u0026quot;: {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(\u0026quot;%v: %v\\n\u0026quot;, name, ip) } }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8e3551f16161a6a08dbe0dda88b01799","permalink":"https://xueqing.github.io/translation/go-doc/gotour/stringer/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/stringer/","section":"translation","summary":"/* Exercise: Stringers Make the IPAddr type implement fmt.Stringer to print the address as a dotted quad. For instance, IPAddr{1, 2, 3, 4} should print as \u0026quot;1.2.3.4\u0026quot;. */ package main import ( \u0026quot;fmt\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;strings\u0026quot; ) type iPAddr [4]byte func (ip iPAddr) String() string { arr := []string{\u0026quot;0\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;0\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;0\u0026quot;, \u0026quot;.\u0026quot;, \u0026quot;0\u0026quot;} for i := 0; i \u0026lt; 4; i++ { arr[i\u0026lt;\u0026lt;1] = strconv.Itoa(int(ip[i])) } sip := strings.Join(arr, \u0026quot;\u0026quot;) return sip } func main() { hosts := map[string]iPAddr{ \u0026quot;loopback\u0026quot;: {127, 0, 0, 1}, \u0026quot;googleDNS\u0026quot;: {8, 8, 8, 8}, } for name, ip := range hosts { fmt.","tags":["go-tour"],"title":"Stringers","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  1 概念 2 安装 3 生命周期 4 其他命令 5 分支 6 标签  1 概念  repository(源代码库): 源代码统一存放的地方 Checkout(提取): 当没有源代码的时候，需要从 repository checkout 一份 Commit(提交): 已经修改了代码，需要 Commit 到 repository Update(更新): 已经 Checkout 了一份源代码， Update 可以和 Repository 上的源代码同步，本地的代码就会有最新的变更 SVN 管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN 都会自动合并两种修改。如果是同一行，SVN 会提示文件冲突，需要手动确认  2 安装 # 安装 sudo apt-get install subversion # 查看版本 svn --version  3 生命周期  创建版本库：create 检出：checkout，用来从版本库创建一个工作副本 更新：update，用来更新版本库。这个操作将工作副本与版本库进行同步 执行变更：  rename 可以更改文件/目录名字 \u0026ldquo;移动\u0026rdquo;操作用来将文件/目录从一处移动到版本库中的另一处  复查变化：  status，列出了工作副本中所进行的变动 diff，显示特定修改的行级详细信息 不带参数，比较工作文件与缓存在.svn的\u0026rdquo;原始\u0026rdquo;拷贝 比较工作拷贝和版本库中版本号为 3 的文件 rule.txt：svn diff -r 3 rule.txt 比较版本库与版本库, -r(revision) 传递两个通过冒号分开的版本号：svn diff -r 2:3 rule.txt  修复错误：revert，重置对工作副本的修改  对目录操作使用 svn revert -R 撤回版本，比如当前是版本 22，要撤回版本21，执行 svn merge -r 22:21 readme  解决冲突：resolve，用来帮助用户找出冲突并告诉版本库如何处理这些冲突 提交更改：commit，将更改从工作副本提交到版本库  add，添加到版本控制 commit 是一个原子操作,也就是说要么完全提交成功，要么失败回滚   4 其他命令  info：查看版本信息 log：展示svn 的版本作者、日期、路径等  希望查看特定的某两个版本之间的信息：svn log -r 6:8 查看某一个文件的版本修改信息：svn log file_path 显示限定 N 条记录的目录信息：svn log -l N -v  cat：取得在特定版本的某文件显示在当前屏幕  显示在指定版本号下的指定文件内容：svn cat -r revision_num file_name  list：显示一个目录或某一版本存在的文件  可以在不下载文件到本地目录的情况下来察看目录中的文件：svn list pro_url   5 分支  分支是 trunk 版(主干线)的一个 copy 版本，分支具有版本控制功能，且和主干线相互独立 可以通过合并功能，将分支合并到 trunk，从而最后合并为一个项目 在本地副本创建一个分支 svn copy trunk branches/branch_name 查看状态 svn status 提交新增的分支到版本库 svn commit -m \u0026quot;message\u0026quot; 到新增分支进行开发  cd branches/my_branch/ ls 修改查看状态 svn status 添加到版本控制 svn add ...... 提交到版本库 svn commit -m \u0026quot;message\u0026quot;  切换到 trunk cd ../trunk 更新版本 svn update 合并分支到 truck svn merge ../branches/branch_name/ 将合并好的 truck 提交到版本库 svn commit -m \u0026quot;message\u0026quot;  6 标签  标签主要用于项目开发中的里程碑，比如开发到一定阶段可以单独一个版本作为发布等，它往往代表一个可以固定的完整的版本 在本地工作副本创建一个 tag svn copy trunk tags/v1.0 查看新的目录  ls tags/ ls tags/v1.0/  查看状态 svn status 提交 tag 内容 svn commit -m \u0026quot;tags v1.0\u0026quot;  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fd029381524a102c114a619e2e25f0a5","permalink":"https://xueqing.github.io/blog/svn/svn/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/svn/svn/","section":"blog","summary":"1 概念 2 安装 3 生命周期 4 其他命令 5 分支 6 标签 1 概念 repository(源代码库): 源代码统一存放的地方 Checkout(提取): 当没有源代","tags":["svn"],"title":"SVN","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  概述  基准测试 示例函数 跳过测试 子测试项目和子基准测试 Main  索引 例子 子目录  参考 Golang 官网文档 学习。\n导入语句：import \u0026quot;testing\u0026quot;\n概述 testing 包提供对 Go 包的自动测试。它适用于和 go test 命令协作，自动执行下面格式的函数\nfunc TestXxx(*testing.T)  其中，Xxx 不是小写字母开头。这个函数名用于识别测试代码。\n在这些函数中，使用 Error、Fail 或相关的方法来标记失败。\n要写一个新的测试集，新建一个文件以 _test.go 结尾，其中包含上述的 TestXxx 函数。将此文件放在将要测试的同一包中。正常的包编译不会包含此文件，但是运行 go test 命令时会包含。查看更多细节，运行 go help test 和 go help testflag。\n一个简单的功能测试函数看起来像这样：\nfunc TestAbs(t testing.T) { got := Abs(-1) if got != 1 { t.Errorf(\u0026quot;Abs(-1) = %d; want 1\u0026quot;, got) } }  基准测试 下面格式的函数被当做基准测试，并且当 go test 命令提供 -bench 标记时会执行此函数。基准测试是顺序执行的。\nfunc BenchmarkXxxx(*testing.B)  对 testing 标记的描述，查看 Testing flags。\n一个简单的基准测试函数看起来像这样：\nfunc BenchmarkHello(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { fmt.Sprintf(\u0026quot;hello\u0026quot;) } }  基准测试函数必须运行目标代码 b.N 次。在执行基准测试期间，会调整 b.N 直到基准测试函数持续时间足够长，认为是时间可靠的。输出 BenchmarkHello 10000000 282 ns/op 意味着这个循环以每次循环 282 纳秒的速度运行了 10000000 次。\n如果一个基准测试在运行之前需要一些耗时的设置，可重置定时器：\nfunc BenchmarkBigLen(b *testing.B) { big := NewBig() b.ResetTimer() for i := 0; i \u0026lt; b.N; i++ { big.Len() } }  如果一个基准测试需要并行测试性能，可以使用 RunParallel 辅助函数；这样的基准测试适用于和 go test -cpu 标识一起使用：\nfunc BenchmarkTemplateParallel(b *testing.B) { templ := template.Must(template.New(\u0026quot;test\u0026quot;).Parse(\u0026quot;Hello, {{.}}!\u0026quot;)) b.RunParallel(func(pb *testing.PB) { var buf bytes.Buffer for pb.Next() { buf.Reset() templ.Execute(\u0026amp;buf, \u0026quot;World\u0026quot;) } }) }  示例函数 testing 包也会运行和验证示例代码。示例函数可以包含一个总结性的行注释，以 “Output:” 开头，并且运行测试的是和这个函数的标准输出比较。(这个比较忽视开始和末尾的空格)。下面是一个示例代码的例子：\nfunc ExampleHello() { fmt.Println(\u0026quot;hello\u0026quot;) // Output: hello } func ExampleSalutations() { fmt.Println(\u0026quot;hello, and\u0026quot;) fmt.Println(\u0026quot;goodbye\u0026quot;) // Output: // hello, and // goodbye }  注释前缀 “Unordered output:” 类似于 “Output:”，但是匹配任意的行顺序：\nfunc ExamplePerm() { for _, value := range Perm(4) { fmt.Println(value) } // Unordered output: 4 // 2 // 1 // 3 // 0 }  没有输出注释的示例函数被编译但是不会被执行。\n声明包、函数 F、类型 T 和作用于类型 T 的方法 M 的示例函数的命名如下：\nfunc Example() { ... } func ExampleF() { ... } func ExampleT() { ... } func ExampleT_M() { ... }  可通过增加一个不同的后缀到函数名字后面以支持对于一个包/类型/函数/方法的多个示例函数。后缀必须以小写字母开始。\nfunc Example_suffix() { ... } func ExampleF_suffix() { ... } func ExampleT_suffix() { ... } func ExampleT_M_suffix() { ... }  当文件包含一个单独的示例函数，及至少一个其他的函数、类型、变量或常数声明，且没有功能测试函数或者基准测试函数时，整个测试文件作为例子显示。\n跳过测试 可在运行时调用 *T 或 *B 的 Skip 方法跳过功能测试或基准测试：\nfunc TestTimeConsuming(t *testing.T) { if testing.Short() { t.Skip(\u0026quot;skipping test in short mode.\u0026quot;) } // ... }  子测试项目和子基准测试 T 和 B 的 Run 方法允许定义子测试项目和子基准测试，而不需要为每个子测试项目和子基准测试定义另外的函数。这使能使用类似表驱动的基准测试和创建分级测试。它也提供了一种方式来共享共用的设置和终止代码：\nfunc TestFoo(t *testing.T) { // \u0026lt;setup code\u0026gt; t.Run(\u0026quot;A=1\u0026quot;, func(t *testing.T) { ... }) t.Run(\u0026quot;A=2\u0026quot;, func(t *testing.T) { ... }) t.Run(\u0026quot;B=1\u0026quot;, func(t *testing.T) { ... }) // \u0026lt;tear-down code\u0026gt; }  每个子测试项目和子基准测试有一个唯一的名字：结合顶层测试的名字以及传递给 Run 的名字的顺序，由斜线分隔，以及一个可选的尾随的序号以消除歧义。\n传递给 -run 和 -bench 命令行标识符的参数是一个不固定的正则表达式，匹配了测试的名字。参数是多个斜线分隔的元素时，比如子测试，参数是自身(斜线分隔)；表达式匹配每个名字元素。因为是不固定的，一个空的表达式匹配任意字符串。比如，使用 “matching” 表达 “谁的名字包含”：\ngo test -run '' # Run all tests. go test -run Foo # Run top-level tests matching \u0026quot;Foo\u0026quot;, such as \u0026quot;TestFooBar\u0026quot;. go test -run Foo/A= # For top-level tests matching \u0026quot;Foo\u0026quot;, run subtests matching \u0026quot;A=\u0026quot;. go test -run /A=1 # For all top-level tests, run subtests matching \u0026quot;A=1\u0026quot;.  子测试也可用于控制并行度。一个父测试只有在其子测试完成时才会完成。在这个例子中，所有测试去其他测试并行运行，且只与其他测试并行，而与可能定义的其他顶层测试无关。\nfunc TestGroupedParallel(t *testing.T) { for _, tc := range tests { tc := tc // capture range variable t.Run(tc.Name, func(t *testing.T) { t.Parallel() // ... }) } }  当程序超过 8192 个并行 goroutine 时，竞争检测器会杀掉程序，因此当运行并行测试且设置了 -race 标识时需要注意。\nRun 只有在并行子测试结束才会返回，为一组并行测试之后的资源清理提供了一种方式。\nfunc TestTeardownParallel(t *testing.T) { // This Run will not return until the parallel tests finish. t.Run(\u0026quot;group\u0026quot;, func(t *testing.T) { t.Run(\u0026quot;Test1\u0026quot;, parallelTest1) t.Run(\u0026quot;Test2\u0026quot;, parallelTest2) t.Run(\u0026quot;Test3\u0026quot;, parallelTest3) }) // \u0026lt;tear-down code\u0026gt; }  Main 测试程序有时需要在测试之前或之后做一些额外的设置和清理。并且，测试程序有时需要控制哪些代码运行在主线程。为了满足这些需求和其他的场景，一个测试文件可以包含一个函数：\nfunc TestMain(m *testing.M)  然后，生成的测试会调用 TestMain(m) 而不是直接运行测试。TestMain 在主的 goroutine 运行，且可以做调用 m.Run 前后所需的所有设置和清理。然后，它应该使用 m.Run 的结果调用 OS.Exit。当调用 TestMain 时，flag.Parse 还没有运行。如果 TestMain(包括这些测试包) 依赖命令行标识，应该显式调用 flag.Parse。\n一个简单的 TestMain 的实现：\nfunc TestMain(m *testing.M) { // call flag.Parse() here if TestMain uses flags os.Exit(m.Run()) }  索引 参考\n例子 参考\n子目录    名字 概述     iotest 实现了主要用于 testing 的 Reader 和 Writer   quick 实现了帮助黑盒测试的工具函数    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2ba7d1a4b1fe66bc92ec62550ecdf5b4","permalink":"https://xueqing.github.io/translation/go-doc/golangpkg/testing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangpkg/testing/","section":"translation","summary":"概述 基准测试 示例函数 跳过测试 子测试项目和子基准测试 Main 索引 例子 子目录 参考 Golang 官网文档 学习。 导入语句：import \u0026quot;testing\u0026quot; 概述 testing 包提供对 Go 包的自动测试。","tags":["golang-pkg"],"title":"testing 包","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  BT  BT 下载  种子市场\n torrent 文件（种子文件）是被下载文件的“索引”。本质上是文本文件，主要包含 Tracker 信息和文件信息\n Tracker 信息：BT 下载中需要用到的 Tracker 服务器的地址和针对 Tracker 服务器的设置 文件信息：根据对目标文件的计算生成，计算结果根据 BitTorrent 协议内的 B 编码规则进行编码  原理：把提供下载的文件虚拟分成大小相等的块，块大小必须为 2k 的整数次方，并把每个块的索引信息和 Hash 验证码写入 .torrent 文件\n 虚拟分块是不在硬盘上产生各个块文件  torrent 文件包含的信息\n 资源的名称 如果资源是以目录形式，还有目录树中每个文件的路径信息和文件名 如果是单个文件呢，包含文件的大小信息；如果是目录形式，目录树中每个文件大小 对资源实际文件按照固定大小进行分块后每块进行 SHA1 hash 运算得到的若干特征值的集合 torrent 文件的创建时间、制作者填写的注释、以及制作者的信息等 至少一个 announce 地址，对应 Internet 上部署的一个 Tracker 服务器   BT  BT（BitTorrent，比特流），一种 P2P 传输协议。  克服了传统下载方式的局限性，下载的人越多，文件下载速度越快 传统下载方式：一般是文件由服务器传送到客户端，例如 FTP，HTPP，PUB等。服务器的带宽一定，所以下载人越多速度越慢 普通的 HTPP/FTP 下载使用 TCp/IP 协议，BitTorrent 协议是在 TCP/IP 协议之上的一个 P2P 文件传输协议，处于 TCP/IP 结构的应用层 根据 BitTorrent 协议，文件发布者发布的文件生成提供一个 .torrent 文件，即种子文件，简称为“种子”   BT 下载  下载者要下载文件内容，需要先得到相应的 .torrent 文件，然后使用 BT 客户端下载 BT 客户端先解析文件得到 Tracker 地址，连接 Tracker 服务器 Tracker 服务器回应下载者的请求，提供下载者和其他下载者（包括发布者）的 IP 下载者连接其他下载者，根据 .torrent 文件，下载者分别告知对方自己已有的块，然后交换对方没有的数据  不需要服务器参与，分散了单个线路的数据流量，减轻了服务器负担 下载者每得到一个块，需计算出下载块的 Hash 验证码与 .torrent 文件对比，一样说明块正确，否则需要重新下载 此规定解决下载内容准确性的问题   种子市场 用户在种子市场共享种子文件；用户可以共享任务列表，也可以浏览下载其他人共享的任务\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a58dbfcc38739552f6fe35f8fc9cf931","permalink":"https://xueqing.github.io/blog/p2p/torrent/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/p2p/torrent/","section":"blog","summary":"BT BT 下载 种子市场 torrent 文件（种子文件）是被下载文件的“索引”。本质上是文本文件，主要包含 Tracker 信息和文件信息 Tracker 信息：BT 下载中需要用到的 Tracker 服务器的地","tags":["p2p"],"title":"torrent 文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  前言 Windows 7 上的 UAC 虚拟化 UAC 虚拟化的现象 思考 总结 参考  前言 在早期的 Windows 版本(XP,NTY,95 等)，通常由管理员安装应用。这些应用可以自由地读写系统文件和注册表。但是，标准养护运行相同的应用会导致错误弹窗。\nWindows 7 上的 UAC 虚拟化  在 Windows 7 上通过重定向写操作到用户配置的一个特殊位置来改善标准账户的应用兼容性 例如：如果标准用户运行一个应用，尝试写C:\\Program Files\\National Instruments\\Settings.ini，这个写操作会被重定向到C:\\User\\Username\\AppData\\Local\\VirtualStore\\Program Files\\National Instruments\\Settings.ini。同样地，尝试注册到HKEY_LOCAL_MACHINE\\Software\\National Instruments\\文件会被重定向到HKEY_CURRENT_USER\\Software\\Classes\\VirtualStore\\MACHINE\\Software\\National Instruments or HKEY_USERS\\...  UAC 虚拟化的现象  如果有下面的现象表明应用可能是受到 UAC 虚拟化的影响  应用写入 Program Files，Windows目录或系统根目录(通常是 C 盘)，但是在这些位置不能找到文件 应用写入 Windows 注册表，特比是HKLM/Software，但是看不到注册表更新 切换到另外一个用户账户时，应用不能找到之前写入 Program Files，Windows目录或系统根目录(通常是 C 盘)的文件，或者应用找到了这些文件的旧版本   思考  UAC 虚拟化只用于辅助在 Windows Vista 之前开发的应用的兼容性。Windows 7 的新应用不应该执行写操作到敏感的系统文件，而且不应该依赖 UAC 虚拟化来提供必要的重定向 当更新已有代码再 Windows 7 上运行时，确保应用在运行时只存储数据在每个用户的位置 判断需要写数据文件到已有目录。被所有用户使用的通用数据应写入全局的公共位置，由所有用户共享。其他的数据应写入每个用户的位置 在确定合适的位置后，确保不会硬编码路径  总结 通过 UAC 虚拟化，Windows 7 支持标准用户运行开发的需要管理员权限的应用。\n参考  UAC Virtualization and how it affects your Installers  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2a579df9475a12daa9c25d02be7f480e","permalink":"https://xueqing.github.io/blog/others/uac_virtualization/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/others/uac_virtualization/","section":"blog","summary":"前言 Windows 7 上的 UAC 虚拟化 UAC 虚拟化的现象 思考 总结 参考 前言 在早期的 Windows 版本(XP,NTY,95 等)，通常由管理员安装应用。这些应用可以自由地读写系统文","tags":["uac"],"title":"UAC 虚拟化","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 错误 1：Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)  可能原因：有另外一个程序正在运行，导致资源锁不可用。导致资源被锁的原因，可能是上次安装没正常完成。 解决方法：执行下面两个命令行 sudo rm /var/cache/apt/archives/lock sudo rm /var/lib/dpkg/lock  错误 2：Unable to fetch some archives, maybe run apt-get update or try with \u0026ndash;fix-missing?  可能原因：未更新源 在 System Settings -\u0026gt; Software \u0026amp; Updates -\u0026gt; Download from: 选择 China 中，比如 mirrors.aliyun.com   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f115cd476405d6ab2fc30dd67bdf03ea","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_apt_get_install_failure/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_apt_get_install_failure/","section":"blog","summary":"错误 1：Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable) 可能原因：有另外一个程序正在运行，导致资源锁不可用。导致资源被锁的原因，可能是上次安装没正常完成。 解决","tags":["ubuntu","linux"],"title":"ubuntu 下安装包失败","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" tree 以树状图逐级列出目录的内容命令  -d 只列举目录 -L level 设置目录树最大的显示深度 -o filename 将结果输出到 filename   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c94c8f2eaf0a6aafd1ea0ae6fbdf5076","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_tool/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_tool/","section":"blog","summary":"tree 以树状图逐级列出目录的内容命令 -d 只列举目录 -L level 设置目录树最大的显示深度 -o filename 将结果输出到 filename","tags":["ubuntu","linux"],"title":"Ubuntu 下的实用工具","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  执行sudo apt-get install phpmyadmin 建立软链接sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin 在浏览器打开网址localhost/phpmyadmin  一些错误  打开网页错误the mbstring extension is missing. please check your php configuration  安装包sudo apt-get install php-mbstring php-gettext 重启 Apache 服务sudo service apache2 restart   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a48078d7e3d6e475069fd63281ca042c","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_phpmyadmin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_phpmyadmin/","section":"blog","summary":"执行sudo apt-get install phpmyadmin 建立软链接sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin 在浏览器打开网址localhost/phpmyadmin 一些错误 打开网页错误the mbstring extension is missing. please check your","tags":["ubuntu","linux"],"title":"ubuntu 安装 phpmyadmin","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 命令行安装 sudo apt-get install wireshark 配置非 root 访问  添加 wireshark 用户组 sudo groupadd wireshark 将 dumpcap 更改为 wireshark 用户组 sudo chgrp wireshark /usr/bin/dumpcap 让 wireshark 用户组有 root 权限使用 dumpcap sudo chmod 4755 /usr/bin/dumpcap 将普通用户加入 wireshark 用户组 sudo gpasswd -a kiki wireshark   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4433d350e3fc5e7fd0d939ba22c01022","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_wireshark/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_wireshark/","section":"blog","summary":"命令行安装 sudo apt-get install wireshark 配置非 root 访问 添加 wireshark 用户组 sudo groupadd wireshark 将 dumpcap 更改为 wireshark 用户组 sudo chgrp wireshark /usr/bin/dumpcap 让 wireshark 用户组有 root 权限使用 dumpcap sudo chmod 4755 /usr/bin/dumpcap 将普通用户加入 wireshark 用户组 sudo gpasswd -a kiki wireshark","tags":["ubuntu","linux"],"title":"Ubuntu 安装 wireshark","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 环境 2 配置静态 ip 3 配置输入法和字体  中文界面 配置搜狗输入法 配置 Consolas 雅黑字体  4 安装与配置 Git 5 安装 Qt  Qt5.7.1 Qt5.4.1  6 命令行安装工具包  supervisor VSCode Chrome 浏览器 TeamViewer 有道词典 截图工具 Shutter   1 环境 默认 Ubuntu 16.04\n2 配置静态 ip  IP地址 192.168.1.81 子网掩码 255.255.0.0 DNS 与网关 192.168.1.1  3 配置输入法和字体 中文界面  系统输入-语言支持-添加删除语言-选择 Chinese 将汉语中国拖动到第一栏  配置搜狗输入法 # 从 Sogou 官网下载 deb 安装包 sudo dpkg -i sougou-packet.deb sudo apt-get install -f   系统输入-语言支持-键盘输入法系统选择 fctix 系统输入-文本输入-添加输入源-选择 sougo 输入法。 系统输入-文本输入-切换到下一个源改为 Super+空格（Ctrl+空格 与 Qt 提示冲突） 重启  配置 Consolas 雅黑字体 cd temp wget http://www.mycode.net.cn/wp-content/uploads/2015/07/YaHeiConsolas.tar.gz tar -zxvf YaHeiConsolas.tar.gz sudo mkdir -p /usr/share/fonts/vista sudo cp YaHeiConsolas.ttf /usr/share/fonts/vista/ sudo chmod 644 /usr/share/fonts/vista/*.ttf cd /usr/share/fonts/vista/ sudo mkfontscale \u0026amp;\u0026amp; sudo mkfontdir \u0026amp;\u0026amp; sudo fc-cache -fv sudo apt-get install unity-tweak-tool reboot # 终端中输入配置字体 unity-tweak-tool  4 安装与配置 Git sudo apt-get install git sudo apt-get install gitk # 创建私钥与公钥，并把公钥放到gitlab上 cd ~/.ssh ssh-keygen 或者 ssh-keygen -t rsa -C \u0026quot;kiki@ubuntu.com\u0026quot; # 配置全局姓名与邮箱 git config --global user.name kiki git config --global user.email kiki@ubuntu.com  5 安装 Qt Qt5.7.1  需要解决 Qt 中不能输入中文的 BUG\nsudo apt-get install fcitx-frontend-qt5 cd usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/ cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.7.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.7.1/5.7/gcc_64/plugins/platforminputcontexts # 重启 Qt_Creator # 双版本需要添加快捷方式 cd ~/.local/share/applications touch DigiaQt-qtcreator-community-5.7.1.desktop  输入以下内容\n[Desktop Entry] Type=Application Exec=/local_path/Qt5.4.1/Tools/QtCreator/bin/qtcreator Name=QtCreator5.4.1 (Community) GenericName=The IDE of choice for Qt development. Icon=QtProject-qtcreator Terminal=false Categories=Development;IDE;Qt; MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.qt.qmakeprofile;application/vnd.qt.xml.resource;text/x-qml;text/x-qt.qml;text/x-qt.qbs;   Qt5.4.1  需要解决 Qt 中不能输入中文的 BUG\nsudo apt-get install fcitx-frontend-qt5 cd usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/ cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.4.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.4.1/5.7/gcc_64/plugins/platforminputcontexts # 重启Qt_Creator # 双版本需要添加快捷方式 cd ~/.local/share/applications touch DigiaQt-qtcreator-community-5.4.1.desktop  输入以下内容\n[Desktop Entry] Type=Application Exec=/local_path/Qt5.4.1/Tools/QtCreator/bin/qtcreator Name=QtCreator5.4.1 (Community) GenericName=The IDE of choice for Qt development. Icon=QtProject-qtcreator Terminal=false Categories=Development;IDE;Qt; MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.qt.qmakeprofile;application/vnd.qt.xml.resource;text/x-qml;text/x-qt.qml;text/x-qt.qbs;   6 命令行安装工具包 supervisor cd ~/temp/ git clone git@192.168.1.36:ylrc/Supervisor.git cd Supervisor sudo dpkg -i python-meld3_1.0.2-2_all.deb supervisor_3.2.0-2_all.deb supervisorctl -v sudo service supervisor start  VSCode 到https://code.visualstudio.com/docs/?dv=linux64_deb下载 使用 sudo dpkg -i target.deb 安装 有错误的话使用 sudo apt-get install -f 修复 修改首选项中 VSCode 的配置文件,配置字体 Consolas\nChrome 浏览器 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i google-chrome-stable_current_amd64.deb sudo apt-get install -f  TeamViewer # https://www.teamviewer.com/zhcn/download/linux/ 下载 sudo dpkg -i teamviewerTarget.deb sudo apt-get install -f  有道词典 # 有道官方下载ubuntu安装包 sudo apt update sudo apt upgrade sudo dpkg -i youdao.deb sudo apt install -f  截图工具 Shutter sudo apt-get install shutter   设置快捷键：系统设置-\u0026gt;键盘-\u0026gt;窗口-\u0026gt;自定义快捷键: commond 输入 shutter -s, 然后在右侧点击输入想要设置的快捷键  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9bb2e6ba1500c3846192b2bece10d1d4","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_rookie/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_rookie/","section":"blog","summary":"1 环境 2 配置静态 ip 3 配置输入法和字体 中文界面 配置搜狗输入法 配置 Consolas 雅黑字体 4 安装与配置 Git 5 安装 Qt Qt5.7.1 Qt5.4.1 6 命令行安装工具包 supervisor VSCode Chrome 浏览器 TeamViewer 有道词典 截","tags":["ubuntu","linux"],"title":"Ubuntu 新手配置","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" df -hl显示目前所有文件系统的可用空间及使用情形  -h表示使用human readable的输出，即使用 GB，MB 等易读的格式 Filesystem表示文件系统 Mounted on表示挂载点 SizeUsedAvailUse分别表示分割区的容量、已使用的大小、剩下的大小及使用的百分比  du -sh *显示当前目录下各个文件及目录占用空间大小  du查询文件或文件夹的磁盘使用空间，可以添加--max-depth=限制目录深度   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1d34a4c0cef3899708e6c283cc3235d8","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_disk/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_disk/","section":"blog","summary":"df -hl显示目前所有文件系统的可用空间及使用情形 -h表示使用human readable的输出，即使用 GB，MB 等易读的格式 Filesyste","tags":["ubuntu","linux"],"title":"ubuntu 查看磁盘空间","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 日志文件存在/var/log即其子目录  message: auth.log: 鉴权日志 kern.log: 内核日志 mysql/: mysql 数据库服务日志文件 utmp或wtmp:  查看日志文件的命令  less:less /var/log/messages more:more -f /var/log/messages cat:cat /var/log/messages grep:grep -i error /var/log/message tail:tail -f /var/log/messages zcat zgrep zmore  上面的日志都有使用 rsyslogd 服务生成的。这是一个系统工具。  配置文件在vim /etc/rsyslog.conf 日志目录ls /etc/rsyslog.d/   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3bb0336cc503c205dccf7a0d70a6379f","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_syslog/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_syslog/","section":"blog","summary":"日志文件存在/var/log即其子目录 message: auth.log: 鉴权日志 kern.log: 内核日志 mysql/: mysql 数据库服务日志文件 utmp或wtmp: 查看日志文件的命令 less:less /var/log/messages more:more -f /var/log/messages cat:cat /var/log/messages grep:grep -i error","tags":["ubuntu","linux"],"title":"Ubuntu 的日志文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  update-alternatives命令用于增加、删除、维护和显示/etc/alternatives下的软链接，用于切换相同或相似功能的应用程序（如浏览器、编辑器等）  generic name一系列功能相似的程序的公用名字 alternative一个可选的程序所在的路径 link一个alternative在/etc/alternatives中的名字 priority一个alternative的优先级，优先级越高，数字越大  ls -l /etc/alternatives可以看到所有的软链接 显示所有可选命令：update-alternatives --display editor 选择配置命令程序：update-alternatives --config editor  不使用交互模式：update-alternatives --set editor path  安装命令程序：update-alternatives --install link generic_name path priority  update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100  删除命令程序：update-alternatives --remove name path  以 Ubuntu14.04 配置 java1.8 为例  安装 java1.6 和 java1.7 可以直接用sudo apt-get install openjdk-6-gre(openjdk-7-gre) 访问 oracle 官网下载 jdk 解压下载的 tar.gz 压缩包 执行命令安装：  mkdir -p /usr/lib/jvm sudo cp -a jdk1.8.0_162/ /usr/lib/jvm/ sudo ln -s /usr/lib/jvm/jdk1.8.0_162/ /usr/lib/jvm/java-8  设置环境变量：  vi ~/.bashrc在文件最后加入 export JAVA_HOME=/usr/lib/jvm/java-8 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib export PATH=${JAVA_HOME}/bin:$PATH source ~/.bashrc  配置默认 jdk 版本  sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8/bin/javac 300 sudo update-alternatives --config java sudo update-alternatives --config javac  测试验证java -version  安装 gcc-4.8、g++-4.8、gcc-5.4、g++-5 以及多版本切换 sudo apt-get install gcc-4.8 gcc-4.8-multilib g++-4.8 g++-4.8-multilib sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 50 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5.4 40 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 50 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 40 #切换版本 sudo update-alternatives --config gcc #删除切换版本的选项 sudo update-alternatives --remove gcc /usr/bin/gcc-4.5  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"453abcff22c1d75f92cbf66711ad68d4","permalink":"https://xueqing.github.io/blog/ubuntu/update_alternatives/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/update_alternatives/","section":"blog","summary":"update-alternatives命令用于增加、删除、维护和显示/etc/alternatives下的软链接，用于切换相同或相似功能的应","tags":["ubuntu","linux"],"title":"update-alternatives","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 对命名空间的 using 指令  命名空间 using 指令  2 对命名空间成员的 using 声明 3 对类成员的 using 声明 4 类型别名与别名模板声明 参考  1 对命名空间的 using 指令 命名空间  命名空间提供了在大项目中避免名字冲突的一种方法。 声明于命名空间块内的符号被放入一个具名的作用域中，避免这些符号被误认为其他作用域中的同名符号。 允许具有相同名字的多个命名空间块。这些块中的所有声明声明于该具名作用域。  using 指令  语法 attr(可选) using namespace 嵌套名说明符(可选) 命名空间名;  attr(C++11)：应用到此 using 指令的任意数量的属性 嵌套名说明符：名字与作用域解析运算符 :: 的序列，以作用域解析运算符结束。单个 :: 代表全局命名空间 命名空间名：命名空间名。查找此名时，查找只考虑命名空间声明  从 using 指令之后到指令出现的作用域结尾为止，以对任何名字的无限定名字查找的视点来说，来自 命名空间名 的任何名字均可见，如同它声明于同时含有该 using 指令和 命名空间名 两者的最接近外围命名空间作用域一样。  2 对命名空间成员的 using 声明 3 对类成员的 using 声明 4 类型别名与别名模板声明 参考  C++ keywords: using  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d960745e9010cb226e8fc28ba17fb1eb","permalink":"https://xueqing.github.io/blog/cplusplus/using/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/using/","section":"blog","summary":"1 对命名空间的 using 指令 命名空间 using 指令 2 对命名空间成员的 using 声明 3 对类成员的 using 声明 4 类型别名与别名模板声明 参考 1 对命名空间的 using 指令 命名空间 命名空间","tags":["c++"],"title":"using 关键字","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" resize  原型  void resize (size_type n); void resize (size_type n, const value_type\u0026amp; val);  resize 方法(传递参数来构造是一样的)调整容器大小使得包含 n 个元素  如果当前大小大于 n，会从尾部删除多余的元素 如果当前大小小于 n，会在尾部插入适量的元素到 vector 达到指定的大小(有第二个可选参数指定元素的值)。如果指定值，新元素初始化为 val 的拷贝，否则使用默认构造函数初始化 如果当前容量(capacity) 小于 n，需要重新分配内存  它会影响 size()，如果不需要重新分配内存，则 capacity() 也不会改变  reserver  原型  void reserve (size_type n);  reserve 方法请求修改容量(capacity)，即容量需要足够包含 n 个元素  如果当前容量小于 n，需要重新分配内存，使得容量不小于 n 如果当前容量不小于 n，不会重新分配内存，也不会影响容量  它只会影响 capacity()，size() 不会改变，也不会修改元素。只分配内存，但是没有初始化。容器中没有添加任何元素。如果之后插入元素，容器不会发生重新分配内存。  取舍  如果需要初始化内存，使用 resize 如果知道需要保存元素的大小，只是为了避免多次分配，使用 reserve\n#include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; class MoreThanOneParam { int m_i; string m_s; public: MoreThanOneParam() : m_i(-1) { cout \u0026lt;\u0026lt; \u0026quot;MoreThanOneParam::default::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } MoreThanOneParam(int ii, string s) : m_i(ii), m_s(s) { cout \u0026lt;\u0026lt; \u0026quot;MoreThanOneParam::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } MoreThanOneParam(const MoreThanOneParam \u0026amp;copy) : m_i(copy.m_i), m_s(copy.m_s) { cout \u0026lt;\u0026lt; \u0026quot;MoreThanOneParam::copy::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } ~MoreThanOneParam( ) { cout \u0026lt;\u0026lt; \u0026quot;~MoreThanOneParam::\u0026quot; \u0026lt;\u0026lt; m_i \u0026lt;\u0026lt; endl; } int getInt() const { return m_i; } string getString() const { return m_s; } }; int main( ) { vector\u0026lt;MoreThanOneParam\u0026gt; vec2={ {1,\u0026quot;s1\u0026quot;} , MoreThanOneParam{2 , \u0026quot;s2\u0026quot;} }; //对于每个元素，构造一次，拷贝一次，析构一次 cout \u0026lt;\u0026lt; \u0026quot;=============at first, size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; vec2.reserve(6); cout \u0026lt;\u0026lt; \u0026quot;=============after reserve(6), size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; vec2.push_back( MoreThanOneParam(3 , \u0026quot;s3\u0026quot; ) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】 vec2.emplace_back( MoreThanOneParam(4 , \u0026quot;s4\u0026quot; )); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】 vec2.emplace_back( 5 , \u0026quot;s5\u0026quot; ); //构造一次 cout \u0026lt;\u0026lt; \u0026quot;=============after push_back/emplace_back 3 elements, size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; vec2.emplace_back( 6 , \u0026quot;s6\u0026quot; ); //构造一次 cout \u0026lt;\u0026lt; \u0026quot;=============after push_back/emplace_back 1 elements, size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; vec2.emplace_back( 7 , \u0026quot;s7\u0026quot; ); //构造一次 cout \u0026lt;\u0026lt; \u0026quot;=============after push_back/emplace_back 1 elements, size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; vec2.reserve(6); cout \u0026lt;\u0026lt; \u0026quot;=============after reserve(6), size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; vec2.resize(14); cout \u0026lt;\u0026lt; \u0026quot;=============after resize(14), size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; vec2.resize(6); cout \u0026lt;\u0026lt; \u0026quot;=============after resize(6), size=\u0026quot; \u0026lt;\u0026lt; vec2.size() \u0026lt;\u0026lt; \u0026quot;; cap=\u0026quot; \u0026lt;\u0026lt; vec2.capacity() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; endl; return 0; }   参考  Choice between vector::resize() and vector::reserve()  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f50fc27654f363c3c3ffbc33fe2fc1fd","permalink":"https://xueqing.github.io/blog/cplusplus/vector_resize_reserve/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/vector_resize_reserve/","section":"blog","summary":"resize 原型 void resize (size_type n); void resize (size_type n, const value_type\u0026amp; val); resize 方法(传递参数来构造是一样的)调整容器大小使得包含 n 个元素 如果当前大小大于 n，会从尾部删除多余的元素 如果当前大","tags":["c++"],"title":"vector 的 resize 和 reserve","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 按ESC进入命令行模式  yy 复制光标所在行 p 粘贴至游标后   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"22c68ee917b45ad2a9b2046a5b2ad721","permalink":"https://xueqing.github.io/blog/vim/vim_copy_paste/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_copy_paste/","section":"blog","summary":"按ESC进入命令行模式 yy 复制光标所在行 p 粘贴至游标后","tags":["vim"],"title":"vim 复制粘贴","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" u撤销上次修改 ctrl+r恢复撤销操作  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f767a023b273fcc79ed7e093a35562ab","permalink":"https://xueqing.github.io/blog/vim/vim_cancel/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_cancel/","section":"blog","summary":"u撤销上次修改 ctrl+r恢复撤销操作","tags":["vim"],"title":"vim 撤销上次修改","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 在 vim 打开一个文件，在另一个地方修改了文件  :e重新加载文件 :e!强制丢掉本地修改，从磁盘加载文件   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d5bbb64eaa62e924a41ec48f4c546b3c","permalink":"https://xueqing.github.io/blog/vim/vim_file_flush/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_file_flush/","section":"blog","summary":"在 vim 打开一个文件，在另一个地方修改了文件 :e重新加载文件 :e!强制丢掉本地修改，从磁盘加载文件","tags":["vim"],"title":"vim 文件刷新","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  概况 字符 单词 行 句子 段落 参考  概况  Vi/Vim 中关于编辑操作的命令也比较多，操作单位按从小到大的顺序为(括号内为相应的操作命令)  字符 x、c、s、r、i、a 单词 cw、cW、cb、cB、dw、dW、db、dB 行 dd、d0、d$、I、A、o、O 句子 (、) 段落 {、}  这些操作单位有些可以加操作次数。操作对象的范围计算公式为：操作范围 = 操作次数 * 操作单位  d3w/3dw 命令删除三个单词 10dd 命令删除十行   字符 # 删除光标位置的字符 x # 更改当前字符并进入插入模式 c # 替换光标位置的字符并进入插入模式 s # 替换光标位置的字符但不进入插入模式 r # 在当前位置的字符之前进入插入模式 i # 在当前位置的字符之后进入插入模式 a  单词 # 删除当前单词从光标开始的部分并进入插入模式 cw/cW # 删除当前单词从光标所在位置至单词开始的部分并进入插入模式 cb/cB # 删除当前单词从光标开始的部分但不进入插入模式 dw/dW # 删除当前单词从光标所在位置至单词开始的部分但不进入插入模式 db/dB # cW、cB、dW、dB 命令操作的单词是以空白字符(空格、Tab)分隔的字串 # 比如字符串“str1-str2 str3-str4”，对 cW,cB,dW,dB 命令来说是两个单词，而对 cw、cb、dw、db 命令来说则是四个单词。  行 # 删除当前行 dd # 删除以当前行开始的 n 行 ndd # 删除从当前光标开始到行末的内容 d0 # 删除从当前光标开始到行末的内容 d$ # 在当前行的行首进入插入模式 I # 在当前行的行尾进入插入模式 A # 在当前行下方另起一行进入插入模式 o # 在当前行上方另起一行进入插入模式 O  句子 # 删除当前句子从光标位置开始到句末的内容 d) # 删除当前句子从光标位置开始到句首的内容 d(  段落 # 删除当前段落从光标位置开始到段末的内容 d} # 删除当前段落从光标位置开始到段首的内容 d{  参考  技巧：快速提高 Vi/Vim 使用效率的原则与途径  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3f32a8745d4fe554818371da68a4b967","permalink":"https://xueqing.github.io/blog/vim/vim_edit/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_edit/","section":"blog","summary":"概况 字符 单词 行 句子 段落 参考 概况 Vi/Vim 中关于编辑操作的命令也比较多，操作单位按从小到大的顺序为(括号内为相应的操作命令) 字符 x、c、s、r、i、a","tags":["vim"],"title":"vim 文本编辑","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" :set number或者:set nu显示行号 :set nonumber或者:set nonu隐藏行号 设置 vim 打开之后自动显示行号  修改/etc/vimrc是系统范围的初始化配置 修改~/.vimrc是个人 vim 的初始化配置 在上述任一文件中输入set number或set nu保存即可   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"592662131d748fdc7735ca187ebe22ff","permalink":"https://xueqing.github.io/blog/vim/vim_show_line_number/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_show_line_number/","section":"blog","summary":":set number或者:set nu显示行号 :set nonumber或者:set nonu隐藏行号 设置 vim 打开之后自动显示行号 修改/etc/vimrc是系统","tags":["vim"],"title":"vim 显示行号","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"使用:s替换字符串，常用的四个\n :s/qwe/asd/替换当前行第一个 qwe 为 asd :s/qwe/asd/g替换当前行所有 qwe 为 asd :n,$s/qwe/asd/替换第 n 行到最后一行每行第一个 qwe 为 asd :n,$s/qwe/asd/g替换第 n 行到最后一行每行所有 qwe 为 asd  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a7866afe9a5e1bf6653202c3c0cd2922","permalink":"https://xueqing.github.io/blog/vim/vim_find_replace/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_find_replace/","section":"blog","summary":"使用:s替换字符串，常用的四个 :s/qwe/asd/替换当前行第一个 qwe 为 asd :s/qwe/asd/g替换当前行所有 qwe 为 asd :n,$s/qwe/a","tags":["vim"],"title":"vim 查找替换","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":" 原文\n 概述 示例  EXTM3U EXT-X-TARGETDURATION EXT-X-VERSION EXT-X-MEDIA-SEQUENCE EXTINF EXT-X-ENDLIST  相对路径  概述 对于 VOD(video on demand, 点播) 会话，可以访问的媒体文件表示显示的整个时间段。索引文件是静态的，且包含相关 URL 的一个完整列表，可以访问从显示开始创建的所有媒体文件。这种会话支持用户对整个程序的完整控制。\n示例 下面的代码是一个 VOD playlist 的示例：\n#EXTM3U #EXT-X-PLAYLIST-TYPE:VOD #EXT-X-TARGETDURATION:10 #EXT-X-VERSION:4 #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, http://example.com/movie1/fileSequenceA.ts #EXTINF:10.0, http://example.com/movie1/fileSequenceB.ts #EXTINF:10.0, http://example.com/movie1/fileSequenceC.ts #EXTINF:9.0, http://example.com/movie1/fileSequenceD.ts #EXT-X-ENDLIST  直播 playlist 示例中使用的标记有：\nEXTM3U 表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。\nEXT-X-TARGETDURATION 指定最大的媒体文件时长。\nEXT-X-VERSION 表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。\nEXT-X-MEDIA-SEQUENCE 表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。\n注意：EXT-X-MEDIA-SEQUENCE 标记的值\nEXTINF 一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。\n注意：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。\nEXT-X-ENDLIST 表明不会再向 playlist 文件增加媒体文件了。\n相对路径 上述的 VOD playlist 示例对于媒体文件 playlist 条目使用完整的路径名。虽然支持这么做，更鼓励使用相对路径。相对路径比绝对路径更易移植且相对于 playlist 文件的 URL。对于单个 playlist 条目使用完整路径名比使用相对路径经常导致文本更长。下面是使用相对路径的相同的 playlist：\n#EXTM3U #EXT-X-PLAYLIST-TYPE:VOD #EXT-X-TARGETDURATION:10 #EXT-X-VERSION:4 #EXT-X-MEDIA-SEQUENCE:0 #EXTINF:10.0, fileSequenceA.ts #EXTINF:10.0, fileSequenceB.ts #EXTINF:10.0, fileSequenceC.ts #EXTINF:9.0, fileSequenceD.ts #EXT-X-ENDLIST  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5a6f13aab508ade2c11831c702f2a62e","permalink":"https://xueqing.github.io/translation/hls/vod_playlist_construction/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/hls/vod_playlist_construction/","section":"translation","summary":"原文 概述 示例 EXTM3U EXT-X-TARGETDURATION EXT-X-VERSION EXT-X-MEDIA-SEQUENCE EXTINF EXT-X-ENDLIST 相对路径 概述 对于 VOD(video on demand, 点播) 会话，可以访问的媒体文件表示显示的整个时间段。索引文件是静态的，且包含相关 URL 的一个完整列","tags":["hls"],"title":"VOD playlist 构造","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  vs2015 使用  快捷键 环境变量   快捷键    快捷键 功能     ctrl+k, ctrl+c 注释   ctrl+k, ctrl+u 取消注释    环境变量    环境变量名 含义     $(SolutionDir) 解决方案目录：即.sln文件所在路径   $(ProjectDir) 项目根目录:, 即.vcxproj文件所在路径   $(Configuration) 当前的编译配置名称，比如Debug，或Release   $(ProjectName) 当前项目名称   $(SolutionName) 解决方案名称   $(OutDir) 项目输出文件目录   $(TargetDir) 项目输出文件目录   $(TargetName) 项目生成目标文件, 通常和$(ProjectName)同名, 如Game   $(TargetExt) 项目生成文件后缀名，如.exe, .lib具体取决于工程设置   $(TargetFileName) 项目输出文件名字。比如Game.exe, 等于 $(TargetName) + $(TargetExt)   $(ProjectExt) 工程文件后缀名，如.vcxproj     参考  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"673dbe01261aa2b43739d717f3b6e1f1","permalink":"https://xueqing.github.io/blog/vs/vs2015/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vs/vs2015/","section":"blog","summary":"vs2015 使用 快捷键 环境变量 快捷键 快捷键 功能 ctrl+k, ctrl+c 注释 ctrl+k, ctrl+u 取消注释 环境变量 环境变量名 含义 $(SolutionDir) 解决方案目录：即.sln文件所在路径 $(ProjectDir) 项目根目录:, 即.vc","tags":["vs"],"title":"VS2015 使用","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  关于 Markdown 编辑的插件 有用的命令  Markdown All in One  vscode-icons  关于 Markdown 编辑的插件 基于 VSCode 编辑 Markdown 文本，推荐下面的插件\n   插件名称 描述     Markdown All in One 快捷键，目录，列表编辑，打印成 HTML，支持特殊数学符号渲染等   Markdown Preview Mermaid Support 使用 mermaid 语法画流程图   markdownlint 检查 Markdown 语法   Markdown Preview Enhanced 增强预览   Code Spell Checker 拼写检查   Markdown PDF 把 Markdown 转成 PDF   npm Intellisense 自动补全 npm 模块   npm 支持 npm 操作    有用的命令 Markdown All in One  Markdown: Create Table of Contents Markdown: Update Table of Contents Markdown: Toggle code span Markdown: Print current document to HTML  vscode-icons  安装 vscode-icons，可为 vscode 不同文件类型提供相应的图标 在 vscode 插件中搜索 vscode-icons，安装 按 F1 输入 icons，选择 Activate VSCode Icons  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"282279419e01f126adecd60f62e33a36","permalink":"https://xueqing.github.io/blog/vscode/%E6%8E%A8%E8%8D%90%E6%8F%92%E4%BB%B6/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vscode/%E6%8E%A8%E8%8D%90%E6%8F%92%E4%BB%B6/","section":"blog","summary":"关于 Markdown 编辑的插件 有用的命令 Markdown All in One vscode-icons 关于 Markdown 编辑的插件 基于 VSCode 编辑 Markdown 文本，推荐下面的插件 插件名称 描述 Markdown All in One 快捷键，目录，列表编辑，打印成 HTM","tags":["vscode"],"title":"VSCode 推荐插件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  命令行 .vscode 文件夹 个性化设置 调试 参考  命令行 # 在 vscode 打开当前目录 code . # 在最近使用的 vscode 窗口打开当前目录 code -r . # 新建一个窗口 code -n # 修改语言 code --locale=es # 打开对比编辑器 code --diff \u0026lt;file1\u0026gt; \u0026lt;file2\u0026gt; # 打开文件跳到指定的行和列 \u0026lt;file:line[:column]\u0026gt; code --goto package.json:10:5 # 查看帮助选项 code --help # 停用所有扩展 code --disable-extensions .  .vscode 文件夹  存放工作区相关文件 tasks.json：Task Runner launch.json：调试器  个性化设置  忽略文件/文件夹：修改settings.json，添加文件或文件夹到files.exclude或search.exclude  调试  Node.js 调试  https://github.com/Microsoft/vscode-recipes/tree/master/nodemon  Chrome 调试  https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome  C++ 调试  https://github.com/xueqing/vscode-debug/tree/master/cppdebug/helloworld   参考  Getting Started  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3afa5273af5807bd7a7cad85d80720d3","permalink":"https://xueqing.github.io/blog/vscode/tutorial/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vscode/tutorial/","section":"blog","summary":"命令行 .vscode 文件夹 个性化设置 调试 参考 命令行 # 在 vscode 打开当前目录 code . # 在最近使用的 vscode 窗口打开当前目录 code -r . # 新建一个窗口 code -n # 修改语言 code --locale=es # 打开对比","tags":["vscode"],"title":"VSCode 教程","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  WaitGroup worker pool  WaitGroup  WaitGroup 用于等待一个集合的 goroutine 执行完毕。 WaitGroup 是一个结构体，内部使用了一个计数器，使用 Add 可以增加计数，使用 Done 可以减少计数。当计数为 0 的时候，Wait 返回\n WaitGroup 不能使用值传递，否则会复制拷贝，将不能通知 Wait 函数\nfunc goroutineProccess(index int, wg *sync.WaitGroup) { fmt.Println(\u0026quot;start goroutineProcess \u0026quot;, index) time.Sleep(2 * time.Second) fmt.Printf(\u0026quot;Ended goroutineProcess %d\\n\u0026quot;, index) wg.Done() } func WaitgroupTest() { routineNumber := 3 var wg sync.WaitGroup for i := 0; i \u0026lt; routineNumber; i++ { wg.Add(1) go goroutineProccess(i, \u0026amp;wg) } wg.Wait() fmt.Println(\u0026quot;All goroutine exit...\u0026quot;) }    worker pool  worker pool 是一个线程的集合，等待分配任务执行。任务完成之后，立刻准备下一个任务 使用 buffered channel 实现 worker pool\ntype Job struct { id int randomno int } type Result struct { job Job sumofdigits int } var jobs = make(chan Job, 10) var results = make(chan Result, 10) func digits(number int) int { sum := 0 no := number for no != 0 { sum += no % 10 no /= 10 } time.Sleep(2 * time.Second) return sum } func dowork(wg *sync.WaitGroup) { for job := range jobs { sum := Result{job, digits(job.randomno)} results \u0026lt;- sum } wg.Done() } func createWorkerPool(noOfWorkers int) { var wg sync.WaitGroup for i := 0; i \u0026lt; noOfWorkers; i++ { wg.Add(1) go dowork(\u0026amp;wg) } wg.Wait() close(results) } func createJobs(noOfJobs int) { for i := 0; i \u0026lt; noOfJobs; i++ { randomno := rand.Intn(999) job := Job{i, randomno} jobs \u0026lt;- job } close(jobs) } func getResult(done chan bool) { for result := range results { fmt.Printf(\u0026quot;Job id = %2d, randomno = %3d, result = %d\\n\u0026quot;, result.job.id, result.job.randomno, result.sumofdigits) } done \u0026lt;- true } func WokerPoolTest() { startTime := time.Now() noOfJobs := 100 go createJobs(noOfJobs) noOfWorkers := 10 go createWorkerPool(noOfWorkers) done := make(chan bool) go getResult(done) \u0026lt;-done endTime := time.Now() diff := endTime.Sub(startTime) fmt.Println(\u0026quot;Cost \u0026quot;, diff.Seconds(), \u0026quot; seconds\u0026quot;) }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"79097c645197560e1f109b30d6114a01","permalink":"https://xueqing.github.io/blog/go/basic/go_waitgroup/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_waitgroup/","section":"blog","summary":"WaitGroup worker pool WaitGroup WaitGroup 用于等待一个集合的 goroutine 执行完毕。 WaitGroup 是一个结构体，内部使用了一个计数器，使用 Add 可以增加计数，使用 Done 可以减少计数。当计数为 0 的时候，Wa","tags":["go"],"title":"WaitGroup 和 worker pool","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"/* Exercise: Web Crawler In this exercise you'll use Go's concurrency features to parallelize a web crawler. Modify the Crawl function to fetch URLs in parallel without fetching the same URL twice. Hint: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not safe for concurrent use! */ package main import ( \u0026quot;fmt\u0026quot; ) type Fetcher interface { // Fetch returns the body of URL and // a slice of URLs found on that page. Fetch(url string) (body string, urls []string, err error) } // Crawl uses fetcher to recursively crawl // pages starting with url, to a maximum of depth. func Crawl(url string, depth int, fetcher Fetcher) { // TODO: Fetch URLs in parallel. // TODO: Don't fetch the same URL twice. // This implementation doesn't do either: if depth \u0026lt;= 0 { return } body, urls, err := fetcher.Fetch(url) if err != nil { fmt.Println(err) return } fmt.Printf(\u0026quot;found: %s %q\\n\u0026quot;, url, body) for _, u := range urls { Crawl(u, depth-1, fetcher) } return } func main() { Crawl(\u0026quot;https://golang.org/\u0026quot;, 4, fetcher) } // fakeFetcher is Fetcher that returns canned results. type fakeFetcher map[string]*fakeResult type fakeResult struct { body string urls []string } func (f fakeFetcher) Fetch(url string) (string, []string, error) { if res, ok := f[url]; ok { return res.body, res.urls, nil } return \u0026quot;\u0026quot;, nil, fmt.Errorf(\u0026quot;not found: %s\u0026quot;, url) } // fetcher is a populated fakeFetcher. var fetcher = fakeFetcher{ \u0026quot;https://golang.org/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;The Go Programming Language\u0026quot;, []string{ \u0026quot;https://golang.org/pkg/\u0026quot;, \u0026quot;https://golang.org/cmd/\u0026quot;, }, }, \u0026quot;https://golang.org/pkg/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;Packages\u0026quot;, []string{ \u0026quot;https://golang.org/\u0026quot;, \u0026quot;https://golang.org/cmd/\u0026quot;, \u0026quot;https://golang.org/pkg/fmt/\u0026quot;, \u0026quot;https://golang.org/pkg/os/\u0026quot;, }, }, \u0026quot;https://golang.org/pkg/fmt/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;Package fmt\u0026quot;, []string{ \u0026quot;https://golang.org/\u0026quot;, \u0026quot;https://golang.org/pkg/\u0026quot;, }, }, \u0026quot;https://golang.org/pkg/os/\u0026quot;: \u0026amp;fakeResult{ \u0026quot;Package os\u0026quot;, []string{ \u0026quot;https://golang.org/\u0026quot;, \u0026quot;https://golang.org/pkg/\u0026quot;, }, }, }  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ade17c3f46c17c4552a0296296a21864","permalink":"https://xueqing.github.io/translation/go-doc/gotour/web_crawler/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/gotour/web_crawler/","section":"translation","summary":"/* Exercise: Web Crawler In this exercise you'll use Go's concurrency features to parallelize a web crawler. Modify the Crawl function to fetch URLs in parallel without fetching the same URL twice. Hint: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not safe for concurrent use! */ package main import ( \u0026quot;fmt\u0026quot; ) type Fetcher interface { // Fetch returns the body of URL and // a slice of URLs found on that page.","tags":["go-tour"],"title":"Web Crawler","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":" 简述  WebRTC，即网络实时通信(Web Real Time Communication)。最初是为了解决浏览器上视频通话提出，即两个浏览器直接进行视频和音频通信，而不经过服务器。现在还可以传输文字和其他数据  APIS  三个主要任务  获得音频和视频 音频和视频通信 任意数据通信  三个 JS APIs  MediaStream(也叫 getUserMedia) RTCPeerConnection RTCDataChannel   MediaStream  访问音频或/和视频流 可以包含多个 track(轨)  数据流对象stream包含方法获取音轨和视轨 stream.getAudioTracks返回数组，成员是数据流包含的音轨。使用的声音源的数量决定音轨的数量 stream.getVideoTracks返回数组，成员是数据流包含的视轨。使用的摄像头的数量决定视轨的数量 每个音轨和视轨有两个属性：kind表示种类，即video/audio；label表示唯一的标识  通过navigator.getUserMedia()获得一个 MediaStream\nvar constraints = {video : true}; function successCallback(stream) { // 返回文档中匹配指定 CSS 选择器的一个元素。 var video = document.querySelector(\u0026quot;video\u0026quot;); // 生成能在 video 中使用 src 属性播放的 URL video.src = window.URL.createObjectURL(stream); } function errorCallback(error) { console.log(\u0026quot;navigator.getUserMedia error: \u0026quot;, error); } // 第一个参数：一个约束对象，表示要获取哪些多媒体设备。此处表示获取视频 // 第二个参数：回调函数，在获取多媒体设备成功时调用，传递给它一个 Stream 对象 // 第三个参数：回调函数，在获取多媒体设备失败时调用，传递给它一个 Error 对象 navigator.getUserMedia(constraints, successCallback, errorCallback);  如果网页使用了getUserMedia方法，浏览器会询问用户，是否同意浏览器调用麦克风或摄像头：用户同意则调用回调函数successCallback，否则调用errorCallback\n errorCallback接收一个Error对象，Error对象的code属性取值说明错误类型 PERMISSION_DENIED：用户拒绝调用设备 NOT_SUPPORTED_ERROR：浏览器不支持硬件设备 MANDATORY_UNSATISFIED_ERROR：无法发现指定的硬件设备   约束对象Constraints  控制 MediaStream 的内容，包括媒体类型、分辨率、帧率     属性 描述     video 是否接受视频流   audio 是否接受音频流   minWidth 视频流的最小宽度   maxWidth 视频流的最大宽度   minHeight 视频流的最小高度   maxHeight 视频流的最大高度   minAspectRatio 视频流的最小宽高比   maxAspectRatio 视频流的最大宽高比   minFramerate 视频流的最小帧速率   maxFrameRate 视频流的最大帧速率    video: { mandatory: { minWidth: 640, minHeight: 360 }, optional [{ minWidth: 1280, minHeight: 720 }] }  获取音频 使用getUserMedia+Web Audio获取音频\n// 获取音频输入成功的回调函数 function gotStream(stream) { var audioContext = new webkitAudioContext(); // 为输入流创建一个 AudioNode var mediaStreamSource = audioContext.createMediaStreamSource(stream); // 连接到目的地或其他节点以处理 mediaStreamSource.connect(audioContext.destination); } navigator.webkitGetUserMedia({audio:true}, gotStream);  RTCPeerConnection  点到点(peer to peer)音频和视频通信，包括信号处理、多媒体编解码处理、端到端通信、安全性、带宽管理等 不同客户端直接的音频、视频传递不用通过服务器中转。但是，两个客户端需要通过服务器建立联系  服务器为 WebRTC 提供 4 个方面的支持 用户发现以及通信 信令传输 NAT/防火墙穿越 点对点通信建立失败时作为中转服务器   RTCPeerConnection例子\n// 创建 RTCPeerConnection 实例 pc = new RTCPeerConnection(null); // 如果检测到媒体流连接到本地，调用此函数 pc.onaddstream = gotRemoteStream; // 向 RTCPeerConnection 中加入需要发送的流 pc.addStream(localStream); // 作为发送方，创建并发送一个 offer 信令 pc.createOffer(gotOffer); // 发送 offer 的函数，发送本地 session 描述 function gotOffer(desc) { pc.setLocalDescription(desc); sendOffer(desc); } // 得到 answer 之后，保存远端的 session 描述 function gotAnswer(desc) { pc.setRemoteDescription(desc); } function gotRemoteStream(e) { attachMediaStream(remoteVideo, e.stream); }   RTCDataConnection  支持点到点交换任意数据，包括和 WebSockets 一样的 API、超低延迟、高吞吐、可靠或不可靠、安全性 API 例子\nvar pc = new webkitRTCPeerConnection(servers, {optional: [{RtpDataChannels: true}]}); pc.ondatachannel = function(event) { receiveChannel = event.channel; receiveChannel.onmessage = function(event) { document.querySelector(\u0026quot;div#receiver\u0026quot;).innerHTML = event.data; }; }; sendChannel = pc.createDataChannel(\u0026quot;sendDataChannel\u0026quot;, {reliable: false}); document.querySelector(\u0026quot;button#send\u0026quot;).onlick = function() { var data = document.querySelector(\u0026quot;textarea#send\u0026quot;).value; sendChannel.send(data); }   服务器和协议  WebRTC 使用 RTCPeerConnection 在浏览器(即 peers)之间传递流数据，但仍然需要服务器来为我们传递信令(signaling)来建立这个信道 WebRTC 没有定义信令的方法和协议，信令并不是 RTCPeerConnection API 的一部分 开发者可以选择采用任意的消息协议(SIP/XMPP)和任意的双工通信通道 信令用于交换三种消息  会话控制消息：初始化或关闭通信，报告错误 网络配置：告诉外部世界我的电脑的 IP 地址和端口 媒体能力：我的浏览器可以处理的编解码和分辨率，以及浏览器想要通讯的媒体格式    NAT和防火墙穿越  STUN  告诉我我的公共 IP 地址是什么 简单的服务器，容易穿越 点到点的数据流  TURN(Traversal Using Delay NAT，中继 NAT 实现的穿透)  如果点到点通讯失败，提供一个云回退 数据通过服务器发送，使用服务器的带宽 确保所有环境的呼叫工作  ICE(Interactive Connectivity Establishment，交互式连接建立)  一个点到点连接的框架，可以整个各种 NAT 穿越技术 尝试为每个呼叫找到最好的路径 大部分的呼叫可以使用 STUN，少部分使用 TURN，即中继的呼叫 优先使用 STUN，尝试建立一个基于 UDP 的连接，如果失败则尝试 TCP(先尝试 HTTP，再尝试 HTTPS)，仍然失败则使用一个中级的 TURN 服务器   JS 框架  视频聊天      点到点数据传输      参考  Getting Started with WebRTC  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a215f778f5ab14a1f0b27438b2e3db99","permalink":"https://xueqing.github.io/blog/webrtc/webrtc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/webrtc/webrtc/","section":"blog","summary":"简述 WebRTC，即网络实时通信(Web Real Time Communication)。最初是为了解决浏览器上视频通话提出，即两个浏览器直接进行视频和音频","tags":["webrtc"],"title":"WebRTC 学习","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 术语 2 webrtc2sip 架构 3 webrtc2sip 配置 4 编译源码  4.1 编译 Doubango IMS Framework 4.1.1 编译 libsrtp 4.1.2 编译 OpenSSL 4.1.3 编译 libspeex 和 libspeexdsp 4.1.4 编译 YASM 4.1.5 编译 libvpx 4.1.6 编译 linyuv 4.1.7 编译 opencore-amr 4.1.8 编译 libopus 4.1.9 编译 libgsm 4.1.10 编译 g729 4.1.11 编译 iLBC 4.1.12 编译 x264 4.1.13 编译 FFMpeg 4.1.14 编译 Doubango 4.2 编译 webrtc2sip 和第三方库 4.3 运行 webrtc2sip  5 测试网关  5.1 本地测试 sipML5 和 webrtc2sip  6 互操作性  6.1 关于服务 6.1.1 Asterisk 6.1.2 FreeSwitch 6.2 关于 web 浏览器 6.2.1 Chrome 6.2.2 Firefox Nightly 6.2.3 Firefox，Safari，IE 和 Opera 6.2.4 Ericsson Bowser  7 安全问题 8 一些编译问题  8.1 webrtc2sip 编译出错 8.2 视频编解码崩溃 8.3 webrtc2sip 项目配置 8.4 关于 sipML5 服务 8.4.1 webrtc2sip 解析 sipML5 请求失败 8.5 关于 Chrome 使用 8.6 守护进程  9 运行问题  9.1 ERR_SSL_VERSION_OR_CIPHER_MISMATCH  10 参考  1 术语    缩写 定义 术语     RTC real-time communication 实时通信   W3C world wide web consortium    SIP session initiation protocol 会话初始协议   VoIP voice over IP 网络电话   IMS IP multimedia subsystem 多媒体子系统   LTE long term evolution 长期演进技术   PSTN public switched telephone networks 公共交换电话网   SMS short message service 短信服务   ICE Internet communication engine 互联网通讯引擎   DTLS datagram transport layer security 数据报传输层安全   SRTP secure real-time transport protocol 安全实时传输协议   AoR address of record 地址记录   b2bua back to back user agent 背对背用户代理   MTI mandatory to implement 命令到实现   WSS secure websocket -   AMR adaptive multi rate 自适应多速率   GSM global system for mobile 全球移动通讯系统    2 webrtc2sip 架构  HTML SIP 客户端：使用 sipML5 实现 网关包括 4 个模块  SIP Proxy：把来自 WebSocket 的 SIP 传输转换成 UDP/TCP/TLS 等传统 SIP 网络支持的协议 如果后台服务支持通过 WebSocket 的 SIP 协议，可以跨过这个模块直接与客户端连接 如果使用 RTCWeb Breaker 或 Media Coder 模块，则建议使用此模块 RTCWeb Breaker RTCWeb支持 ICE 和 DTLS/SRTP，而传统的 SIP 终端不支持 RTCWeb Breaker 转换媒体流以协商两种媒体方式 默认是不使用 RTCWeb Breaker，需要客户端再注册之前启用  在 URI 参数中包含\u0026rdquo;rtcweb-breaker=true\u0026rdquo;  Media Coder Chrome 使用 VP8 的视频编解码，Bowser 使用 H.264 AVC Media Coder 使得可以在 Chrome 和 Bowser 直接建立视频会话 可使用 xml 配置文件启用 Media Coder，同时需要启用 RTCWeb breaker 模块 click-to-call service 基于其他三个模块的完整 SIP click-to-call 解决方案 允许通过一个链接直接打电话 包括 4 个组件  SMTP Client：为新注册的用户发送激活链接的邮件 HTTPS Server：交换浏览器和 click-to-call 服务之间的内容 Database connector：连接数据库的接口 JSON API：用于认证用户和管理用户账户    3 webrtc2sip 配置  网关使用 config.xml 文件进行配置，和网关的运行目录相同  4 编译源码  基于 CentOS 64，也可在 Linux，Windows 或 OS X 环境编译\n# 准备系统 sudo yum update sudo yum install make libtool autoconf subversion git cvs wget libogg-devel gcc gcc-c++ pkgconfig sudo yum install nasm  ubuntu 环境下错误\n# E: Unable to locate package libogg-devel sudo apt-get install libogg-dev # E: Unable to locate package gcc-c+ # E: Couldn't find any package by regex 'gcc-c+' sudo apt-get install g++ # E: Unable to locate package pkgconfig sudo apt-get install pkg-config   4.1 编译 Doubango IMS Framework  Doubango IMS Framework 包含所有的信号协议(SIP/SDP/WebSocket 等)和媒体引擎(RTP 栈/音视频编解码)\n# 检出 Doubango 2.0 的源码 svn checkout https://doubango.googlecode.com/svn/branches/2.0/doubango doubango  ubuntu 环境下错误\n# svn: E170013: Unable to connect to a repository at URL 'https://doubango.googlecode.com/svn/branches/2.0/doubango' # svn: E000110: Error running context: Connection timed out wget https://storage.googleapis.com/google-code-archive-source/v2/code.google.com/webrtc2sip/source-archive.zip ## git 仓库没有 2.0 分支 ##git clone https://github.com/DoubangoTelecom/doubango.git   4.1.1 编译 libsrtp # 源码编译安装 git clone https://github.com/cisco/libsrtp/ cd libsrtp git checkout v1.5.0 CFLAGS=\u0026quot;-fPIC\u0026quot; ./configure --enable-pic \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install  4.1.2 编译 OpenSSL  如果使用 RTCWeb Breaker 模块或者 WSS，需要 OpenSSL 如果需要支持 DTLS-SRTP，需要 OpenSSL 1.0.1 版本\n# 检查版本 openssl version # 源码编译安装 wget http://www.openssl.org/source/openssl-1.0.1c.tar.gz tar -xvzf openssl-1.0.1c.tar.gz cd openssl-1.0.1c ./config shared --prefix=/usr/local --openssldir=/usr/local/openssl \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install  编译错误\n# installing man1/cms.1 # cms.pod around line 457: Expected text after =item, not a number # cms.pod around line 461: Expected text after =item, not a number sudo make install_sw   4.1.3 编译 libspeex 和 libspeexdsp  libspeex(音频编解码) 和 libspeexdsp(音频处理和抖动缓冲区)是可选的，建议启用 libspeexdsp\n# 命令行安装 dev 包 sudo yum install speex-devel # 源码编译安装 wget http://downloads.xiph.org/releases/speex/speex-1.2beta3.tar.gz tar -xvzf speex-1.2beta3.tar.gz cd speex-1.2beta3 ./configure --disable-oggtest --without-libogg \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install  ubuntu 环境\n# E: Unable to locate package speex-devel sudo apt-get install libspeex-dev sudo apt-get install libspeexdsp-dev   4.1.4 编译 YASM  如果要使能 VPX(VP8 视频编解码) 或 x264(H.264 编解码)，需要 YASM\n# 源码编译安装 wget http://www.tortall.net/projects/yasm/releases/yasm-1.2.0.tar.gz tar -xvzf yasm-1.2.0.tar.gz cd yasm-1.2.0 ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install   4.1.5 编译 libvpx  libvpx 支持 VP8，是可选的，但是如果需要使用 Chrome 或 Firefox 的视频会话，推荐编译\n# 命令行安装 dev 包 sudo yum install libvpx-devel # 源码编译安装 git clone http://git.chromium.org/webm/libvpx.git cd libvpx ./configure --enable-realtime-only --enable-error-concealment --disable-examples --enable-vp8 --enable-pic --enable-shared --as=yasm make \u0026amp;\u0026amp; make install  ubuntu 环境\n# E: Unable to locate package libvpx-devel sudo apt-get install libvpx-dev   4.1.6 编译 linyuv  libyuv 可选，支持视频缩放和 chroma 转换\n# 源码编译安装 mkdir libyuv \u0026amp;\u0026amp; cd libyuv svn co http://src.chromium.org/svn/trunk/tools/depot_tools . ./gclient config http://libyuv.googlecode.com/svn/trunk ./gclient sync \u0026amp;\u0026amp; cd trunk make -j6 V=1 -r libyuv BUILDTYPE=Release make -j6 V=1 -r libjpeg BUILDTYPE=Release cp out/Release/obj.target/libyuv.a /usr/local/lib cp out/Release/obj.target/third_party/libjpeg_turbo/libjpeg_turbo.a /usr/local/lib mkdir --parents /usr/local/include/libyuv/libyuv cp -rf include/libyuv.h /usr/local/include/libyuv cp -rf include/libyuv/*.h /usr/local/include/libyuv/libyuv  svn 源码仓库克隆失败，跳过\n 查找到资料：安装 libyuv\n  4.1.7 编译 opencore-amr  opencore-amr 可选，支持 AMR 音频编解码\n# 源码编译安装 git clone git://opencore-amr.git.sourceforge.net/gitroot/opencore-amr/opencore-amr cd opencore-amr autoreconf --install \u0026amp;\u0026amp; ./configure \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install   4.1.8 编译 libopus  libopus 是用于 WebRTC 的 MTI 编解码，可选但建议使用，支持 Opus 音频编解码\n# 源码编译安装 wget http://downloads.xiph.org/releases/opus/opus-1.0.2.tar.gz tar -xvzf opus-1.0.2.tar.gz cd opus-1.0.2 ./configure --with-pic --enable-float-approx \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install   4.1.9 编译 libgsm  libgsm 可选，支持 GSM 音频编解码\n# 命令行安装 dev 包(建议) sudo yum install gsm-devel # 源码编译安装 wget http://www.quut.com/gsm/gsm-1.0.13.tar.gz tar -xvzf gsm-1.0.13.tar.gz cd gsm-1.0-pl13 \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install #cp -rf ./inc/* /usr/local/include #cp -rf ./lib/* /usr/local/lib  ubuntu 环境\n# E: Unable to locate package gsm-devel sudo apt-get install libgsm1-dev   4.1.10 编译 g729  G729 可选，支持 G.729 音频编解码\n# 源码编译安装 svn co http://g729.googlecode.com/svn/trunk/ g729b cd g729b ./autogen.sh \u0026amp;\u0026amp; ./configure --enable-static --disable-shared \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make install  svn 源码仓库克隆失败，跳过\n  4.1.11 编译 iLBC  iLBC 可选，支持 ILBC 音频编解码\n# 源码编译安装 svn co http://doubango.googlecode.com/svn/branches/2.0/doubango/thirdparties/scripts/ilbc cd ilbc wget http://www.ietf.org/rfc/rfc3951.txt awk -f extract.awk rfc3951.txt ./autogen.sh \u0026amp;\u0026amp; ./configure make \u0026amp;\u0026amp; make install  svn 源码仓库克隆失败，跳过\n  4.1.12 编译 x264  x264 可选，支持 H.264 视频编解码(要求有 FFMpeg)\n# 源码编译安装 wget ftp://ftp.videolan.org/pub/x264/snapshots/last_x264.tar.bz2 tar -xvjf last_x264.tar.bz2 # the output directory may be difference depending on the version and date cd x264-snapshot-20121201-2245 ./configure --enable-shared --enable-pic \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install  ubuntu 环境\n# Found no assembler # Minimum version is nasm-2.13 # If you really want to compile without asm, configure with --disable-asm.   4.1.13 编译 FFMpeg  FFMPeg 可选，支持 H.263，H.264(需要 x264) 和 MP4V-ES 视频编解码\n# 源码编译安装 git clone git://source.ffmpeg.org/ffmpeg.git ffmpeg cd ffmpeg # grap a release branch git checkout n1.2 # configure source code ./configure \\ --extra-cflags=\u0026quot;-fPIC\u0026quot; \\ --extra-ldflags=\u0026quot;-lpthread\u0026quot; \\ \\ --enable-pic --enable-memalign-hack --enable-pthreads \\ --enable-shared --disable-static \\ --disable-network --enable-pthreads \\ --disable-ffmpeg --disable-ffplay --disable-ffserver --disable-ffprobe \\ \\ --enable-gpl \\ \\ --disable-debug # 加入 H.264 编码，在 configure 后添加 --enable-libx264 make \u0026amp;\u0026amp; sudo make install   4.1.14 编译 Doubango # 源码编译安装 ## 最小化编译 cd doubango \u0026amp;\u0026amp; ./autogen.sh \u0026amp;\u0026amp; ./configure --with-ssl --with-srtp --with-speexdsp make \u0026amp;\u0026amp; sudo make install ## 建议的编译 cd doubango \u0026amp;\u0026amp; ./autogen.sh \u0026amp;\u0026amp; ./configure --with-ssl --with-srtp --with-speexdsp --with-ffmpeg make \u0026amp;\u0026amp; sudo make install ## 完整的编译 cd doubango \u0026amp;\u0026amp; ./autogen.sh \u0026amp;\u0026amp; ./configure --with-ssl --with-srtp --with-vpx --with-yuv --with-amr --with-speex --with-speexdsp --with-gsm --with-ilbc --with-g729 --with-ffmpeg make \u0026amp;\u0026amp; sudo make install  4.2 编译 webrtc2sip 和第三方库  webrtc2sip 依赖于 Doubango IMS Framework v2.0 和 libxml2\n# 检出源码 svn co http://webrtc2sip.googlecode.com/svn/trunk/ webrtc2sip # 安装 libxml2 yum install libxml2-devel # 编译 webrtc2sip export PREFIX=/opt/webrtc2sip cd webrtc2sip \u0026amp;\u0026amp; ./autogen.sh \u0026amp;\u0026amp; ./configure --prefix=$PREFIX # ./configure --prefix=$PREFIX LDFLAGS='-ldl' LIBS='-ldl' make clean \u0026amp;\u0026amp; make \u0026amp;\u0026amp; sudo make install cp -f ./config.xml $PREFIX/sbin/config.xml  svn 源码仓库克隆失败，跳过\n ubuntu 环境\ngit clone https://github.com/DoubangoTelecom/webrtc2sip.git sudo apt-get install libxml2-dev   4.3 运行 webrtc2sip  需要有效的配置文件，默认的配置文件是与 webrtc2sip 同目录的 config.xml\n# 执行二进制文件运行 webrtc2sip      命令行参数 支持的版本 描述 示例     \u0026ndash;config=PATH 2.1.0 覆盖 config.xml 的默认路径 \u0026ndash;config=/tmp/config.xml   \u0026ndash;help 2.1.0 显示帮助信息 -   \u0026ndash;version 2.1.0 显示网关版本 -     运行时错误\n# sqlite/mp_db_sqlite.cc\u0026quot; # line: \u0026quot;51\u0026quot; # MSG: Failed to open SQLite database with error code = 14 and connectionInfo=./c2c_sqlite.db # 在 webrtc2sip 所在文件夹执行语句，修改文件夹权限 sudo chown -R ubuntu:ubuntu ./   5 测试网关  假定 webrtc2sip 运行在 192.168.0.1 机器，SIP 服务运行在 192.168.0.2 机器  在浏览器打开 http://sipml5.org/expert.htm 在WebSocket Server URL区域填写 webrtc2sip 网关监听的 IP 和端口，比如ws://192.168.0.1:10060或ws://192.168.0.1:10062。注意不要忘记ws://或wss:// 在SIP outbound Proxy URL设置目的 IP 和端口，忽视域名，如udp://192.168.0.2:5060 如果调用传统的 SIP 终端，检查Enable RTCWeb Breaker选项   5.1 本地测试 sipML5 和 webrtc2sip  开启 sipML5 服务，使用lite_server，网址默认http://localhost:3000/ 配置注册信息，具体值见下面的表格  假定 sipML5 服务运行在 192.168.1.140 机器 传统的 SIP 网关接收待认证的注册，用户编码是 34020000001110000001，密码是 12345678(默认)，端口是 5062(默认)      注册项 值 必填(Y/N)     Display Name test N   Private Identity 34020000001110000001 Y   Public Identity sip:34020000001110000001@192.168.1.140:5062 Y   Password 12345678 N   Realm 192.168.1.140 Y     配置http://localhost:3000/设置网关信息，具体值见下面的表格  假定传统的 SIP 服务运行在 192.168.1.140 机器，端口是 5060(默认) 假定 webrtc2sip 运行在 192.168.1.140 机器，端口是 10060(默认)      网关配置项 值     WebSocket Server URL ws://192.168.1.140:10060   SIP outbound Proxy URL udp://192.168.1.140:5060     会话配置 phonenumber 为 34020000001310000001  6 互操作性  建议使用 Chrome 的文档版本  6.1 关于服务 6.1.1 Asterisk  Asterisk 和 Chrome 在同时获得视频和音频时会有一些问题，解决方法有两种  使能 RTCWeb Breaker(建议) Patching Asterisk：当作为开发者且正在尝试学习新特性时使用。但是 Asterisk 不支持 VP8。打补丁的教程参考   6.1.2 FreeSwitch  FreeSwitch 不支持 ICE 和其他的 RTCWeb 特性 使能 RTCWeb Breaker 模块可以解决  6.2 关于 web 浏览器 6.2.1 Chrome  建议使用稳定版本 Chrome 使用 SAVPF 配置文件。S 即 secure(SRTP)，F 即 feedback。如果远端的 SIP 客户端/服务器不支持这些特性，需要使能 RTCWeb Breaker 模块（web 浏览器端） Chrome 只包含 VP8 视频编解码，但是大多数 SIP 客户端/服务器不支持。如果 SIP 客户端/服务器 支持 H.264，H.263，The偶然 或 MP4V-ES，那么需要使能 RTCWeb Breaker 和 Media Coder 模块  注意：Media Coder 很可能在 sipml5.org 的服务上不能启用   6.2.2 Firefox Nightly  目前只有 Firefox Nightly 原生支持 RTCWeb 关于 DTLS-SRTP 解码的 issue Firefox Nightly 使用 DTLS-SRTP 实现 RTCWeb，Chrome 使用 SDES-SRTP，因此在两个浏览器之间会话需要使能 RTCWeb Breaker 模块  6.2.3 Firefox，Safari，IE 和 Opera 6.2.4 Ericsson Bowser  Ericsson Bowser 不支持 SRTP，且只有 H.264 视频编解码 Ericsson Bowser 可以与大部分 SIP 客户端通信，但是和 Canary 及其他 RTCWeb 客户端不兼容 使能 RTCWeb Breaker(浏览器端) 可以支持 Bowser 与 Chrome 音频会话，因为 G.711 是一个普遍的编解码。需要支持视频的话，需要使能 Media Coder(服务器端)  7 安全问题  当在客户端(web 浏览器)使能 RTCWeb Breaker 模块，服务器会为所有到 web 浏览器收到的和传出去的 INVITE 请求承担 b2bua 的角色。这只适用于绑定到指定 web 浏览器的 SIP 账户 作为 b2bua 意味着为每个 INVITE 生成一个全新的请求。新的请求可能被远端的传统 SIP 网络认证，即 b2bua 必须持有 SIP 账户的鉴权信息  8 一些编译问题 8.1 webrtc2sip 编译出错 # Error: configure: error: Failed to find libtinyIPSec export PKG_CONFIG_PATH=\u0026quot;$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig\u0026quot; # 编译 webrtc2sip  # mp_object.h:23:23: fatal error: tsk_debug.h: No such file or directory make -I/usr/local/include/tinysak/  # /usr/bin/ld: webrtc2sip-sqlite3.o: undefined reference to symbol 'dlclose@@GLIBC_2.2.5' # //lib/x86_64-linux-gnu/libdl.so.2: error adding symbols: DSO missing from command line # collect2: error: ld returned 1 exit status ./configure --prefix=$PREFIX LDFLAGS='-ldl' LIBS='-ldl'  # /usr/local/lib/libtinyNET.so: undefined reference to `CT_POLICY_EVAL_CTX_set1_cert' # /usr/local/lib/libtinyNET.so: undefined reference to `X509_get0_pubkey' # /usr/local/lib/libtinyNET.so: undefined reference to `SM2_compute_share_key' # /usr/local/lib/libtinyNET.so: undefined reference to `CRYPTO_THREAD_write_lock' # /usr/local/lib/libtinyNET.so: undefined reference to `OPENSSL_sk_insert # 检查 Doubango，重新编译  8.2 视频编解码崩溃  修改文件：doubango/tinySAK/src/tsk_object.c(199) 修改函数：tsk_object_unref() 修改内容：将 tsk_object_delete(self); 替换为 TSK_OBJECT_SAFE_FREE(self);  8.3 webrtc2sip 项目配置  操作系统配置：局域网使用时，将 DNS 配置清空\nvim /etc/resolv.conf # 注释掉下面的行 nameserver 172.17.192.21  FreeSwitch 添加 H264 编码支持\nvim freeswitch/conf/vars.xml # \u0026lt;X-PRE-PROCESS cmd=\u0026quot;set\u0026quot; data=\u0026quot;global_codec_prefs=G722,PCMU,PCMA,GSM,H264\u0026quot;/\u0026gt; # \u0026lt;X-PRE-PROCESS cmd=\u0026quot;set\u0026quot; data=\u0026quot;outbound_codec_prefs=PCMU,PCMA,GSM,H264\u0026quot;/\u0026gt;   8.4 关于 sipML5 服务  源码地址 sipML5 服务连接失败，可能的原因和解决方案  根本原因是没有连接上 webrtc2sip 或 FreeSwitch 服务 可能原因1：网络中断。解决方法：恢复网络连接 可能原因2：Linux 的防火墙阻止了webrtc2sip 和 FreeSwitch 服务，关闭防火强可以解决此类问题  Sipml5连接无反应，可能的原因及解决方案  可能的原因是 webrtc2sip 有问题，重新启动 webrtc2sip  sipML5 与 Yealink 可视电话进行语音通话成功，但是视频通话呼叫方语音进入 echo 模式，视频不通，可能的原因及解决方案  可能是 webrtc2sip 的配置中\u0026lt;enable-media-coder\u0026gt;no\u0026lt;/enable-media-coder\u0026gt; 应该改成 yes  webrtc2sip 启动自动退出，可能的原因及解决方案  可能是配置中所设置的本地 IP 地址与服务器的 IP 地址不一致造成的。修改 IP 地址可以解决此问题   8.4.1 webrtc2sip 解析 sipML5 请求失败  注册配置中Realm配置成编号，修改成 IP 地址\n***[DOUBANGO ERROR]: function: \u0026quot;tsip_message_parse()\u0026quot; file: \u0026quot;src/parsers/tsip_parser_message.c\u0026quot; line: \u0026quot;226\u0026quot; MSG: Failed to parse SIP message: /WS df7jal23ls0d.invalid;branch=z9hG4bKy6rW8Wp53Xb2ScABiUoaIJSmmfVGnfyi;rport From: \u0026quot;test\u0026quot;\u0026lt;sip:34020000001310000001@192.168.1.140:5062\u0026gt;;tag=TvKDkETklspHcSTWievL To: \u0026quot;test\u0026quot;\u0026lt;sip:34020000001310000001@192.168.1.140:5062\u0026gt; Contact: \u0026quot;test\u0026quot;\u0026lt;sip:34020000001310000001@df7jal23ls0d.invalid;rtcweb-breaker=yes;transport=ws\u0026gt;;expires=200;click2call=no;+g.oma.sip-im;+audio;language=\u0026quot;en,fr\u0026quot; Call-ID: 5b7f4bd8-b0c2-1511-b1f1-2360114685dd CSeq: 31494 REGISTER Content-Length: 0 Route: \u0026lt;sip:192.168.1.140:5060;lr;sipml5-outbound;transport=udp\u0026gt; Max-Forwards: 70 User-Agent: IM-client/OMA1.0 sipML5-v1.2016.03.04 Organization: Doubango Telecom Supported: path ***[DOUBANGO ERROR]: function: \u0026quot;tsip_transport_layer_ws_cb()\u0026quot; file: \u0026quot;src/transports/tsip_transport_layer.c\u0026quot; line: \u0026quot;632\u0026quot; MSG: Failed to parse SIP message   8.5 关于 Chrome 使用  Chrome 浏览器呼叫时出现 “Media stream permission denied”  可能原因1：使用本地网页访问时容易出现这样的问题。请使用网址访问网站上的网页 可能原因2：如果是询问时禁止访问了麦克风和摄像头，请关闭 Chrome，重启 如果是 chrome for Android，到应用管理里，清除所有数据  Chrome 浏览器主叫，被叫方隔很长时间才振铃  很有可能是 webrtc2sip 所在的服务器设置了 DNS，删除 DNS   8.6 守护进程  使用守护进程，当 webrtc2sip 服务崩溃时，自动重启该服务 使用进程守护者process-monitor  拷贝二进制文件 process-monitor 到 webrtc2sip 的 sbin 目录 执行命令 ./process-monitor webrtc2sip   9 运行问题 9.1 ERR_SSL_VERSION_OR_CIPHER_MISMATCH  sipML5 报错：Error in connection establishment: net::ERR_SSL_VERSION_OR_CIPHER_MISMATCH webrtc2sip 报错：Remote party requesting DTLS-DTLS (UDP/TLS/RTP/SAVPF) but this option is not enabled  https://github.com/DoubangoTelecom/webrtc2sip/blob/master/FAQ.md#i-see-remote-party-requesting-dtls-dtls-udptlsrtpsavpf-but-this-option-is-not-enabled-how-can-i-fix-this https://stackoverflow.com/questions/36293964/dtls-dtls-is-not-enabled   10 参考  webrtc2sip - Building_Source_v2_0.wiki ice WebRTC tutorial using SIPML5  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d42167b5192121bab75ce0eae1c668e2","permalink":"https://xueqing.github.io/blog/webrtc/sip/webrtc2sip/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/webrtc/sip/webrtc2sip/","section":"blog","summary":"1 术语 2 webrtc2sip 架构 3 webrtc2sip 配置 4 编译源码 4.1 编译 Doubango IMS Framework 4.1.1 编译 libsrtp 4.1.2 编译 OpenSSL 4.1.3 编译 libspeex 和 libspeexdsp 4.1.4 编译 YASM 4.1.5 编译 libvpx 4.1.6 编译 linyuv 4.1.7 编译 opencore-amr 4.1.8 编译 libopus 4.1.9 编译 libgsm 4.1.10 编译 g729 4.1.11 编译 iLBC 4.1.12 编","tags":["webrtc","sip"],"title":"webrtc2sip","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"参考\n wget 用来从指定的 URL 下载文件 wget 非常稳定，在网络原因下载失败时会不断重试知道下载完毕；如果是服务器影响下载，会再次连到服务器从断掉的地方继续下载 wget URL下载单个文件 wget -O filename URL下载并保存成不同的文件名 wget -c URL使用断点续传  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"44a581b6fbb62c968a67e1a86ad4a64c","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_wget/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_wget/","section":"blog","summary":"参考 wget 用来从指定的 URL 下载文件 wget 非常稳定，在网络原因下载失败时会不断重试知道下载完毕；如果是服务器影响下载，会再次连到服务器从断掉的地方继续下","tags":["ubuntu","linux"],"title":"wget 命令","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  Windows 下的 DLL 和 LIB 文件  LIB DLL 总结 参考   LIB  LIB 是静态库，在应用程序编译时 LIB 的函数和程序可被替换和调用。链接器从 LIB 获取所有被引用函数，编译时直接将静态库代码加入程序，运行时会将这部分代码加载到内存，多个程序同时运行使用的是同一份拷贝，可以节省内存 LIB 文件可能是静态库文件(包含对象文件)或导入库文件(包含链接器链接到 DLL 的符号)  如果有 DLL 文件，那么 LIB 一般是一些索引信息，记录了 DLL 中函数的入口和位置，DLL 中是函数的具体内容。LIB 文件不是 obj 文件的集合，即里面不会有实际的实现 如果只有 LIB 文件，那么这个 LIB 文件是静态编译出来的，索引和实现都在文件中。使用静态编译的 LIB 文件，在运行程序时不需要再挂载动态库，缺点是导致应用程序比较大，失去了动态库的灵活性，发布新库时要发布新的应用程序。一个 LIB 文件实际是任意 obj 文件的集合，obj 文件时 cpp 文件编译生成的   DLL  DLL(Dynamic Link Library)，动态链接库，真正的可执行文件，即应用程序可以在运行时而不是编译时调用这些库。这相对使用 LIB 有一些优点 LIB 包含了函数所在 DLL 文件和文件中函数位置的信息(入口)，代码由运行时加载到进程空间中的 DLL 提供。允许可执行模块(DLL 或可执行文件)。仅包含在运行时定位 DLL 函数的可执行代码所需的信息  动态链接包含两个文件：LIB 文件包含被 DLL 导出的函数名称和位置，DLL 包含实际的函数和数据。应用程序使用 LIB 文件链接到 DLL 文件 在应用程序的可执行文件，存放的不是被调用的函数代码，而是 DLL 中相应函数代码的地址，从而节省了内存资源 DLL 和 LIB 文件必须随应用程序一起发布，否则应用程序会报错 如果不想用 LIB 文件或没有 LIB 文件，可以用 Win32 API 函数 LoadLibrary/GetProcAddress 加载库  使用 DLL 编写的程序体积小，但是需要 DLL 和可执行文件同时发布  总结  LIB 是静态库，编译时使用；DLL(Dynamic Link Library)，动态链接库，运行时使用 LIB 文件通常是一个较大的文件；DLL 通常是多个小文件 当编写新版本或完全新的应用时，DLL 的复用性比 LIB DLL 文件可被其他程序使用，但是 LIB 文件不能 DLL 比 LIB 容易遇到版本方面的问题 使用 DLL 开发软件时，因为 DLL 只包含应用需要调用 DLL 代码的存根，仍然需要 LIB 文件，后者包含了函数和代码  参考  DLL and LIB files - what and why? Difference Between LIB and DLL Windows 环境下 LIB 和 DLL 的区别和联系  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"65f0ef7873809e9ec93bfbe29d0fd71f","permalink":"https://xueqing.github.io/blog/vs/dll_vs_lib_files/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vs/dll_vs_lib_files/","section":"blog","summary":"Windows 下的 DLL 和 LIB 文件 LIB DLL 总结 参考 LIB LIB 是静态库，在应用程序编译时 LIB 的函数和程序可被替换和调用。链接器从 LIB 获取所有被引用函数，编译时直接将静态库代码","tags":["vs","lib","windows"],"title":"Windows 下的 DLL 和 LIB 文件","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":" 原文参考 Binary-compatible C++ Interfaces。\n作者：Chad Austin, 2002.02.15\n 二进制兼容的 C++ 接口  概述 背景 概念 初次尝试 第二次尝试 第三次修正 第四次修正 完成润色 最终实现 总结 参考   概述 本文解释如何生成跨编译器和配置(发布/调试等)的 C++ DLL API。\n背景 许多平台对他们偏好的编程语言有自己的 ABI。比如，BeOS 的主要语言是 C++，所以 C++ 编译器一定可以生成保持操作系统 C++ 系统调用二(还有类等)进制兼容的代码。\nWindows 为 C 语言定义 API 和 ABI，因此 C++ 编译器的开发者可以自由控制 C++ ABI 的实现。但是，MS 最后为 Windows 创建面向对象的 ABI，称为 COM。为了简化 COM 的使用，他们使 C++ ABI 的虚表(vtables)映射到 COM 接口所需的虚表。由于不能使用 COM 的 Windows 编译器非常受限，其他的编译器强制执行 COM 虚表和 C++ 虚表之前的映射。\nABI 包含多个方面。这篇文章只讨论在 Windows 下使用 C++ 的问题。其他平台要求不一样。(幸运的是，因为大部分其他平台不如 Windows 流行，这些平台只有一或两个编译器，因此不是很大的问题。)\n概念  ABI(Application Binary Interface，应用程序二进制接口)：系统之间的二进制接口。如果一个二进制接口改变，接口两端(使用者和实现)必须被重新编译。 API(Application Program Interface，应用程序编程接口)：系统之间的源接口。如果一个源接口改变，使用这个接口的代码必须修改。API 改变通常暗示 ABI 改变。 Interface(接口)：一个所有方法都是纯虚的类，因此没有内在实现。一个接口只是对象之间通讯的协议。 Factory(工厂)：用于创建对象。在这篇文章中，我们使用一个全局的函数作为我们的工厂。 DLL Boundary(DLL 界限)：DLL 中被实例化的代码和调用进程的代码之间的线被称为 DLL 界限。在一些情况下，代码可以在界限两侧：一个头文件中的一个内联函数在 DLL 和可执行文件中被使用。这个函数实际上在界限两侧被实例化。因此，如果内联函数有一个静态变量，会创建两个变量，分别在可执行文件和 DLL 中，哪个变量被使用取决于 DLL 还是可执行文件中的代码调用了这个函数。  初次尝试 假设想要创建一个可移植的 windowing API，而且想要把实现放在 DLL 中。我会创建一个名为 Window 的类，这个类可以表示不同的 windowing 系统的一个窗口，Win32，MFC，wxWindows，Qt，Gtk，Aqua，X11，Swing(gasp)等。我们会多次尝试创建一个接口直到它可以在不同的实现、编译器和编译器设置上工作。\n// Window.h #include \u0026lt;string\u0026gt; #ifdef WIN32 #ifdef EXPORTING #define DLLIMPORT _declspec(dllexport) #endif #else #define DLLIMPORT _declspec(dllimport) #endif #define CALL __stdcall #else #define DLLIMPORT #define CALL #endif class DLLIMPORT Window { public: Window(std::string title); ~Window(); void setTitle(std::string title); std::string getTitle(); //... private: HWND m_window; };  我不会展示实现，因为我假定你已经知道如何实现。关于这个接口有一个明显的问题：它假定你使用基础的 Win32 API。即它持有一个 HWND 作为私有成员，因此引入了 Window 类和 WIn32 SDK 的依赖。一个可能的解决方案是使用 pImpl 语法从类的定义中移除这个私有成员。参考文档1、2、3和4。同时，你不能在不破坏二进制兼容的条件下向这个类增加新成员，因为这个类的大小会改变。\n可能这个方法最重要的问题是成员方法不是纯虚的。因此，这些成员方法被实现为专门命名的函数，且函数使用 this 指针作为第一个参数。不幸的是，我不知道有哪两种编译器对方法的名称重整(name mangling)是一样的。因此不要认为你用一个编译器生成的的 DLL 可被另一个编译器编译的可执行文件使用。\n第二次尝试 对于面向对象编程，你知道每个类可以分为两个概念：接口和工厂。工厂是创建对象的一种机制，接口支持对象之间通讯。下个版本的 Window.h 会分离这些概念。注意你不再需要导出类(你需要导出工厂函数)，因为这个是抽象类：所有的方法调用经过对象的虚表(vtables)，而不是通过一个直接的链接到 DLL。只有调用这个工厂函数会直接调用 DLL。\n// Window.h #include \u0026lt;string\u0026gt; class Window { public: virtual ~Window() {} virtual void setTitle(std::string title) = 0; virtual std::string getTitle() = 0; }; Window* DLLIMPORT CreateWindow(std::string title);  这样的代码更好。使用 Window 对象的代码不关心 Window 对象实际的类型，只要实现 Window 接口的类型都可以。但是，还有一个问题：不同的编译器重整符号名称不同，因此不同编译器生成的 DLL 中的 CreateWindow 函数名称不同。这意味着如果你使用 Visual C++ 6 编译 windowing DLL，不能再 Bor兰 C++ 中使用，反之亦然。幸运的是，C++ 标准通过 extern \u0026quot;C\u0026quot; 使得禁用符号重整成特殊的名称。\n一些人可能注意到代码的另一个问题。不同的编译器对 C++ 库的实现不同。在一些不明显的情况下，一些人会用其他的(如 STLPort)替代编译器的库实现……由此你不能依赖跨编译器的 STL 对象是二进制兼容的，你不能在 DLL 接口中安全使用它们。\n如果一个 C++ ABI 曾为 Windows 创建，需要明确指定如何与标准库中的每个类交互，但是我马上就不会再看到这个事情发生了。\n最后一个问题比较小。出于惯例，COM 方法和 DLL 函数使用 __stdcall 调用惯例。我们可以使用前面定义的 CALL 宏解决这个问题。(可以在工程中重命名)\n第三次修正 // Window.h class Window { public: virtual ~Window() {} virtual void CALL setTitle(const char* title) = 0; virtual const char* CALL getTitle() = 0; }; extern \u0026quot;C\u0026quot; Window* CALL CreateWindow(const char* title);  马上就完成了！这个特殊的接口可能在大多数情况下会有效。但是，虚析构函数使得事情有趣了……因为 COM 不使用虚析构函数，你不能依赖不同的编译器使用是一样的。然而，你可以使用一个虚方法取代虚析构函数。即在实现类中通过 delete this 实现；这个方式会在 DLL 界限同一侧实现构造和析构函数。比如，如果尝试使用 VC++6 的发布版可执行程序调试 DLL，程序会崩溃或遇到类似“Value of ESP not saved across function call”的警告。发生这个错误是因为 VC++ 运行时库的调试版本和发布版的分配器(allocator)不同。因为两个分配器不兼容，我们不能在 DLL 界限一侧申请内存然后再另一侧释放这个内存。\n但是一个虚析构函数和一个虚方法是什么不同呢？虚析构函数不负责释放这个对象使用的内存：它们只是在释放对象之前简单地被调用执行必要的清理。使用 DLL 的可执行程序不会尝试释放对象本身的内存。另一方面， destroy() 函数负责释放内存，因此所有的 new 和 delete 调用在 DLL 界限的同一侧。\n可以将接口的析构函数设为受保护的，以便使用接口的地方在析构函数中不小心删除它。\n第四次修正 //Window.h class Window { protected: virtual ~Window() {} //use destroy() public: virtual void CALL destroy() = 0; virtual void CALL setTitle(const char* title) = 0; virtual const char* CALL getTitle() = 0; }; extern \u0026quot;C\u0026quot; Window* CALL CreateWindow(const char* title);  因为这段代码不使用 COM 定义的语义，它可以跨编译器和配置工作。不幸的是，它不是完美的。你必须记住使用 object-\u0026gt;destroy() 删除对象，这个不如 delete object 直观。可能更重要的是，你不能在这个对象类型上使用 std::auto_ptr，autho_ptr 会使用 delete object 删除它拥有的对象。有一种方式实现 delete object 语法吗，实际上调用 object-\u0026gt;destroy()？有的。这正使得事情有点奇怪……你可以为这个接口重载 operator delete，在内部调用 destroy()。因为运算符 delete 持有一个 void 指针，你需要记得你永远不会对任何非 Window 调用 Window::operator delete。这是一个相当安全的假设。下面是运算符的实现\n//... void operator delete(void *p) { if(p) { Window* w = static_cast\u0026lt;Window*\u0026gt;(p); w-\u0026gt;destroy(); } } //...  看起来相当好……你现在可以再使用 autho_ptr，而且你仍然有一个稳定的二进制接口。当你重新编译和测试你的新代码，你会注意到在 WindowImpl::destroy 有一个栈溢出！发生了什么？如果你记得 destroy 方法如何被实现，你会发现它只是简单的执行 delete this。由于这个接口重载了 operator delete，WindowImpl::destroy 调用 Window::operator delete 会调用 WindowImpl::destroy……无限循环。这个特别问题的解决方法是在实现类中重载运算符 delete 来调用全局的运算符 delete\n//... void operator delete(void *p) { ::operator delete(p); } //...  完成润色 如果你的系统有很多接口和实现，你会发现你想要一些方式自动化取消定义运算符 delete。幸运的是，这个也是可能的。简单地创建一个模板类叫做 DefaultDelete，然后不要从接口类 I 衍生，而是从 class DefaultDelete\u0026lt;I\u0026gt; 衍生实现类。下面是 DefaultDelete 的实现\ntemplate\u0026lt;typename T\u0026gt; class DefaultDelete : public T { public: void operator delete(void *p) { ::operator delete(p); } };  最终实现 下面是最终版本的代码\n//Window.h #ifdef WIN32 #define CALL __stdcall #else #define CALL #endif class Window { public: virtual void CALL destroy() = 0; virtual void CALL setTitle(const char* title) = 0; virtual const char* CALL getTitle() = 0; void operator delete(void* p) { if(p) { Window* p = static_cast\u0026lt;Window*\u0026gt;(p); w-\u0026gt;destroy(); } } }; extern \u0026quot;C\u0026quot; Window* CALL CreateWindow(const char* title);  //DefaultDelete.h template\u0026lt;typename T\u0026gt; class DefaultDelete : public T { public: void operator delete(void* p) { ::operator delete(p); } }  //Window.cpp #include \u0026quot;Window.h\u0026quot; #include \u0026lt;string\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026quot;DefaultDelete.h\u0026quot; class WindowImpl : public DefaultDelete\u0026lt;Window\u0026gt; { public: WindowImpl(HWND window) { m_window = window; } ~WindowImpl() { DestroyWindow(m_window); } void CALL destroy() { delete this; } void CALL setTitle(const char* title) { SetWindowtext(m_window, title); } const char* CALL getTitle() { char title[512]; GetWindowText(m_window, title, 512); m_title = title; //save the title past the call return m_title.c_str(); } private: HWND m_window; std::string m_title; } Window* CALL CreateWindow(const char* title) { // create Win32 window object HWND window = ::CreateWindow(..., title, ...); return (window ? new WindowImple(window) : 0); }  总结 我会枚举一些指导方针，在创建 C++ 接口的时候需要记得。你可以回顾作为一个参考或者使用它帮助巩固你的知识。\n 所有的接口类应该是完全抽象的。每个方法应该是纯虚的(或者内联的……你可以安全地编写内联方法调用其他方法)。 所有的全局函数应该是 extern \u0026quot;C\u0026quot; 以避免不兼容的名称重整。并且，导出的函数和方法应该使用。__stdcall 调用惯例，因为 DLL 函数和 COM 习惯上使用这种调用惯例。这种方式，如果这个库的使用者使用默认的 __cdecl 编译，对 DLL 的调用仍然使用正确的惯例。 不要使用标准 C++ 库。 不要使用异常处理。 不要使用虚析构函数。相反地，创建一个 destroy() 方法和一个重载的 operator delete 调用 destroy()。 不要在 DLL 界限的一侧申请内存，在另一侧释放它。不同的 DLL 和 可执行文件可以使用不同的堆编译，并且使用不同的堆申请和释放内存块肯定会导致崩溃。比如，不要内联内存申请函数以便函数不会编译到不同的可执行文件和 DLL。 不要在接口使用重载的方法。不同的编译器在虚表中排序不同。  参考  STLPort 是 STL 的替代 SGI 有另外一个标准的 C++ 库实现 Corona 图片 I/O 库使用了本文引入的技术  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ea51cb398b9086b3f726a5a942dd9b12","permalink":"https://xueqing.github.io/translation/cplusplus/binary_compatible_cpp_interface/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/cplusplus/binary_compatible_cpp_interface/","section":"translation","summary":"原文参考 Binary-compatible C++ Interfaces。 作者：Chad Austin, 2002.02.15 二进制兼容的 C++ 接口 概述 背景 概念 初次尝试 第二次尝试 第三次修正 第四次修正 完成润色 最终实现 总结","tags":["c++"],"title":"二进制兼容的 C++ 接口","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  简介 广告 增值服务 佣金 O2O 闭环  O2O 行业的普遍困境 闭环：走出困境的关键 如何构造闭环  O2O 分销  活动预热 引爆活动 保持活跃，二次刺激  缴税  简介  互联网企业通过广告、游戏、电商三大业务获取盈利  对于互联网公司而言，广告既是一种业务也是一种盈利手段，而游戏和电商则更多是一种业务，完全把二者当作盈利模式来定义太笼统也太模糊  互联网本身不是实体经济，不参与直接的生产性活动，生产创造价值进而盈利这一简单原始的方式不是互联网企业的盈利模式。互联网企业的价值是在信息、商品的流通中产生的 “连接”是互联网发展的主线，人与信息的连接、人与物的连接、人与人的连接，基于连接和整合的发展特点，互联网盈利模式有其独特的一面 互联网三大盈利模式总结为：广告、增值服务、佣金  广告  广告无处不在，作为互联网免费时代的代价，广告充斥着互联网的每个角落 按照呈现载体不同，广告可分为文字广告、图片广告、视频广告等 相比传统媒体，互联网产品覆盖面更广，广告形式更丰富，人群定位更精准，因此具有独特的优势 互联网广告最主要的两种形式  搜索排名：包括百度搜索、淘宝竞价排名、各大手机应用市场竞价排名等 信息流广告：包括微博、头条、抖音、各类新闻产品、朋友圈等  另外还有传统的首页推荐，开屏广告等形式 互联网广告形式多样，各大互联网巨头均拥有各自的广告业务，每年通过广告产生的收益占据了互联网整个行业营收的重要部分  增值服务  通过提供增值服务进行收费  产品的基础功能免费，高级功能收费：大多数互联网游戏的盈利模式都属于增值服务。很多游戏可以免费玩，但是你想要更炫酷的皮肤，更强大的技能，游戏内更高的地位，你就得充值 基本内容免费，高级内容收费：视频网站的付费视频  会员制。包括电商、视频、文学小说还是各类工具型产品。比如亚马逊、爱奇艺、优酷土豆、QQ会员、在线音乐、笔记类应用。通过提供更低的价格、更高级的功能、更好的使用体验、更优质的内容等手段，会员模式已经成为一种流行且有效的增值服务类型 淘宝对商家提供各类插件等收费手段  佣金  大多数互联网巨头都属于平台模式。平台不直接生产创造价值，而是通过连接不同商业群体来整合价值  美团点评、滴滴出行、携程、饿了么等 O2O 巨头，均是通过促成团购、打车、酒旅、外卖等商业交易，并从中提取一定的佣金而盈利 佣金、交易提成、交易手续费等说法本质相同  支付宝、微信支付这些支付工具，佣金也是其盈利模式 佣金似乎是最简单的盈利模式：只要你交易我就躺着挣钱，但是这种模式要求平台具有足够的影响力  O2O 闭环 O2O 行业的普遍困境  优惠券模式(丁丁优惠、大众点评)：用户下载优惠券，在消费时向商家出示，获得优惠。商家也知道该用户来自丁丁优惠。丁丁网收取广告费，看似皆大欢喜。但若丁丁优惠嫌广告费太少，提出向商家收取交易佣金，问题来了：丁丁优惠无法确切知道自己促成了多少单交易。商家可以统计到交易量，但谁会愿意跟人分钱呢 外卖模式(美餐网、饿了么)：用户在网上进行订餐，订餐网通过电话、短信等手段向餐厅推送订单。但若订餐平台想和餐厅进行分成，困难重重。光“有效订单数”这一项就很难达成共识 今夜特价酒店： 用户在今夜特价上获取到特价酒店信息，到店后，酒店以更大优惠为诱饵劝说用户取消网上订单(避免支付佣金) 这些困境的共同点：O2O 平台将用户引流到线下之后，就失去了对流程的掌控  闭环：走出困境的关键  闭环用百度百科的定义：O2O 闭环是指两个 O 之间要实现对接和循环。……要将客流引到线下去消费体验，实现交易。但是这样……还没有做到闭环，要做到闭环，就要从线下再返回线上去 有了闭环，每一单交易的最终结果会流转到平台，为平台所掌握、记录。而所有这些记录下来的交易(关键在可记录)，就是 O2O 平台的价值所在以及挖掘更大价值的基础  无可争议的具体交易记录，保证了平台对线下商家的议价权 积累下来的具体到每一个用户的消费记录，形成大数据基础，对商家可以提供精准营销，对用户可以提供个性化服务，从而进一步促进 O2O 循环  只有这样，O2O 才成其为真正的 O2O，而不是沦为单纯的广告平台或者分类信息提供者  如何构造闭环  比如会员卡、二维码支付等等 其实，闭环的核心在于形成对每一单交易的跟踪和记录，形式上不一定要“闭环”。例如最好的闭环其实是在线支付 最佳解决方案：支付闭环  假如用户是在平台进行预支付，那么闭环就天然形成了。因为支付不仅仅是支付本身，它是交易最终形成的唯一标识 本地生活服务的团购就是实现了闭环的 O2O。但团购只是 O2O 的冰山一角。大部分的 O2O，在线支付根本行不通。举个极端的例子，打车就没办法预支付。微信支付之所以被看重，某种程度上也是因为它被看成是腾讯打通了 O2O 的最后一环  闭环是必须的吗？大众点评在做团购之前，做优惠券也挣了不少广告费。丁丁优惠、各种订餐网也活的好好的。再扯远一点，百度做广告简直跟印钞票似的。但是，作为产业链的上游，如果想要最大化变现自身的价值，往往就得往下游走。假如下游产业无法亲力亲为，那就做闭环。巨头如百度，力推的各种中间页，也可以看成是在做闭环。毕竟 O2O 的价值远不止这点广告费。即便专注于广告的模式，也需要借助闭环才能为每个用户进行更个性化、更精准的广告  O2O 分销 活动预热  要想点燃活动热度，活动开始前的预热工作是必不可少的  精准触达：活动推送。如何将活动消息提前告知用户呢？据统计，一次精准的消息推送能使活动的打开率提高近40%。活动消息推送功能可以帮助平台将活动消息精准触达消费者 提升曝光：热门活动场。城市 O2O 设有专门的热门活动场，可提前将参与活动的商品添加入热门活动场，增加活动的曝光度，为活动提前预热。此外，平台还可自定义参与资格，方便会员报名参与活动 商品预售。预售的好处之一是拉长战线，增加销售额，平台用预售的活动可以吸引更多人的关注，为活动造成更大的声势。买家提前预购，确保价格优惠。同时也能方便提前配货，根据已经预售的数据信息提前调货，协调库存   引爆活动  带来大量客流：拼团。人们对省钱的事情都乐此不疲，只需少赚一点，就可以让新客户N倍裂变增长！在上线拼团活动前期，可以筛选市面上卖得好的，持续力强、口碑好并且大众熟知率高的商品，打造出爆款的稀缺感，从而提高产品销量，缓解商品库存压力 提升客单量：满减优惠券。满减优惠券一方面满足了消费者爱占便宜的心理，另一方面满足了完成满减后产生的成就感，快速帮助消费者决策，买到优惠的商品。而对于优惠放利的商家，能快速带来流量  满减优惠券除了提供减现金的直接的功能之外，还可以跟其他功能来配合，实现不同的营销模式，只有想不到没有做不到  打造爆款：限时秒杀。限时秒杀的玩法可以说是相当给力了，除了打造爆款效应之外，还能迅速增加店铺的流量、客源，实现低成本获客  那么限时秒杀要怎么玩呢？设定一个时间准时秒杀：准备几个爆款作为秒杀产品，轮流交换。有限的数量、极大的优惠、有限的优惠时间，能时刻吸引客户进店关注活动，为店铺带来流量的同时，提升商品曝光度   保持活跃，二次刺激  大促后用户消费会进入一定的疲软期，此时平台业绩会有回落。为了防止落差太大，可以试试以下几个方法：  签到打卡：保持日活跃。签到打卡是相当常见的玩法，具有持续性，以“天”为单位，每天登录APP参与签到的用户，将会获得积分、道具、优惠券等签到奖励 签到的操作简单，每天签到每天有奖，物质的刺激能充分调动消费者的积极性，最终培养成每天登录签到的习惯，日活跃因此形成。另外，用户来签到，也会顺便看看商城商品，这样更深层次的活跃度就被提升上来了 积分商城：刺激二次消费。会员在下单消费、完成积分任务之后即可轻松获取积分，还可以在积分商城中进行积分兑券、积分兑礼，从而刺激会员二次消费，提升复购率。同时还能将会员引流到店，并产生再次门店消费贡献 快速获客：多级分销。一场活动下来必定获得了不少新用户，如何利用这些新用户快速发展种子用户呢？那就试试方维城市O2O的分销玩法吧   缴税 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"587a59ca918507403113071b46102911","permalink":"https://xueqing.github.io/blog/o2o/%E7%9B%88%E5%88%A9/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E7%9B%88%E5%88%A9/","section":"blog","summary":"简介 广告 增值服务 佣金 O2O 闭环 O2O 行业的普遍困境 闭环：走出困境的关键 如何构造闭环 O2O 分销 活动预热 引爆活动 保持活跃，二次刺激 缴税 简介 互联网企业通过广告","tags":["o2o"],"title":"互联网盈利模式","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"原文\n好的程序员并一定是技术强的程序员，而是那些可以在不完美的工作环境下保证软件质量和工作效率的程序员\n 寻找不同观点  要经常在做事之前问自己和别人，这么做对不对 做完事后问自己，还可不可以改进 努力去寻找别的不同的观点或方法 程序员应该经常上网，经常和同事讨论不同的实现方法，不同的技术观点，这样才能取长补短  千万别信自己的代码  当出现问题的时候，要学会 review 代码中所有的可疑点，千万别觉得某段代码很简单，可以略过 在查错的过程中，切忌过早下结论，切忌四处乱改,停下来想一想，会是哪儿的代码有重大嫌疑，然后查看一下代码，捋一捋程序的逻辑  思考和放松  思考其实就是一种放松 做事前多想一想，这样做事的时候就不会不顾此失彼，手忙脚乱 在工作中要学会享受，要学会放松心情 善于总结成败得失，善于思考，善于调整，善于放松  学习历史，跟上时代  一定要学习历史，整个计算机文化的历史 只有通过历史，才能明白历史上出现的问题，新技术出来的原因，这样才能够更了解新的技术和未来的方向 使用新型的技术，停下来接受培训，可以工作得更快更高效  积极推动测试活动  积极地在各个环节推动项目组进行测试活动 只有测试才能证明软件可以正常工作，只有测试才能保证软件的质量   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9a34cd5156d610012d0aca560b68b125","permalink":"https://xueqing.github.io/blog/coolshell/%E4%BA%94%E4%B8%AA%E6%96%B9%E6%B3%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/coolshell/%E4%BA%94%E4%B8%AA%E6%96%B9%E6%B3%95%E6%88%90%E4%B8%BA%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98/","section":"blog","summary":"原文 好的程序员并一定是技术强的程序员，而是那些可以在不完美的工作环境下保证软件质量和工作效率的程序员 寻找不同观点 要经常在做事之前问自己和别人","tags":["coolshell"],"title":"五个方法成为更好的程序员","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 编译器遇到一个名字的引用时，从最内层的封闭词法块到全局块寻找其声明  没有找到会报 “undeclared name” 错误 内层和外层都存在声明时，内层的先被找到。此时内层声明会覆盖外部声明，外部声明将不可访问  短变量声明依赖一个明确的作用域。只有在同一个词法块中已经存在变量的情况下，短声明的行为才和赋值操作一样，外层声明将被忽略。下面的代码容易覆盖全局声明的 cwd\n 因为 cwd 和 err 在函数块内部都尚未声明，所以 := 语句将它们视为局部变量。内存 cwd 声明使得外部声明不可见 解决方法是不使用 :=，而是使用 var 声明变量\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;os\u0026quot; ) var cwd string func main() { cwd, err := os.Getwd() //compile error: cwd declared and not used if err != nil { fmt.Printf(\u0026quot;err=%s\\n\u0026quot;, err) } }   下面的代码，main 函数中的 cwd 是局部变量，会覆盖全局变量\npackage main import ( \u0026quot;log\u0026quot; \u0026quot;os\u0026quot; ) var cwd string = \u0026quot;.\u0026quot; func main() { mylog() cwd, err := os.Getwd() if err != nil { log.Fatalf(\u0026quot;os.Getwd failed: %v\\n\u0026quot;, err) } log.Printf(\u0026quot;os.Getwd success: %s\\n\u0026quot;, cwd) mylog() } func mylog() { log.Printf(\u0026quot;global cwd: %s\\n\u0026quot;, cwd) }   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"978b48befeb7949b5759bfd8b15be992","permalink":"https://xueqing.github.io/blog/go/traps/var_scope/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/traps/var_scope/","section":"blog","summary":"编译器遇到一个名字的引用时，从最内层的封闭词法块到全局块寻找其声明 没有找到会报 “undeclared name” 错误 内层和外层都存在声明时，内","tags":["go"],"title":"作用域","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  介绍 表驱动测试基础 表驱动的基准测试 使用子测试的表驱动测试 运行指定的测试或基准测试 设置和清理 并行控制 并行运行一组测试 一组并行测试之后的清理 结论 相关文章  参考 Go 博客——使用子测试和子基准测试学习。\n作者：Marcel van Lohuizen 日期：2016/10/3  介绍 在 Go1.7，testing 包引入了一个 Run 方法，作用于 T 和 B 类型，允许创建子测试和子基准测试。子测试和子基准测试的引入使得支持更好的失败处理，从命令行对运行哪个测试的细粒度控制，并行控制，并且经常生成更简单和可维护的代码。\n表驱动测试基础 在深入细节之前，让我们先讨论用 Go 编写测试的常用方式。可以通过对一个测试用例切片的循环实现一系列相关的检查：\nfunc TestTime(t *testing.T) { testCases := []struct { gmt string loc string want string }{ {\u0026quot;12:31\u0026quot;, \u0026quot;Europe/Zuri\u0026quot;, \u0026quot;13:31\u0026quot;}, // incorrect location name {\u0026quot;12:31\u0026quot;, \u0026quot;America/New_York\u0026quot;, \u0026quot;7:31\u0026quot;}, // should be 07:31 {\u0026quot;08:08\u0026quot;, \u0026quot;Australia/Sydney\u0026quot;, \u0026quot;18:08\u0026quot;}, } for _, tc := range testCases { loc, err := time.LoadLocation(tc.loc) if err != nil { t.Fatalf(\u0026quot;could not load location %q\u0026quot;, tc.loc) } gmt, _ := time.Parse(\u0026quot;15:04\u0026quot;, tc.gmt) if got := gmt.In(loc).Format(\u0026quot;15:04\u0026quot;); got != tc.want { t.Errorf(\u0026quot;In(%s, %s) = %s; want %s\u0026quot;, tc.gmt, tc.loc, got, tc.want) } } }  这个方法常备表驱动测试提及。且相比为每个测试重复相同的代码，此方法减少了大量的重复代码，且使得增加测试用例更加直接。\n表驱动的基准测试 在 Go1.7 之前，不能为基准测试使用相同的表驱动方法。一个基准测试测试整个函数的性能，因此遍历基准测试只是将它们作为一个整体测试。\n一个常用的变通方案是定义单独的顶层基准测试，每个基准测试使用不同参数调用一个公共的函数。比如，在 1.7 之前，strconv 包地狱塔 AppendFloat 的基准测试看起来像这样：\nfunc benchmarkAppendFloat(b *testing.B, f float64, fmt byte, prec, bitSize int) { dst := make([]byte, 30) b.ResetTimer() // Overkill here, but for illustrative purposes. for i := 0; i \u0026lt; b.N; i++ { AppendFloat(dst[:0], f, fmt, prec, bitSize) } } func BenchmarkAppendFloatDecimal(b *testing.B) { benchmarkAppendFloat(b, 33909, 'g', -1, 64) } func BenchmarkAppendFloat(b *testing.B) { benchmarkAppendFloat(b, 339.7784, 'g', -1, 64) } func BenchmarkAppendFloatExp(b *testing.B) { benchmarkAppendFloat(b, -5.09e75, 'g', -1, 64) } func BenchmarkAppendFloatNegExp(b *testing.B) { benchmarkAppendFloat(b, -5.11e-95, 'g', -1, 64) } func BenchmarkAppendFloatBig(b *testing.B) { benchmarkAppendFloat(b, 123456789123456789123456789, 'g', -1, 64) } ...  Go1.7 可使用 Run 方法，相同的基准测试现在可以表示为一个顶层的基准测试：\nfunc BenchmarkAppendFloat(b *testing.B) { benchmarks := []struct{ name string float float64 fmt byte prec int bitSize int }{ {\u0026quot;Decimal\u0026quot;, 33909, 'g', -1, 64}, {\u0026quot;Float\u0026quot;, 339.7784, 'g', -1, 64}, {\u0026quot;Exp\u0026quot;, -5.09e75, 'g', -1, 64}, {\u0026quot;NegExp\u0026quot;, -5.11e-95, 'g', -1, 64}, {\u0026quot;Big\u0026quot;, 123456789123456789123456789, 'g', -1, 64}, ... } dst := make([]byte, 30) for _, bm := range benchmarks { b.Run(bm.name, func(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { AppendFloat(dst[:0], bm.float, bm.fmt, bm.prec, bm.bitSize) } }) } }  每次调用 Run 方法创建一个单独的基准测试。调用 Run 方法的闭包的基准测试函数只允许一次且不被测量。\n新代码行数更多，但是更易维护，更易读，且与测试常用的表驱动方法是一致的。此外，现在可以在运行时共享设置代码，同时不再需要重置计时器。\n使用子测试的表驱动测试 Go1.7 也引入了用于创建子测试的 Run 方法。这个测试是使用子测试对之前的例子重新的版本：\nfunc TestTime(t *testing.T) { testCases := []struct { gmt string loc string want string }{ {\u0026quot;12:31\u0026quot;, \u0026quot;Europe/Zuri\u0026quot;, \u0026quot;13:31\u0026quot;}, {\u0026quot;12:31\u0026quot;, \u0026quot;America/New_York\u0026quot;, \u0026quot;7:31\u0026quot;}, {\u0026quot;08:08\u0026quot;, \u0026quot;Australia/Sydney\u0026quot;, \u0026quot;18:08\u0026quot;}, } for _, tc := range testCases { t.Run(fmt.Sprintf(\u0026quot;%s in %s\u0026quot;, tc.gmt, tc.loc), func(t *testing.T) { loc, err := time.LoadLocation(tc.loc) if err != nil { t.Fatal(\u0026quot;could not load location\u0026quot;) } gmt, _ := time.Parse(\u0026quot;15:04\u0026quot;, tc.gmt) if got := gmt.In(loc).Format(\u0026quot;15:04\u0026quot;); got != tc.want { t.Errorf(\u0026quot;got %s; want %s\u0026quot;, got, tc.want) } }) } }  第一件要注意的事情是两个实现的输出不同。原本的实现打印：\n--- FAIL: TestTime (0.00s) time_test.go:62: could not load location \u0026quot;Europe/Zuri\u0026quot;  即使有两个错误，测试执行终止在对 Fatalf 的调用，且第二个测试永远不会运行。\n使用 Run 的实现打印两个错误：\n--- FAIL: TestTime (0.00s) --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s) time_test.go:84: could not load location --- FAIL: TestTime/12:31_in_America/New_York (0.00s) time_test.go:88: got 07:31; want 7:31  Fatal 及其同属函数导致子测试被跳过，但是不会跳过父测试或后续的子测试。\n另外一件要注意的事情是新版本中的错误信息更短。因为子测试的名字唯一标识了一个子测试，因此不再需要在错误信息内部识别该测试。\n使用子测试或子基准测试还有其他的益处，下面的部分会阐明。\n运行指定的测试或基准测试 子测试和子基准测试可以在命令行使用 -run 或 -bench 标识选择。两个标识都接收一个斜线分隔的正则表达式列表，匹配了子测试或子基准测试的完整名字的对应部分。\n子测试或子基准测试的完整名字是一个斜线分隔的列表，包括自身的名字以及所有父测试的名字，从顶层测试开始。名字是顶层测试和基准测试对应的名字，且第一个参数必须是 Run。为了避免显示和解析问题，名字使用下划线替换空格，且忽视不可打印字符。相同的处理适用于传递给 -run 或 -bench 表示的正则表达式。\n一些例子：\n使用欧洲时区运行测试：\n$ go test -run=TestTime/\u0026quot;in Europe\u0026quot; --- FAIL: TestTime (0.00s) --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s) time_test.go:85: could not load location  只运行时间在午后的测试：\n$ go test -run=Time/12:[0-9] -v === RUN TestTime === RUN TestTime/12:31_in_Europe/Zuri === RUN TestTime/12:31_in_America/New_York --- FAIL: TestTime (0.00s) --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s) time_test.go:85: could not load location --- FAIL: TestTime/12:31_in_America/New_York (0.00s) time_test.go:89: got 07:31; want 7:31  可能有点奇怪，使用 -run=TestTime/NewYork 没有匹配任何测试。这是因为出现在位置名字的斜线被当做一个分割符。反之使用：\n$ go test -run=TestTime//New_York --- FAIL: TestTime (0.00s) --- FAIL: TestTime/12:31_in_America/New_York (0.00s) time_test.go:88: got 07:31; want 7:31  注意传递给 -run 的字符串中的 //。时区名字 America/New_York 中的 / 被当做是来自子测试的一个分隔符处理。第一个正则表达式模式 (TestTime) 匹配顶层测试。第二个正则表达式(空字符串)匹配所有，这种情况匹配时间和位置的大洲部。第三部分正则表达式(New_york)匹配位置的城市部分。\n把名字中的斜线当做分隔符允许用户重构测试的层次结构，而不用修改名字。它也简化了避免规则。如果这暴露一个问题的话，用户应该避免名字中的斜线，比如使用下划线替代。\n一个唯一的序列号被增加到不唯一的测试名字末尾。因此如果子测试没有明显的名字结构，可以只传递一个空字符串给 Run，且子测试可以简单地通过序列号识别。\n设置和清理 子测试和自己准测试可用于管理公共的设置和清理代码：\nfunc TestFoo(t *testing.T) { // \u0026lt;setup code\u0026gt; t.Run(\u0026quot;A=1\u0026quot;, func(t *testing.T) { ... }) t.Run(\u0026quot;A=2\u0026quot;, func(t *testing.T) { ... }) t.Run(\u0026quot;B=1\u0026quot;, func(t *testing.T) { if !test(foo{B:1}) { t.Fail() } }) // \u0026lt;tear-down code\u0026gt; }  如果任一闭包的子测试运行，设置和清理代码会被允许且最多只运行一次。即使任何子测试调用 Skip、FAIL 或 Fatal 也适用。\n并行控制 子测试支持细粒度控制并行，为了理解如何用这种方式使用子测试，理解并行测试的语法是重要的。\n每个子测试和一个测试函数相关。如果一个测试的测试函数在其 testing.T 实例中调用 Parallel 方法，那么这个测试被称为并行测试。一个并行测试不会和一个顺序测试并发运行，且并行测试的执行被中止直到调用它的测试方法，即父测试返回。-parallel 标识定义了可以并行运行的并行测试的最大数目。\n一个测试会阻塞直到它的测试函数返回且它所有的子测试结束。这意味着顺序测试运行的并行测试会在任何其他一连串的顺序测试运行之前完成。\n这种行为对使用 Run 创建的测试和顶层测试是一样的。事实上，在底层，顶层测试被实现为一个隐藏的主测试的子测试。\n并行运行一组测试 上述语义支持并行运行一组测试，这组测试内部是并行的，但不与其他并行测试并行：\nfunc TestGroupedParallel(t *testing.T) { for _, tc := range testCases { tc := tc // capture range variable t.Run(tc.Name, func(t *testing.T) { t.Parallel() if got := foo(tc.in); got != tc.out { t.Errorf(\u0026quot;got %v; want %v\u0026quot;, got, tc.out) } ... }) } }  外部测试一直到所有通过 Run 启动的并行测试完成之后才会结束。因此，不会有其他并行测试可以和这些并行测试并行运行。\n注意我们需要捕获 range 变量以确保 tc 与正确的实例绑定。\n一组并行测试之后的清理 在上述例子中，我们在开始其他测试之前使用语义等待一组并行测试结束。相同的技术可用于在一组共享公共资源的并行测试之后清理：\nfunc TestTeardownParallel(t *testing.T) { // \u0026lt;setup code\u0026gt; // This Run will not return until its parallel subtests complete. t.Run(\u0026quot;group\u0026quot;, func(t *testing.T) { t.Run(\u0026quot;Test1\u0026quot;, parallelTest1) t.Run(\u0026quot;Test2\u0026quot;, parallelTest2) t.Run(\u0026quot;Test3\u0026quot;, parallelTest3) }) // \u0026lt;tear-down code\u0026gt; }  等待一组并行测试的行为和之前的例子是相同的。\n结论 Go1.7 对子测试和子基准测试的增加允许你用正常的方式编写结构化的测试和基准测试，可以优雅的融入现有的工具。一种思考方式是 testing 包之前的版本有 1 层结构：包级别的测试被组织为一个单独的测试和基准测试的集合。现在这种组织可以递归扩展到这些单独的测试和基准测试。事实上，在实现中，顶层测试和基准测试被作为一个隐藏的主测试和基准测试的子测试和基准测试：这种处理在每一层都是相同的。\n对于测试来说，定义这种结构的能力使能细粒度执行指定的测试用例、共享设置和清理，以及更好地控制测试并行。我们很高兴看到人们发现其他用途。享受它！\n相关文章  Go 可测试的示例函数 关于覆盖的故事  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3600066dae28c14bcb8c32ad41511f95","permalink":"https://xueqing.github.io/translation/go-doc/blog/subtest/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/blog/subtest/","section":"translation","summary":"介绍 表驱动测试基础 表驱动的基准测试 使用子测试的表驱动测试 运行指定的测试或基准测试 设置和清理 并行控制 并行运行一组测试 一组并行测试之后的清理 结论","tags":["go-blog"],"title":"使用子测试和子基准测试","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  channel 单向 channel close 关闭信道 有缓冲的 channel  channel  channel 可认为是带有类型的 pipe，goroutine 通过 channel 通信 每个 channel 有一个关联的类型，这个类型是 channel 允许传输的数据类型  chan T 是一个 T 类型的通道  channel 的初始化值是 nil，使用 make 定义chan_name := make(chan chan_type) 使用信道操作符 \u0026lt;- 发送或接收值，箭头是数据流的方向\n data := \u0026lt;- chan_name从 chan_name 读数据，当不需要保存读的数据时是\u0026lt;- chan_name chan_name \u0026lt;- data往 chan_name 写数据 发送和接收模式是阻塞的，通过 channel 发送数据的时候，控制会阻塞在发送语句直到其他的 goroutine 从 channel 读数据，读数据亦然 避免死锁：如果等待从 channel 读或写的 goroutine 没有对应的写或读，将会阻塞\nfunc calcSquares(number int, squareop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit number /= 10 } squareop \u0026lt;- sum } func calcCubes(number int, cubeop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit * digit number /= 10 } cubeop \u0026lt;- sum } func ChannelTest() { number := 54 squarech := make(chan int) cubech := make(chan int) go calcSquares(number, squarech) go calcCubes(number, cubech) squareop, cubeop := \u0026lt;-squarech, \u0026lt;-cubech fmt.Printf(\u0026quot;squares = %d, cubes = %d\\n\u0026quot;, squareop, cubeop) }    单向 channel  可以创建单向的 channel，只用来发送或接受数据，然而没有什么意义\n chan\u0026lt;- chan_type创建只发送/写 channel\nfunc unidirectionalChannel(unich chan\u0026lt;- int) { unich \u0026lt;- 1 } func unidirectionalChannelTest() { unich := make(chan\u0026lt;- int) go unidirectionalChannel(unich) // fmt.Println(\u0026lt;-unich) //invalid operation xx(received from send-only type) }    close 关闭信道  发送者可以通过close chan_name关闭 channel，通知接收者没有数据了，接收者通过var, ok := \u0026lt;- chan_name接受数据，如果是已经关闭的 channel，ok 会赋值 false，主要在用 for range 循环从 channel 不断接受数据时使用 只有发送者才能关闭信道。向一个已经关闭的信道发送数据会引发程序 panic 信道与文件不同，通常情况下无需关闭。只有在必须告诉接收者不再有需要发送的值时才有必要关系，例如终止一个 for range 循环\nfunc chanSender(chanop chan int) { for i := 0; i \u0026lt; 10; i++ { chanop \u0026lt;- i } close(chanop) } func chanReceiver() { chanop := make(chan int) go chanSender(chanop) // for { // data, ok := \u0026lt;-chanop // if ok == false { // break // } // fmt.Println(\u0026quot;Received \u0026quot;, data, ok) // } for data := range chanop { fmt.Println(\u0026quot;Received \u0026quot;, data) } }  func getDigits(number int, digitch chan int) { for number != 0 { digit := number % 10 digitch \u0026lt;- digit number /= 10 } close(digitch) } func calcSquares(number int, squareop chan int) { sum := 0 digitch := make(chan int) go getDigits(number, digitch) for digit := range digitch { sum += digit * digit } squareop \u0026lt;- sum } func calcCubes(number int, cubeop chan int) { sum := 0 digitch := make(chan int) go getDigits(number, digitch) for digit := range digitch { sum += digit * digit * digit } cubeop \u0026lt;- sum } func ChannelTest() { number := 54 squarech := make(chan int) cubech := make(chan int) go calcSquares(number, squarech) go calcCubes(number, cubech) squareop, cubeop := \u0026lt;-squarech, \u0026lt;-cubech fmt.Printf(\u0026quot;squares = %d, cubes = %d\\n\u0026quot;, squareop, cubeop) }   有缓冲的 channel  channel 默认没有缓冲，发送和接收都会阻塞 make(chan type, capacity)可以创建 buffered channel，只有缓冲满的时候发送会阻塞，只有缓冲空的时候接收会阻塞  channel 容量默认为 0，即没有缓冲，会阻塞 长度是 channel 缓冲现有的元素数目，容量是 channel 缓冲最多可以容纳的数目   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"09538da7b4af2e9714c0585b780f0222","permalink":"https://xueqing.github.io/blog/go/basic/go_channel/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_channel/","section":"blog","summary":"channel 单向 channel close 关闭信道 有缓冲的 channel channel channel 可认为是带有类型的 pipe，goroutine 通过 channel 通信 每个 channel 有一个关联的类型，这个类型是 channel 允许传输的数据类","tags":["go"],"title":"信道","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" ubuntu 公司内部添加了域名服务器，每次将域名改成 IP 地址很麻烦，所以修改本地 hosts 可以直接重定向 sudo vim /etc/hosts\nwindows  搜索程序“记事本”，用管理员身份打开 在记事本中打开文件，路径是C:\\Windows\\System32\\drivers\\etc，选择所有文件 可以看到hosts文件，选中打开进行修改，保存就可以了  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1c5169c501e58c20aac775a3c398895d","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_hosts/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_hosts/","section":"blog","summary":"ubuntu 公司内部添加了域名服务器，每次将域名改成 IP 地址很麻烦，所以修改本地 hosts 可以直接重定向 sudo vim /etc/hosts windows 搜索程序“记事本”，用管理员身份打开 在记事本中打","tags":["ubuntu","linux"],"title":"修改 hosts 文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 使用对应功能需要的库  apt-get install mpi-default-dev安装 mpi 库 apt-get install libicu-dev支持正则表达式的 UNICODE 字符集 apt-get install python-dev需要 python 的话 apt-get install libbz2-dev如果编译出现错误bzlib.h: No such file or directory  解压源代码安装包，切换到对应文件夹：./bootstrap.sh  生成 bjam，上述命令可以带有各种选项，具体可参考帮助文档：./bootstrap.sh --help --prefix参数，可以指定安装路径，如果不带--prefix参数的话（推荐），默认路径是/usr/local/include和/usr/local/lib，分别存放头文件和各种库。 当前目录下，生成两个文件 bjam 和 b2，这两个是一样的，所以接下来的步骤，可以用这两个中的任意一个来执行 using mpi如果需要 MPI 功能，需要在 /tools/build/v2/user-config.jam 文件的末尾添加  利用生成的 bjam 脚本编译源代码  ./b2 -a -sHAVE_ICU=1，-a参数，代表重新编译，-sHAVE_ICU=1代表支持 Unicode/ICU  编译完成后，进行安装，也就是将头文件和生成的库，放到指定的路径（\u0026ndash;prefix）下  ./b2 install   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8582b91ecc122e8df9a9fee099f8d258","permalink":"https://xueqing.github.io/blog/cplusplus/boost/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/boost/","section":"blog","summary":"使用对应功能需要的库 apt-get install mpi-default-dev安装 mpi 库 apt-get install libicu-dev支持正则表达式的 UNICODE 字符集 apt-get install python-dev需要 python","tags":["c++"],"title":"关于 boost 库","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 常量正确性(const correctness)  1.1 概述 1.2 const 和 * 1.3 const 和 \u0026amp; 1.4 成员函数  2 二重指针 3 修改 const 4 X-\u0026gt;const X 5 reference  1 常量正确性(const correctness) 1.1 概述  常量正确性：即使用关键字const避免常量对象被修改 函数接收一个参数，且在调用过程中不能修改参数，实现方式有三种\n f1/f2 中不能修改传入参数，否则会有编译警告 f3 值传递，只修改局部拷贝 f1/f2 中不能调用 g1/g2，否则会有编译警告\nvoid f1(const std::string\u0026amp; s); //pass by reference-to-const void f2(const std::string* sp); //pass by pointer-to-const void f3(std::string s); //pass by value void g1(std::string\u0026amp; s); //pass by reference-to-non-const void g2(std::string* sp); //pass by pointer-to-non-const   常量正确性：避免意外修改不希望修改的东西\n 一般来说，const 作用于离它最近的左侧的类型，否则，作用于离它最近的右侧的类型\n 规则：read it backwards，即倒着读\n 建议：X 放在修饰符的右边\n  1.2 const 和 *  const X * ptr：ptr is a pointer to an X that is const  ptr 是一个指针变量，指向一个 X 的对象，但不能通过指针修改 X 对象, *ptr 只读 不能通过 ptr 调用 X 非 const 的成员方法，否则会有编译警告      声明 解释 描述     const int const0=96; int is const const1 是整型常量，不可再赋值   X * ptr ptr is a pointer to an X X 对象实例的指针   const X * ptr ptr is a pointer to an X that is const ptr 是一个指针变量，指向一个 X 的对象，但不能通过指针修改 X 对象, *ptr 只读   X const * ptr 同上 同上   X const const * ptr 同上 同上   const X const * ptr 同上 同上   X * const ptr ptr is a const pointer to an X ptr 是一个常量指针，指向一个 X 的对象，不能给指针再赋值，但是可以通过指针修改 X 对象，ptr 只读   X const * const ptr ptr is a const pointer to a const X ptr 是一个常量指针，指向一个 X 的对象，但不能给指针再赋值，也不能通过指针修改 X 对象   const X * const ptr 同上 同上    const char *Function1() { return \u0026quot;Some text\u0026quot;; } Function1()[1]='a'; //error   常量指针指向变量：变量可修改，且未从内存移除 指向常量的指针变量：函数返回常量字符串数组，防止修改返回值错误  1.3 const 和 \u0026amp;  const X \u0026amp; obj：obj is a reference to an X that is const  obj 是一个 X 对象的引用，但不能通过 obj 修改 X 对象 不能通过 obj 调用 X 非 const 的成员方法，否则会有编译警告      声明 解释 描述     const X \u0026amp; obj obj is a reference to an X that is const obj 是一个 X 对象的引用，但不能通过 obj 修改 X 对象, obj 只读   X const \u0026amp; obj 同上 同上    1.4 成员函数  在成员函数后加const避免在内部修改成员变量\nclass MyClass{ int m_var; // modify m_var is not allowed void SomeMethod() const; // the var pointed to by returned pointer and returned pointer is not allowed to altered // the var pointed to by given pointer and given pointer is const // modify m_var is not allowed const int * const AnotherMethod(const int * const \u0026amp;) const; // the return value must not be reference to a member of MyClass std::string\u0026amp; BadMethod() const; // the return value can be reference to a member of MyClass const std::string\u0026amp; GoodMethod() const; }   2 二重指针    声明 解释 描述     int ** pp pp is a pointer to a pointer to an int -   int ** const pp pp is a const pointer to a pointer to an int -   int * const * pp pp is a pointer to a const pointer to an int -   int const ** pp pp is a pointer to a pointer to a const int -   int * const * const pp pp is a const pointer to a const pointer to an int     3 修改 const  一个对象或变量被声明成const，后续可以使用const_cast修改其为可变 将类的某些成员变量声明为mutable，可在const成员函数中修改它们  4 X-\u0026gt;const X  将X*转成const X*是安全的 将X**转成const X**会有编译警告，因为可能会不经 cast 操作修改一个const X对象\nclass MyClass { public: void Modify(); } int main() { const MyClass obj; MyClass * ptr; const MyClass ** pptr = \u0026amp;ptr; // compile error *pptr = \u0026amp;obj; // ptr points to obj ptr-\u0026gt;Modify(); // ptr modifies const obj return 0; }   5 reference  const correctness What is the difference between const int*, const int * const, and int const * The C++ \u0026lsquo;const\u0026rsquo; Declaration: Why \u0026amp; How  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"abcc5886bdeb2a8c00919c2f3cb6d42d","permalink":"https://xueqing.github.io/blog/cplusplus/const/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/const/","section":"blog","summary":"1 常量正确性(const correctness) 1.1 概述 1.2 const 和 * 1.3 const 和 \u0026amp; 1.4 成员函数 2 二重指针 3 修改 const 4 X-\u0026gt;const X 5 reference 1 常量正确性(const correctness) 1.1 概述 常量正确性：即使用关键","tags":["c++"],"title":"关于 const","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  格式规范  通配符 斜线 两个星号 \u0026rdquo;!\u0026rdquo; 取消忽视  忽略文件示例 参考  格式规范  所有空行或者以 ＃ 开头的行都会被 git 忽略 可以使用标准的 glob 模式匹配  glob 模式指 shell 所使用的简化了的正则表达式，包括*、?、[]、**  匹配模式可以以(/)开头防止递归 匹配模式可以以(/)结尾指定目录 要忽略指定模式以外的文件或目录, 可以在模式前加上惊叹号(!)取反  通配符  * 匹配除了 / 的所有字符，匹配零个或多个任意字符 ? 匹配除了 / 的所有单字符 [] 匹配任何一个列在方括号中的字符：如果在方括号中使用短划线分隔两个字符, 表示所有在这两个字符范围内的都可以匹配  比如 [0-9] 表示匹配所有 0 到 9 的数字   斜线  行首第一个 / 匹配路径的开始, 以 .gitignore 当前所在路径计算相对路径 如 /*.txt 匹配与 .gitignore 同一路径下的 txt 文件, 不包含 .gitignore 当前路径下子文件内的 txt 文件  test/*.txt 路径的开始是 t 而不是 /   两个星号  **/ 匹配任意中间目录 /** 匹配包含的所有内容, 包括文件和文件夹, 以及子文件和子文件下的文件 /**/ 匹配 0 个或多个目录  \u0026rdquo;!\u0026rdquo; 取消忽视  !pattern 否认 pattern, 即前一个 pattern 匹配的文件会再被包含 注意: 如果一个文件的父文件夹被忽略, 那么 git 不能再包含该文件 忽视除了 /build/debug 下 除了 snap 的文件和文件夹\n## 前两句可互换顺序 build/debug/* !build/debug !build/debug/snap ## 如果包含下面的语句则不能再包含 snap 文件和文件夹 # build # build/ # build/**   忽略文件示例  # 注释行 *.[oa] # 忽略所有以 .a 或 .o 为扩展名的文件 !lib.a # 但是 lib.a 文件或者目录不要忽略 /TODO # 只忽略根目录下的 TODO, 子目录的 TODO 不忽略 build/ # 忽略所有 build/ 目录下的文件 doc/*.txt # 忽略 doc/.txt, 但 doc/server/.txt 不忽略 doc/**/*.pdf # 忽略 doc文件夹下所有的*.pdf  参考  教程 ignore 模板  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9729962dd29dec6bbd3602ab9d8a5de9","permalink":"https://xueqing.github.io/blog/git/git_ignore/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_ignore/","section":"blog","summary":"格式规范 通配符 斜线 两个星号 \u0026rdquo;!\u0026rdquo; 取消忽视 忽略文件示例 参考 格式规范 所有空行或者以 ＃ 开头的行都会被 git 忽略 可以使用标准的 glob 模式匹配 glob 模式指 shell 所使用的简","tags":["git"],"title":"关于 gitignore 文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 编译错误fatal error: GL/gl.h: No such file or directory  sudo apt-get install build-essential安装OpenGL Library sudo apt-get install libgl1-mesa-dev安装OpenGL Utilities sudo apt-get install libglu1-mesa-dev安装OpenGL Utility Toolkit   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2af8e0fc34b6d32f12b34bb1674f847f","permalink":"https://xueqing.github.io/blog/qt/qt_gl/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/qt/qt_gl/","section":"blog","summary":"编译错误fatal error: GL/gl.h: No such file or directory sudo apt-get install build-essential安装OpenGL Library sudo apt-get install libgl1-mesa-dev安装OpenGL Utilities","tags":["qt"],"title":"关于 GL 的问题","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 引言 2 第三方呼叫控制  2.1 流程 I 2.2 流程 II 2.3 流程 III 2.4 流程 IV 2.5 流程总结  3 应用 4 总结  1 引言  SIP 协议：IETF 提出的会话初始协议，是在 IP 网进行多媒体通信的应用层控制协议，用于发起、建立和释放会话 SDP 协议：会话描述协议，用来描述与媒体流相关的参数以及与会话相关的信息，其中包括对会话的描述以及媒体类型、数据发送到的端口、传输协议(如 RTP)以及媒体格式(如 RTP 载荷格式)的描述 在传统的电话网环境中，第三方呼叫控制(3pcc, third party call control)允许一个实体(称之为控制器 controller)建立并管理另外两方或多方之间的通信关系 3pcc 常用语运营商业务(运营商需要创建一个呼叫连接两个用户)和会议  在 PSTN(public switched telephone network，公共交换电话网) 网中，第三方呼叫控制通常用于会议、接线业务(接线员创建一个连接另外双方的呼叫) 使用 SIP 协议可借助第三方呼叫控制完成业务，例如点击拨号、通话过程中放音等 RFC3264 中定义了一种提供/应答模式，使两个实体之间可以使用 SDP 的提供/应答(offer/answer)模式进行会话协商   2 第三方呼叫控制  SIP 消息可携带 SDP 消息体。3pcc 的关键在于控制器如何在会话双方之间使用 SDP 消息协商即将建立的会话 根据 SIP 协议的机制，有以下 4 中方法实现 3pcc  2.1 流程 I  流程图中的 offer 和 answer 都是 SDP 消息 流程包括以下几步  控制器-\u0026gt;A： 发送一个 INVITE，没有 SDP A-\u0026gt;控制器：A 电话振铃应答之后，200 OK 响应中包含一个 offer1，携带用户 A 所希望建立会话的媒体类型、媒体格式、传输协议以及接收媒体流的端口和 IP 地址 控制器-\u0026gt;B：发送一个 INVITE，包含来自 A 的 offer1 B-\u0026gt;控制器：B 振铃应答之后，产生对 offer1 的应答 answer1 控制器-\u0026gt;B：发送 ACK 作为应答 控制器-\u0026gt;A：发送 ACK 作为应答， 包含 answer1  优点：简单，不需要控制器产生 SDP，不必考虑控制器自身对媒体类型的要求 缺点：超时问题。如果 B 不能立即响应，控制器无法马上给 A 发送 ACK，有可能导致 A 定时(64*T1 秒)重发 200 OK  根据 RFC 3261，走时之后没有收到 ACK，呼叫失败 此流程只能用于 B 可以立即响应 INVITE 请求   2.2 流程 II  流程图中的“黑洞” SDP 指包含的连接地址是一个无效的连接地址(如 rtp.invalid 或 0.0.0.0)，即想建立一个空的流媒体，因为实际上并没有媒体或 RTP 包从 A 流出 流程包括以下几步  控制器-\u0026gt;A：发送 INVITE，包含 SDP1，用来创建一个空的媒体流 A-\u0026gt;控制器：A 振铃并产生应答，包含 SDP2，其中包含的是有效的连接地址，但此时仍没有媒体流向控制器 控制器-\u0026gt;B：发送 INVITE，携带 SDP2 作为对 B 的 offer 控制器-\u0026gt;A：发送 ACK 作为应答 B-\u0026gt;控制器：B 振铃并产生应答，200 OK 中包含 SDP3，是对 SDP2 的应答 控制器-\u0026gt;B：发送 ACK 作为应答 控制器-\u0026gt;A：发送 re-INVITE，包含 SDP3 作为 offer A-\u0026gt;控制器：假设用户 A 不想改变原来的会话属性，在 200 OK 响应中包含的应答仍是 SDP2 控制器-\u0026gt;A：发送 ACK 作为应答 A-\u0026gt;B：流  优点：本流程所有的最终响应都可立即确认，不会有因超时而导致呼叫失败的问题 缺点：  控制器必须预先知道本次呼叫所要使用的媒体类型，来创建初始的“黑洞” SDP “黑洞” SDP是一种扩展机制，并不能确保所有的 UA 支持这种机制，以及如果收到这样的地址做何反应 流程完成的前提是假设用户 A 对 re-INVITE 的响应中仍然包含 SDP2 如果不是 SDP2，控制器还需向 B 再发送 re-INVITE，然后又可能从 B 得到另一个不同的 SDP，然后还需向 A 发送 re-INVITE，等等，可能形成一个无限循环的会话协商 可采用一个智能 UA，要求其固定的返回 SDP2，或采用一个智能的控制器能够分析收到的 SDP 确定是否需要发送 re-INVITE。但是简单起见，应尽量避免控制器了解 SDP 的具体内容，所以本流程根本不可用   2.3 流程 III  流程包括以下几步  控制器-\u0026gt;A：发送 INVITE，没有 SDP A-\u0026gt;控制器：A 振铃应答，200 OK 响应中包含一个 offer1 控制器-\u0026gt;A：在 ACK 消息中产生一个“黑洞” SDP 应答 控制器-\u0026gt;B：发送 INVITE，没有 SDP B-\u0026gt;控制器：B 振铃应答，200 OK 响应中包含一个提供 offer2 控制器-\u0026gt;A：发送 re-INVITE，基于 offer2 offer2 可能需要稍作修改来满足媒体要求。例如如果 offer1 包含一个音频和一个视频行，而 offer2 只有一个音频行，控制器需要在 offer2 中增加一个视频行构成 offer2\u0026rsquo; A-\u0026gt;控制器：A 振铃应答，200 OK 响应中包含 answer2\u0026rsquo; 由于是一个 re-INVITE，通常能立即收到应答 控制器-\u0026gt;B：发送 ACK，基于 answer2\u0026rsquo;，可能修改为 answer2，作为 offer2 的应答 控制器-\u0026gt;A：发送 ACK 作为应答  优点：  操作通常没有超时，没有多余的重发(如果 re-INVITE 没有很快回复，所以还可能发生超时) 不需要控制器猜测参与者将要使用的媒体信息  缺点  控制器需要处理 SDP 必须接收 SDP，生成另外一个 SDP，媒体信息相同，但是连接地址是无效的 需要保存之前的 SDP 信息，以便之后处理 SDP 信息，使之与保存的 SDP 匹配 B 的 offer2 可能没有 A 的 offer1 中的解码器或媒体。控制器需要检测这种条件，终止流程 导致处理流程更加复杂   2.4 流程 IV  流程包括以下几步  控制器-\u0026gt;A：发送 INVITE，SDP 中没有媒体信息 A-\u0026gt;控制器：A 振铃应答，200 OK 中的 SDP 也没有媒体信息 控制器-\u0026gt;A：发送 ACK 应答 控制器-\u0026gt;B：发送 INVITE，没有 SDP 下面的步骤和流程 III 相同，但是，修改 offer2 为 offer2\u0026rsquo; 以及修改 answer2 为 answer2\u0026rsquo; 更加简单 不需要处理媒体信息 只需要修改原始行，使得 offer2\u0026rsquo; 的原始行基于 offer1 的值是有效的(版本加 1，其他参数不变)  优点：降低了复杂度 缺点：  A 需要振铃应答，但此时没有任何媒体建立。这意味着 A 不能基于它自己的媒体信息拒绝或接受呼叫 A 和 B 将会在不知道是否有兼容的媒体之前就应答了呼叫(如产生 2000 响应) 如果没有相同的媒体，调用会通过之后的 BYE 终止。但是，用户已经响铃，造成了骚扰，并可能产生计费事件   2.5 流程总结  流程 I 最简单且最有效。如果控制器预先知道 B 是自动应答的能够立即响应(如 B 是媒体服务器、会议服务器、消息服务器等)，使用流程 I  大多数情况下，3pcc 建立的通信中会有一方是自动设备，因此这个流程会很常用  如果通信双方都是真实的人，或者是未知类型的实体，可使用流程 IV 来实现 3pcc  流程 III 也可使用，但是不会提供额外的好处  一般不应该使用流程 II，因为可能有无限的循环 使用 III 和 IV 对控制器的智能性要求比较高 在多数情况下，包括建议的流程，A 在 B 完成呼叫的过程中，会听到一段时间的静默。这样不太理想。可以考虑在完成呼叫的时候，将 A 连接到一个 music-on-hold 资源上  3 应用  SIP 协议的突出优点在于灵活的多媒体会话的控制功能，配合使用 3pcc 可比传统电话网更加灵活方便的实现各种补充业务和新业务 3pcc 应用广泛，例如可方便对信令的控制，易于实现点击拨号、早期媒体放音、通话过程中播放语音通知的业务等  点击拨号业务是最典型的 3pcc 的应用实例。用户浏览网站时，可直接点击网页上的链接地址，使用 HTTP 启动控制器对客服代表和 SIP 用户直接的第三方呼叫控制。然后控制器就可使用上述 4 种方法在两者之间建立媒体通话 播放过程中播放语音通知，可使用控制器将媒体服务器跟正在通话的用户之间连接起来，播放通知   4 总结 3pcc 在多方通信中(如会议)的应用广泛，SIP 协议的 3pcc 功能应用灵活，使用一个控制器可将多个用户联系起来进行通信，方便管理\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"262dfc7021aced8e863c9bc76c551c46","permalink":"https://xueqing.github.io/blog/sip/sip_3pcc/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/sip_3pcc/","section":"blog","summary":"1 引言 2 第三方呼叫控制 2.1 流程 I 2.2 流程 II 2.3 流程 III 2.4 流程 IV 2.5 流程总结 3 应用 4 总结 1 引言 SIP 协议：IETF 提出的会话初始协议，是在 IP 网进行多媒体通信","tags":["sip"],"title":"关于 SIP 协议第三方呼叫控制","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  前言 变量或函数的声明和定义 声明和定义全局变量的最好方式 关键点 1：可以声明多次但初始化一次 关键点 2：默认存储类是 extern 关键点 3：extern 变量或程序对整个程序可见 关键点 4：extern 作用于变量  只用于声明变量 全局变量自动初始化 不能局部地初始化 extern 变量 不能写全局的赋值语句 对类成员无效  常见错误  未定义的行为 外部定义 多重外部定义 头文件中变量的声明  参考  前言  extern 用于声明 C 语言中的外部变量和函数。这个修饰符用于所有数据类型，比如 int，float，double，array，pointer，structure，function 等 范围(scope)：不绑定到任何函数。作用域整个程序，是全局的 默认值(default value)：全局变量的默认初始化值是 0(或 null) 生命周期(lifetime)：直到整个程序执行结束 extern 告诉编译器变量或函数(非静态的)都可以在链接时找到。适用于在模块之间共享某些全局变量，但是不想把它们放在一个头文件，或者在一个头文件中定义它们  大部分编译器编译器会优化程序确保它们不会为 extern 对象保留内存，因为编译器知道定义它们的模块会保留内存   变量或函数的声明和定义  声明(declaration)：声明变量或函数存在程序的某个地方，但是不为它们分配内存。确定了变量或函数的类型  声明一个变量时，程序知道这个变量的类型；声明一个函数时，程序知道函数的参数、数据类型、参数顺序和函数返回类型 声明是编译器需要的用于接受对标识符的引用  定义(definition)：既包含声明的作用，也为变量或函数分配内存。可以认为定义是声明的一个超集 因此一个函数或变量可以声明多次，但是只能定义一次(即同一个函数或变量不能存在两个位置)  定义是对标识符的实例化/实现 定义时链接器需要的用于链接对这些实体的引用 单一定义原则(One Definition Rule)：编译单元不应该对任意变量、函数、类类型、枚举类型或模板有多余一个的定义   声明和定义全局变量的最好方式  声明和定义全局变量的清晰、可靠的方式是使用一个头文件，该头文件包含变量的 extern 声明  定义这些变量的源文件和引用这些变量的源文件包含此头文件 对于每一个程序，有且只有一个源文件定义这些变量 对于每一个程序，有且只有一个头文件声明这些变量 这个头文件时重要的，它使能在独立的翻译单元(TU，translation units，源文件)之间交叉检查，同时确保一致性  完整的程序可能还需要全局函数。C99 和 C11 要求函数在使用之前必须是已经声明或定义过的。使用一个头文件包含全局函数的 extern 声明。也可以不加 extern 尽量避免使用全局函数——可以使用全局变量  关键点 1：可以声明多次但初始化一次  一个特殊的 extern 变量或函数可以声明多次，但是只初始化一次。但是不可以声明一次，初始化多次\n#include \u0026lt;stdio.h\u0026gt; extern int i;//declaring variable i int i=25;//initializing variable i extern int i;//again declaring variable i int main() { extern int i;//again declaring variable i printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：25  #include \u0026lt;stdio.h\u0026gt; extern void sum(int,int);//by default it is extern function int main() { extern void sum(int,int);//by default it is extern function int a=5,b=10; sum(a,b); return 0; } void sum(int a, int b) { printf(\u0026quot;%d\\n\u0026quot;, a+b); }  #include \u0026lt;stdio.h\u0026gt; extern int i;//declaring variable i int i=25;//initializing variable i int main() { printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } int i=20;//again initializing variable i // 输出：编译错误(error: redefinition of ‘i’)   关键点 2：默认存储类是 extern  extern 是所有全局变量和函数的默认存储类(storage class)，即全局变量和函数默认对整个程序可见，不需要声明或定义 extern 函数。使用 extern 关键字是多余的 编译器会在全局函数的声明和定义前面自动加上 extern 在下面两个测试代码中，变量 i 都是 extern 变量\n// test1.c #include \u0026lt;stdio.h\u0026gt; int i;//definition of i: by default it is extern variable int main() { printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：0  // test2.c #include \u0026lt;stdio.h\u0026gt; extern int i;//extern variable int main() { printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：编译错误，未定义的引用(undefined reference to i)  // test3.c #include \u0026lt;stdio.h\u0026gt; void sum(int,int);//by default it is extern function int main() { int a=5,b=10; sum(a,b); return 0; } void sum(int a, int b) { printf(\u0026quot;%d\\n\u0026quot;, a+b); } // 输出：15   关键点 3：extern 变量或程序对整个程序可见  extern 关键字用于扩展变量或函数的可见性。如果全局声明一个 extern 变量或函数，那么它的可见性是整个程序，这个程序可能包含一个或多个文件。比如一个 C 程序，包含两个文件 one.c 和 two.c 下面程序的输出是 30\n//one.c #include \u0026lt;conio.h\u0026gt; int i=25;//by default extern variable int j=5;//by default extern variable //above two lines is initialization of variable i and j void main() { clrscr(); sum(); getch(); }  //two.c #include \u0026lt;stdio.h\u0026gt; extern int i;//declaration of variable i extern int j;//declaration of variable j //above tow lines will search the initialization statement of variable i and j either in two.c(if initialized variable id static and static) // or one.c(if initialized variable is extern) void sum() {//by default extern function int s; s = i + j; printf(\u0026quot;%d\\n\u0026quot;, s); }  一个 extern 变量或函数有外部(external)链接，一个外部链接的变量或函数对所有文件可见\n extern 作用于函数只是告诉编译链接是外部的；作用于变量只声明变量而不会定义(初始化或实例化)变量   关键点 4：extern 作用于变量 只用于声明变量  当对变量使用 extern 修饰符时，它只用于声明(比如不会为这些变量分配内存)。因此在上述 test2.c 中，编译器报错undefined symbol。如果要定义变量(比如为 extern 变量分配内存)，必须初始化变量 初始化 extern 变量即是定义 extern 变量\n#include \u0026lt;stdio.h\u0026gt; extern int i=10;//extern variable int main() { printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：10 // warning: ‘i’ initialized and declared ‘extern’ // 如果声明时也提供了初始化，那么会为变量分配内存，该变量认为是被定义过的  编译警告参考warning in extern declaration\n#include \u0026lt;stdio.h\u0026gt; extern int i;//extern variable int main() { return 0; } // 编译成功。只声明变量 i 但是未使用，不会报错  如果我们声明一个变量是 extern，那么编译器会搜索这个变量是否已经初始化。如果已经初始化为 extern 或 static 则成功。否则编译器会报错\n 修正：初始化为 static 仍然报错????\n#include \u0026lt;stdio.h\u0026gt; int main() { extern int i;//it will search the initialization of i printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } int i=20;//initialization of extern variable i // 输出：20  #include \u0026lt;stdio.h\u0026gt; int main() { extern int i;//it will search the initialization of i printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } static int i=20;//initialization of static variable i // 输出：编译错误(error: static declaration of ‘i’ follows non-static declaration)   全局变量自动初始化  如果全局变量不适用 extern 关键字，编译器会使用默认值自动初始化 extern 变量 extern 整数类型变量的默认初始化值是 0 或者 null\n#include \u0026lt;stdio.h\u0026gt; char c; int i; float f; char *str; int main() { printf(\u0026quot;%d %d %f %s\\n\u0026quot;, c, i, f, str); return 0; } // 输出：0 0 0.000000 (null)   不能局部地初始化 extern 变量  不能在任何代码块内部局部地初始化 extern 变量，不论是声明时初始化还是初始化和声明分开。我们只能全局地初始化 extern 变量\n#include \u0026lt;stdio.h\u0026gt; int main() { extern int i=10; printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：编译错误(error: ‘i’ has both ‘extern’ and initializer)  #include \u0026lt;stdio.h\u0026gt; int main() { extern int i;//declaration of extern variable i int i=10;//try to locally initialize extern variable i printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：编译错误(error: declaration of ‘i’ with no linkage follows extern declaration)  #include \u0026lt;stdio.h\u0026gt; extern int i;//declaration of extern variable i int main() { int i=10;//declare and define a local variable printf(\u0026quot;%d\\n\u0026quot;, i);//the i is local return 0; } // 输出：10  #include \u0026lt;stdio.h\u0026gt; int main() { extern int i;//declaration of extern variable i, its memory is not allocated i=10;//try to change the value of variable i to 10, but it doesn't exist printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：编译错误(两处错误：undefined reference to i)   不能写全局的赋值语句  在声明变量时给变量赋值叫做初始化(initialization) 不在变量声明时给变量赋值叫做赋值(assignment)\n#include \u0026lt;stdio.h\u0026gt; extern int i;//declaring variable i int i=25;//initializing variable i i=20; int main() { printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } // 输出：编译错误(error: redefinition of ‘i’)  #include \u0026lt;stdio.h\u0026gt; extern int i;//declaring variable i int main() { i=20;//assignment printf(\u0026quot;%d\\n\u0026quot;, i); return 0; } int i=25;//initialization // 输出：20   对类成员无效  extern \u0026quot;C\u0026quot; 被类成员忽略  常见错误 未定义的行为  Undefined behavior：使用了一个带外部链接的标识符，但是程序中不存在该标识符的外部定义，或者没有使用此标识符但是有多处定义此标识符  外部定义  External definitions：外部定义指一个外部声明，同事也是函数(除了内联函数)或对象的定义。如果一个表达式中使用了一个有外部链接的标识符(除了作为 sizeof或_Alignof运算符的操作数的一部分，这些运算符的结果是一个证书常数)，程序的其它地方应该有且仅有一个对此标识符的外部定义 因此，如果一个声明为外部链接的标识符未在表达式中被使用，不应该有它的外部定义  多重外部定义  Multiple external definitions：对于一个对象的标识符可能有多于一处的外部定义，这些定义可能有也可能没有显式使用 extern 关键字；如果这些定义不一致，或者多于一处有初始化，就会导致 undefined behavior  头文件中变量的声明  声明 int some_var;：如果一个头文件不使用 extern 定义一个变量，那么每个包含此头文件的文件都会尝试创建一个此变量的一个定义。但是 C 标准不确保这个一定会正常工作 声明 int some_var = 13;：如果头文件定义并初始化一个变量，那么在给定的程序中只有一个源文件可以使用这个头文件。因为头文件主要是用来共享信息的，创建一个只能使用一次的头文件不是好的做法 声明 static int some_var =3;：如果头文件定义一个静态变量(不论是否初始化)，那么每个源文件都会有此“全局”变量的一份私有拷贝。而且，如果这个变量是一个复杂的数组，那么会导致大量代码的拷贝  参考  extern keyword in c Understanding “extern” keyword in C How do I use extern to share variables between source files DECLARATIONS V.S. DEFINITIONS  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0299bdce16e27e401fd7efdec7218556","permalink":"https://xueqing.github.io/blog/cplusplus/extren_c/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/extren_c/","section":"blog","summary":"前言 变量或函数的声明和定义 声明和定义全局变量的最好方式 关键点 1：可以声明多次但初始化一次 关键点 2：默认存储类是 extern 关键点 3：extern 变量或","tags":["c++"],"title":"关键字 extern 在 C 语言的使用","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 设置 tab 为 4 个空格:set ts=4 (tabstop)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b2bee3f373819c6b70bdc046213c4f34","permalink":"https://xueqing.github.io/blog/vim/vim_other_cmd/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_other_cmd/","section":"blog","summary":"设置 tab 为 4 个空格:set ts=4 (tabstop)","tags":["vim"],"title":"其他命令","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  管理页面  接口 django CMS Site menu Page menu Language menu Publishing controller 管理员视图和组成 页面列表   管理页面 接口 django CMS 的工具栏包括以下几部分。\ndjango CMS 返回到网站的主页。\nSite menu example.com 是网站菜单。这个菜单开放一些对网站的管理控制。\n Pages ...：直接跳转到页面编辑接口 Users ...：直接跳转到用户管理面板 Administration ...：跳转到网站管理员面板 User settings ...：切换管理员界面和工具栏的语言 Disable toolbar：无论登录和工作状态如何，完全禁用工具栏和前端编辑。想要重新记号，需要手动或通过后端管理进入编辑模式 Shortcuts ...：快捷键 Logout admin：退出登录  Page menu 管理当前页面的选项。\nLanguage menu 切换当前页面的语言，管理多个翻译。支持的操作\n 增加一个缺失的翻译 删除一个已有的翻译 从一个已有的翻译复制所有插件及其内容到当前语言  Publishing controller 管理页面的发布状态。\n Edit：打开页面进行编辑 View published：更新页面，退出编辑模式 Publish page now：发布一个未发布的页面 Publish page changes：发布在页面做的修改  管理员视图和组成 页面列表 页面列表可以纵观页面及其状态。\n从左至右，列表元素具有下面的属性：\n 展开/折叠控制：有子节点的页面有这个控制 tab：用于拖拽列表元素 页面 Title 语言版本指示符和控制：  空白：不存在翻译；点击之后会打开基本设置 灰色：翻译存在但是未发布 绿色：翻译已发布 蓝色：翻译有一个修改的草稿  Menu 指示符：页面是否会出现在导航菜单 编辑：修改页面设置 添加子页面 其他行为：拷贝页面、剪切页面、删除页面、高级设置等  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"df3e519a6d4ab23aab989f397e636a7e","permalink":"https://xueqing.github.io/blog/django_cms/using/content_editor/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/django_cms/using/content_editor/","section":"blog","summary":"管理页面 接口 django CMS Site menu Page menu Language menu Publishing controller 管理员视图和组成 页面列表 管理页面 接口 django CMS 的工具栏包括以下几部分。 django CMS 返回到网站的主页。 Site menu example.com 是网站菜单。这个","tags":["django"],"title":"内容编辑参考","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  描述 术语和定义  编译单元 单定义规则  内联声明  非成员函数 成员函数  不适合内联替换的用法 C/C++ static/extern + inline  C89/90 inline C99 inline C++ inline  GCC 编译选项 内联函数对安全性和速度的取舍 inline vs micro 问题  问题：C99 inline without static or extern  参考  描述  C++ 提出，C99 引入支持，C89 支持内联扩展 inline用于需要某个函数的定义对调用者可见的程序优化  可见性：函数需要有内部链接，或者外部链接且和调用者在同一个编译单元。此时，函数声明或定义中的inline只用于指示对这个函数的调用可被展开优化 当调用者和被调用的函数定义位于不同的编译单元时，inline支持包含调用者的编译单元也包含一个局部(内联)的函数的定义  inline用于声明一个内联函数，可使 GCC 直接更快地调用此函数  GCC 可以将内联函数代码展开插入到调用者代码内部，因此减少了函数调用(寄存器状态的修改保存)的负载 如果实参的值是常量，可在编译时计算简化，因此不是所有内联函数代码都会被包含  可使用-finline-functions选项指定 GCC 将所有“足够简单”的函数展开插入到调用者内部 inline用于多个编译单元调用某个函数，但是只想暴露该函数的定义在一个头文件 在关闭优化时，GCC 不会内联任何函数，必须在某处定义符号，inline声明定义的函数才是可见的  术语和定义 编译单元  What is a “translation unit” in C++ 编译单元(compilation/translation unit): C++ 编译的基础单元。包括一个单独的源文件，以及直接或间接包含的头文件的内容，减去条件预处理忽视的内容 一个编译单元可被编译成一个目标文件、库或可执行程序  单定义规则  What exactly is One Definition Rule in C++ 单定义规则(one-definition rule)：每个程序对于其使用的每个非内联函数或对象应该只包含一个定义。定义可以显式出现在该程序中，可在标准库或用户定义的库中查找，或者隐式定义。内联函数应在每个使用的编译单元中定义 每个编译单元对于所有的变量、函数、类的类型、枚举类型或模板不超过一个定义  内联声明 非成员函数  GCC 实现三种语法来声明内联函数  使用-finline-functions，同时指定参数-std=gnu89/fgnu89-inline，或所有内联函数声明处有gnu-inline属性 指定参数-std=c99/-std=gnu99，或者使用更新的 C 版本 编译 C++ 代码  使用inline关键字\nstatic inline int inc(int *a) { return (*a)++; }  如果在 ISO C90 程序的头文件中声明内联，使用__inline__\n 上述三种类型的内联行为再两种情况下是行为是类似的\n 用于static函数 第一次声明时未使用inline关键字，定义时使用inline关键字  除了速度，上述两种方式和不使用inline关键字行为相同\nextern int inc(int *a); inline int inc(int *a) { return (*a)++; }  当一个函数是static inline时，如果所有调用函数的地方展开插入了此函数的代码，而且函数的地址从未被使用，那么函数自己的汇编代码从未被引用。这种情况下，除非使用-fkeep-inline-functions，GCC 实际上不会为此函数生成汇编代码。如果有一处调用未展开插入代码，那么正常生成汇编代码；如果程序引用了该地址，函数必须正常编译，因为此处不能被内联\n 注意：除非是在一个.cpp文件使用，必须将内联函数定义放在一个头文件，然后从其他.cpp调用，否则会有链接错误unresolved external\n  成员函数  GCC 将定义在类内的成员函数视作内联函数(可没有inline)。可使用-fno-default-inline覆盖\nclass Fred { public: void f(int i, char c) { // ... } };  类似声明非成员函数：声明时不带inline，定义时使用inline，在类外部定义\n 建议使用此方式，以隐藏类的实现\nclass Foo { public: void method(); // Best practice: Don't put the inline keyword here // ... }; inline void Foo::method() // Best practice: Put the inline keyword here { // ... }   注意：必须将内联函数定义放在一个头文件，然后从其他.cpp调用，否则会有链接错误unresolved external\n  不适合内联替换的用法  函数定义包含下面用法的不适合内联替换  可变参数函数 使用alloca函数 使用计算的goto 使用非本地的goto 使用嵌入函数 使用setjmp 使用__builtin_longjmp/__builtin_return/__built_apply_args   C/C++ static/extern + inline C89/90 inline  inline：可能会被内联展开。总会生成非内联版本且对外部可见。只在一个编译单元定义，其他编译单元可见且视为非内联函数\n 每个编译单元只会拥有该函数的拷贝，每个拷贝只对编译单元内部可见，且拷贝之间不会有冲突。缺点包括两部分 大型工程中，可能包含很多相同函数的拷贝，导致目标代码增大 不太可能比较函数指针，因为不确定是哪份拷贝版本 C89 编译器支持内联扩展 MVC++：__forceinline GCC/Clang：在不优化时，除非指定always_inline属性，GCC 不会内联任何函数  __attribute__((always_inline)) __attribute__((__always_inline__))：可避免与用户定义的宏always_inline冲突  编译器在某些情况下不能内联替换，此时会有编译警告 建议使用下面的可移植代码\n#ifdef _MSC_VER #define forceinline __forceinline #elif defined(__GNUC__) #define forceinline inline __attribute__((__always_inline__)) #elif defined(__CLANG__) #if __has_attribute(__always_inline__) #define forceinline inline __attribute__((__always_inline__)) #else #define forceinline inline #endif #else #define forceinline inline #endif   extern inline：不会生成非内联版本对外部可见，但是可以调用(必须在其他编译单元定义，且调用的代码和内联代码相同)，one-definition的原则适用\n 原因：C89 中定义为extern的存储不会被保留，而不带extern的存储一定会保留；C99 的extern inline会生成非内联函数 类似宏。使用方式是将函数定义(同时指定inline和extern关键字)放在一个头文件中，把另一个定义的拷贝(不指定inline和extern关键字)放在一个库文件中。头文件的定义使得大部分函数调用都是内联展开的。如果存在其他编译单元的函数调用，引用这个库文件的唯一拷贝  static inline：不会生成外部可见的非内联版本，但是可能会生成一个局部可见的函数，one-definition的原则不适用\n  C99 inline  inline：类似 C89/90的extern inline，不会生成外部可见代码，但是可以调用(必须在其他编译单元定义，且调用的代码和内联代码相同)\n 在头文件(.h)中使用inline定义，在一个编译单元的源文件(.c)中使用extern和inline\n//.h inline double dabs(double x) {return x \u0026lt; 0.0 ? -x : x;} //.c extern inline double dabs(double x);   extern inline：类似 C89/90的inline，不会生成外部可见代码，至多一个编译单元可以使用此函数\n 定义为inline的函数要求：程序的其他地方有且只有一处需要声明该函数为extern inline或没有修饰符 如果有多处声明，链接器会报重复的符号错误 其他地方没有声明，链接器不会报错 建议：在头文件定义inline函数，为每个函数创建一个.c文件，包含该函数的extern inline声明以及对应的头文件：声明和包含头文件的语句先后无关  static inline：类似 C89/90，二者之间相同\n  C++ inline  inline：一处内联其他所有地方都会内联。编译器/链接器会排序该符号的多个实例  在头文件定义，对整个工程可见；且如果不能展开替换，只会生成一个外部符号 在所有地方有相同的定义，必须有inline关键字 类内定义的函数会自动添加inline修饰符  extern inline：没有此定义，支持的编译器行为类似 C89/90 static inline：没有此定义，支持的编译器行为类似 C89/90  GCC 编译选项  GCC 版本大于等于 4.2：使用 C89 的inline语法，即使显式指定了-std=c99 GCC 版本是 5：GCC 使用 gnu11 的语法，默认使用 C99 的inline语法  显式指定-std=gnu89：使用 C89 语法 指定-fgnu89-inline或在所有inline声明处增加gnu_inline属性：使用 C89 语法，只会影响内联 指定-std=c99或-std=c11或-std=gnu99(不带-fgnu89-inline)：确定使用 C99 语法  使用-winline：当标记为inline的函数不可替换时，编译警告  内联函数对安全性和速度的取舍  C 语言中，可以通过在结构体中放一个void*实现对结构体的封装，即结构体的使用者不知道void*指向的真正的数据，但可以通过调用函数将void*转成合适的隐藏类型。这个做法会破坏类型的安全性，也会包括对结构体其他字段的访问(如果允许直接访问结构体的域，需要知道如何解释void*的使用者就可以直接访问结构体，使得很难修改底层的数据结构) 包含内联函数的目标代码的大小和执行速度的影响是不可预测的  时间性能：以空间换时间 可使程序变快  减少函数调用的代价 可移除函数调用所需的指令：栈和寄存器的使用 不需要寄存器传递参数 在引用调用、地址调用或共享调用时，不需要引用和解引用 支持高级优化和调度  可使程序变慢：内联展开会增加代码大小，在内存页有限的情况下，可能增加内存页的置换和磁盘的读写 目标代码大小 可使程序变大：通常状况下展开代码类似于拷贝代码 可使程序变小：展开函数时，编译器可能会优化代码，移除不必要的代码 内存性能 系统抖动(内存页置换)  调用的内联函数和当前函数可能位于不同的页，内联展开可能使其位于同一个页，可避免系统抖动 可能增大二进制可执行文件大小，导致系统抖动  缓存未命中  内联通常改善了二进制代码内部引用的局部性，可减少使用缓存行来存储内部循环，使得 CPU 受限的应用运行更快 可能导致对多个缓存行的循环处理，导致缓存抖动  可能和运行速度无关：大部分系统不是 CPU 受限的，而是 I/O、数据库或网络受限的，即系统整个性能的瓶颈在于文件系统、数据库或网络。因此，除非 CPU 固定在 100%，内联函数不会使得程序运行更快   inline vs micro  展开时间不同  内联展开发生在编译时，不会修改源码(text) 宏展开发生在编译之前，生成不同的 text 再给编译器处理，会污染命名空间和代码，不利于调试  类型检查：C 语言中宏调用没有类型检查；内联函数会检查参数类型，必须正确执行类型转换 C 语言中，宏不能像函数一样调用return关键字，不能终止调用者 编译错误：宏内的编译错误很难理解，因为指向的是展开的代码，而不是源代码 递归：很多编译器可以内联递归函数，但是递归宏是不允许的  有的编译器可控制递归展开的深度  代码的可维护性：随着函数改进，函数的内联属性可能会变化，一个函数内联与否比宏的修改要简单 宏的其他问题  含if 含多个语句 含令牌黏贴  内联函数避免上述问题：内联函数检查每个参数一次，类似于调用普通函数，但是更快\n// A macro that returns the absolute value of i #define unsafe(i) ( (i) \u0026gt;= 0 ? (i) : -(i) ) // An inline function that returns the absolute value of i inline int safe(int i) { return i \u0026gt;= 0 ? i : -i; } int f(); void userCode(int x) { int ans; ans = unsafe(x++); // Error! x is incremented twice ans = unsafe(f()); // Danger! f() is called twice ans = safe(x++); // Correct! x is incremented once ans = safe(f()); // Correct! f() is called once }   问题  编译器不一定会内联程序员指定的函数  模板方法/函数不是总被内联展开  内联函数的代码暴露给调用者 传统的 C 编译系统会增加内联编译时间，因为会拷贝函数体到调用者 C99 的要求  如果在别处使用某内联函数，只能有一个extern声明。当关掉优化禁止内联时，如果没有会有链接错误 如果增加声明，放到一个库进行链接，使用链接时优化或static inline，可能导致不能到达的代码  C++中，普通函数只需要在一个模块中定义，但是需要在每个模块中定义使用的内联函数，否则不能编译某个单独的模块(依赖其他模块)。视编译器而定，可能会导致不能内联替换的模块的对象文件包含函数的拷贝 在嵌入式软件中，可能通过类似pragma编译指令将一些函数放到代码段。如果一个内存段的代码调用另一个内存段的代码，如果被调用函数内部有内联，那么可能会停到一个不应该的段。比如高性能的内存段代码空间有限，如果内部函数调用另一个高性能内存之外的函数，且被调用函数较大，内部有内联的话，可能会超出高性能内存的空间 C++ 编译时链接，因此如果修改了内联函数，必须重新编译使用此函数的所有代码  问题：C99 inline without static or extern  C, inline function and GCC [duplicate] Is “inline” without “static” or “extern” ever useful in C99 C99 inline function in .c file\n// main.cpp inline int foo() {return 10 + 3;} int main() {foo(); return 0;} // g++ -std=c99 -x c main.cpp // gcc -std=c99 -o a main.cpp  GCC 链接错误undefined reference to foo\n 问题：inline只是声明内联函数，不会生成实际的代码，但是extern和static用于告诉编译器将函数放在哪个对象文件，用于编译生成对应的代码(可能是拷贝)\n 解决方案：\n 增加extern inline int foo(); 增加static修饰符，告诉编译器有且只在这里，以便生成对应代码 或使用-O优化代码，编译器将标记为inline的代码内联展开，在这里会忽略这部分代码   参考  Inline function An Inline Function is As Fast As a Macro inline functions Myth and reality about inline in C99  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"346f102f8aea619cc99302db0867ca34","permalink":"https://xueqing.github.io/blog/cplusplus/inline/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/inline/","section":"blog","summary":"描述 术语和定义 编译单元 单定义规则 内联声明 非成员函数 成员函数 不适合内联替换的用法 C/C++ static/extern + inline C89/90 inline C99 inline C++ inline GCC 编译选项 内联函数对安全性和速度的取舍 inline vs","tags":["c++"],"title":"内联","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  Bittorrent协议 中心化原理 去中心化原理  DHT/kademlia NAT IPFS/libp2p  去中心化流媒体应用livepeer  Bittorrent协议 比特流（BitTorrent）是一种内容分发协议，由布拉姆·科恩自主开发。它采用高效的软件分发系统和点对点技术共享大体积文件（如一部电影或电视节目），并使每个用户像网络重新分配结点那样提供上传服务。一般的下载服务器为每一个发出下载请求的用户提供下载服务，而BitTorrent的工作方式与之不同。分配器或文件的持有者将文件发送给其中一名用户，再由这名用户转发给其它用户，用户之间相互转发自己所拥有的文件部分，直到每个用户的下载都全部完成。这种方法可以使下载服务器同时处理多个大体积文件的下载请求，而无须占用大量带宽。\nBittorrent 中文协议1,2,3,4是有中心化的 Bittorrent协议中文版一 Bittorrent协议中文版二 Bittorrent协议中文版三 Bittorrent协议中文版四 BitTorrent DHT 协议是扩充协议没有中心化的 Bittorrent DHT 去中心化协议 关键名词\n  peers: 在本文档中，一个 peer 可以是任何参与下载的 BitTorrent 客户端 tracker 是一个响应HTTP GET请求的HTTP/HTTPS服务 node 是一个dht节点   中心化原理 参考 Bittorrent协议中文1,2,3,4原理tracker Bittorrent协议中文版三\n去中心化原理 去中心化，即，不存在数据中心，每个节点的信息存储能力都是对等的，存储的内容都是一致的，账目是公开的（这个公开我也不是很理解，我认为应该是有一定的加密机制）。进行支付时，用户只需要向任意一个节点发送支付信息，网络中的各节点是对等的，它们最终会对如何记录这笔支付达成共识，将这笔支付记入一个公开账本。从这个角度说，去中心化可以提升安全性、提升效率、提升资源利用率，降低系统运行成本\nDHT/kademlia P2P中DHT网络介绍\nNAT NAT 的四种类型\n  Full Cone NAT Restricted Cone NAT Port Restricted Cone NAT\n Symmetric NAT   IPFS/libp2p IPFS/libp2p结构文档\n去中心化流媒体应用livepeer livepeer源码\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3a8502a1f543769b31410ed09955efca","permalink":"https://xueqing.github.io/blog/p2p/dht/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/p2p/dht/","section":"blog","summary":"Bittorrent协议 中心化原理 去中心化原理 DHT/kademlia NAT IPFS/libp2p 去中心化流媒体应用livepeer Bittorrent协议 比特流（BitTorrent）","tags":["p2p"],"title":"分布式原理","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":" 原文\n概述 master playlist 描述了对于你的内容所有可访问的 variant(变体)。每个 variant 是一个特定比特率的流版本且被包含在一个单独的 playlist。客户端基于测量的网络比特率切换到最合适的 variant。调节客户端的播放器最小化回放的停顿，以便给用户进坑好的流体验。\nmaster playlist 不能重复读。一旦客户端读到 master playlist，它假定 variant 集合不会改变。当客户端在其中一个单一的 variant playlist 中看到 EXT-X-ENDLIST 标记时流结束。\n示例 下面的示例展示了定义不同 variant 的一个 master playlist：\n#EXTM3U #EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=\u0026quot;avc1.42e00a,mp4a.40.2\u0026quot; http://example.com/low/index.m3u8 #EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=\u0026quot;avc1.42e00a,mp4a.40.2\u0026quot; http://example.com/lo_mid/index.m3u8 #EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=\u0026quot;avc1.42e00a,mp4a.40.2\u0026quot; http://example.com/hi_mid/index.m3u8 #EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=\u0026quot;avc1.42e00a,mp4a.40.2\u0026quot; http://example.com/high/index.m3u8 #EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=\u0026quot;mp4a.40.5\u0026quot; http://example.com/audio/index.m3u8  master playlist 示例中使用的标记有：\nEXTM3U 表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。\nEXT-X-STREAM-INF 表示 playlist 文件的下一个 URL 标识了另一个 playlist 文件。EXT-X-STREAM-INF 标记包含下面的参数：\nAVERAGE-BANDWIDTH (可选，但是建议使用)一个整数，表示这个 variant 流的平均比特率。\nBANDWIDTH (必选)一个证书，表示对于每个媒体文件所有比特率的上限，单位是 比特/秒。上限值的计算包含了所有出现或将会出现在 playlist 中的容器负载。\nFRAME-RATE (可选，但是建议使用)一个浮点值，描述了一个 variant 流的最大帧率。\nHDCP-LEVEL (可选)表明使用的加密类型。有效值是 TYPE-0 和 NONE。如果只有使用 HDCP 保护输出才能播放这个流，使用 TYPE-0。\nRESOLUTION (可选，但是建议使用)这个选项展示了播放 playlist 所有视频的大小，单位是像素。所有包含视频的流都应该包含这个参数。\nVIDEO-RANGE (视编码而定)一个字符串，有效值是 SDR 或 PQ。如果没有指定传输特征编码 1, 16 或 18，那么必须忽视这个参数。\nCODECS (可选，但是建议使用)一个引用字符串，包含了一个逗号分隔的格式列表，其中每个格式指定了出现在 playlist 中的一个媒体片段的媒体采样类型。有效的格式标识是根据 RFC 6381 定义的 ISO 文件格式命名空间。\n注意：虽然 CODECS 参数可选，每个 EXT-X-STREAM-INF 标记应该包含这个属性。这个属性提供了解码一个特定流所需的完整编码。它支持客户端区分只包含音频的 variant 和包含音频及视频的 variant。然后，客户端可以利用这个信息在切换流的时候提供更好的用户体验。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5b05f73fa8e04a182cfb94ad35137ebb","permalink":"https://xueqing.github.io/translation/hls/creating_a_master_playlist/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/hls/creating_a_master_playlist/","section":"translation","summary":"原文 概述 master playlist 描述了对于你的内容所有可访问的 variant(变体)。每个 variant 是一个特定比特率的流版本且被包含在一个单独的 playlist。客户端","tags":["hls"],"title":"创建一个 master playlist","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"Is it safe to delete a void pointer?\n 代码如下：\nvoid* my_alloc (size_t size) { return new char [size]; } void my_free (void* ptr) { delete [] ptr; }  对于内建类型，delete void*不会造成内存泄漏，系统在分配内存的时候记录了分配内存的大小，指针的分配信息和指针放在一起，释放的时候会返回到对应的位置。\n 分配对象的时候，除了分配所需内存大小存放对象信息，会先分配一个内存控制块，标记该内存块的大小及是否可用。调用delete的时候会将该内存块标记为空闲，释放内存 内存控制块结构如下：\nstruct mem_control_block { int is_available; int size; };  对于类，析构的时候会调用析构函数（在其中释放指针变量申请的内存）。但是调用void*丢失了指针的类型，将不会调用类的析构函数，当类中存在指针类型时，该指针类型指向的内存将无法释放。\n  对于自定义类型的分配和释放，delete void*可能会造成内存泄漏，这是未定义的行为（undefined behavior），建议用模板实现。或者生成分配池，对于特定的类型会更有效。\n  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4cc68c3fc24669085ccf4397b0bbe944","permalink":"https://xueqing.github.io/blog/stackoverflow/delete_void_pointer/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/stackoverflow/delete_void_pointer/","section":"blog","summary":"Is it safe to delete a void pointer? 代码如下： void* my_alloc (size_t size) { return new char [size]; } void my_free (void* ptr) { delete [] ptr; } 对于内建类型，delete void*不会造成内存泄漏，系统在分配内存的时候记","tags":["stackoverflow"],"title":"删除 void 指针","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  拉取基础镜像 编写 Dockerfile 制作镜像 更新镜像  安装 Sphinx + ReadTheDocs 支持 方法 1：进入镜像内部更新镜像 方法 2：编写新的 Dockerfile  推送镜像  推送到官方仓库 Docker Hub 推送到私有仓库 xxx   拉取基础镜像 docker pull ubuntu:16.04  编写 Dockerfile # 创建目录 mkdir docker-image/python \u0026amp;\u0026amp; cd docker-image/python # 编写 Dockerfile  FROM ubuntu:16.04 MAINTAINER kiki # 更新 apt RUN apt-get update \u0026amp;\u0026amp; apt-get install -y # 安装依赖 RUN apt-get install gcc -y \\ \u0026amp;\u0026amp; apt-get install make -y \\ \u0026amp;\u0026amp; apt-get install vim -y \\ \u0026amp;\u0026amp; apt-get install openssl -y \\ \u0026amp;\u0026amp; apt-get install libssl-dev -y \\ \u0026amp;\u0026amp; apt-get install python3.5 -y \\ \u0026amp;\u0026amp; apt-get install python3-pip -y CMD [\u0026quot;pip3\u0026quot;] CMD [\u0026quot;python3\u0026quot;]  安装出现警告信息 debconf: delaying package configuration, since apt-utils is not installed。解决方法：\nRUN apt-get update \u0026amp;\u0026amp; apt-get install -y --no-install-recommends apt-utils  制作镜像 docker build -t python3 . # 查看镜像 docker images # 运行容器 docker run -i -t python3 /bin/bash # 进入 docker 之后，运行 python3 和 pip3 python3 pip3  更新镜像 安装 Sphinx + ReadTheDocs 支持 方法 1：进入镜像内部更新镜像 # 在 docker 内部安装相关依赖 pip3 install sphinx sphinx-autobuild sphinx_rtd_theme recommonmark pypandoc # 提交更新 docker commit -m=\u0026quot;add Sphinx + ReadTheDocs support\u0026quot; -a=\u0026quot;kiki\u0026quot; CONTAINER-ID sphinx-rtd # 查看新镜像 docker images # 启动新镜像 docker run -i -t -v sphinx-rtd /bin/bash # 给镜像设置标签 docker tag CONTAINER-ID compile-blog  安装 Python 包遇到错误：requests.packages.urllib3.exceptions.ReadTimeoutError: HTTPSConnectionPool(host='files.pythonhosted.org', port=443): Read timed out。解决方法：\n# 在 Dockerfile 中增加下面的参数 pip3 --default-timeout=1000 install sphinx sphinx-autobuild sphinx_rtd_theme recommonmark pypandoc  方法 2：编写新的 Dockerfile FROM python3 MAINTAINER kiki # 安装依赖 RUN pip3 --default-timeout=1000 install sphinx sphinx-autobuild sphinx_rtd_theme recommonmark pypandoc CMD [\u0026quot;pip3\u0026quot;] CMD [\u0026quot;python3\u0026quot;]  docker build -t sphinx-rtd . # 查看镜像 docker images # 运行容器 docker run -i -t sphinx-rtd /bin/bash # 进入 docker 之后，运行 python3 和 pip3 python3 pip3  推送镜像 推送到官方仓库 Docker Hub docker login -u username -p password docker push sphinx-rtd docker logout  推送到私有仓库 xxx # 参考 https://github.com/docker/docker.github.io/blob/master/registry/insecure.md 设置 http 连接 # 给镜像添加标签 docker tag sphinx-rtd xxx:sphinx-rtd # 推送镜像 docker push xxx:sphinx-rtd  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"9774ebddbe8608689ccd0508945f545a","permalink":"https://xueqing.github.io/blog/docker/python_img/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/docker/python_img/","section":"blog","summary":"拉取基础镜像 编写 Dockerfile 制作镜像 更新镜像 安装 Sphinx + ReadTheDocs 支持 方法 1：进入镜像内部更新镜像 方法 2：编写新的 Dockerfile 推送镜像 推送到官方仓库 Docker Hub 推送到私有仓库 xxx 拉取","tags":["docker"],"title":"制作 Python 运行环境镜像","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  git fast-import git fast-export  git fast-import  git fast-import支持从一个特定格式的文本读入，从头创建 git 历史记录 可用这个命令很快写一个脚本运行一次，一次迁移整个项目 写一个临时文件置于/tmp/history，文本内容如下\ncommit refs/heads/master committer Alice \u0026lt;alice@example.com\u0026gt; Thu, 01 Jan 1970 00:00:00 +0000 data \u0026lt;\u0026lt;EOT Initial commit. EOT M 100644 inline hello.c data \u0026lt;\u0026lt;EOT #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;Hello, world!\\n\u0026quot;); return 0; } EOT commit refs/heads/master committer Bob \u0026lt;bob@example.com\u0026gt; Tue, 14 Mar 2000 01:59:26 -0800 data \u0026lt;\u0026lt;EOT Replace printf() with write(). EOT M 100644 inline hello.c data \u0026lt;\u0026lt;EOT #include \u0026lt;unistd.h\u0026gt; int main() { write(1, \u0026quot;Hello, world!\\n\u0026quot;, 14); return 0; } EOT  # 使用上述临时文件创建一个 git 仓库 mkdir project; cd project; git init git fast-import --date-format=rfc2822 \u0026lt; /tmp/history # 检出最新版本 git checkout master   git fast-export  git fast-export可将任意仓库转成git fast-import格式  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"356f746e223d4dd96c9f3cade036d488","permalink":"https://xueqing.github.io/blog/git/git_fast_import/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_fast_import/","section":"blog","summary":"git fast-import git fast-export git fast-import git fast-import支持从一个特定格式的文本读入，从头创建 git 历史记录 可用这个命令很快写一个脚本运行一次，一次迁移整个项目 写一","tags":["git"],"title":"制造历史","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"常见的线程不安全函数和对应的 unix 下的线程安全函数\n 保持跨越多个调用状态的函数  rand，对应 rand_r strtok，对应 strtok_r  返回指向静态变量的指针的函数  asctime，对应 asctime_r ctime，对应 ctime_r gethostbyaddr，对应 gethostbyaddr_r gethostbyname，对应 gethostbyname_r inet_ntoa， localtime，对应 localtime_r gmtime，对应 gmtime_r  可重入性  可重入函数（reentrant function）：当被多个线程调用时，不会引入任何共享数据 可重入函数是线程安全函数的一个真子集 显式可重入（explicitly reentrant）：函数都是传值传递的（即没有指针），并且所有的数据引用都是本地的自动栈变量（即没有引用静态或全局变量） 隐式可重入（implicitly reentrant）：函数的一些参数是引用传递的（允许传递指针），传递的是非共享数据的指针   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"39bf5cb849b6fca7144989a4e16ce52b","permalink":"https://xueqing.github.io/blog/cplusplus/reentrant/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/reentrant/","section":"blog","summary":"常见的线程不安全函数和对应的 unix 下的线程安全函数 保持跨越多个调用状态的函数 rand，对应 rand_r strtok，对应 strtok_r 返回指向静态变量的指针的函数 as","tags":["c++"],"title":"可重入性","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 同一个包 pkgname 有多个源文件，比如 A.go、B.go。A.go 中声明了变量 var1，B.go 使用此变量直接写 var1，如果使用 pkgname.var1 会报错，找不到定义  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b1b65740df2b5a30af2b7d5d9b2e11b9","permalink":"https://xueqing.github.io/blog/go/traps/package_var/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/traps/package_var/","section":"blog","summary":"同一个包 pkgname 有多个源文件，比如 A.go、B.go。A.go 中声明了变量 var1，B.go 使用此变量直接写 var1，如果使用 pkgname.var1 会报错，找不到定义","tags":["go"],"title":"同一包不同源文件变量声明时不要带包名","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  cat touch 标准重定向符号 \u0026gt; echo/printf nano vi/vim  cat cat 可用于创建文件。输入回车后，光标移到到下一行，可以开始输入文本。完成之后使用 Ctrl+D 退出，并返回到提示符\ncat \u0026gt; file_name  cat 也可以查看文件内容。\ncat file_name  touch touch 支持一条命令创建多个文件，且不支持立刻输入文本。\ntouch file1 file2  标准重定向符号 \u0026gt; 标准重定向符号通常用于重定向一个命令的输出到一个新文件。如果没有前置的命令，命令只创建一个新文件。类似于 touch。\n与 touch 不同，\u0026gt; 只能一次创建一个文件。\n\u0026gt; file_name  echo/printf 使用 echo/printf 命令输入文本到指定文件，文件不存在则会被创建。\necho 'hello' \u0026gt; file1 printf \u0026quot;world\\nI'm kiki\u0026quot; \u0026gt; file2  nano nano 是 GNU 项目的文本编辑器。输入回车之后可以开始输入文本。按照命令提示退出编辑界面。\nnano file_name  vi/vim 使用 vi/vim 文本编辑器。\nvi file_name  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"8a7d8bbb1e4133bc0e5e8fd54e540afb","permalink":"https://xueqing.github.io/blog/ubuntu/shell_new_file/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/shell_new_file/","section":"blog","summary":"cat touch 标准重定向符号 \u0026gt; echo/printf nano vi/vim cat cat 可用于创建文件。输入回车后，光标移到到下一行，可以开始输入文本。完成之后使用 Ctrl+D 退出，并返回到提示符 cat \u0026gt; file_name cat 也可","tags":["ubuntu","linux","shell"],"title":"命令行创建文件","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"原文\n 软件的精髓在于设计  时间和空间的取舍、TCP/UDP 通信、同步异步、数据冗余 重要 多和客户讨论需求和未来可能的变化：避免边开发边加需求 调查实现的技术难点和细节 和其他人讨论并推敲架构和设计：选择成熟的框架？  TDD、快速原型和迭代可能会对软件和团队产生负面影响  TDD、快速原型和迭代更关注功能性需求 需要考虑性能问题、高可用性问题、系统维护性问题  重构是噩梦，应该越少越好 避免过度设计和纸上谈兵，设计不仅仅是太累和思考，还需要尝试  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"190b53229f7529b8d674b19a8ba5c8cf","permalink":"https://xueqing.github.io/blog/coolshell/%E5%A4%9A%E4%BA%9B%E6%97%B6%E9%97%B4%E8%83%BD%E5%B0%91%E5%86%99%E4%BA%9B%E4%BB%A3%E7%A0%81/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/coolshell/%E5%A4%9A%E4%BA%9B%E6%97%B6%E9%97%B4%E8%83%BD%E5%B0%91%E5%86%99%E4%BA%9B%E4%BB%A3%E7%A0%81/","section":"blog","summary":"原文 软件的精髓在于设计 时间和空间的取舍、TCP/UDP 通信、同步异步、数据冗余 重要 多和客户讨论需求和未来可能的变化：避免边开发边加需求 调查实","tags":["coolshell"],"title":"多些时间能少写些代码","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  介绍 代码组织  概览 工作区 GOPATH 环境变量 导入路径 第一个程序 第一个库 包名  测试 远程包 下一步 获取帮助  参考 Golang 官网文档 学习。\n介绍 此文档演示一个简单的 Go 包的发展，并介绍 go 工具。go 工具是拉取、编译和安装 Go 包和目录的标准方式。\ngo 工具要求你按照指定方式组织你的代码。请仔细阅读此文档。它解释了使用 Go 安装组织和运行的最简单的方式。\n一个类似的解释可参考编写、编译、安装和测试 Go 代码。\n代码组织 概览  Go 开发人员通常保存他们所有的 Go 代码在一个单一的工作区。 一个工作区包含很多版本控制仓库(比如使用 Git 管理)。 每个仓库包含一个或多个包。 每个包由同一目录的一个或多个 Go 源文件组成。 包目录的路径确定了导入路径。  注意这个其他编程环境不同。其他编程环境的每个工程有一个单独的工作区，且工作区和版本控制仓库紧密相关。\n工作区 一个工作区是一个目录层次架构，在其根有两个目录：\n src 包含 Go 源文件，且 bin 包含可执行命令。  go 工具编译和安装二进制到 bin 目录。\nsrc 子目录通常包含多个版本控制仓库(比如 Git 或 Mercurial)，跟踪了一个或多个源包的发展。\n为了让你理解一个工作区实际上的组织，这里有一个例子：\nbin/ hello # command executable outyet # command executable src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source outyet/ main.go # command source main_test.go # test source stringutil/ reverse.go # package source reverse_test.go # test source golang.org/x/image/ .git/ # Git repository metadata bmp/ reader.go # package source writer.go # package source ... (many more repositories and packages omitted) ...  上述树显示一个工作区有两个仓库(example 和 image)。example 仓库包含两个命令(hello 和 outyet)和一个库(stringutil)。image 仓库包含 bmp 包和其他的包。\n一个普通的工作区包含许多源仓库，这些仓库包含一些包和命令。大多数 Go 开发人员保存他们所有的 Go 源代码和依赖在一个单一的工作区。\n注意不应使用符号链接链接文件或目录到你的工作区。\n命令和库由不同的源包编译。我们之后会讨论区别。\nGOPATH 环境变量 GOPATH 环境变量指定你的工作区位置。默认是你的主目录下名字为 go 的目录，因此在 Unix 上是 $HOME/go，Plan9 上是 $home/go，Windows 上是 %USERPROFILE%\\go (通常是 C:\\Users\\YourName\\go)。\n如果你想要在不同的位置工作，你需要设置 GOPATH 到那个目录。(另外一个常用的设置是设置 GOPATH=$HOME)。注意 GOPATH 一定不能和你的 Go 安装路径相同。\n命令 go env GOPATH 打印当前实际的 GOPATH；如果该环境变量没有设置，它会打印默认的位置。\n方便起见，增加工作区的 bin 子目录到你的 PATH：\nexport PATH=$PATH:$(go env GOPATH)/bin  简洁起见，这个脚本在文档的其他部分使用 $GOPATH 而不是 $(go env GOPATH)。如果你还未设置 GOPATH，为了使得所写的脚本可运行，可以使用 $HOME/go 替换这些命令或者运行\nexport GOPATH=$(go env GOPATH)  要了解更多关于 GOPATH 环境变量，参考 go help gopath。\n要使用自定义的工作区位置，设置 GOPATH 环境变量。\n导入路径 导入路径是一个唯一的标识一个包的字符串。一个包的导入路径对应它在工作区或远程仓库内的位置(下面会解释)。\n标准库的包使用短的导入路径类似 “fmt” 和 “net/http”。对于你自己的包，你必须选择一个基础路径，该路径不太可能与将来增加的标准库或其他外部库冲突。\n如果你将代码保存在其他地方的源仓库，那么你应该使用该源码库的根作为你的基础路径。比如，如果你有一个 Github 账户位于 github.com/user，那么 github.com/user 应该是你的基础路径。\n注意在你可以编译代码之前，你不需要发布你的代码到一个远程仓库。这只是一个组织代码的好习惯以便某天你会发布它。实际上你可以选择任意的路径名字，只要它对于标准库和更大的 Go 生态系统是唯一的。\n我们将会使用 github.com/user 作为我们的基础路径。在你的工作区内新建一个目录来保存源码：\nmkdir -p $GOPATH/src/github.com/user  第一个程序 为了编译和运行一个简单的程序，首先选择一个包路径(我们将会使用 github.com/user/hello)，并且在你的工作区内创建一个对应的包目录：\nmkdir $GOPATH/src/github.com/user/hello  接下来，在目录内部创建一个名为 hello.go 的文件，包含下面的 Go 代码。\npackage main import \u0026quot;fmt\u0026quot; func main() { fmt.Println(\u0026quot;Hello, world.\u0026quot;) }  现在你可以使用 go 工具编译和安装这个程序：\ngo install github.com/user/hello  注意你可以在你的系统任何地方运行这个命令。go 工具通过在 GOPATH 指定的工作区内查找 github.com/user/hello 包找到源码。\n如果你从包目录运行 go install，你也可以忽视包路径：\ncd $GOPATH/src/github.com/user/hello go install  这个命令编译 hello 命令，生成可执行的二进制文件。它接着安装该二进制文件到工作区的 bin 目录，安装的文件名字是 hello(或者在 Windows 上是 hello.exe)。在我们的例子中，该文件将会是 $GOPATH/bin/hello，也就是 $HOME/go/bin/hello。\n发生错误时，go 工具只会打印输出。因此如果这些命令没有生成输出，那么这些命令已经被正确执行。\n你现在可以通过在命令行输入程序的完整路径来运行它：\n$ $GOPATH/bin/hello Hello, world.  或者，因为你已经添加 $GOPATH/bin 到你的 PATH，只需要输入二进制文件的名字：\n$ hello Hello, world.  如果你在使用一个源码控制系统，现在将是一个好的时机来初始化一个仓库，增加这些文件，并提交你的第一次修改。重申一次，这一步是可选的：你不必使用源码控制来写 Go 代码。\ncd $GOPATH/src/github.com/user/hello git init git add hello.go git commit -m \u0026quot;initial commit\u0026quot;  推送代码到远程仓库留作读者的一个练习。\n第一个库 让我们编写一个库，并在 hello 程序使用它。\n重申一次，第一步是选择一个包路径(我们将会使用 github.com/user/stringutil)并创建一个包目录：\nmkdir $GOPATH/src/github.com/user/stringutil  接下来，在该目录创建一个名为 reverse.go 的文件，包含下面的内容。\n// Package stringutil contains utility functions for working with strings. package stringutil // Reverse returns its argument string reversed rune-wise left to right. func Reverse(s string) string { r := []rune(s) for i, j := 0, len(r)-1; i \u0026lt; len(r)/2; i, j = i+1, j-1 { r[i], r[j] = r[j], r[i] } return string(r) }  现在，使用 go build 编译测试这个包：\ngo build github.com/user/stringutil  或者，如果你正在包的源目录，只需要：\ngo build  这不会生成一个输出文件。反之，它将编译的包保存在本地的编译缓存。\n在确认编译 stringutil 包之后，修改你原始的 hello.go(在 $GOPATH/src/github.com/user/hello)，使用下面的内容：\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;github.com/user/stringutil\u0026quot; ) func main() { fmt.Println(stringutil.Reverse(\u0026quot;!oG ,olleH\u0026quot;)) }  安装 hello 程序：\ngo install github.com/user/hello  运行这个程序的新版本，你应该看到一个新的、翻转的消息：\n$ hello Hello, Go!  上述步骤之后，你的工作区应该看起来是下面的结构：\nbin/ hello # command executable src/ github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source  包名 Go 源文件的第一个语句必须是\npackage name  其中，name 是用于导入包的默认名字。(包内的所有文件必须使用这个名字。)\nGo 的管理是包名是导入路径的最后一个元素：按照 “crypto/rot13” 导入的包名应该命名为 rot13。\n可执行的命令必须总使用 package main。\n不需要包名在链接所有包成一个单一的二进制文件时是唯一的，只要它的导入路径(完整的文件名)是唯一的。\n查看实效 Go 编程了解更多关于 Go 的命名惯例。\n测试 Go 有一个轻量级的测试框架，由 go test 命令和 testing 包组成。\n你可以通过新建一个以 _test.go 结尾的文件编写测试，文件包含名字为 TestXXX，签名为 func (t *testing.T) 的函数。测试框架运行每个像这样的函数；如果函数调用一个失败函数，如 t.Error 或 t.Fail，认为该测试失败。\n向 stringutil 包增加一个测试，新建文件 $GOPATH/src/github.com/user/stringutil/reverse_test.go，包含下面的代码\npackage stringutil import \u0026quot;testing\u0026quot; func TestReverse(t *testing.T) { cases := []struct { in, want string }{ {\u0026quot;Hello, world\u0026quot;, \u0026quot;dlrow ,olleH\u0026quot;}, {\u0026quot;Hello, 世界\u0026quot;, \u0026quot;界世 ,olleH\u0026quot;}, {\u0026quot;\u0026quot;, \u0026quot;\u0026quot;}, } for _, c := range cases { got := Reverse(c.in) if got != c.want { t.Errorf(\u0026quot;Reverse(%q) == %q, want %q\u0026quot;, c.in, got, c.want) } } }  然后使用 go test 运行测试：\n$ go test github.com/user/stringutil ok github.com/user/stringutil 0.165s  和平时一样，如果你在包目录运行 go 工具，可以忽视包路径\n$ go test ok github.com/user/stringutil 0.165s  运行 go help test 并查看 testing 包文档 获取更多信息。\n远程包 导入路径可以描述如何使用版本控制系统(如 Git 或 Mercurial)获取包源码。go 工具使用这个属性从远程仓库自动拉取代码。比如，文档中描述的例子也保存在 Github 托管的 Git 仓库。如果你在包的导入路径包含这个仓库的 URL，go get 会自动拉取、编译和运行它：\ngo get github.com/golang/example/hello $GOPATH/bin/hello # 输出 Hello, Go examples!  如果指定的包没有出现在工作区，go get 会放置在 GOPATH 指定的第一个工作区。(如果包以及存在，go get 会跳过远程拉取，行为类似于 go install。)\n在执行上述 go get 命令只会，工作区目录树应该看起来是下面的结构：\nbin/ hello # command executable src/ github.com/golang/example/ .git/ # Git repository metadata hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source github.com/user/ hello/ hello.go # command source stringutil/ reverse.go # package source reverse_test.go # test source  Github 托管的 hello 命令依赖相同仓库的 stringutil 包。hello.go 文件中的导入使用相同的导入路径惯例，因此 go get 命令也可以定位和安装依赖依赖包。\nimport \u0026quot;github.com/golang/example/stringutil\u0026quot;  此惯例是使得你的 Go 包被其他人可用的最简单的方式。Go 维基 和 go 官方文档 提供了外部 Go 过程的列表。\n要获取更多关于借助 go 工具使用远程仓库的信息，查看远程导入路径。\n下一步 订阅 golang 宣传 邮件列表，接受发行新的稳定版本 Go 的通知。\n查看实效 Go 编程了解更多关于编写清楚、惯用的 Go 代码的建议。\n访问 Go 语言之旅 学习语言规则。\n访问官方文档查看关于 Go 语言及其库和工具的全面深入的文章。\n获取帮助 需要实时帮助，询问有帮助的 gopher ，它位于 FreeNode IRC 服务的 #go-nuts。\n关于 Go 语言讨论的官方邮件列表在 Go Nuts 群组。\n使用 Go issue 跟踪报告错误。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"4a6169ea0d0c803071b8305d8d7d4164","permalink":"https://xueqing.github.io/translation/go-doc/golangdoc/code/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangdoc/code/","section":"translation","summary":"介绍 代码组织 概览 工作区 GOPATH 环境变量 导入路径 第一个程序 第一个库 包名 测试 远程包 下一步 获取帮助 参考 Golang 官网文档 学习。 介绍 此文档演示一个简单的 Go 包的发展","tags":["golang-doc"],"title":"如何编写 Go 代码","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  介绍  愿景 目标  网络堆栈技术现状分析  客户端-服务端（C/S）模型 按解决方案对网络分类 目前的缺点  要求  匿名传输 多种多路复用（multi-multiplexing） 加密 NAT 遍历（traversal） 中继（relay） 启用多个网络拓扑 资源发现 消息 命名  架构  节点路由 集群 分布式记录存储 发现 mDNS-discovery random-walk bootstrap-list 消息-架构 发布订阅 命名-架构 IPRS IPNS  数据结构 接口 特性  通信模型-流 端口-受限入口 传输协议 非 IP 网络 网线  实现 参考  介绍 解决兼容性问题：分布式文件系统运行的网络配置、网络性能、设备不同\n愿景 建立分布式系统，由开发者决定在网络中的交互，以及支持的配置和扩展性\n目标  支持多种协议：  传输：TCP，UDP，STCP，UDT，uTP，QUIC，SSH 等 认证的传输：TLS，DTLS，CurveCPU，SSH  有效使用套接字（连接复用 connection reuse） 支持 peer 之间的通讯可以通过一个套接字复用（multiplex）（避免握手的负载） 支持 peer 之间通过协商过程，使用不同的协议或者不同的版本 向后兼容 在现有系统上运行 使用现有网络技术的所有能力 有 NAT 穿墙（raversal） 支持连接中继（relay） 支持加密的通道（channel） 有效使用底层传输（如 native stream muxing，native auth）  网络堆栈技术现状分析 分析网络栈可用的协议和架构\n客户端-服务端（C/S）模型  C/S 模型表明通道两端承担不同的角色，支持不同的服务，或者具有不同的能力 C/S 应用成为趋势的原因  数据中心的带宽比相互连接的客户端之间的带宽高很多 数据中心的资源更便宜，因为利用充分以及存储量大（bulk stocking） 开发者和系统管理更容易拥有对应用的较好的细粒度控制 减少了要处理的异构系统的数目（数字仍然很大） 像 NAT 的系统使得客户端机器很难找到彼此并且互相通信，迫使开发者解决这些问题 协议开始设计的前提是开发者会开发一个C/S应用  libp2p 在拨号者-监听者（dialer-listener）交互上前进了一步  不明确 dialer 和 listener 各自的功能以及可以执行的操作 dialer 和 listener 可以独立地执行请求   按解决方案对网络分类  传统的 7 层 OSI 模型不适用于 libp2p，OSI 模型按照通讯功能划分  物理层 Physical Layer：通过物理介质传输比特流 数据链路层 Data Link Layer：将比特组合成字节，再将字节组合成帧，使用链路层地址访问介质，并进行差错检测 逻辑链路控制子层 LLC：定义一些字段使上层协议可以共享数据链路层，不是必须的 媒体访问控制子层 MAC：处理 CSMA/CD 算法、数据出错校验、成帧等 网络层 Network Layer：通过 IP 寻址建立两个节点之间的连接 传输层 Transport Layer：建立主机端到端的链接，为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等 会话层 Session Layer：负责建立、管理和终止表示层实体之间的通话会。由不同设备中的应用程序之间的服务请求和响应组成 表示层 Presentation Layer：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别 应用层 Application Layer：为计算机用户提供应用接口，也为用户直接提供各种网络服务  libp2p 根据角色将协议分类  建立物理链路：Ethernet，Wi-Fi，Bluetooth，USB 寻址一个机器或程序：IPv4，IPv6，隐藏的寻址（无 SDP） 发现其他 peer 或服务：ARP，DHCP，DNS，Onion 通过网络路由消息：RIP(1,2)，OSPF，BGP，PPP，Tor，I2P，cjdns 传输：TCP，UDP，UDT，QUIC，WebRTC 数据通道 商定应用通讯的语义：RMI，Remoting，RPC，HTTP   目前的缺点  大量的协议和解决方案使得让一个应用支持多种传输或通过多种传输并可用比较困难  如浏览器应用缺少 TCP/UDP 栈  一个 peer 不能在不同传输 announce 自己，使得其他的 peer 确信是同一个 peer  要求 匿名传输  为了推理可能的传输，libp2p 使用多地址（multiaddr），一种自描述的地址格式  libp2p 可以在系统的任何地方将地址视为不透明的，支持网络层的不同传输协议 libp2p 的地址格式是 ipfs-addr，以 IPFS 的节点 ID 结尾的多地址  目前，没有不可靠的实现存在。即定义和使用不可靠的传输协议接口未被定义  多种多路复用（multi-multiplexing）  libp2p 收集了多种协议，为了保留资源，是的建立连接更容易，libp2p 可以在一个端口（TCP 或 UDP，取决于使用的传输）上执行所有的操作 libp2p 可以通过一个端到端的连接复用多种协议。这个复用包括可靠的流和不可靠的数据包 libp2p 网络层提供的多路复用包括  可以复用多个监听网络接口 可以复用多个传输协议 每个 peer 可以复用多个连接 可以复用多个客户端协议 每个协议，每个连接可以复用多个流 具有流控制（backpressure，fairness） 用不同的短暂的 key 为每个连接加密   加密  libp2p 中的通讯是三种状态  加密的 签名的（未加密） 清楚的（未加密，未签名）  对于一些性能要求高的数据中心，加密是不可行的。建议  实现默认为所有的通讯加密 实现是审核的（audited） 除非绝对必须，用户通常只操作加密的通讯   NAT 遍历（traversal）  NAT（Network Address Translation，网络地址转换）在互联网普遍存在  大部分消费者设备在很多层的 NAT 后面 大多数数据中心节点尝尝处于安全或虚拟化原因也在 NAT 后面 在基于容器的部署阶段，这个现象更加普遍  IPFS 的实现应该提高一种方式来遍历 NAT，否则操作会受影响，即使是在真实 IP 地址运行的节点也要实现 NAT 遍历，因为节点可能需要和 NAT 之后的节点建立连接 libp2p 使用 ICE-like 的协议实现完全的 NAT 遍历  不是真的 ICE，因为 IPFS 网络可能为了 hole-punching 或者中继通讯通过 IPFS 协议中继通讯  建议使用一些现有的 NAT 遍历库来实现：libnice，libwebrtc，natty  中继（relay）  由于对称的 NAT，容器和 VM NAT，以及其他的 impossible-to-bypass 的 NAT，libp2p 必须中继通讯以建立完整的连接图 因此，实现必须支持中继，虽然可能是可选的，而且可能被终端用户拒绝 连接中继应该作为传输实现，以便于传给上层  启用多个网络拓扑  P2P 的拓扑分为：  unstructed 无结构的：网络是完全随机的，或者不确定的 structed 结构化的：有一种隐式的方式来识别网络节点 hybrid 混合的：无结构和结构化的拓扑混合 centralized 中心化的：中心化的拓扑是 web 应用框架中最常见的，它要求一个或一些指定的服务在已知的静态位置一直存在  libp2p 必须执行不同的路由机制和 peer 的发现，以便建立路由表  资源发现  libp2p 通过记录（records）解决王路内部的资源发现问题  一个 record 是一个数据单元，可以按位签名，加时间戳或/和使用其他方法给它一个时效性 这些 records 持有信息包括网络中的位置、资源的有效性等  资源可以是数字，存储，CPU 周期和其他类型的服务 libp2p 不能限制资源的位置，但是提供方式简单的发现网络中的资源或者使用一个 side channel  消息  有效的消息协议提供方法来发送消息，使得延迟最小，且/或支持庞大复杂的拓扑以便于分布式 libp2p 结合 Multicast 和 PubSub 来实现这些需求  命名  网络变化和应用可以使用网络以使得对于拓扑是匿名的，命名用于解决这个问题  架构  libp2p 包括多个子系统。这些子系统可以遵循统一的接口建立在其他子系统之上  Peer Routing：节点路由。这个机制决定使用哪些节点来路由指定的消息。路由可以是递归的、迭代的，甚至是广播或多播的模式 Swarm：集群。处理 libp2p2 中和打开流相关的部分，包括多传输过程中的协议复用，流复用，NAT 遍历，连接中继 Distributed Record Store：分布式记录存储。存储和分发记录的系统。记录是指被其他吸烟使用的小的条目，用于发送信号，建立链路，announce 节点或内容等。和网络中的 DNS 类似 Discovery：发现。发现和识别网络中的其他节点   节点路由  子系统暴露了一个接口来识别一个消息应该被路由到 DHT 中的哪些节点：接收一个 key，返回一个或多个 PeerInfo 对象  kad-routing：基于 Kademlia DHT，实现了 Kademlia 路由表，每个节点持有一个 k-bucket 的集合。每个k-bucket 包含几个 PeerInfo 对象 mDNS-routing：使用 mDNS 探测和识别，当局域网内的节点有一个指定的 key 或者节点容易出现   集群  Stream Muxer：必须实现 interface-stream-muxer 中的接口 Protocol Muxer：在应用层被处理而不是传统的端口层（不同的服务或协议监听不同的端口）。使得我们支持多种协议在一个套接字被复用，节约了多端口 NAT 遍历的花费  协议复用通过 multistream 完成，一个协议和不同的流协商使用 multicodec  Transport：传输 Crypto：加密 Identify：鉴别是 Swarm 之上的一些协议，是 Connection Handler。使得节点之间可以互换监听者地址(listenAddrs)和观察者(observeAddrs)地址。因为每个开放的套接字会实现 REUSEPORT，另一个节点的 ObserveAddr 可以使得第三个节点连接进来，因为端口已经是开放的，可以在 NAT 上重定向到开放的端口 Relay：中继，参考 Circuit Relay  分布式记录存储  Record abstract-record-store kad-record-store mDNS-record-store s3-record-store  发现 发现和识别网络中的其他节点\nmDNS-discovery  mDNS-discovery 是局域网内使用 mDNS 的一个发现协议。它发射一个 mDNS 信号来发现是否有更多可用的节点。局域网内的节点对于 peer-to-peer 是非常有用的，因为链路延迟更低 mDNS-discovery 是一个独立的协议，不依靠 libp2p2 中的其他协议。可以不依赖其他底层架构在局域网内生成可用的节点 mDNS-discovery 可为每个服务配置，也可以在私有网络配置 原始的 mDNS 会暴露本地 IP 地址，正在设法加密 mDNS-discovery 信号，使得局域网内其他节点不能识别正在使用的服务  不建议将 mDNS-discovery 应用到隐私敏感的应用或者未知到路由协议   random-walk  random-walk 是应用于 DHT （或其他有路由表的协议）的发现协议。它生成随机的 DHt 请求以快速了解大量的节点 这个会在一开始的时候花费一些负载，但是可以使得 DHT （或其他协议）更快聚合  bootstrap-list  bootstrap-list 是用本地存储来缓存网络中的高稳定（或信任的）节点的发现协议  列表应当被存储在对于本地节点来说是长期的本地存储 在大部分情况下应该是可以用户配置的   消息-架构 发布订阅  PubSub 参考 pubsub 和 pubsub/gossippub  命名-架构 IPRS 参考 IPRS spec\nIPNS 数据结构 网络协议处理的数据结构包括\n PrivateKey：节点的私钥 PublicKey：节点的公钥 PeerId：节点公钥的一个哈希 PeerInfo：一个对象，包含节点的 PeerId 和已知的多地址 Transport：用于和其他 peer 建立连接的传输，必须实现 interface-transport Connection：两个 node 之间的一个 point-to-point 链路，必须实现 interface-connection Muxed-Stream：一个双向（duplex）的消息通道 Stream-Muxer：流复用器，必须实现 interface-stream-muxer Record：LPLD（IPFS Linked Data）描述的对象，实现 IPRS multiaddr：自描述的网络地址，参考 multiaddr multicodec：自描述的编码类型，参考 multicodec multihash：自描述的哈希，参考 multihash  接口  libp2p 传输 链接 流多路复用器 集群 节点发现 节点路由 内容路由  接口-分布式记录存储  libp2p 接口和 UX  特性 通信模型-流 端口-受限入口 传输协议 非 IP 网络 网线  协议复用-同一个流上运行多个协议  多流-自描述协议流，为协议定义一个协议头 多流选择器-自描述协议流选择器 允许列举和选择其他协议。协议复用有一个注册协议的列表，监听一个协议，然后包装或升级连接来描述注册的协议 直接利用了多流，可以交替多个协议，检查远端可能使用的协议 流复用-通过一个网线运行多个独立流 将多个流复用或合并成一个单独的流  便携式编码-使用便携的序列格式  目前使用 protobuf，候选的还有 capnp，bson，ubjson  安全通信-使用加密算法建立安全和隐私（像 TLS） 协议多解码（multicodecs）  实现 参考 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a9b9f14234a058e2ef556a5d153def38","permalink":"https://xueqing.github.io/blog/p2p/libp2p/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/p2p/libp2p/","section":"blog","summary":"介绍 愿景 目标 网络堆栈技术现状分析 客户端-服务端（C/S）模型 按解决方案对网络分类 目前的缺点 要求 匿名传输 多种多路复用（multi-multip","tags":["p2p"],"title":"学习 libp2p","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  node.js npm  node.js  event-driven, non-blocking I/O model  lightweight and efficient  architecture  L1: Node core/Standard Library(JS) L2: Node Bindings(C++) L3: Chrome V8(C++) + libuv\u0026copy;   npm  NPM(Node package manager) package: JS files + package.json(manifest)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3c15994d08b36bd41251fa5e32baf385","permalink":"https://xueqing.github.io/blog/js/nodejs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/js/nodejs/","section":"blog","summary":"node.js npm node.js event-driven, non-blocking I/O model lightweight and efficient architecture L1: Node core/Standard Library(JS) L2: Node Bindings(C++) L3: Chrome V8(C++) + libuv\u0026copy; npm NPM(Node package manager) package: JS files + package.json(manifest)","tags":["js"],"title":"学习 Node.js","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  内容  参考 Go 维基官网——学习测试学习。\n原网页由 Evgeny Vereshchagin 在 2019/1/29 编辑。第 4 次修订。\n内容 这个页面链接到关于 Go 测试的资源。\n阅读如何编写 Go 代码，尤其是测试 学习测试包 阅读为什么 Go 没有断言 阅读我最喜欢的测试辅助函数在哪里 观看测试技巧 阅读表驱动测试 阅读使用子测试项目和子基准测试  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"fb46ad8ebcb68fe6f32ce4dac309cabe","permalink":"https://xueqing.github.io/translation/go-doc/wiki/learn_testing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/wiki/learn_testing/","section":"translation","summary":"内容 参考 Go 维基官网——学习测试学习。 原网页由 Evgeny Vereshchagin 在 2019/1/29 编辑。第 4 次修订。 内容 这个页面链接到关于 Go 测试的资源。 阅读如何编写 Go 代码，尤其是测试 学习","tags":["go-doc-wiki"],"title":"学习测试","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"环境：ubuntu16.04\n# 安装 docker sudo apt-get install docker.io # 启动 docker sudo /etc/init.d/docker start # 创建 docker 用户组 sudo groupadd docker # 应用用户 kiki 加入 docker 用户组 sudo usermod -aG docker kiki # 重启 docker 服务 sudo /etc/init.d/docker restart # 切换或者退出当前账户再从新登入 su root # 切换到root用户 su kiki # 再切换到原来的应用用户以上配置才生效  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"459282971eab4b3d3a87fbf197324afa","permalink":"https://xueqing.github.io/blog/docker/install/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/docker/install/","section":"blog","summary":"环境：ubuntu16.04 # 安装 docker sudo apt-get install docker.io # 启动 docker sudo /etc/init.d/docker start # 创建 docker 用户组 sudo groupadd docker # 应用用户 kiki 加入 docker 用户组 sudo usermod -aG docker kiki # 重启 docker 服务 sudo /etc/init.d/docker restart # 切换或者","tags":["docker"],"title":"安装","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  Linux 安装和使用 go  安装 设置工作目录 GOPATH 测试安装 安装其他版本  Windows 安装和使用 go MacOS 安装和使用 go 卸载旧版本 命令 vscode 使用 go 配置代理  Linux 安装和使用 go 安装  下载安装包  选择最新的 Linux 版本 下载wget https://dl.google.com/go/go1.11.2.linux-amd64.tar.gz  安装  解压：tar -C /usr/local -zxf go1.11.2.linux-amd64.tar.gz  配置环境变量  修改/etc/profile或~/.profile 追加export PATH=$PATH:/usr/local/go/bin 执行source命令更新配置文件立即生效   设置工作目录 GOPATH  工作目录下面有三个文件夹  src：存放源码的目录，新建项目都在该目录下 pkg：编译生成的包文件存放目录 bin：编译生成的可执行文件和 go 相关的工具  默认工作目录是 $HOME/go 如果需要自定义工作目录：  建议：不要和 go 的安装目录相同 修改 ~/.bashrc，添加 export GOPATH=$HOME/go 执行 source ~/.bashrc 使脚本生效 修改/etc/profile或~/.profile，添加 export GOROOT=$HOME/go，将 $HOME/go/bin 加入系统环境变量 PATH 执行source命令更新配置文件立即生效    测试安装  创建并进入默认工作目录 ~/go 创建并进入目录 src/hello 创建文件 hello.go\npackage main import \u0026quot;fmt\u0026quot; func main() { fmt.Printf(\u0026quot;Hello, world\\n\u0026quot;) }  编译：go build，生成可执行文件 hello\n 运行：./hello\n 安装二进制文件到工作目录的 bin 目录：go install\n 删除工作目录的二进制文件：go clean -i\n  安装其他版本  安装版本 1.10.7  go get golang.org/dl/go1.10.7 go1.10.7 download  使用版本 1.10.7  go1.10.7 version   Windows 安装和使用 go  下载 Windows 安装包 msi 文件 安装到 c:\\Go 目录 将 c:\\Go\\bin 加入系统环境变量 PATH 测试安装  创建 go 的工作目录，比如 g:\\gopro 设置工作目录路径：在用户变量中加入 GOPATH 将 g:\\gopro\\bin 加入系统环境变量 PATH 创建 g:\\gopro\\src\\hello 目录，创建 hello.go 文件 打开 Windows 终端，切换到 g:\\gopro\\src\\hello 目录 编译：go build，生成可执行文件 hello.exe 运行：hello 安装二进制文件到工作目录的 bin 目录：go install 删除工作目录的二进制文件：go clean -i   MacOS 安装和使用 go  执行 brew install go 配置环境变量  修改 ~/.profile 追加export GOROOT=/usr/local/go 追加export PATH=$PATH:$GOROOT/bin 执行source ~/.profile命令更新配置文件立即生效  验证配置：执行 go version 写测试程序\n 写 hello.go\npackage main import \u0026quot;fmt\u0026quot; func main() { fmt.println(\u0026quot;Hello World!\u0026quot;) }  执行 go run hello.go\n   卸载旧版本  删除 go 目录  Linux/MacOS/FreeBSD /usr/local/go Windows c:\\go  从环境变量 PATH 中删除 go 的 bin 目录  Linux/FreeBSD 编辑 /etc/profile 或 ~/.profile MacOS 删除 /etc/paths.d/go   命令  查看 golang 环境变量 go env  vscode 使用 go  安装插件 Go 配置 vscode  选择 File -\u0026gt; Preferences -\u0026gt; Settings，搜索 go \u0026ldquo;Go: Build On Save\u0026rdquo;: \u0026ldquo;workspace\u0026rdquo; \u0026ldquo;Go: Gopath\u0026rdquo;: \u0026ldquo;/home/kiki/go\u0026rdquo;  Linux 配置: \u0026ldquo;/home/kiki/go\u0026rdquo; Windows 配置: \u0026ldquo;G:\\gopro\u0026rdquo;  \u0026ldquo;Go: Goroot\u0026rdquo;  Linux 配置: \u0026ldquo;/usr/local/go\u0026rdquo; Windows 配置：\u0026rdquo;C:\\Go\u0026rdquo;   打开 go 的工作目录，第一次打开 go 后缀结尾的文件时，会提示安装 gopkgs，选择 Install All，等待安装结束 vscode 自动安装失败，执行手动安装  1 在 %GOPATH%/src/golang.org/x 目录下，执行 git clone git@github.com:golang/tools.git 2 进入 %GOPATH%/src/golang.org/x/tools/cmd/gorename 目录，执行 go install 3 进入 %GOPATH%/src/golang.org/x/tools/cmd/guru 目录，执行 go install 4 重启 vscode，打开 go 后缀结尾的文件，点击 Analysis Tools Missing，继续之前安装失败的 go 包  安装过程中，有的包可能会安装失败\n 1 使用 tools 下载 进入 %GOPATH%/src/golang.org/x 目录，使用命令 git clone https://github.com/golang/tools.git 下载插件依赖工具的源码，所需工具源码就都保存在 tools 目录中 进入 %GOPATH% 目录，根据之前的安装失败提示信息安装对应的依赖工具：比如 go install github.com/mdempsky/gocode 2 使用 lint 下载 go install golang.org/x/lint/golint 报错\ncan't load package: package golang.org/x/lint/golint: cannot find package \u0026quot;golang.org/x/lint/golint\u0026quot; in any of: /usr/local/go/src/golang.org/x/lint/golint (from $GOROOT) /home/kiki/go/src/golang.org/x/lint/golint (from $GOPATH)  因为 golint 的源码在 lint 下，而不是 tools，需要单独拉取 golint 源码\n 进入 %GOPATH%\\src\\golang.org\\x 目录，执行命令 git clone https://github.com/golang/lint 拉取 golint 源码\n 进入 %GOPATH% 目录，通过 go install 安装 golint：go install golang.org/x/lint/golint\n  重启 vscode 后，插件就可以正常使用了\n  配置代理  执行 go mod init 生成默认 module 文件 配置环境变量 export GOPROXY=https://goproxy.io 重启 vscode，安装插件  Ctrl+Shift+P，输入 go 选择 Install/Update Tools 全选，安装。重启 vscode 即可   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e1947c35ec8b419b0200e27603e46a61","permalink":"https://xueqing.github.io/blog/go/basic/go_install/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_install/","section":"blog","summary":"Linux 安装和使用 go 安装 设置工作目录 GOPATH 测试安装 安装其他版本 Windows 安装和使用 go MacOS 安装和使用 go 卸载旧版本 命令 vscode 使用 go 配置代理 Linux 安装和使用 go 安装 下载安装包 选","tags":["go"],"title":"安装 go","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"参考 Linuxbrew。\nsh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)\u0026quot;  安装脚本将 Homebrew 安装到 /home/linuxbrew/.linuxbrew(sudo) 或者 ~/.linuxbrew。安装之后不需要 sudo 使用 Homebrew。使用 /home/linuxbrew/.linuxbrew 弄马壮加密和搭配和人的主目录支持使用更多二进制包。\n遵循下面的步骤指导增加 Homebrew 到 PATH 和 bash shell 配置脚本，即 Debian/Ubuntu 下是 ~/.profile， CentOS/Fedora/RedHat 下是 ~/bash_profile。\ntest -d ~/.linuxbrew \u0026amp;\u0026amp; eval $(~/.linuxbrew/bin/brew shellenv) test -d /home/linuxbrew/.linuxbrew \u0026amp;\u0026amp; eval $(/home/linuxbrew/.linuxbrew/bin/brew shellenv) test -r ~/.bash_profile \u0026amp;\u0026amp; echo \u0026quot;eval \\$($(brew --prefix)/bin/brew shellenv)\u0026quot; \u0026gt;\u0026gt;~/.bash_profile echo \u0026quot;eval \\$($(brew --prefix)/bin/brew shellenv)\u0026quot; \u0026gt;\u0026gt;~/.profile  下面尝试安装一个包：\nbrew install hello  重启\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ae87d2c1abd38dd93ad135ad5e424470","permalink":"https://xueqing.github.io/blog/ubuntu/ubuntu_brew/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/ubuntu_brew/","section":"blog","summary":"参考 Linuxbrew。 sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)\u0026quot; 安装脚本将 Homebrew 安装到 /home/linuxbrew/.linuxbrew(sudo) 或者 ~/.linuxbrew。安装之后不需要 sudo 使用 Homebrew。使用 /home/linuxbrew/.linuxbrew 弄马壮加密和","tags":["ubuntu","linux"],"title":"安装 Linuxbrew","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  安装 Apache 创建自己的网站 设置 VirtualHost 配置文件 激活 VirtualHost 文件 其他 VirtualHost 例子  在一个 IP 地址上运行多个不同主机名的网站 在不同端口上运行不同网站  参考  安装 Apache 环境：ubuntu 16.04\nsudo apt-get install update # 安装 sudo apt-get install apache2 # 可在浏览器输入本机 ip，看到 Apache2 的欢迎页面说明服务正常 # 修改显示内容：修改 `/var/www/html` 文件夹 # 或修改配置文件，修改 /var/www/html 为 html 文件所在目录 vim /etc/apache2/sites-enabled/000-default.conf  创建自己的网站 # 新建文件夹 sudo mkdir /var/www/mysite \u0026amp;\u0026amp; cd /var/www/mysite # 创建 html 文件 vim index.html # 在浏览器输入本机 ip，看到新的内容  设置 VirtualHost 配置文件 # 切换到配置文件目录，创建配置文件 cd /etc/apache2/sites-available \u0026amp;\u0026amp; sudo cp 000-default.conf mysite.conf # 修改配置文件，修改 ServerAdmin 为自己的邮箱 # 修改 DocumentRoot 为 /var/www/mysite， # 修改 ServerName 为 mysite.example.com sudo vim mysite.conf  激活 VirtualHost 文件 cd /etc/apache2/sites-available \u0026amp;\u0026amp; sudo a2ensite mysite.conf # 重新加载网页 sudo service apache2 reload  其他 VirtualHost 例子 在一个 IP 地址上运行多个不同主机名的网站 # Ensure that Apache listens on port 80 Listen 80 \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot \u0026quot;/www/example1\u0026quot; ServerName www.example.com # Other directives here \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost *:80\u0026gt; DocumentRoot \u0026quot;/www/example2\u0026quot; ServerName www.example.org # Other directives here \u0026lt;/VirtualHost\u0026gt;  在不同端口上运行不同网站 Listen 80 Listen 8080 \u0026lt;VirtualHost 172.20.30.40:80\u0026gt; ServerName www.example.com DocumentRoot \u0026quot;/www/domain-80\u0026quot; \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost 172.20.30.40:8080\u0026gt; ServerName www.example.com DocumentRoot \u0026quot;/www/domain-8080\u0026quot; \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost 172.20.30.40:80\u0026gt; ServerName www.example.org DocumentRoot \u0026quot;/www/otherdomain-80\u0026quot; \u0026lt;/VirtualHost\u0026gt; \u0026lt;VirtualHost 172.20.30.40:8080\u0026gt; ServerName www.example.org DocumentRoot \u0026quot;/www/otherdomain-8080\u0026quot; \u0026lt;/VirtualHost\u0026gt;  参考  Install and Configure Apache VirtualHost Examples  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a6cfbf0164b8f23d7ae1eb1b2dac5707","permalink":"https://xueqing.github.io/blog/ubuntu/apache/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/apache/","section":"blog","summary":"安装 Apache 创建自己的网站 设置 VirtualHost 配置文件 激活 VirtualHost 文件 其他 VirtualHost 例子 在一个 IP 地址上运行多个不同主机名的网站 在不同端口上运行不同网站 参考 安装 Apache 环境：ubun","tags":["ubuntu","linux"],"title":"安装和配置 Apache 服务","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  介绍  例子  格式化 注释 名字  包名 getter 接口名 驼峰  分号 控制结构  if 重新声明和重新赋值  函数  多返回值 命名结果参数 defer  数据  使用 new 分配 构造函数和复合字面量 使用 make 分配 数组 切片 二维切片 映射 打印 追加  初始化  常数   参考 Golang 官网文档——Effective Go 学习。\n介绍 Go 是一门新语言。虽然它从现有语言借鉴了想法，但是它有独特的属性使得实效的 Go 程序和使用其他语言编写的程序特点不同。直接将一个 C++ 或 Java 程序翻译成 Go 不太可能生成令人满意的结果——Java 程序是用 Java 写的，而不是 Go。另一方面，从 Go 的角度思考一个问题可能产生一个成功的但是完全不同的程序。换句话说，要写好 Go，理解它的特性和惯用语是很重要的。而且，了解用 Go 编程已有的惯例，比如命名、格式化、程序结构等等也很重要，以便你编写的程序容易被其他 Go 开发人员理解。\n此文档给出关于编写清晰、惯用的 Go 代码的建议。它增补了语言规范、Go 语言之旅以及如何编写 Go 代码，所有这些你应该先阅读。\n例子 Go 包源码用于作为和核心库，也作为如何使用语言的例子。此外，很多包包含可工作的、自包含的可执行例子，你可以直接从 golang.org 网站运行，比如这个网站(如果需要，点击单词 “Example” 打开它)。如果你对于如何处理一个问题或一些东西是如何实现的有疑问，这个库中的文档、代码和例子可以给出答案、思想和背景。\n格式化 格式化问题是最有争议却最不重要的。人们可以选择不同的格式风格，但是如果每个人遵循相同的风格，那么人们不需要且可以花费更少的时间在这个问题上是更好的。问题是如何在没有一个长长的风格规范指南的情况下实现这个想法。\n对于 Go，我们使用了一种特别的方法且交由机器注意大多数格式化问题。gofmt 程序(也可以通过 go fmt 使用，它作用于包级别而不是源文件级别)读入一个 Go 程序并且以标准的风格缩进、垂直对齐、保持或者需要的话重新格式化注释，然后发出源文件。如果你想要知道如何处理一些新的格式场景，运行 gofmt；如果答案看起来不正确，重新组织你的程序(或提出一个 gofmt 的错误)，不要绕过这个问题。\n作为一个例子，不必花时间对结构体的域做注释对齐。gofmt 将会为你做这些。给出一个声明\ntype T struct { name string // 对象的名字 value int // 对象的值 }  gofmt 会列对齐：\ntype T struct { name string // 对象的名字 value int // 对象的值 }  标准库中所有的 Go 代码都已经使用 gofmt 格式化过。\n还有一些格式化细节。非常简洁：\n缩进 我们使用 tab 键缩进，且 gofmt 默认使用 tab 键。只在必要的时候使用空格。 行长度 Go 没有行长度限制。不要担心溢出穿孔卡片。如果感觉一行太长，包裹它并使用额外的 tab 键缩进 括号 Go 比 C 和 Java 需要更少的括号：控制结构 (if/for/switch) 的语法没有括号。同时，操作符优先级层次更短更清晰。 因此不像其他语言， `x\u0026lt;\u0026lt;8 + y\u0026lt;\u0026lt;16` 就是空格暗示的含义。  注释 Go 提供 C-风格的块注释 /**/ 和 C++-风格的行注释 //。行注释是常态；块注释大多出现在包注释，但是在一个表达式内部或禁用大段代码是有用的。\ngodoc 程序，也是 web 服务器，处理 Go 源文件以提取关于包内容的文档。在顶层声明之前出现的注释，中间没有新行，和声明一起提取作为该元素的解释文本。这些注释的本性和风格决定了 godoc 生成的文档的质量。\n每个包应该有一个包注释，即 package 语句之前的一个块注释。对于多文件的包，包注释只需要出现在一个文件，且每个文件都可以看到。包注释应该介绍包并提供和包有关的信息作为一个整体。它会先出现在 godoc 页面，并且应该设置后面的详细文档。\n/* 包 regexp 实现了正则表达式的一个简单库。 接收正则表达式的语法是: 正则表达式: 连接 { '|' 连接 } 连接: { 闭包 } 闭包: 项 [ '*' | '+' | '?' ] 项: '^' '$' '.' 字符 '[' [ '^' ] 字符范围 ']' '(' 正则表达式 ')' */ package regexp  如果是一个简单包，包注释可以是简洁的。\n// 包 path 实现了功能代码，用于操作斜线分隔的文件名路径。  注释不需要额外的格式比如一行星号。生成的输出可能不能显式为固定宽度的字体，因此不要依赖空格对齐——godoc 像 gofmt 一样，会注意对齐问题。注释是无解释的普通文本，因此 HTML 和其他的注解，比如 _this_，会逐字重复，不应该使用。godoc 会做的一个调整是按固定宽度的字体显示缩进文本，适用于代码片段。fmt 包对包注释的使用恰到好处。\n视上下文而定，godoc 甚至可能不会重新格式化注释，因此确保他们直接看起来是格式好的：使用正确的拼写、标点符号和句子结构，折叠长行等等。\n在包内部，任何紧紧出现在顶层声明之前的注释作为该声明的一个文档注释。程序中每个导出的(大写开头的)名字应该有一个文档注释。\n文档注释最好是完整的句子，允许不同的自动化显示。第一个句子应该是一个总结句，以声明的名字开头。\n// Compile 解析一个正则表达式，且成功时返回一个可用于匹配文本的 Regexp 对象。 func Compile(str string) (*Regexp, error) {  如果每个文档注释以描述的元素名字开头，你可以使用 go 工具的 doc 子命令并通过 grep 运行输出。设想你不能急的 “Compile” 名字但是正在查找正则表达式的解析函数，因此你运行命令：\ngo doc -all regexp | grep -i parse  如果包内所有的文档注释以“这个函数……”开头，grep 不会帮助你记得那个名字。但是因为包的每个文档注释以名字开始，你会看到类似下面的内容，这会回忆起你正在寻找的单词。\n$ go doc -all regexp | grep -i parse Compile parses a regular expression and returns, if successful, a Regexp MustCompile is like Compile but panics if the expression cannot be parsed. parsed. It simplifies safe initialization of global variables holding  Go 的声明语法允许分组声明。一个单一的文档注释可以介绍一组相关的常量或变量。因为显示了整个声明，这样的注释通常是敷衍了事的。\n// 解析表达式失败时返回的错误代码。 var ( ErrInternal = errors.New(\u0026quot;regexp: internal error\u0026quot;) ErrUnmatchedLpar = errors.New(\u0026quot;regexp: unmatched '('\u0026quot;) ErrUnmatchedRpar = errors.New(\u0026quot;regexp: unmatched ')'\u0026quot;) ... )  分组也可以指示元素之间的关系，比如被一个所保护的变量集合的事实。\nvar ( countLock sync.Mutex inputCount uint32 outputCount uint32 errorCount uint32 )  名字 Go 中的名字和其他语言中的一样重要。它们甚至有语义影响：一个名字在包外的可见性取决于它的第一个字母是否是大写。因此值得花费一些时间讨论 Go 编程中的命名惯例。\n包名 当导入一个包时，包名成为这些内容的一个访问器。在 import \u0026quot;bytes\u0026quot; 之后，导入包可以讨论 bytes.buffer。每个使用该包的人可以使用相同的名字来引用包内容是有帮助的，这意味着包名应该是好的：短、简明、引起共鸣的。按照惯例，包使用小写的、单一单词的名字；不应该需要使用下划线或驼峰。Err 就是简洁的，因为每个人使用你的包都会输入那个名字。并且不予担心与先前的冲突。包名只是导入的默认名字；它不需要在所有源码范围内唯一，并且在极少冲突的情况下，导入包可选择一个不同的名字在局部使用。无论如何，混淆是稀少的，因为这个导入的文件名只决定正在使用的包。\n另外一个惯例是包名是源路径的基础名；在 src/encoding/base64 中的包作为 “encoding/base64” 导入，但名字是 base64，而不是 encoding_base64 或者 encodingBase64。\n包的导入者将会使用包名来引用它的内容，因此包中导出的名字可使用这个事实来避免停顿。(不要使用 import . 符号，这可以简化必须在被测试包之外的测试，但应该被避免。)比如， bufio 包中的带缓冲的 reader 类型叫做 Reader，而不是 BufReader，因为使用者看到的是 bufio.Reader，这是一个更加清晰简洁的名字。此外，因为导入的实体总是用包名处理，bufio.Reader 和 io.Reader 不会冲突。类似的，生成 ring.Ring 实例的函数——这是 Go 中构造函数的定义——通常会使用 NewRing 调用，但是因为 Ring 是这个包导出的唯一类型，且这个包叫做 ring，这个函数只用 New 调用，这个包的使用者看到的是 ring.New。使用包结构来帮助你选择好名字。\n另外一个简单的例子是 once.Do；once.Do(setup) 读着不错，并且不会被写做 once.DoOrWaitUntilDone(setup) 而有改善。长名字不会自动使得东西更易读。一个有用的文档注释通常比一个特别长的名字更有价值。\ngetter Go 不提供对 getter 和 setter 的自动支持。自己提供 getter 和 setter 是没有问题的，且通常这样做事合适的。但是将 Get 放在 getter 名字中既不是惯例也非必要的。如果你有一个域叫 owner(小写的，不导出)，它的 getter 方法应叫做 Owner(大写，导出的)，而不是 GetOwner。使用大写名字导出可以区分域名和方法名。如果有必要，一个 setter 方法可能叫做 SetOwner。两个名字实际上也是易读的：\nowner := obj.Owner() if owner != user { obj.SetOwner(user) }  接口名 按照惯例，一个方法的接口用方法名和一个 -er 后缀或类似的修改器命名，用以构造一个代理名词：Reader，Writer，Formatter，CloseNotifier 等。\n有许多类似的名字，且尊重这些名字及其捕获的函数名是富有成效的，Read，Write，Close，Flush，String 等等有规范的签名和含义。为了避免混淆，除非方法具有相同的签名和含义，不要使用上述这些名字给方法命名。相反地，如果你的类型实现的方法与一个熟悉的类型的方法有相同的含义，使用这个相同的名字和签名；将你的字符串转换方法命名为 String 而不是 ToString。\n驼峰 最后，Go 的惯例是使用 MixedCaps 或 mixedCaps 而不是下划线来写多单词的名字。\n分号 类似 C，Go 规范的语法使用分号来终止一个语句，但是和 C 不同的是，这些分号不会出现在源文件。反之，词法分析器使用一个简单的规则在扫描时自动插入分号，因此输入文本可免除大部分分号。\n规则如下。如果新行之前的最后一个符号是一个标识符(包括像 int 和 float64 的单词)，一个基本字面量，比如一个数字、字符串常量，或者下面的一个符号\nbreak continue fallthrough return ++ -- ) }  词法分析器总是在这个符号之后插入一个分号。这可以概括为，“如果在一个可以结束一句话的符号之后有一个新行，插入一个分号”。\n紧挨着在一个右大括号之前出现的分号也可以忽略，因此一个类似下面的语句不需要分号：\ngo func() {for { dts \u0026lt;- \u0026lt;- src }} ()  习惯上，Go 程序只在类似于 for 循环子句中有分号，用于分隔初始化、条件和连续元素。如果你在一行中写多个语句，也需要分号来分隔语句。\n插入分号规则的一个结果是你不能将一个控制结构(if/for/switch/select)的左大括号放在下一行。如果你这样做，会在一个大括号之前插入分号，这会导致不想出现的影响。像这样编写代码：\nif i \u0026lt; f() { g() }  不要像这样：\nif i \u0026lt; f() // 错误! { // 错误! g() }  控制结构 Go 的控制结构和 C 的控制结构相关，但是很不相同。Go 没有 do 或 while 循环，只有一个稍微普遍的 for；switch 更加灵活；if 和 switch 接受一个可选的类似 for 中的初始化语句；break 和 continue 语句使用一个可选的标签来识别从哪里跳出或继续循环；Go 也有新的控制结构，包括 type switch 和多向通讯复用器 select。语法也有一点不同：Go 没有小括号，且控制结构体必须使用大括号分隔。\nif 在 Go 中，一个简单的 if 看起来像这样：\nif x \u0026gt; 0 { return y }  强制的大括号鼓励将一个简单的 if 语句分为多行。无论如何，这样编写是一个好的风格，尤其是当代码体包含一个控制语句，比如 return 或 break。\n因为 if 和 switch 接受一个初始化语句，常见的是用于设置一个局部变量：\nif err := file.Chmod(0664); err != nil { log.Print(err) return err }  在 Go 的库中，你会发现当一个 if 没有流入下一句——即代码体以 break、continue、goto 或 return 结束——会忽略不需要的 else。\nf, err := os.Open(name) if err != nil { return err } codeUsing(f)  这是一个常见情形的例子，即代码必须防止一系列错误条件。如果成功的控制流沿着页面向下，而错误出现的时候消除它们时，代码阅读体验更好。因为错误情况倾向于以 return 语句结束，生成的diamante不需要 else 语句。\nf, err := os.Open(name) if err != nil { return err } d, err := f.Stat() if err != nil { f.Close() return err } codeUsing(f, d)  重新声明和重新赋值 函数 多返回值 Go 其中一个非凡的特性时函数和方法可以返回多个值。这个性质可用于改善 C 程序中的一些笨拙的写法：in-band 错误返回类似 -1 的值表示错误码并修改通过地址传递的参数。\n在 C 语言，使用一个负的计数器标记一个写入错误，且错误码隐藏在一个不固定位置。在 Go 语言，Write 可以返回一个计数器和一个错误：“是的，你写了一部分但非全部的字节，因为你已经填满了设备”。os 包中作用于文件的 Write 方法签名：\nfunc (file *File) Write(b []byte) (n int, err error)  且如文档所说，当 n 不等于 b 时这个方法返回写入的字节数和一个非空的错误。这是常见的风格；查看错误处理部分获得更多例子。\n一个类似的方法不需要传递一个指针给返回值来模拟一个引用参数。下面是一个简单的函数，从一个字节切片的某个位置起捕获一个数字，返回该数字和下一个位置。\nfunc nextInt(b []byte, i int) (int, int) { for ; i \u0026lt; len(b) \u0026amp;\u0026amp; !isDigit(b[i]); i++ { } x := 0 for ; i \u0026lt; len(b) \u0026amp;\u0026amp; isDigit(b[i]); i++ { x = x*10 + int(b[i]) - '0' } return x, i }  你可以使用这个方法像下面这样来扫描一个输入切片 b 的数字：\nfor i := 0; i \u0026lt; len(b); { x, i = nextInt(b, i) fmt.Println(x) }  命名结果参数 Go 函数的返回或结果“参数”可以指定名字并作为普通变量使用，就像使用传入参数。当函数开始时，命名的参数被初始化对应类型的零值；如果函数执行一个不带参数的 return 语句，返回参数的当前值被作为返回值。\n名字不是必须的，但是名字可以使得代码更加简短清晰：名字即是文档。如果我们将 nextInt 的结果命名，很显然返回的 int 含义。\nfunc nextInt(b []byte, pos int) (value, nextPos int) {  因为命名的结果会被初始化且绑定在一个简单的 return，它们可以既简单又清晰。下面是 oi.ReadFull 使用命名结果良好的版本：\nfunc ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) \u0026gt; 0 \u0026amp;\u0026amp; err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:] } return }  defer Go 的 defer 语句安排执行 defer 的函数返回之前立即运行一个函数调用(即推迟的函数)。这是一个处理一些场景特别而高效的方式，比如无论函数使用哪条路径返回都必须释放的资源。经典的例子是解锁一个互斥锁或关闭一个文件。\n// Contents 将文件内容作为字符串返回。 func Contents(filename string) (string, error) { f, err := os.Open(filename) if err != nil { return \u0026quot;\u0026quot;, err } defer f.Close() // 函数结束时会运行 f.Close。 var result []byte buf := make([]byte, 100) for { n, err := f.Read(buf[0:]) result = append(result, buf[0:n]...) // 后面会讨论 append。 if err != nil { if err == io.EOF { break } return \u0026quot;\u0026quot;, err // 如果在这里返回，会关闭 f。 } } return string(result), nil // 如果在这里返回，会关闭 f。 }  推迟一个类似于 Close 的函数调用有两个优点。其一，它保证你永远不会忘记关闭一个文件，如果你之后编辑这个函数增加一个新的返回路径，这是很容易犯的一个错误。其二，它意味着关闭挨着打开操作，这比放在函数末尾更加清晰。\n推迟的函数参数(当函数是一个方法时还包括接收者)在执行 defer 时计算值，而不是执行调用时计算。除了避免担心在函数执行时修改变量值，这还意味着一个单一的推迟调用可以推迟多个函数执行。这里有一个丑陋的示例。\nfor i := 0; i \u0026lt; 5; i++ { defer fmt.Printf(\u0026quot;%d \u0026quot;, i) }  推迟的函数按照 LIFO (后进先出)的顺序执行，因此上述代码函数返回时，会打印“ 4 3 2 1 0”。一个更加合乎情理的例子是使用一个简单的方式来跟踪程序的函数执行。我们可以写一些像这样的简单的跟踪代码：\nfunc trace(s string) { fmt.Println(\u0026quot;entering:\u0026quot;, s) } func untrace(s string) { fmt.Println(\u0026quot;leaving:\u0026quot;, s) } // 像这样使用它们: func a() { trace(\u0026quot;a\u0026quot;) defer untrace(\u0026quot;a\u0026quot;) // 做一些事情.... }  我们可以利用延迟函数的参数在执行 defer 时计算这一事实做的更好。跟踪代码可以设置不跟踪代码的参数。下面的例子\nfunc trace(s string) string { fmt.Println(\u0026quot;entering:\u0026quot;, s) return s } func un(s string) { fmt.Println(\u0026quot;leaving:\u0026quot;, s) } func a() { defer un(trace(\u0026quot;a\u0026quot;)) fmt.Println(\u0026quot;in a\u0026quot;) } func b() { defer un(trace(\u0026quot;b\u0026quot;)) fmt.Println(\u0026quot;in b\u0026quot;) a() } func main() { b() }  打印\nentering: b in b entering: a in a leaving: a leaving: b  对于习惯块级别资源管理的其他语言的编程人员，defer 可能看起来怪异的，但是它最有趣且强大的应用正来自它不是块级别而是函数级别的事实。在 panic 和 recover 部分，我们会看到另一个可能使用 defer 的例子。\n数据 使用 new 分配 Go 有两种分配原语，即内置函数 new 和 make。它们做了不同的事情且适用于不同类型，这可能有点难以理解，但是规则很简单。我们首先讨论 new。它是一个分配内存的内置函数，但是和一些其他语言的同名函数不同，它不会初始化内存，它只是将内存置零。也就是说，new(T) 为类型 T 的新条目分配置零的存储，并返回存储地址(值为类型 T*)。在 Go 的术语中， 它返回一个指针指向一个新分配的类型 T 的零值。\n因为 new 返回的内存是置零的，当将你的数据结构设计为每个类型的零值都可以直接使用不需要进一步初始化，在安排的时候是很有用的。这意味着数据结构的使用者可以使用 new 创建一个对象并正常工作。比如，bytes.Buffer 的文档声明“ Buffer 的零值是一个就绪的空缓冲”。类似的，sync.Mutex 没有一个显式的构造函数或 Init 方法。反之，sync.Mutex 的零值被定义为一个未上锁的互斥锁。\n“零值是有用的”这一属性可以传递。考虑这个类型声明：\ntype SyncedBuffer struct { lock sync.Mutex buffer bytes.Buffer }  SyncedBuffer 类型的值也是分配或声明时就绪的。在下一个片段中，p 和 v 都可以正确工作而不用进一步安排。\np := new(SyncedBuffer) // *SyncedBuffer 类型 var v SyncedBuffer // SyncedBuffer 类型  构造函数和复合字面量 有时候零值不够好，且需要一个初始化构造函数，正如下面从 os 包衍生的一个例子：\nfunc NewFile(fd int, name string) *File { if fd \u0026lt; 0 { return nil } f := new(File) f.fd = fd f.name = name f.dirinfo = nil f.nepipe = 0 return f }  这里有很多模板式代码。我们可以使用一个“复合字面量”来简化代码。“复合字面量”是一个表达式，它在每次求值时创建一个新的实例。\nfunc NewFile(fd int, name string) *File { if fd \u0026lt; 0 { return nil } f := File{fd, name, nil, 0} return \u0026amp;f }  注意，和 C 不同，返回一个局部变量的地址是完全可以的；和变量相关的存储在函数返回时仍存在。事实上，使用复合字面量的地址在每次求值时分配一个新的实例，因此我们可以合并后面两行代码：\nreturn \u0026amp;File{fd, name, nil, 0}  复合字面量的域按顺序放置且必须都要出现。然而，通过显式给域打像 field:value 的标签，初始化列表可以按任何顺序出现，且缺失的域会分别使用对应的零值。因此我们可以写\nreturn \u0026amp;File{fd: fd, name: name}  作为一个限制性场景，如果一个复合字面量不包含任何域，它会为类型创建零值。表达式 new(File) 和 \u0026amp;File{} 是等价的。\n复合字面量也可用于创建数组、切片和映射，使用索引或合适的键给域打标签，在这些例子中，无论 Enone、Eio 和 Einval 的值是什么，只要它们是唯一的，初始化器都可以工作。\na := [...]string {Enone: \u0026quot;no error\u0026quot;, Eio: \u0026quot;Eio\u0026quot;, Einval: \u0026quot;invalid argument\u0026quot;} s := []string {Enone: \u0026quot;no error\u0026quot;, Eio: \u0026quot;Eio\u0026quot;, Einval: \u0026quot;invalid argument\u0026quot;} m := map[int]string{Enone: \u0026quot;no error\u0026quot;, Eio: \u0026quot;Eio\u0026quot;, Einval: \u0026quot;invalid argument\u0026quot;}  使用 make 分配 数组 切片 二维切片 映射 打印 追加 初始化 常数 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6ccdeadec8efbe462465546d801c9aa7","permalink":"https://xueqing.github.io/translation/go-doc/golangdoc/effective_go/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangdoc/effective_go/","section":"translation","summary":"介绍 例子 格式化 注释 名字 包名 getter 接口名 驼峰 分号 控制结构 if 重新声明和重新赋值 函数 多返回值 命名结果参数 defer 数据 使用 new 分配 构造函数和复合字面量 使用 make 分配","tags":["golang-doc"],"title":"实效 Go 编程","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  列出容器 连接容器 获取容器日志  列出容器 docker ps [OPTIONS]  OPTIONS 说明：\n -a: 显示所有的容器，包括未运行的 -f: 根据条件过滤显示的内容 \u0026ndash;format: 指定返回值的模板文件 -l: 显示最近创建的容器 -n: 列出最近创建的n个容器 \u0026ndash;no-trunc: 不截断输出 -q: 静默模式，只显示容器编号 -s: 显示总的文件大小  列出所有在运行的容器信息。\ndocker ps  输出详情介绍：\n CONTAINER ID: 容器 ID IMAGE: 使用的镜像 COMMAND: 启动容器时运行的命令 CREATED: 容器的创建时间 STATUS: 容器状态。状态有 7 种  created（已创建） restarting（重启中） running（运行中） removing（迁移中） paused（暂停） exited（停止） dead（死亡）  PORTS: 容器的端口信息和使用的连接类型（tcp\\udp） NAMES: 自动分配的容器名称  列出最近创建的 5 个容器信息。\ndocker ps -n 5  列出所有创建的容器 ID。\ndocker ps -a  连接容器 连接到正在运行中的容器。\ndocker attach [OPTIONS] CONTAINER  要 attach 上去的容器必须正在运行，可以同时连接上同一个容器来共享屏幕（与 screen 命令的 attach 类似）。\n容器 mynginx 将访问日志指到标准输出，连接到容器查看访问信息。\ndocker attach --sig-proxy=false mynginx  获取容器日志 docker logs [OPTIONS] CONTAINER  OPTIONS 说明：\n -f: 跟踪日志输出 \u0026ndash;since: 显示某个开始时间的所有日志 -t: 显示时间戳 \u0026ndash;tail: 仅列出最新 N 条容器日志  跟踪查看容器 mynginx 的日志输出。\ndocker logs -f mynginx  查看容器 mynginx 从 2016 年 7 月 1 日后的最新 10 条日志。\ndocker logs --since=\u0026quot;2016-07-01\u0026quot; --tail=10 mynginx  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"180c50aefb29bf601f66d7a979354225","permalink":"https://xueqing.github.io/blog/docker/container/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/docker/container/","section":"blog","summary":"列出容器 连接容器 获取容器日志 列出容器 docker ps [OPTIONS] OPTIONS 说明： -a: 显示所有的容器，包括未运行的 -f: 根据条件过滤显示的内容 \u0026ndash;format: 指定返回值的模板文件 -l: 显示最近创建","tags":["docker"],"title":"容器操作","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  创建容器 启动/停止/重启容器 杀掉容器 删除容器  创建容器 创建一个新的容器并运行一个命令。\ndocker run [OPTIONS] IMAGE [COMMAND] [ARG...]  OPTIONS 说明：\n -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项 -d: 后台运行容器，并返回容器ID -i: 以交互模式运行容器，通常与 -t 同时使用 -P: 随机端口映射，容器内部端口随机映射到主机的高端口 -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用 \u0026ndash;name string: 为容器指定一个名称 \u0026ndash;dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致 \u0026ndash;dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致 -h \u0026ldquo;mars\u0026rdquo;: 指定容器的hostname -e username=\u0026ldquo;ritchie\u0026rdquo;: 设置环境变量 \u0026ndash;env-file=[]: 从指定文件读入环境变量 \u0026ndash;cpuset-cpus string: 绑定容器到指定 CPU 运行(\u0026ldquo;0-2\u0026rdquo;/\u0026ldquo;0,1,2\u0026rdquo;) -m: 设置容器使用内存最大值 \u0026ndash;net=\u0026ldquo;bridge\u0026rdquo;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型 \u0026ndash;link=[]: 添加链接到另一个容器 \u0026ndash;expose=[]: 开放一个端口或一组端口 \u0026ndash;volume , -v: 绑定一个卷  使用 docker 镜像 nginx:latest 以后台模式启动一个容器,并将容器命名为 mynginx。\ndocker run --name \u0026quot;mynginx\u0026quot; -d nginx:latest  使用镜像 nginx:latest 以后台模式启动一个容器,并将容器的 80 端口映射到主机随机端口。\ndocker run -P -d nginx:latest  使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。\ndocker run -p 80:80 -v /data:/data -d nginx:latest  绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。\ndocker run -p 127.0.0.1:80:8080/tcp ubuntu bash  使用镜像 nginx:latest 以交互模式启动一个容器,在容器内执行/bin/bash命令。\ndocker run -it nginx:latest /bin/bash  启动/停止/重启容器 # 启动一个或多个已经被停止的容器 docker start [OPTIONS] CONTAINER [CONTAINER...] # 停止一个运行中的容器 docker stop [OPTIONS] CONTAINER [CONTAINER...] # 重启容器 docker restart [OPTIONS] CONTAINER [CONTAINER...]  启动已被停止的容器 myrunoob。\ndocker start myrunoob  停止运行中的容器 myrunoob。\ndocker stop myrunoob  重启容器 myrunoob。\ndocker restart myrunoob  杀掉容器 杀掉一个运行中的容器。\ndocker kill [OPTIONS] CONTAINER [CONTAINER...]  OPTIONS 说明：\n -s: 向容器发送一个信号  杀掉运行中的容器 mynginx。\ndocker kill -s KILL mynginx  删除容器 删除一个或多少容器。\ndocker rm [OPTIONS] CONTAINER [CONTAINER...]  OPTIONS 说明：\n -f: 通过SIGKILL信号强制删除一个运行中的容器 -l: 移除容器间的网络连接，而非容器本身 -v: 删除与容器关联的卷  强制删除容器db01、db02。\ndocker rm -f db01 db02  移除容器 nginx01 对容器 db01 的连接，连接名 db。\ndocker rm -l db  删除容器 nginx01，并删除容器挂载的数据卷。\ndocker rm -v nginx01  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"ef2ce8a20a46f17721984cbf96a2e15b","permalink":"https://xueqing.github.io/blog/docker/container_life/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/docker/container_life/","section":"blog","summary":"创建容器 启动/停止/重启容器 杀掉容器 删除容器 创建容器 创建一个新的容器并运行一个命令。 docker run [OPTIONS] IMAGE [COMMAND] [ARG...] OPTIONS 说明： -a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR","tags":["docker"],"title":"容器生命周期管理命令","type":"blog"},{"authors":["kiki"],"categories":["reading"],"content":" 因此在雨水充沛的小森，各家都用塑料大棚来种植西红柿。我的西红柿却是露天栽培，偶尔遇到少雨的年头还算不错，多数情况是遭遇病害，收获屈指可数。 要是建了温室大棚，就感觉自己已经决定一直呆在这里，所以我一直在拖着。\n ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"cf6cc3e05fcfb1e72e1a4c93b27e0389","permalink":"https://xueqing.github.io/reading/%E5%B0%8F%E6%A3%AE%E6%9E%97/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/reading/%E5%B0%8F%E6%A3%AE%E6%9E%97/","section":"reading","summary":"因此在雨水充沛的小森，各家都用塑料大棚来种植西红柿。我的西红柿却是露天栽培，偶尔遇到少雨的年头还算不错，多数情况是遭遇病害，收获屈指可数。 要","tags":["food","life"],"title":"小森林","type":"reading"},{"authors":["kiki"],"categories":["blog"],"content":" Windows    快捷键组合 功能     Ctrl+Shift+P 显示命令面板   Ctrl+P 显示最近打开文件   Ctrl+Shift+F 在工作区所有文件中查找   Shift+Alt+F 在文件夹中查找   Ctrl+F 在当前文件中查找   Ctrl+Shift+H 在工作区所有文件中替换   Ctrl+H 在当前文件中替换   Ctrl+Shift+` 新建终端   Ctrl+` 切换终端   Alt+/ 显示输入候选列表   Ctrl+= 放大   Ctrl+- 缩小   Ctrl+-\u0026gt; 前进   Ctrl+\u0026lt;- 返回   F2 文件或文件夹重命名   Shift+Alt+C 复制路径    Ubuntu    快捷键组合 功能     Ctrl+Shift+P 显示命令面板   Ctrl+P 显示最近打开文件   Ctrl+Shift+F 在工作区所有文件中查找   Shift+Alt+F 在文件夹中查找   Ctrl+F 在当前文件中查找   Ctrl+Shift+H 在工作区所有文件中替换   Ctrl+H 在当前文件中替换   Ctrl+Shift+` 新建终端   Ctrl+` 切换终端   Alt+/ 显示输入候选列表   Ctrl+= 放大   Ctrl+- 缩小   Ctrl+Shift+- 前进   Ctrl+Alt+- 返回   F2 文件或文件夹重命名   Ctrl+Alt+C 复制路径    增加快捷键 设置大小写  打开 File-\u0026gt; Preferences -\u0026gt; Keyboard Shortcuts 搜索 upper，看到 editor.action.transformToUppercase，选中左边的加号，增加快捷键设置 Ctrl+Shift+u 搜索 lower，看到 editor.action.transformToLowercase，选中左边的加号，增加快捷键设置 Ctrl+Shift+l  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0c30b2eada737062eb3deaa752c6ef0a","permalink":"https://xueqing.github.io/blog/vscode/%E5%BF%AB%E6%8D%B7%E9%94%AE/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vscode/%E5%BF%AB%E6%8D%B7%E9%94%AE/","section":"blog","summary":"Windows 快捷键组合 功能 Ctrl+Shift+P 显示命令面板 Ctrl+P 显示最近打开文件 Ctrl+Shift+F 在工作区所有文件中查找 Shift+Alt+F 在文件夹中查找 Ctrl+F 在当前文件中查找 Ctrl+Shift+H 在工作区所有文件中替换 Ctrl+H 在当前文","tags":["vscode"],"title":"常用快捷键","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  1 恢复之前删除的文件 2 将 dev 分支快速合并到 master 分支 3 将基于 server 分支的 client 分支的提交和 server 的提交快速合并到 master 分支 4 从所有提交中删除某文件 5 将 dev 新提交的代码合并到 master 分支  6 撤消操作   1 恢复之前删除的文件 比方 A，B，C，D 是四个连续的提交，其中 B 基于 A 删除了一些文件。现在需要把这些删除的文件加回 D。假设现在位于 D\n# 方法1：A与B的差别是那些删除的文件。可以创建一个补丁代表这些差别，然后打补丁 git diff B A | git apply # 方法2：从 A 中把文件拿出来 git checkout A foo.c bar.h # 方法3：把从 A 到 B 的变化视为可撤销的变更 git revert B  2 将 dev 分支快速合并到 master 分支 # 找到 dev 和 master 分支最近共同祖先, 提取 dev 分支相对于最近共同祖先所做的所有提交修改并存为临时文件, # 然后将 dev 分支 指向 master 分支, 最后将之前另存的临时文件的修改依次应用 # 等同于 git checkout dev \u0026amp;\u0026amp; git rebase master git rebase master dev # 切回 master 分支, 进行一次快速合并 git checkout master \u0026amp;\u0026amp; git merge dev  3 将基于 server 分支的 client 分支的提交和 server 的提交快速合并到 master 分支 # 取出 client 分支, 找出处于 client 和 server 分支的共同祖先之后的修改, 然后把它们在 master 分支上重放一遍 git rebase --onto master server client # 切回 master 分支, 进行一次快速合并 git checkout master \u0026amp;\u0026amp; git merge client # 将 server 分支变基到目标分支 master # 等同于 git checkout server \u0026amp;\u0026amp; git rebase master git rebase master server # 切回 master 分支, 进行一次快速合并 git checkout master \u0026amp;\u0026amp; git merge server # 删除两个分支 git branch -d client server  4 从所有提交中删除某文件  5 将 dev 新提交的代码合并到 master 分支  合并分支分两种\n 刻意制造分支，使得版本迭代历史更加清晰 --no-off 即执行正常合并，在当前分支上生成一个合并节点 不加 --no-off，git 默认执行“快速合并（fast-forward merge）”，如果 dev 分支本来是基于最新的 master 分支开发的，合并之后 master 分支会指向当前的 dev 分支 将提交历史直线化，使得 master 分支的提交历史没有分叉\n# 1 切换到 dev 分支 git checkout dev # 2 提交修改 git commit -a -m \u0026quot;xxx\u0026quot; # 3 切换到 master 分支 git checkout master # 4 拉取最新的代码 git pull --rebase origin master # 5 合并分支 # 5.1 刻意制造分支：合并 dev 分支代码到 master 分支 git merge --no-off dev # 5.2 将提交历史直线化 # 5.2.1 切换到要合并的分支 git checkout dev # 5.2.2 将需要提交的代码变基到最新的 master 分支 git rebase master # 5.2.3 切换到 master 分支 git checkout master # 5.2.4 快速合并 dev 分支 git merge dev # 6 推送代码到远程仓库 git push origin master    6 撤消操作 # 尝试重新提交 git commit --amend # 取消暂存文件 f1 git reset HEAD f1 # 撤消之前对文件 f1 所做的修改 git checkout -- f1 # git reset [--hard | soft | mixed | merge | keep] [HEAD | \u0026lt;commit\u0026gt;]  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f6cdbb55d8e945cd90503c39bb0ac12d","permalink":"https://xueqing.github.io/blog/git/git_scenario/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_scenario/","section":"blog","summary":"1 恢复之前删除的文件 2 将 dev 分支快速合并到 master 分支 3 将基于 server 分支的 client 分支的提交和 server 的提交快速合并到 master 分支 4 从所有提交中删除某文件 5 将 dev 新提交的代","tags":["git"],"title":"常见场景","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 显示反引号  用两个反引号`  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1215c4c56bd92aa6e4086d28c8ccaa22","permalink":"https://xueqing.github.io/blog/markdown/problem/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/markdown/problem/","section":"blog","summary":"显示反引号 用两个反引号`","tags":["md"],"title":"常见问题","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  起源 用法 设计  为什么 Go 没有断言  类型 值 编写代码 指针和分配 并发 函数和方法 控制流 包和测试 实现  我最喜欢的测试辅助函数在哪里  性能 从 C 的改变  参考 Go 官方文档——常见问题解答学习。\n起源 用法 设计 为什么 Go 没有断言 Go 不提供断言。他们无疑是方便的，但是我们已有的经验是开发人员依赖断言避免思考合适的错误处理和报告。合适的错误处理意味着服务在一个非严重的错误之后继续操作而不是崩溃。合适的错误处理意味着错误是直接的、扼要的，使开发人员免于解释大量的崩溃跟踪。当看到错误的开发人员不熟悉代码，错误的准确尤为重要。\n我们明白这是一个争论点。Go 语言和库有很多不同于现代实践的地方，只是因为我们感觉有时候值得尝试一个不同的方法。\n类型 值 编写代码 指针和分配 并发 函数和方法 控制流 包和测试 实现 我最喜欢的测试辅助函数在哪里 Go 的标准 testing 包使得易于编写单元测试，但是它缺少其他语言测试框架提供的一些特性，比如断言函数。此文档前面的部分解释了为什么 Go 没有断言，以及在测试中使用断言的相同论点。合适的错误处理意味着使得其他测试在一个测试失败时继续运行，以便调试错误的人员可以得到一个错误的完整信息。对于一个测试来说，比起报告 isPrime 对于 2 的答案是错误的并因此不再运行更多测试，报告 isPrime 对 2、3、5、7 (或 2、4、8、16) 给出错误的答案是更加有用的。触发测试错误的开发人员可能不熟悉失败的代码。在测试失败时，花费时间编写一个好的错误消息是值得的。\n相关的一点是测试框架趋向于发展成为他们自己的微语言，包括条件、控制和打印机制，但是 Go 已经有所有这些功能了；为什么要创建他们？我们更愿意用 Go 编写测试；它是一门学习更少的语言，而且这个方法保持测试是直截了当易于理解的。\n如果编写好的错误所需的额外代码数量看起来是重复的、巨大的，那么表驱动测试可能效果更好。表驱动是迭代遍历定义在一个数据结构(Go 对于数据结构字面量有极好的支持)的输入和输出列表。编写一个好的测试和错误信息的工作在测试拥挤很多时将会被分摊。标准的 Go 库有许多说明示例，比如 fmt 包的格式化测试。\n性能 从 C 的改变 ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6c26f520b3123c91136f2e28127cf273","permalink":"https://xueqing.github.io/translation/go-doc/golangdoc/faq/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/golangdoc/faq/","section":"translation","summary":"起源 用法 设计 为什么 Go 没有断言 类型 值 编写代码 指针和分配 并发 函数和方法 控制流 包和测试 实现 我最喜欢的测试辅助函数在哪里 性能 从 C 的改变 参考 Go 官方文档","tags":["golang-doc"],"title":"常见问题解答","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  坚持阅读现存软件源码 进入下一阶段之前完成文档：设计方法、要诀和技巧、特殊函数/命令/指令、学习的教训、特殊场景、调试方法、最好的实践、任何对未来有帮助的 遵循定义好的规范，不要创建规范：文件命名习俗、函数/模块命名习俗、变量命名习俗、历史/缩进/注释、可读性指导、do/don\u0026rsquo;t 列表 写的代码应该被评审：不好的代码、不遵循规范、没有考虑性能、历史/缩进/注释不合适、可读性差、未关闭打开的文件、未释放申请的内存、太多全局变量、太多硬编码、不好的错误处理、没有模块化、重复的代码 像宗教信仰一样遵循测试 保持代码和文件的安全性 保持工具和技术是已使用的 持续学习  有用的书  Better Software. Faster!: Best Practices in Virtual Prototyping The Art of Lean Software Development Software Architecture in Practice (3rd Edition) (SEI Series in Software Engineering) Software Requirements (3rd Edition) (Developer Best Practices) Software Requirement Patterns (Developer Best Practices) Software Engineering Best Practices: Lessons from Successful Projects in the Top Companies  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"3584c0f12a1a7cb0bb0b8b9729aefdb9","permalink":"https://xueqing.github.io/blog/others/developers_best_practices/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/others/developers_best_practices/","section":"blog","summary":"坚持阅读现存软件源码 进入下一阶段之前完成文档：设计方法、要诀和技巧、特殊函数/命令/指令、学习的教训、特殊场景、调试方法、最好的实践、任何对","tags":["develop"],"title":"开发人员最佳实践","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 原文\n几种典型的开发方式  软件开发中的“锁”  技术能力上的锁：需要不同的语言开发一个项目，每人只会一种语言 负责模块上的锁：不同的人负责不同的模块 时间锁、进度锁：掌握语言或模块负责的人不同，需要协作开发 沟通锁、利益锁：人员增多会增加沟通成本 解决方案 一个程序员应该可以掌握多个语言，能够负责多个模块甚至不同的职责  接力棒式软件开发  底层开发-上层开发-测试-运维。。。 解决方案 不同的团队有自己的框架（开发框架和服务框架），使得其他团队可以自己接入  保姆式软件开发  从产品到研发、测试和运维，每个团队没有较好的完成自己的工作，需要之后的团队来发现问题 产品的需求不完整，后期边开发边加需求 研发没有充分测试自己的代码，使得测试花更多时间来定位错误 测试没有充分测试产品，使得运维需要花更多时间重新部署服务 解决方案 招聘懂“需求”、注重“软件工程”、“软件质量”和“软件维护”的工程师 自己管理自己 支持性工作的人越少越好 服务化。我服务于代表让对方做起事来更容易  WatchDog 软件开发  为了解决某个系统的问题，要用一个新的系统去监控 解决方案 想好设计，多评估几个设计，简化流程  故障驱动式软件开发  以上线为目的，出问题再改，使得后期话更多时间定为错误、重构代码 解决方案 基础知识和理论知识的重要性，多使用成熟的方案 考虑清楚再写实现，做好设计  总结  软件工程师分工分得越细这个团队就越没效率，团队间的服务化是关键的关键 需要在一个环节上认真，这个环节越往前就越有效率，越往后就越没效率：需求收集-设计和编码-测试 “小而精的团队”+“条件和资源受限”是效率的根本，这样才会用最经济的手段做最有价值的事 软件架构上要松耦合，团队组织上要紧耦合 工程师文化是关键，重视过程就是重视结果   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7a5a55651067d108cabfe319524c6c3a","permalink":"https://xueqing.github.io/blog/coolshell/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E6%95%88%E7%8E%87/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/coolshell/%E5%BC%80%E5%8F%91%E5%9B%A2%E9%98%9F%E7%9A%84%E6%95%88%E7%8E%87/","section":"blog","summary":"原文 几种典型的开发方式 软件开发中的“锁” 技术能力上的锁：需要不同的语言开发一个项目，每人只会一种语言 负责模块上的锁：不同的人负责不同的模块 时","tags":["coolshell"],"title":"开发团队的效率","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  为什么使用异常 C++ 使用异常  使用异常的反对观点 替代方案：通过判断或函数返回值检查错误 使用 try/catch/throw 而不是条件判断和返回错误码来改善软件质量 异常便于传递错误信息 异常使得代码更简洁 异常更易区分正常执行的代码 使用异常处理错误是值得的 构造函数可以抛异常 析构函数不抛异常 抛出什么异常 捕获什么异常 throw 再次抛异常 注解  参考  为什么使用异常  使用异常处理错误使得代码更简单、更干净，并且更不可能错过错误。使用 errno 和 if 语句使得错误处理和普通代码紧密缠绕，因此代码更加凌乱，也更难确保已经处理了所有的错误。 构造函数的工作是创建类的不变性(创建成员函数运行的环境)，这经常需要获取如内存、锁、文件、套接字等资源，即 RAII(Resource Acquisition Is Initialization)。 报告一个构造函数检查到的错误需要抛异常实现。  C++ 使用异常  C++ 中，异常用于指示内部不能处理的错误，比如构造函数内部获取资源失败。 不要使用异常作为函数的返回值。 C++ 使用异常来支持错误处理：  使用 throw 指示错误(函数不能处理错误，或者暴露错误的后置条件)。 在知道可以处理错误的时候使用 catch 指定错误处理行为(可以翻译成另一种类型并且重新抛出)。 不要使用 throw 指示调用函数的代码错误。而是使用 assert 或其他机制，或者发送进程给调试器，或者使得进程崩溃并收集崩溃日志以便程序员调试。 当发现对组件不变式的意外违反时，不要使用 throw，使用 throw 或其他机制来终止程序。抛出异常不能解决内存崩溃甚至会导致后续使用数据的错误。   使用异常的反对观点  异常是昂贵的：和没有错误处理相比，现代 C++ 实现已经将异常的负载降到 3% 左右。正常情况不抛异常，比使用返回值和检查代码运行更快。只有出现错误才会有负载。 JSF++ 禁止异常：JSF++ 是硬实时和严格安全性的应用(飞机控制系统)。我们必须保证响应时间，所以我们不能使用异常，甚至禁止使用释放分配的存储。 使用 new 调用构造函数抛异常会导致内存泄漏：这是旧编译器的 bug，现在早已经解决了。\nT *p= new T;//将被编译器转换给类似下面的代码 void allocate_and_construct() { // 第一步，分配原始内存，若失败则抛出bad_alloc异常 try { // 第二步，调用构造函数构造对象 new (p)T; // placement new: 只调用T的构造函数 } catch(...) { delete p; // 释放第一步分配的内存 throw; // 重抛异常，通知应用程序 } }   替代方案：通过判断或函数返回值检查错误 ofstream os(\u0026quot;myfile\u0026quot;);//需要打开一个文件 if(os.bad()) { /*打开失败需要处理错误*/ }   可以通过函数返回一个错误码或设置一个局部变量(如 errno)。  不使用全局变量：全局变量需要立即检查，因为其他函数可能会重置它；多线程也会有问题。 这就需要测试每个对象。当类由许多对象组成，尤其是这些子对象互相依赖时，会导致代码一团糟。  但是检查返回值要求智慧甚至不可能达到目的。比如下面的代码\n 对于 my_negate 函数，每一个 int 返回值都是正确的，但是当使用二进制补码表示的时候，是没有最大负数的，可参考C语言中INT_MIN的一些问题。这种情况下，就需要返回值对，分别表示错误码和运算结果。\ndouble d = my_sqrt(-1);//错误返回 -1 if(d == -1) { /*处理错误*/ } int x = my_negate(INT_MIN);//额。。。    使用 try/catch/throw 而不是条件判断和返回错误码来改善软件质量  条件语句更易犯错 延迟发布时间：白盒测试需要覆盖所有条件分支 增加开发花费：非必须的条件控制增加了发现 bug、解决 bug 和测试的复杂度 检测到错误的代码通常需要传递错误信息，这可能是多层函数调用，这种情况下每一层调用函数都需要添加判断代码和返回值；而异常可以更简洁、干净地传递错误信息到可以处理错误的调用者  异常便于传递错误信息  使用异常\nvoid f1() { try { // ... f2(); // ... } catch (some_exception\u0026amp; e) { // ...code that handles the error... } } void f2() { ...; f3(); ...; } // f3 到 f9 逐层调用，f9 调用 f10 void f10() { // ... if ( /*...some error condition...*/ ) throw some_exception(); // ... }  不使用异常\nint f1() { // ... int rc = f2(); if (rc == 0) { // ... } else { // ...code that handles the error... } } int f2() { // ... int rc = f3(); if (rc != 0) return rc; // ... return 0; } // f3 到 f9 都需要增加判断代码 int f10() { // ... if (...some error condition...) return some_nonzero_error_code; // ... return 0; }   异常使得代码更简洁 Number 类支持加减乘除 4 种基本运算，但是加会溢出，除会导致除 0 错误或向下溢出等等\n 使用异常\nvoid f(Number x, Number y) { try { // ... Number sum = x + y; Number diff = x - y; Number prod = x * y; Number quot = x / y; // ... } catch (Number::Overflow\u0026amp; exception) { // ...code that handles overflow... } catch (Number::Underflow\u0026amp; exception) { // ...code that handles underflow... } catch (Number::DivideByZero\u0026amp; exception) { // ...code that handles divide-by-zero... } }  不使用异常\nint f(Number x, Number y) { // ... Number::ReturnCode rc; Number sum = x.add(y, rc); if (rc == Number::Overflow) { // ...code that handles overflow... return -1; } else if (rc == Number::Underflow) { // ...code that handles underflow... return -1; } else if (rc == Number::DivideByZero) { // ...code that handles divide-by-zero... return -1; } Number diff = x.sub(y, rc); if (rc == Number::Overflow) { // ...code that handles overflow... return -1; } else if (rc == Number::Underflow) { // ...code that handles underflow... return -1; } else if (rc == Number::DivideByZero) { // ...code that handles divide-by-zero... return -1; } Number prod = x.mul(y, rc); if (rc == Number::Overflow) { // ...code that handles overflow... return -1; } else if (rc == Number::Underflow) { // ...code that handles underflow... return -1; } else if (rc == Number::DivideByZero) { // ...code that handles divide-by-zero... return -1; } Number quot = x.div(y, rc); if (rc == Number::Overflow) { // ...code that handles overflow... return -1; } else if (rc == Number::Underflow) { // ...code that handles underflow... return -1; } else if (rc == Number::DivideByZero) { // ...code that handles divide-by-zero... return -1; } // ... }   异常更易区分正常执行的代码  使用异常\nvoid f() // Using exceptions { try { GResult gg = g(); HResult hh = h(); IResult ii = i(); JResult jj = j(); // ... } catch (FooError\u0026amp; e) { // ...code that handles \u0026quot;foo\u0026quot; errors... } catch (BarError\u0026amp; e) { // ...code that handles \u0026quot;bar\u0026quot; errors... } }  不使用异常\nint f() // Using return-codes { int rc; // \u0026quot;rc\u0026quot; stands for \u0026quot;return code\u0026quot; GResult gg = g(rc); if (rc == FooError) { // ...code that handles \u0026quot;foo\u0026quot; errors... } else if (rc == BarError) { // ...code that handles \u0026quot;bar\u0026quot; errors... } else if (rc != Success) { return rc; } HResult hh = h(rc); if (rc == FooError) { // ...code that handles \u0026quot;foo\u0026quot; errors... } else if (rc == BarError) { // ...code that handles \u0026quot;bar\u0026quot; errors... } else if (rc != Success) { return rc; } IResult ii = i(rc); if (rc == FooError) { // ...code that handles \u0026quot;foo\u0026quot; errors... } else if (rc == BarError) { // ...code that handles \u0026quot;bar\u0026quot; errors... } else if (rc != Success) { return rc; } JResult jj = j(rc); if (rc == FooError) { // ...code that handles \u0026quot;foo\u0026quot; errors... } else if (rc == BarError) { // ...code that handles \u0026quot;bar\u0026quot; errors... } else if (rc != Success) { return rc; } // ... return Success; }   使用异常处理错误是值得的  使用异常处理错误需要付出  异常处理要求原则和严谨：需要学习； 异常处理不是万能药：如果团队是草率没有纪律的，那么使用异常和返回值都会有问题 异常处理不是通用的：应当知道什么条件应该使用返回值，什么条件使用异常 异常处理会鞭策学习新技术   构造函数可以抛异常  当不能正确初始化或构造一个对象时，应该在构造函数内部抛出异常  构造函数没有返回值，所以不能使用返回错误码的方式 最差的方式是使用一个内部状态码来判断是否构造成功，但是需要在每次调用构造函数的时候使用 if 检查状态码，或者在成员函数内部增加 if 检查  构造函数抛异常也不会有内存泄漏\n 构造函数抛异常时，对象的析构函数不会运行。因为对象的生命周期是构造函数成功完成或返回，抛异常表示构造失败，生命周期没有开始。因此需要将 undone 的东西保存在对象的数据成员 比如使用智能指针保存分配的成员对象，而不是保存到原始的 Fred* 数据成员\n// Fred.h #include \u0026lt;memory\u0026gt; class Fred { public: //typedef 简化了使用 Fred 对象的语法，可以使用Fred::Ptr 取代 std::unique_ptr\u0026lt;Fred\u0026gt; typedef std::unique_ptr\u0026lt;Fred\u0026gt; Ptr; // ... }; //调用者 cpp #include \u0026quot;Fred.h\u0026quot; void f(std::unique_ptr\u0026lt;Fred\u0026gt; p); // explicit but verbose void f(Fred::Ptr p); // simpler void g() { std::unique_ptr\u0026lt;Fred\u0026gt; p1( new Fred() ); // explicit but verbose Fred::Ptr p2( new Fred() ); // simpler // ... }    析构函数不抛异常  析构函数抛异常会导致异常点之后的代码不能指向，可能造成内存泄漏问题 可以在析构函数抛异常，但是该异常不能出析构函数，即需要在析构函数内部使用 catch 捕获异常。否则会破坏标准库和语言的规则。 处理方式是：  可以写信息到日志文件，终止进程。 提供一个普通函数执行可能抛异常的操作，给客户处理错误。  C++ 规则是异常的 “栈展开(stack unwinding)” 进程中调用的析构函数不能抛异常：  “stack unwinding”：当抛出一个异常时，栈是 “unwound” 的，因此在 throw 和 catch 之间的栈帧会被弹出。 在 “stack unwinding” 过程中，这些栈帧中的所有局部变量会被析构。如果其中一个析构函数抛出异常，C++ 运行时系统将进入 “no-win” 状态：两个异常只能处理一个，忽视任何一个都会丢失信息。 此时 C++ 会调用 terminate() 终止进程。即在发生异常的情况下调用析构函数抛出异常会导致程序崩溃。因此避免的方法就是永远不要在析构函数抛异常。   抛出什么异常  抛出对象。如果可以，写子类继承自 std::exception 类，可以提供更多关于异常的信息  捕获什么异常  可以的话，捕获异常的引用：拷贝可能会有不同的行为；指针则不确定是否需要删除指向异常的指针  throw 再次抛异常  可用于实现简单的 “stack-trace”，即堆栈跟踪，在程序重要函数内部增加 catch 语句\nclass MyException { public: // ... void addInfo(const std::string\u0026amp; info); // ... }; void f() { try { // ... } catch (MyException\u0026amp; e) { e.addInfo(\u0026quot;f() failed\u0026quot;); throw;//再次抛出当前异常 } }  也可用于 “exception dispatcher”，即异常分发\nvoid handleException() { try { throw; } catch (MyException\u0026amp; e) { // ...code to handle MyException... } catch (YourException\u0026amp; e) { // ...code to handle YourException... } } void f() { try { // ...something that might throw... } catch (...) { handleException(); } }   注解  不是所有编译器支持异常捕获(exception-try-block)，只有 GCC 和大多数新版本的 MSVC 支持。 初始化的异常不能被隐藏：构造函数内的异常处理部分必须抛出一个异常，或重新抛出捕获的异常。下面两个版本的代码是等价的\n// Version 1 struct A { Buf b_; A(int n) try : b_(n) { cout \u0026lt;\u0026lt; \u0026quot;A initialized\u0026quot; \u0026lt;\u0026lt; endl; } catch(BufError\u0026amp; ) { cout \u0026lt;\u0026lt; \u0026quot;BufError caught\u0026quot; \u0026lt;\u0026lt; endl; } }; // Version 2 struct A { Buf b_; A(int n) try : b_(n) { cout \u0026lt;\u0026lt; \u0026quot;A initialized\u0026quot; \u0026lt;\u0026lt; endl; } catch(BufError\u0026amp; be) { cout \u0026lt;\u0026lt; \u0026quot;BufError caught\u0026quot; \u0026lt;\u0026lt; endl; throw; } };   参考  Throwing Catch Throwing exceptions from constructors Exception in constructor exceptions Can a constructor throw an exception in Java? Can constructors throw exceptions in Java? C++构造函数、析构函数与抛出异常  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6186c12fc339e7f81cbd63848c9935c1","permalink":"https://xueqing.github.io/blog/cplusplus/exception/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/exception/","section":"blog","summary":"为什么使用异常 C++ 使用异常 使用异常的反对观点 替代方案：通过判断或函数返回值检查错误 使用 try/catch/throw 而不是条件判断和返回错误码来改善软件质量 异常便于传递错","tags":["c++"],"title":"异常","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  defer 使用  defer 栈  panic 使用 recover 使用\n Go 不支持 try..catch..finally 这种异常。使用多值返回来返回错误\n 在极端情况下才用异常（如除数为 0），异常处理使用了 defer，panic，recover\n go 可以抛出一个 panic 的异常，在 defer 中通过 recover 捕获异常，然后处理\n  defer 使用  defer 的参数值是在执行 defer 语句的地方立即计算的，而不是在调用实际函数的时候计算，但是会在对应环境返回时调用函数 应用场景：与代码流无关必须执行的函数或方法调用\n 等待并发结束 打开一些资源的时候，遇到错误需要提前返回，在返回前需要关闭对应的资源\nfunc readWritFile() bool { file.open(\u0026quot;file\u0026quot;) defer file.close() if faiure1 { return false } if failure2 { return false } return true }    defer 栈  可以在函数中添加多个 defer 语句。当函数执行到最后，返回之前，会逆序执行这些语句，类似一个 defer 栈\npackage main import ( \u0026quot;fmt\u0026quot; ) func main() { fmt.Println(\u0026quot;counting\u0026quot;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } fmt.Println(\u0026quot;done\u0026quot;) }   panic 使用  panic 用来表示非常严重的不可恢复的错误。是一个内置函数 函数执行到 panic，不会继续执行，但是会执行 defer 的代码，之后将控制转移给调用者，向上传递，直至遇到打印 panic 消息，打印堆栈，然后终止 场景 1：一个不可恢复的错误,程序不能继续执行。如 web 服务不能绑定端口 场景 2：编程错误，如空指针访问  recover 使用  在 panic 之后，执行 defer 的时候可以将 panic 捕获，阻止 panic 向上传递。 在 defer 的地方调用 recover 函数，如果有 panic，被捕获的 panic 就不会向上传递，defer 处理完之后返回\n recover 只在 defer 中调用才有用 只有在相同的 goroutine 中调用 recover 才有效 运行时的 panic 也可用 recover 捕获恢复 在 recover 之后会丢失堆栈，可在 recover 中获取和打印堆栈，使用debug.PrintStack()打印堆栈\npackage main import \u0026quot;fmt\u0026quot; func caller() { fmt.Println(\u0026quot;Enter caller\u0026quot;) defer func() { //先声明 defer fmt.Println(\u0026quot;Enter func\u0026quot;) if err := recover(); err != nil { fmt.Println(err) //打印 panic 传入的内容 } fmt.Println(\u0026quot;Leave func\u0026quot;) }() callee() fmt.Println(\u0026quot;Leave caller\u0026quot;) } func callee() { fmt.Println(\u0026quot;Enter callee\u0026quot;) panic(-1) fmt.Println(\u0026quot;Leave callee\u0026quot;) } func main() { caller() }    输出结果是\nEnter caller Enter callee Enter func -1 Leave func  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"5b429427c1294b37e62d6094de762641","permalink":"https://xueqing.github.io/blog/go/basic/go_exception/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/go/basic/go_exception/","section":"blog","summary":"defer 使用 defer 栈 panic 使用 recover 使用 Go 不支持 try..catch..finally 这种异常。使用多值返回来返回错误 在极端情况下才用异常（如除数为 0），异常处理使用了 defer，panic，r","tags":["go"],"title":"异常处理","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 课程链接  Distributed Systems  教程链接  Code your own blockchain with golang  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7b7c11fb2269238dceefa89a9382773c","permalink":"https://xueqing.github.io/blog/course/interesting_links/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/course/interesting_links/","section":"blog","summary":"课程链接 Distributed Systems 教程链接 Code your own blockchain with golang","tags":["course"],"title":"感兴趣的链接","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  公钥基础设施 PKI X.509  X.509 证书 CA 用户证书 证书撤销  参考  公钥基础设施 PKI  PKI 系统: 由硬件、软件、人、策略和程序构成的一整套体系 功能: 用来创建，管理，存储，分发和撤销建立在非对称密码算法之上的数字证书 目的: 用来安全、便捷、高效地获得公钥  PKIX(Public Key Infrastructure X.509) 模型的关键元素\n 端实体: 必备元素。可以是一个终端用户、设备(如应用服务器、路由器等)，或是其他可以在一个公钥数字证书作用范围中被认证的实体。终端实体支持 PKI 相关的设备 签证机构 CA: 证书和证书撤销列表的发行人，常常在其上运行着一个或多个注册机构，同时还承担一些管理任务 注册机构 RA: 可选元素。可承担一些签证机构的管理任务。一般来说都是和端实体的注册相关的任务，也可支持一些其他的管理任务 证书撤销列表发布点: 可选元素。签证机构可通过它来发布证书撤销列表 证书存取库: 必备元素。提供了存取数字证书和证书撤销列表的方法，可以被终端用户检索  X.509  X.509 是基于公钥密码体制和数字签名的服务 标准中并未规定使用某个特定的算法，但是推荐使用 RSA 其数字签名需要用的 Hash 函数，但是没有规定具体的 Hash 算法  X.509 证书  X.509 的核心是与每个用户相关的公钥证书 证书由一些可信的签证机构(CA)创建并被 CA 或用户放入目录服务器中 目录服务器为用户获得证书提供一种简单的存取方式，本身不创建公钥和证书  X.509 证书包含三个文件\n key: 服务器上的私钥文件，用于对发送给客户端数据的加密，以及对从客户端收到的数据的解密 csr: 证书签名请求文件，用于提交给证书签证机构 CA 对证书签名 crt: 由证书签证机构 CA 签名后的证书，或是开发者自签名的证书，包含证书持有人的信息，持有人的公钥，以及签署者的签名等信息  CA 用户证书 CA 生成的用户证书的特点\n 任何可以访问 CA 公钥的用户均可获得证书中的用户公钥 只有 CA 可以修改证书  证书不可伪造，因此可将证书存放在目录中而不需要对目录进行特别保护\n证书撤销 提前撤回证书的原因有\n 用户私钥被认为不安全 用户不再信任该 CA。原因包括主体名已改变、证书已被废弃或证书没有按照 CA 的规则发行 CA 证书被认为不安全  CRL: 证书撤销表。包含所有被 CA 撤销还未到期的证书，包括发给用户和其他 CA 的证书\n参考  数字证书的有效性验证 国密算法SM2证书制作 SM2非对称算法加解密 SM2国密算法证书解析 数字证书原理  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a897c06c13d0521d3b71037a1039d2a7","permalink":"https://xueqing.github.io/blog/sip/certificate/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/certificate/","section":"blog","summary":"公钥基础设施 PKI X.509 X.509 证书 CA 用户证书 证书撤销 参考 公钥基础设施 PKI PKI 系统: 由硬件、软件、人、策略和程序构成的一整套体系 功能: 用来创建，管理，存储，分","tags":["sip"],"title":"数字证书","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 数组退化  类型和纬度丢失就是数组退化。通常发生在通过值或指针传递数组。这种情况下，数组发送的是它的首地址，因此数组的大小不是原始大小，而是首地址在内存中占用的大小。 下面的代码中，实际数组有 7 个 int 元素，因此大小是 28。但是调用时传递值和指针，数组退化成指针，打印的是 1 个指针的大小\n#include \u0026lt;iostream\u0026gt; using namespace std; void decayByPassVal(int *p) { cout \u0026lt;\u0026lt; \u0026quot;Modified size of array by passing by value: \u0026quot; \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; } void decayByPassPointer(int (*p)[7]) { cout \u0026lt;\u0026lt; \u0026quot;Modified size of array by passing by pointer: \u0026quot; \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; } int main() { int a[7] = {1, 2, 3, 4, 5, 6, 7,}; cout \u0026lt;\u0026lt; \u0026quot;Actual size of array is: \u0026quot; \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt;endl; decayByPassVal(a); decayByPassPointer(\u0026amp;a); return 0; }   如何避免数组退化  典型的方法避免数组退化是传递数组的大小作为单独的参数，而不是使用 sizeof 另外一个方法避免数组退化是传递引用，这个可以避免数组转化为指针，因此避免了退化\n#include \u0026lt;iostream\u0026gt; using namespace std; void avoidByPassReference(int (\u0026amp;p)[7]) { cout \u0026lt;\u0026lt; \u0026quot;Modified size of array by passing by reference: \u0026quot; \u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt; endl; } int main() { int a[7] = {1, 2, 3, 4, 5, 6, 7,}; cout \u0026lt;\u0026lt; \u0026quot;Actual size of array is: \u0026quot; \u0026lt;\u0026lt; sizeof(a) \u0026lt;\u0026lt;endl; avoidByPassReference(a); return 0; }   参考  What is Array Decay in C++? How can it be prevented?  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"69c77ed2d4d0fd8add3adc75eafd2cba","permalink":"https://xueqing.github.io/blog/cplusplus/array_decay/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/array_decay/","section":"blog","summary":"数组退化 类型和纬度丢失就是数组退化。通常发生在通过值或指针传递数组。这种情况下，数组发送的是它的首地址，因此数组的大小不是原始大小，而是首地","tags":["c++"],"title":"数组退化问题","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"参考 Go 维基官网——文章 学习。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"1a0a3865529165b0d9fc7db0cd18d82f","permalink":"https://xueqing.github.io/translation/go-doc/wiki/articles/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/wiki/articles/","section":"translation","summary":"参考 Go 维基官网——文章 学习。","tags":["go-doc-wiki"],"title":"文章","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  创建第一个页面 发布一个页面 再创建一个页面 修改页面配置  页面高级设置  结构和内容模式  增加一个插件   创建第一个页面 django CMS 的 Create Page 向导会打开一个新的对话框，点击 Next，完善新页面的内容\n Title：标题 Slug：默认为空 Content：文本内容  然后点击 Create，就可以看到这个新创建的页面。\n可以看到 django CMS Content 工具栏，用于管理 django CMS 的内容。\n发布一个页面 上面新建的页面只是一个草稿 draft，直到你确定时才会发布。编辑者可以看到草稿，但是其他浏览者只能看到发布的页面。\n点击 View published 可以看到页面的发布版。\n点击 Edit 可以切换到编辑模式。在编辑模式，双击文本段落可以修改文本。这会打开一个 Text 插件，包含了文本内容。修改之后，点击 Save 保存。\n再创建一个页面 django CMS 可以层次组织页面。新页面可以和先前的文件位于同一层级，或者成为其他页面的一个子页面。\n点击 Create 再创建一个页面，会打开 Create Page 对话框。这次多了一个选项 New sub page。创建子页面并按照之前的方式完善内容。\n可以点击 Publish page now 来发布文章。\n修改页面配置  切换到某个页面的编辑模式，从工具栏选择 page -\u0026gt; Page settings ...。弹出的 Change page 对话框允许你管理页面的一些关键设置。\n Slug：【必选】用于构造页面的 URL。可以修改自动生成的 slug。保持 slug 简短有意义，因为这个对于读者和搜索引擎等很有用。\n Menu Title：【可选】默认使用创建页面时填写的 Title 显示在菜单。但是可以通过 Menu Title 字段更改显示。一般当完整的 Title 比较长时使用。\n Page Title：【必选】页面的 \u0026lt;title\u0026gt; 元素默认使用创建页面时填写的 Title，但是可以通过 Page Title 字段更改显示。Page Title 不会展示在当前页面，但是搜索引擎和 web 浏览器会使用，这是页面的实际标题。Page Title 会出现在浏览器顶部或者收藏夹。\n Description meta tag：【可选】一个简短的文本段，由文档的 \u0026lt;head\u0026gt; 的 \u0026lt;meta\u0026gt; 标签使用。供搜索引擎和其他索引系统使用(并作为页面内容概览显示在搜索结果)。\n  页面高级设置 大多数时候不需要接触页面的高级设置。\n Overwrite URL：修改默认 URL。可缩短默认 URL 保持导航栏层级不变。 Redirect：可将用户定向到一个不同的页面。当移动内容到另一个页面，但是不想破坏用户可能收藏的 URL 或者影响搜索引擎的排名时可以使用重定向。 Template：设置当前页面使用的模板。 Id：在与网站开发人员协商之后放可使用。否则可能导致网站不可访问。 Soft root：对于深度嵌套的页面，可以缩短导航层级。选中之后，页面会作为导航栏的顶层页面。 Attached menu：给页面增加自定义菜单。修改之后需要重启服务，因此需要与开发人员协商。 Application：给页面增加自定义应用(如 weblog)。这个也需要和开发人员协商，并重启服务以使生效。 X Frame Options：控制当前页面是否可被另一个 web 页面或网站嵌套。  结构和内容模式 内容模式：双击内容以编辑。\n结构模式：可以在页面结构内部管理内容的放置。\n切换到结果模式，可以看到结构面板，包含页面用的占位符，以及占位符的插件。默认有一个 Content 占位符，包含一个 text 插件。\n增加一个插件 点击 + 按钮，增加一个插件。选择可用插件类型列表中的 Text，会打开一个熟悉的文本编辑器。\n增加一些文本，并点击 Save。现在可以在结构面板看到新的 Text 插件——可以在结构内部移动，重排序这些插件。\n注意：不需要手动保存修改，在拖动的时候会自动保存。但是需要手动发布以便其他用户可以看到修改。\n结构面板中的每个插件可以通过双击或点击 Edit 编辑。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"470e9a631b427c1a85a085d61e739d6e","permalink":"https://xueqing.github.io/blog/django_cms/using/create_page/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/django_cms/using/create_page/","section":"blog","summary":"创建第一个页面 发布一个页面 再创建一个页面 修改页面配置 页面高级设置 结构和内容模式 增加一个插件 创建第一个页面 django CMS 的 Create Page 向导会打开一个新的对话框，","tags":["django"],"title":"新建一个页面","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  服务费和佣金计算  淘宝客服务费和佣金 移动支付的利润来源 平台合作商户结算及结算资金转移问题 外卖抽成   淘宝客服务费和佣金  淘宝客推广方式：按成交扣费 佣金：支付给帮商家推广的淘宝客。卖家可设置佣金比例  卖家在用淘宝客推广的时候需要在交易成功后支付一定比例的佣金，佣金是从卖家绑定的支付宝账户直接扣除的  服务费：阿里巴巴提供平台给淘宝客挣钱，之后会收取淘宝客佣金的 10% 作为技术服务费。服务费需要支付给组织这个活动的团长  营销团长设置的最终佣金：服务费+佣金 只有报名团长活动才会有服务费支出  关于退款佣金  淘宝客按成交计费，若产生全额退款，不管是确认收货前还是收货后，都不收佣金。部分退款则按实际成交额结算佣金  卖家通过支付宝交易并确认收货时，系统自动将应付的佣金从卖家收入中扣除并在第二天计入淘宝客的预期收入账户。每个月 15 号做上一个整月的月结，月结时将收取佣金的 10% 作为技术服务费，结算之后正式转入淘宝客的收入账户。淘宝客需要通过实名认证的支付宝账号，才可以体现到支付宝  移动支付的利润来源  能在市场上销售移动支付终端，必定要获取第三方支付牌照 如果客户通过移动支付终端转账或消费 1 万元，就会产生 100 手续费(按 1%扣率计算)，发卡银行和银联收取保底费率 0.77%，发卡银行拿 0.7%，即 70元；银联拿 0.07%，即 7 元 剩下的 0.23%，即 23 元，由第三方支付公司和及其旗下的代理商收取；一般第三方支付平台根据代理商下面商户的刷卡量的大小产生分润，能拿到 0.23% 的 40% 至 80%；按最低档算 0.23% 的 40%，即 9.2 元 如果 100 个客户每台终端每个月刷卡 3 万元，一年产生分润即 100*30000*12*0.23%*40%=33120；这里只是 100 个客户按最低分成比例一年产生的分润，而且每年都有  平台合作商户结算及结算资金转移问题  这里的平台指的是：平台上售卖的产品/服务非平台方所属，售卖所得资金也非平台所属 平台自身业务考虑：  平台交易资金留存：平台采取对接银行/第三方支付公司即时到账网关收款接口。用户在平台购买产品后，用户资金进入平台在银行/第三方支付公司开设的帐户，再由平台通过网银或银企直连或委托付款接口/功能将资金结算给商家 只做信息撮合：(一些平台会考虑业务纠纷问题，以及从业务合规性考虑毕竟非自营业务涉及资金非平台所属)用户支付后交易资金直接划转到商户帐户。支付公司往往会提供类似分润接口形式的收款接口。用户支付时，平台会通过该接口传送订单信息、收款平台账户等信息，交易完成后资金会直接进入商户对应平台账户 模式的不足之处：要求平台商户开设有对应支付平台账户  平台对接银行接口  如果平台与银行有较深的合作关系(如与银行联合做营销活动，银行有营销费用补贴等优惠)，或第三方支付的支付接口不能满足业务需求时，平台可自己接银行，提供在线支付、银企直连等功能 账户设置：平台在银行开设自己的银行账户 平台与银行的对账、结算：平台按照结算周期与银行对账后，银行将结算周期内的资金结算到平台在银行设立的账户上。此处由于是同行交易，因此不存在费用 平台与商户的对账、结算：平台按照与商户约定的结算周期进行对账、结算(如果存在类似联盟、分销的情况，可能还包括分账)，此时只是在平台自己的交易、账务系统中做处理，并未完成资金实际的转移 一般情况下，由于平台具有话语权，而且考虑到手续费问题，平台与商户不一定按照结算周期结算的，可能会在交易额达到一定额度时候一次性结算 平台将结算资金实际转移给商户时，存在几种途径  平台的财务人员通过企业网银同行/跨行转账 平台调用银行的银企直连之类的接口完成同行/跨行转账 通过其他平台的代付功能(也有叫委托结算)完成代付  具体收费只能具体情况谈  平台对接第三方支付公司接口  第一种方式由于涉及与银行接口联调以及还需要平台自己处理对商户的清结算、分账、代付等问题，这些并不是平台所擅长的，而且在整体费用上并不具备优势(例如涉及一堆小银行跨行转账)，因此平台会同时接入多家第三方支付，借助第三方支付相对专业化服务来帮助解决 账户设置：第三方支付会按照商户接入流程要求平台提供银行结算账户、营业执照等信息，然后在运营系统中开通平台对应的虚拟账户 每一笔成功交易产生后，都会汇总到平台在第三方支付的虚拟账户中 在银行端，按照央行备付金管理办法，第三方支付会有收付户、汇缴户等类型的账户，用于存放所有合作商户的备付金，但并不区分某一个商户的资金。从资金安全角度来说，备付金管理办法就是为了监管第三方支付对商户资金挪用、洗钱等风险 平台与第三方支付平台的对账、结算：第三方支付平台按照结算周期与平台对账、结算，对账结算完成后，第三方支付平台一般提供了诸如代付/委托结算、分账功能，能够将资金代付给商户。另外还提供了诸如对公/对私结算、周末及节假日委托结算、T+0结算、商户自助上传批量代付文件、银行回单等增值服务 在具体费用上，如果平台合作商户的结算银行比较分散，则在整体成本上，应该比平台自己接银行具有优势   外卖抽成  一二线的外卖市场专送的抽点基本稳定在 20%，三四线专送抽点普遍在 22%~24% 美团第一年抽佣约 3%，第二年约 3.8%。饿了么一般为 3.5% 饿了么在 18 年 7 月份开始如果采用平台专送的配送方式，代理商最多收商家 25% 采用平台专送的配送方式收取 20% 的服务费，是目前一线城市多数商家的收佣标准  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"e4a3f3c38b8ada0706ceacd29a970c0d","permalink":"https://xueqing.github.io/blog/o2o/%E6%9C%8D%E5%8A%A1%E8%B4%B9%E5%92%8C%E4%BD%A3%E9%87%91/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/o2o/%E6%9C%8D%E5%8A%A1%E8%B4%B9%E5%92%8C%E4%BD%A3%E9%87%91/","section":"blog","summary":"服务费和佣金计算 淘宝客服务费和佣金 移动支付的利润来源 平台合作商户结算及结算资金转移问题 外卖抽成 淘宝客服务费和佣金 淘宝客推广方式：按成交扣费 佣","tags":["o2o"],"title":"服务费和佣金计算","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  列出本地镜像 删除镜像 标记本地镜像 创建镜像 保存镜像 导入镜像  列出本地镜像 docker images [OPTIONS] [REPOSITORY[:TAG]]  OPTIONS 说明：\n -a: 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层） \u0026ndash;digests: 显示镜像的摘要信息 -f: 显示满足条件的镜像 \u0026ndash;format: 指定返回值的模板文件 \u0026ndash;no-trunc: 显示完整的镜像信息 -q: 只显示镜像ID  列出本地镜像中 REPOSITORY 为 ubuntu 的镜像列表。\ndocker images ubuntu  删除镜像 删除本地一个或多少镜像。\ndocker rmi [OPTIONS] IMAGE [IMAGE...]  OPTIONS 说明：\n -f: 强制删除 \u0026ndash;no-prune: 不移除该镜像的过程镜像，默认移除  强制删除本地镜像 runoob/ubuntu:v4。\ndocker rmi -f runoob/ubuntu:v4  标记本地镜像 标记本地镜像，将其归入某一仓库。\ndocker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]  将镜像 ubuntu:15.10 标记为 runoob/ubuntu:v3 镜像。\ndocker tag ubuntu:15.10 runoob/ubuntu:v3  创建镜像 使用 Dockerfile 创建镜像。\ndocker build [OPTIONS] PATH | URL | -  OPTIONS 说明：\n \u0026ndash;build-arg=[]: 设置镜像创建时的变量 \u0026ndash;cpu-shares: 设置 cpu 使用权重 \u0026ndash;cpu-period: 限制 CPU CFS周期 \u0026ndash;cpu-quota: 限制 CPU CFS配额 \u0026ndash;cpuset-cpus: 指定使用的CPU id \u0026ndash;cpuset-mems: 指定使用的内存 id \u0026ndash;disable-content-trust: 忽略校验，默认开启 -f: 指定要使用的Dockerfile路径 \u0026ndash;force-rm: 设置镜像过程中删除中间容器 \u0026ndash;isolation: 使用容器隔离技术 \u0026ndash;label=[]: 设置镜像使用的元数据 -m: 设置内存最大值 \u0026ndash;memory-swap: 设置Swap的最大值为内存+swap，\u0026rdquo;-1\u0026rdquo;表示不限swap \u0026ndash;no-cache: 创建镜像的过程不使用缓存 \u0026ndash;pull: 尝试去更新镜像的新版本 \u0026ndash;quiet, -q: 安静模式，成功后只输出镜像 ID \u0026ndash;rm: 设置镜像成功后删除中间容器 \u0026ndash;shm-size: 设置/dev/shm的大小，默认值是64M \u0026ndash;ulimit: Ulimit配置 \u0026ndash;tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签 \u0026ndash;network: 默认 default。在构建期间设置RUN指令的网络模式  使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1。\ndocker build -t runoob/ubuntu:v1 .  使用 URL github.com/creack/docker-firefox 的 Dockerfile 创建镜像。\ndocker build github.com/creack/docker-firefox  也可以通过 -f Dockerfile 文件的位置。\ndocker build -f /path/to/a/Dockerfile .  在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回。\n保存镜像 将指定镜像保存成 tar 归档文件。\ndocker save [OPTIONS] IMAGE [IMAGE...]  OPTIONS 说明：\n -o: 输出到的文件  将镜像 runoob/ubuntu:v3 生成 my_ubuntu_v3.tar 文档。\ndocker save -o my_ubuntu_v3.tar runoob/ubuntu:v3  导入镜像 导入使用 docker save 命令导出的镜像。\ndocker load [OPTIONS]  OPTIONS 说明：\n \u0026ndash;input, -i: 指定导入的文件，代替 STDIN \u0026ndash;quiet, -q: 精简输出信息  从 busybox.tar.gz 导入镜像。\ndocker load \u0026lt; busybox.tar.gz  指定导入文件 fedora.tar 导入镜像。\ndocker load -i fedora.tar  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2778fe5f8ba6e8fab3fa3d63fa176bf4","permalink":"https://xueqing.github.io/blog/docker/image_cmd/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/docker/image_cmd/","section":"blog","summary":"列出本地镜像 删除镜像 标记本地镜像 创建镜像 保存镜像 导入镜像 列出本地镜像 docker images [OPTIONS] [REPOSITORY[:TAG]] OPTIONS 说明： -a: 列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中","tags":["docker"],"title":"本地镜像管理命令","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  GB/T 9387.2-1995 GB/T 16262.1-2006 GB/T 16264.2-2008 GB/T 16264.8-2005 GB/T 17969.1-2000 GB/T 19713-2005 GB/T 19714-2005 GB/T 25056-2010 GB/T 25059-2010 GB/T 25060-2010 GM/T 0006-2012 GM/T 0009-2012 GM/T 0010-2012 GM/T 0011-2012 GM/T 0014-2012 GM/T 0015-2012 GM/T 0016-2012 GM/T 0018-2012 GM/T 0020-2012 GM/T 0034-2012  GB/T 9387.2-1995    术语 定义 缩写 详细信息     服务数据单元 service data unit SDU -   安全管理信息库 security management information base SMIB -   管理信息库 management information base MIB -   访问控制 access control - 防止对资源的未授权使用，包括防止以未授权方式使用某一资源   访问控制表 access control list - 带有访问权限的实体表，这些访问权是授予它们访问某一资源的   可确认性 accountability - 一种性质，确保一个实体的作用可以被独一无二地跟踪到该实体   主动威胁 active threat - 这种威胁是对系统的状态进行故意的非授权的改变   安全审计 security audit - -   安全审计跟踪 security audit trail - -   鉴别 authentication - -   鉴别信息 authentication information - 用以建立身份有效性的信息   鉴别交换 authentication exchange - 通过信息交换来保证实体身份的一种机制   授权 authorization - 授予权限，包括袁旭基于访问权的访问   可用性 availability - 根据授权实体的请求可被访问与使用   权利 capability - 作为资源标识符使用的权标，拥有它便拥有对该资源的访问权   信道 channel - 信息传送通路   密文 cipher-text - 经加密处理而产生的数据，其语义内容是不可用的   明文 clear-text - 可理解的数据，其语义内容是可用的   机密性 confidentiality - 这一性质使信息不泄露给非授权的个人、实体或进程，不为其所用   凭证 credentials - 用来为一个实体建立所需身份而传送的数据   密码学 cryptography - 学科包含了对数据进行变换的原理、手段和方法，其目的是隐藏数据的内容   数据原发鉴别 data origin authentication - 确认接收到的数据的来源是所要求的   解密 decipherment - 与一个可逆的加密过程相对应的反过程   加密 encipherment - 对数据进行密码变换以产生密文   密钥 key - 控制加密与解密操作的一序列符号   口令 password - 机密的鉴别信息，通常由一串字符组成   对等实体鉴别 peer-entity authentication - 确认有关的对等实体是所需的实体    GB/T 16262.1-2006    术语 定义 缩写 详细信息     基本多文种平面 basic multilingual plane BMP -    GB/T 16264.2-2008 | 术语 | 定义 | 缩写 | 详细信息 | \u0026ndash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | 访问控制决策功能 | access control decision function | ACDF | - | | 访问控制信息 | access control information | ACI | - | | 访问控制内部区 | access control inner area | ACIA | - | | 访问控制特定区 | access control specific area | ACSA | - | | 公共目录管理区 | administration directory management domain | ADMD | - | | 属性值断言 | attribute value assertion | AVA | - | | 目录访问控制域 | directory access control domain | DACD | - | | 目录访问协议 | directory access protocol | DAP | - | | 目录信息映像协议 | directory information shadowing protocol | DISP | - | | 目录管理域 | directory management domain | DMD | - | | 域管理组织 | domain management organization | DMO | - | | 目录操作绑定管理协议 | directory operational binding management protocol | DSA | - | | 目录系统协议 | directory system protocol | DSP | - | | 目录信息库 | directory information base | DIB | - | | 目录系统代理 | directory system agent | DSA | - | | SA 特定条目 | DSA-specific entry | DSE | - | | 目录用户代理 | directory user agent | DUA | - | | 分等级操作绑定 | hierarchical operational binding | HOB | - | | 非特定分等级操作绑定 | non-specific hierarchical operational binding | NHOB | - | | 专用目录管理域 | private directory management domain | PRDMD | - | | 影像 DSE | shadowed DSE | SDSE | - |\nGB/T 16264.8-2005    术语 定义 缩写 详细信息     属性授权机构 attribute authority AA 通过发布属性证书来分配特权的证书认证机构   属性授权机构撤销列表 attribute authority revocation list AARL 一种包含发布给属性授权机构的证书索引的撤销列表，发布机构认为这些证书已不再有效   属性证书撤销列表 attribute certificate revocation list ACRL 标识由发布机构已发布的、不再有效的属性证书的索引表   属性证书 attribute certificate - AA 进行数字前面的数据结构，把持有者的身份信息与一些属性值绑定   鉴别令牌 authentication token token 在强鉴别交换期间传送的一种信息，可用于鉴别其发送者   机构 authority - 负责证书发布的实体，包括证书认证机构(发布公钥证书)和属性授权机构(发布属性证书)   机构证书 authority certificate - 发布给机构的证书   基础 CRL base CRL - 一种 CRL，用于产生增量 CRL 的基础   间接 CRL indirect CRL ICRL 撤销列表，至少包含不是发布此 CRL 的其他机构发布的证书撤销信息   终端实体 end entity - 不以签署证书为目的而使用其私钥的证书主体或依赖(证书)方   终端实体属性 CRL end-entity attribute certificate revocation list EARL 撤销列表，包含一系列向持有者发布的属性证书，持有者不是 AA，且这些属性证书对证书发布者不再有效   终端实体公钥 CRL end-entity public-key certificate revocation list EPRL 撤销列表，包含发布给非 CA 的主体的公钥证书列表，证书发布者认为这些证书不再有效   证书使用系统 certificate using system - 证书用户使用的、本部分定义的哪些功能实现   证书源授权机构 source of authority SOA 为资源的特定权限验证者所信任的，位于顶层的分配特定权限的属性授权机构   强鉴别 strong authentication - 使用由密码技术生产的凭证进行的鉴别   特定权限管理基础设施 privilege management infrastructure PMI 支持授权服务的综合基础设施，与公钥基础设施有着密切的联系    GB/T 17969.1-2000 | 术语 | 定义 | 缩写 | 详细信息 | | \u0026ndash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | | 文卷传送、访问和管理 | file transfer access and management | FTAM | - | | 国际标准化轮廓 | international standard profile | ISP | - | | 开放系统互连 | open system interconnection | OSI | - | | 开放系统互连环境 | open system interconnection environment | OSIE | - | | 协议控制规范 | protocol control information ??? | PCI | - | | 相关可辨别名称 | relative distinguished name | RDN | - |\nGB/T 19713-2005    术语 定义 缩写 详细信息     证书序列号 certificate serial number - 在一个 CA 所签发的证书中用于唯一标识数字证书的一个整数，此整数值与该 CA 所颁发的证书一一对应   请求者 requester - 申请在线证书状态查询服务的主体   响应者 responder - 提供在线证书状态查询服务的主体   证书认证机构 certificate authority CA 对数字证书进行全生命周期管理的实体，也称为电子认证服务机构或认证中心   证书认证机构群体 - CAs -   证书撤销列表 certificate revocation list CRL 由 CA 签发并发布的被撤销证书的列表   超文本传输协议 hypertext transfer protocol HTTP -   在线证书状态查询协议 online certificate status protocol OCSP -   简明在线证书状态查询协议 simple online certificate status protocol SOCSP -   对象标识符 object identifier OID -   公钥基础设施 public key infrastructure PKI -    GB/T 19714-2005 | 术语 | 定义 | 缩写 | 详细信息 | | \u0026ndash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | | 抽象语法记法 | abstract syntax notation 1 | ASN.1 | 用来组织复杂数据对象的表示法 | | 公钥证书 | public key certificate | - | 用户的公钥连同其他信息，并由发布该证书的证书认证机构的私钥进行加密使其不可伪造 | | 证书持有者 | certificate holder | - | 有效证书的主体对应的实体 | | 证书用户 | certificate user | - | 需要确切地指导另一实体的公开密钥的某一实体 | | 证书认证路径 | certification path | - | 在 DIT 中对象证书的一个有序序列。路径初始点是最初待验证对象的公钥，可通过路径获得最终的顶点的公钥 | | 认证业务说明 | certification practice statement | CPS | CA 发放证书时遵循的业务说明 | | 交叉证书 | cross-certificate | - | 两个 CA 间为交叉认证所互相签发的电子证书 | | 发证 | certify | - | 颁发一个证书的行为 | | 可辨别编码规则 | distinguished encoding rules | DER | 对 ASN.1 进行编码的规则 | | 数字签名 | digital signature | - | 允许接收者验证签名人的身份和数据完整性的数据单元 | | 目录服务 | directory service | DS | 分布在网络中的各种节点或服务器提供的分布式数据库服务 | | 散列函数 | hash function | - | 哈希函数，将值从一个大的定义域映射到一个较小值域的函数 | | 散列码 | hash code | - | 散列函数的输出比特串 | | 消息认证码 | message authentication code | MAC | 通过密码技术由消息产生的认证数据 | | 消息摘要 | message digest | - | 散列一个消息后得到的固定长度数据 | | 个人安全环境 | personal security environment | PSE | 证书及私钥的终端实体的安全本地存储 | | 拥有证明 | proof of possession | POP | 终端实体用以证明自己拥有(即能够使用)与为之申请证书的公钥相对应的私钥 | | 资料库 | repository | - | 存储证书和 CRL 等信息，并提供无需验证的信息检索服务的数据库 | | 自颁发证书 | self-issued certificate | - | 证书的主体和颁发者相同的 CA 证书 | | 公钥加密标准 | public-key cryptography standards | PKCS | - |\nGB/T 25056-2010    术语 定义 缩写 详细信息     证书验证 certificate validation - 确定定数在指定的时间内是否有效的过程，包括有效期验证、签名验证和证书状态验证   安全超文本传输协议 secure hypertext transfer protocol HTTPS -    GB/T 25059-2010    术语 定义 缩写 详细信息     带加密的散列消息验证码 hash message authentication code HMAC -   简单邮件发送协议 simple mail transfer protocol SMTP -   安全套接口层协议 secure socket layer protocol SSL -   传输层安全协议 transport layer security protocol TLS -    GB/T 25060-2010    术语 定义 缩写 详细信息     数字信封 digital envelope - 附加到消息中的数据，它允许消息的预期接收方验证改消息内容的完整性    GM/T 0006-2012    术语 定义 缩写 详细信息     BASE64 - - 将 16 进制数据转换为可见字符的编码规则   密码分组链接模式 cipher block chaining CBC -   电码本模式 electronic code book ECB -   密文反馈模式 cipher-text feedback CFB -   输出反馈模式 output feedback OFB -    GM/T 0009-2012    术语 定义 缩写 详细信息     SM3 算法 SM3 algorithm - 一种杂凑算法，输出长度为 256 比特    GM/T 0010-2012    术语 定义 缩写 详细信息     算法标识 algorithm identifier - 用于标明算法机制的数字化信息   椭圆曲线密码算法 elliptic curve cryptography ECC -   用户标识 identity ID -    GM/T 0011-2012    术语 定义 缩写 详细信息     可信计算平台 trusted computing platform - 构建在计算系统中，用于实现可信计算功能的支撑系统   可信计算密码支撑平台 cryptographic support platform for trusted computing - 为可信计算平台自身的完整性、身份可信性和数据安全性提供密码支持，产品形态主要表现为 TCM 和 TSM   可信密码模块 trusted cryptography module TCM 可信计算平台的硬件模块，为可信计算平台提供密码运算功能，具有受保护的存储空间   TCM 服务模块 TCM service module TSM 可信计算密码支撑平台内部的软件模块，对平台外部提供访问 TCM 的软件接口   密码模块密钥 TCM endorsement key EK TCM 的初始密钥   非易失性 non-volatility NV -   完整性度量 integrity measurement - 使用密码杂凑算法对被度量对象计算其杂凑值的过程   完整性度量值 integrity measurement value - 部件被度量后得到的杂凑值   平台配置寄存器 platform configuration register PCR TCM 内部用于存储平台完整性度量值的存储单元   平台身份密钥 platform identity key PIK TCM 的身份密钥   平台加密密钥 platform encryption key PEK TCM 中与平台身份密钥关联的加密密钥   存储主密钥 storage master key SMK 用于保护平台身份密钥和用户密钥的主密钥    GM/T 0014-2012    术语 定义 缩写 详细信息     CA 撤销列表 certificate authority revocation list CARL 标记已被撤销的 CA 的公钥证书列表，表示这些证书已经无效   证书认证系统 certificate authentication system - 对生存周期内的数字证书进行全过程管理(签发、发布、更新、撤销)的安全系统   密钥管理系统 key management KM -   待签名的(证书) to be signed TBS -   PKCS 1 RSA 加密 PKCS #1 RSA cryptography standard PKCS #1 -   PKCS 7 密文消息语法 PKCS #7 cryptographic message syntax standard PKCS #7 -   任务序列号 task no - -    GM/T 0015-2012    术语 定义 缩写 详细信息     数字证书 digital certificate - 由国家认可的，具有权威性、可信性和公正性的第三方 CA 进行数字签名的一个可信的数字化文件   CA 证书 CA certificate - 一个 CA 给另一个 CA 签发的证书，CA 也可以为自己签发证书，即自签名的证书   终端实体证书 entity certificate - 也称为用户证书，是由数字证书认证机构签发的个人证书、机构证书、设备证书等   目录信息树 directory information tree DIT -   版本 version - -   序列号 serial number - -   签名算法 signature algorithm -    颁发者 issuer - -   可辨别名称 distinguished name DN -   有效期 validity - -   世界时间 UTC time - 格林威治标准时间(coordinated universal time)   通用时间 generalized time - -   主体 subject - -   主体公钥信息 subject public key information - -   颁发者唯一标识符 issuer unique ID - -   主体唯一标识符 subject unique ID - -   扩展项 extensions - -   颁发机构密钥标识符 authority key identifier - -   主体密钥标识符 subject key identifier - -   密钥用法 key usage - -   密钥扩展用途 ext key usage - -   私有密钥使用期 private key usage period - -   证书策略 certificate policies - 一个指定的规则集合，它指出证书对于具有普通安全需求的一个特定团体和(或)具体应用类的适用性   策略映射 policy mappings - -   主体替换名称 subject alt name - -   颁发者替换名称 issuer alt name - -   主体目录属性 subject directory attributes - -   基本限制 basic constraints - -   名称限制 name constraints - -   策略限制 policy constraints - -   证书撤销列表分发点 CRL distribution points - 一个目录条目或其他的证书撤销列表发布源   限制所有策略 inhibit any policy - -   最新证书撤销列表 freshest CRL - -   个人身份标识码 identify code - -   个人社会保险号 insurance number - -   企业工商注册号 IC registration number - -   企业组织机构代码 organization code - -   企业税号 taxation number - -   专用因特网扩展 private internet extensions id-pkix - -   机构信息访问 authority information access - -   主体信息访问 subject information access - -   生效日期 this update - -   下次更新日期 next update - -   被撤销的证书列表 revoked certificates - -   颁发机构密钥标识符 authority key identifier - -   颁发者替换名称 issuer alt name - -   证书撤销列表号 CRL number - -   增量证书撤销列表指示 delta CRL indicator dCRL 一个部分的 CRL，只包括那些在基础证书撤销列表确认后注销状态改变的证书的条目   颁发分发点 issuing distribution point - -   证书撤销列表条目 CRL entry - -   撤销时间 invalidity date - -   证书颁发者 certificate issuer - -   统一资源标识符 uniform resource identifier URI -    GM/T 0016-2012    术语 定义 缩写 详细信息     PKCS #5 - - PKCS 第 5 部分，描述一种利用从口令派生出来的安全密钥加密字符串的方法   个人身份识别码 personal identification code PIN -    GM/T 0018-2012    术语 定义 缩写 详细信息     内部加密密钥 internal public key IPK -   内部加密私钥 internal private key ISK -   外部加密密钥 external public key EPK -   密钥加密密钥 key encrypt key KEK -    GM/T 0020-2012    术语 定义 缩写 详细信息     应用程序接口 application program interface API -   通用名 common name CN -   加密服务提供者 cryptographic service provider CSP -    GM/T 0034-2012    术语 定义 缩写 详细信息     认证机构证书 authority certificate - 签发给证书认证机构的证书   数字证书 digital certificate - 也称公钥证书，由 CA 签名的包含公钥拥有者信息、公钥、签发者信息、有效期以及扩展信息的一种数据结构   完全的证书撤销列表 full CRL - 在给定的范围内，包含所有已经被注销证书的 CRL   私钥 private key  非对称密码算中只能由拥有者使用的不公开密钥   公钥 public key  非对称密码算中可以公开的密钥   证书注册机构 registration authority RA 受理数字证书的申请、更新、恢复和注销等业务的实体   依赖方 relying party - 使用证书中的数据进行决策的用户或代理   安全策略 security policy - 由 CA 发布的用于约束安全服务以及设施的使用和提供方式的规则集合   SM2 算法 SM2 algorithm - 一种椭圆曲线公钥密码算法，密钥长度为 256 比特   信任 trust - 通常说一个实体信任另一个实体表示后者将完全按照前者的规定进行相关的活动   密钥管理中心 key management center KMC -   轻量级目录访问协议 lightweight directory access protocol LDAP -    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"6d2e11f6fdeb0ea817eadddc94b7080d","permalink":"https://xueqing.github.io/blog/sip/terminology/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/terminology/","section":"blog","summary":"GB/T 9387.2-1995 GB/T 16262.1-2006 GB/T 16264.2-2008 GB/T 16264.8-2005 GB/T 17969.1-2000 GB/T 19713-2005 GB/T 19714-2005 GB/T 25056-2010 GB/T 25059-2010 GB/T 25060-2010 GM/T 0006-2012 GM/T 0009-2012 GM/T 0010-2012 GM/T 0011-2012 GM/T 0014-2012 GM/T 0015-2012 GM/T 0016-2012 GM/T 0018-2012 GM/T 0020-2012 GM/T 0034-2012 GB/T 9387.2-1995 术语 定义 缩写 详细信息 服务数据单元 service data unit SDU - 安全管理信息库","tags":["sip"],"title":"术语和缩略语","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 分组  加()，即小括号，表示分组：例如m_([a|b|c]) 每个分组有一个组号：从左向右，以分组的左括号为标识，第一个出现的分组的组号是 1，第二个是 2，以此类推 后向引用：用于重复搜索前面某个分组匹配的文本：例如，\\1代表分组 1 匹配的文本 可以自己指定子表达式的组名：m_(?\u0026lt;Word\u0026gt;[a|b|c])，或者m_(?'Word'[a|b|c])，可以把[a|b|c]的组名指定为Word，后面可以使用\\k\u0026lt;Word\u0026gt;来反向引用该分组捕获的内容  匹配符  匹配开始符^ 匹配结束符$  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d59eebc1507222b0dfc450c060ee941c","permalink":"https://xueqing.github.io/blog/ubuntu/regular_expression/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/ubuntu/regular_expression/","section":"blog","summary":"分组 加()，即小括号，表示分组：例如m_([a|b|c]) 每个分组有一个组号：从左向右，以分组的左括号为标识，第一个出现的分组的组号是 1，第","tags":["ubuntu","linux"],"title":"正则表达式","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"go test 命令预期查找对应测试包的 “*_test.go” 文件中的测试函数、基准测试函数和示例函数。\n测试函数命名为 TestXxx(Xxx 不以小写字母开始)，且应当有签名\nfunc TestXxx(t *testing.T) { ... }  一个基准测试函数命名为 BenchmarkXxx，且应该有签名\nfunc BenchmarkXxx(b *testing.B) { ... }  一个示例函数，类似于测试函数，但不使用 *testing.T 报告成功或失败，而是打印输出到 os.Stdout。如果函数内最后的注释以 “Output:” 开头，那么输出与注释精确比较(看下面的例子)。如果最后的注释以 “Unordered output:” 开始，那么输出和注释做比较，但是忽视行的顺序。一个不带这样的注释的示例被编译但是不执行。一个在 “Output:” 之后没有文本的示例会被编译、执行并预期不会生成输出。\nGodoc 显示 ExampleXxx 的消息体来演示函数、常量或变量 Xxx 的使用。一个接收类型是 T 或 *T 的方法 M 的示例函数命名为 ExampleT_M。对于一个给定的函数、常数或变量可能有多个示例，通过后缀 _xxx 区分，xxx 是一个不以大写字母开始的后缀。\n有一个示例函数的例子：\nfunc ExamplePrintln() { Println(\u0026quot;The output of\\nthis example.\u0026quot;) // Output: The output of // this example. }  另外一个忽视输出顺序的例子：\nfunc ExamplePerm() { for _, value := range Perm(4) { fmt.Println(value) } // Unordered output: 4 // 2 // 1 // 3 // 0 }  当文件包含一个单独的示例函数，及至少一个其他的函数、类型、变量或常数声明，且没有测试函数或者基准测试函数时，整个测试文件作为例子显示。\n查看 testing 包的文档查看更多信息。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f69f54bc9b6afed287550cde8afa0417","permalink":"https://xueqing.github.io/translation/go-doc/command/test_func/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/test_func/","section":"translation","summary":"go test 命令预期查找对应测试包的 “*_test.go” 文件中的测试函数、基准测试函数和示例函数。 测试函数命名为 TestXxx(Xxx 不以小写字母开始)，且应当有签名","tags":["go-command"],"title":"测试函数","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"go test 命令使用只适用于 go test 的标识以及适用于生成二进制测试的标识。\n一些标识控制概要并且写适用于 go tool pprof 的执行概要；运行 go tool pprof -h 查看更多信息。pprof 的 \u0026ndash;alloc_space、\u0026ndash;alloc_objects 和 \u0026ndash;show_bytes 选项控制如何显示这些信息。\n下面的标识被 go test 命令识别，并且控制测试的执行：\n-bench regexp Run only those benchmarks matching a regular expression. By default, no benchmarks are run. To run all benchmarks, use '-bench .' or '-bench=.'. The regular expression is split by unbracketed slash (/) characters into a sequence of regular expressions, and each part of a benchmark's identifier must match the corresponding element in the sequence, if any. Possible parents of matches are run with b.N=1 to identify sub-benchmarks. For example, given -bench=X/Y, top-level benchmarks matching X are run with b.N=1 to find any sub-benchmarks matching Y, which are then run in full. -benchtime t Run enough iterations of each benchmark to take t, specified as a time.Duration (for example, -benchtime 1h30s). The default is 1 second (1s). The special syntax Nx means to run the benchmark N times (for example, -benchtime 100x). -count n Run each test and benchmark n times (default 1). If -cpu is set, run n times for each GOMAXPROCS value. Examples are always run once. -cover Enable coverage analysis. Note that because coverage works by annotating the source code before compilation, compilation and test failures with coverage enabled may report line numbers that don't correspond to the original sources. -covermode set,count,atomic Set the mode for coverage analysis for the package[s] being tested. The default is \u0026quot;set\u0026quot; unless -race is enabled, in which case it is \u0026quot;atomic\u0026quot;. The values: set: bool: does this statement run? count: int: how many times does this statement run? atomic: int: count, but correct in multithreaded tests; significantly more expensive. Sets -cover. -coverpkg pattern1,pattern2,pattern3 Apply coverage analysis in each test to packages matching the patterns. The default is for each test to analyze only the package being tested. See 'go help packages' for a description of package patterns. Sets -cover. -cpu 1,2,4 Specify a list of GOMAXPROCS values for which the tests or benchmarks should be executed. The default is the current value of GOMAXPROCS. -failfast Do not start new tests after the first test failure. -list regexp List tests, benchmarks, or examples matching the regular expression. No tests, benchmarks or examples will be run. This will only list top-level tests. No subtest or subbenchmarks will be shown. -parallel n Allow parallel execution of test functions that call t.Parallel. The value of this flag is the maximum number of tests to run simultaneously; by default, it is set to the value of GOMAXPROCS. Note that -parallel only applies within a single test binary. The 'go test' command may run tests for different packages in parallel as well, according to the setting of the -p flag (see 'go help build'). -run regexp Run only those tests and examples matching the regular expression. For tests, the regular expression is split by unbracketed slash (/) characters into a sequence of regular expressions, and each part of a test's identifier must match the corresponding element in the sequence, if any. Note that possible parents of matches are run too, so that -run=X/Y matches and runs and reports the result of all tests matching X, even those without sub-tests matching Y, because it must run them to look for those sub-tests. -short Tell long-running tests to shorten their run time. It is off by default but set during all.bash so that installing the Go tree can run a sanity check but not spend time running exhaustive tests. -timeout d If a test binary runs longer than duration d, panic. If d is 0, the timeout is disabled. The default is 10 minutes (10m). -v Verbose output: log all tests as they are run. Also print all text from Log and Logf calls even if the test succeeds. -vet list Configure the invocation of \u0026quot;go vet\u0026quot; during \u0026quot;go test\u0026quot; to use the comma-separated list of vet checks. If list is empty, \u0026quot;go test\u0026quot; runs \u0026quot;go vet\u0026quot; with a curated list of checks believed to be always worth addressing. If list is \u0026quot;off\u0026quot;, \u0026quot;go test\u0026quot; does not run \u0026quot;go vet\u0026quot; at all.  下面的标识被 go test 命令识别，且可用于概述执行期间的测试：\n-benchmem Print memory allocation statistics for benchmarks. -blockprofile block.out Write a goroutine blocking profile to the specified file when all tests are complete. Writes test binary as -c would. -blockprofilerate n Control the detail provided in goroutine blocking profiles by calling runtime.SetBlockProfileRate with n. See 'go doc runtime.SetBlockProfileRate'. The profiler aims to sample, on average, one blocking event every n nanoseconds the program spends blocked. By default, if -test.blockprofile is set without this flag, all blocking events are recorded, equivalent to -test.blockprofilerate=1. -coverprofile cover.out Write a coverage profile to the file after all tests have passed. Sets -cover. -cpuprofile cpu.out Write a CPU profile to the specified file before exiting. Writes test binary as -c would. -memprofile mem.out Write an allocation profile to the file after all tests have passed. Writes test binary as -c would. -memprofilerate n Enable more precise (and expensive) memory allocation profiles by setting runtime.MemProfileRate. See 'go doc runtime.MemProfileRate'. To profile all memory allocations, use -test.memprofilerate=1. -mutexprofile mutex.out Write a mutex contention profile to the specified file when all tests are complete. Writes test binary as -c would. -mutexprofilefraction n Sample 1 in n stack traces of goroutines holding a contended mutex. -outputdir directory Place output files from profiling in the specified directory, by default the directory in which \u0026quot;go test\u0026quot; is running. -trace trace.out Write an execution trace to the specified file before exiting.  所有这些标识也有一个可选的 “test.” 前缀被识别(如 -test.v)。但是当直接调用生成的二进制测试时(go test -c 生成)，这个前缀是强制的。\ngo test 命令在调用二进制测试之前，适当地重写或移除在可选的包列表之前或之后识别的标识。\n比如，命令 go test -v -myflag testdata -cpuprofile=prof.out -x 将会编译二进制测试然后运行 pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out。(-x 标识被移除，因为它只适用于go 命令的执行，而不是go test)\n生成概述(除了用于覆盖)的测试标识也会将二进制测试留在 pkg.test 以便用于分析概述。\n当 go test 运行一个二进制测试时，它从对应包源码目录内部运行。视测试而定，可能需要在直接调用一个生成的二进制测试时也这样做。\n命令行的包列表，如果有的话，必须出现在所有 go test 命令不知道的标识之前。继续上面的例子，包列表需要出现在 -myflag 之前，但是可以出现在 -v 两侧。\n当 go test 在列表模式运行时，go test 缓存成功的包测试结果以避免不必要的重复运行测试。要禁用测试缓存，使用除了可缓存的标识以外的任意的测试标识或参数。惯用的显式禁用测试缓存的方法是使用 -count=1。\n要保持二进制测试的一个参数不被翻译成一个已知的标识或者包名，使用 -args (查看 got help test) 换地命令行的剩余部分给二进制测试，该部分不会被解释或修改。\n例如，命令 go test -v -args -x -v 会编译二进制测试然后运行 pkg.test -test.v -x -v。类似的，go test -args math 会编译二进制测试然后运行 pkg.test math。\n在第一个例子中，-x 和第二个 -v 被传递给二进制测试且未被修改，且对 go 命令本身没有影响。在第二个例子中，参数 math 被传递给二进制测试，而不是解释成包列表。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c6f26e15ac3b6de09fdcfed406bdfe8c","permalink":"https://xueqing.github.io/translation/go-doc/command/test_flag/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/test_flag/","section":"translation","summary":"go test 命令使用只适用于 go test 的标识以及适用于生成二进制测试的标识。 一些标识控制概要并且写适用于 go tool pprof 的执行概要；运行 go tool pprof -h 查看更多信息。ppr","tags":["go-command"],"title":"测试标识","type":"translation"},{"authors":["kiki"],"categories":["reading"],"content":" 6-24  单纯地为做某事而做某事似乎很难，也不被称道。社会价值观基于为某个原因而做某事。这导致了贫瘠的存在，即永不完整、永不满足的人生。这便是具有破坏性的不满情绪产生的原因之一。 满足是丑陋的，但不满会滋生仇恨。为了上天堂或是博得社会或德高望重人士的认可而遵守道德就如在一块贫瘠、从未播种过的土地上反复耕作。这种为某个目的而做某事的行为说到底就是偏离事物本质的一系列自我逃避。\n ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"d666f9b21dc210d20721aee505230f91","permalink":"https://xueqing.github.io/reading/%E7%94%9F%E5%91%BD%E7%9A%84%E7%AC%94%E8%AE%B0/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/reading/%E7%94%9F%E5%91%BD%E7%9A%84%E7%AC%94%E8%AE%B0/","section":"reading","summary":"6-24 单纯地为做某事而做某事似乎很难，也不被称道。社会价值观基于为某个原因而做某事。这导致了贫瘠的存在，即永不完整、永不满足的人生。这便是具有破","tags":["krishnamurti"],"title":"生命的笔记","type":"reading"},{"authors":["kiki"],"categories":["blog"],"content":"  研读 GB35114  前端设备分级 视频监控安全管理平台 设备接入认证 信令 运算 密钥种类 数字证书类型 SIP 服务器认证 FDWSF 的单向身份认证 SIP 服务器与 FDWSF 的双向身份认证 管理平台间认证(网关 1 向网关 2 发起认证) 控制信令认证 密钥与证书管理 新增协议获取密钥与证书   前端设备分级  FDWSF(具有安全功能的前端设备) 的安全能力分为三个等级     能力 目标 关联标准 加密算法 A 级 B 级 C 级     基于数字证书与管理平台双向身份认证能力 身份真实 GBT/28181 (SVAC) SM2, SM3 Y Y Y   对视频数据签名的能力 视频真实(来源真实, 内容真实, 未被篡改) GBT/25724 (SVAC) SM2, SM3 N Y Y   视频内容加密 防止泄露 GBT/25724 (SVAC) SM1/SM4, SM3 N N Y    视频监控安全管理平台  对 FDWSF 的基本信息、属性信息以及 FDWSF 的 ID、其密码模块 ID 与设备证书的对应关系作管理 对所有接入的 FDWSF 进行单向或双向设备身份认证 平台互联互通时应进行管理平台间的双向身份认证  设备接入认证  平台需要:  解析 FDWSF 支持的算法 生成随机数的算法 校验签名的时效性 获取 FDWSF 的公钥 获取管理平台的私钥 可设置 Date 比对有效时间范围   信令  除注册信令, 其他信令作摘要 增加设备控制请求: 前端签名控制、前端加密控制, 都是有应答的请求 增加通知信令: FDWSF 的 VKEK 改变时, SIP 服务器通知媒体流接收者新的 VKEK 密文和版本号 第三方呼叫控制中, 媒体流接收者需要在 Invite 请求中添加 Monitor-User-Identity 表明用户身份 在 Invite 的回复中, SIP 服务器在 SDP 中添加媒体流发送者的的 VKEK 密文和版本号 导出加密视频: 解密视频数据, 生成新的 VEK 进行加密, 保存 VETK 和播放权限到安全芯片  运算  算法包括非对称算法、对称算法、杂凑算法和随机数生成算法 参考算法在国标中的应用     分类 算法 国标应用 长度     非对称密码算法 SM2 用于用户身份认证、数字签名、密钥协商 密钥 256 比特   对称密码算法 SM1、SM4_OFB 用于视频数据的加密保护 SM4 密钥 128 比特   - SM4_ECB 用于密钥协商数据的加密保护 SM4 密钥 128 比特   密码杂凑算法 SM3 用于完整性校验 输出 256 比特   随机数生成算法  生成随机数，应能通过 GM/T 0005-2012 中规定的方法进行检测      VEK 是 128 比特 IV (采用 OFB 模式) 是 128 比特  密钥种类  具有安全功能的前端设备、用户终端、中心信令控制服务器、路由网关、媒体服务器都持有各自的: 非对称密钥和对称密钥  非对称密钥 管理平台内功能实体的签名公私钥和加密公私钥 FDWSF 的签名公私钥 具有安全功能的用户终端签名公私钥 对称密钥：视频加密密钥、视频密钥加密密钥、视频主密钥   | 密钥名称 | 密钥简称 | 算法 | 备注 | | \u0026mdash; | \u0026mdash; | \u0026mdash; | \u0026mdash; | | 视频加密密钥 | VEK | SM4 | 加密视频流 | | 视频密钥加密密钥 | VKEK | SM4 | 加密保护 VEK | | 视频主密钥 | VEMK | SM4 | 分散得到 VKEK |\n数字证书类型  基于非对称密码算法 包括用户证书、前端设备证书、服务器设备证书和管理平台证书 支持 GM/T 0015-2012 基于 SM2 密码算法的数字证书格式规范     名称 用途 备注     签名密钥 签名密钥为 SM2 非对称密钥对中的私钥，主要用于数据签名 系统内所有安全实体均拥有自己的签名密钥，且由自身的密码设备生成该密钥   加密密钥 加密密钥为 SM2 非对称密钥对中的公钥，主要用于对数据进行加密 仅服务器实体具有。由密钥管理中心产生并负责安全管理   签名证书 由 CA 颁发给申请实体，内含申请实体的公钥和申请信息。签名证书主要用于对申请实体的签名进行验证 系统内所有安全实体均拥有自己的签名证书   加密证书 由 CA 颁发给申请实体，内含 CA 分配给申请实体的公钥、私钥和申请信息。外部实体使用申请实体加密证书中的公钥加密数据信息，申请实体利用加密证书中的私钥解密，从而做到加密通讯 仅服务器实体具有     签名证书和加密证书一起保存在用户的证书载体中  SIP 服务器认证 FDWSF 的单向身份认证  FDWSF 收到 401, 发送请求: 使用 FDWSF 的私钥对 (R2 + R1 + SIP_Server_ID) 做签名运算  R2: FDWSF 产生的随机数 R1: 第一次 register, SIP 服务器在 401 返回的随机数 SIP_Server_ID: SIP 服务器的设备 ID 签名: SM2 椭圆曲线密码算法  管理平台回复:  使用 FDWSF 证书校验签名, 使用 FDWSF 公钥解密, 验证各个参数 使用 FDWSF 的公钥对 VKEK 加密经 Base64 编码后得到 crypt_key 加密: SM4 分组密码算法 ECB 模式   SIP 服务器与 FDWSF 的双向身份认证  FDWSF 收到 401, 请求: 同上 管理平台回复:同上  用管理平台私钥对 (R1 + R2 + device_id + crypt_key) 做签名运算 R1: 第一次 register, SIP 服务器在 401 返回的随机数 R2: FDWSF 产生的随机数 device_id: FDWSF 的 ID 签名: SM2 椭圆曲线密码算法  FDWSF 收到管理平台 200 回复  用 SIP 服务器证书校验签名, 使用管理平台公钥解密, 验证各个参数 用 FDWSF 私钥解密 crypt_key, 获得 VKEK 的值   管理平台间认证(网关 1 向网关 2 发起认证)  网关 1 收到 401, 发送请求: 使用网关 1 的私钥对 (R2 + R1 + 网关_2_ID) 做签名运算  R2: 网关 1 产生的随机数 R1: 第一次 register, 网关 2 在 401 返回的随机数 网关_2_ID: 网关 2 的 ID 签名: SM2 椭圆曲线密码算法  网关 2 回复:  使用网关 1 的公钥对 VKEK 加密经 Base64 编码后得到 crypt_key_1 使用网关 1 的公钥对 VEMK 和 VEMK 版本号加密经 Base64 编码后得到 crypt_key_2 加密: SM4 分组密码算法 ECB 模式 用网关 2 私钥对 (R1 + R2 + 网关_1_ID + crypt_key_1 + crypt_key_2) 做签名运算 R1: 第一次 register, 网关 2 在 401 返回的随机数 R2: 网关 1 产生的随机数 网关_1_ID: 网关 1 的 ID 签名: SM2 椭圆曲线密码算法  网关 1 收到 200 回复  用网关 2 证书校验签名, 使用网关 2 公钥解密, 验证各个参数 用网关 1 私钥解密 crypt_key_1, 获得 VKEK 的值 用网关 1 私钥解密 crypt_key_2, 获得 VEMK 和 VEMK 版本号   控制信令认证  对注册信令以外的消息作带密钥的杂凑 发起消息之前计算 nonce  对 (METHOD + From + To + CallID + Date + VKEK + 消息体) 做杂凑运算经 Base64 编码得到的值  收到消息之后计算并校验摘要  对 (METHOD + From + To + CallID + Date + VKEK + 消息体) 做杂凑运算经 Base64 编码得到的值 对比收到的 nonce 和计算的结果   密钥与证书管理  FDWSF持有：  签名私钥(SM2) 加密私钥(SM4_ECB) 对称密码，和加密公钥相同 管理平台签名证书(包含管理平台签名公钥) 管理平台加密证书(包含管理平台加密公钥)  管理平台持有：  签名私钥(SM2) 加密私钥(SM4_ECB) 对称密码，和加密公钥相同 前端设备签名证书(包含设备签名公钥) 前端设备加密证书(包含设备加密公钥)   新增协议获取密钥与证书  请求签名公私钥(SM2)  GetSM2SignKeyPair(std::string \u0026amp;pubKey, std:;string \u0026amp;priKey);  请求签名证书(SM2)  GetSM2SignCert(std::string \u0026amp;pubKey, std::string \u0026amp;cert);  请求加密公私钥(对称加密 SM4)  GetSymmCipherKeyPair(std::string \u0026amp;key);  请求加密证书(对称加密 SM4)  GetSymmCipherCert(std::string \u0026amp;key, std::string \u0026amp;cert);   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0780e88eb388c5a2573632bbacc1ce69","permalink":"https://xueqing.github.io/blog/sip/gb35114/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/gb35114/","section":"blog","summary":"研读 GB35114 前端设备分级 视频监控安全管理平台 设备接入认证 信令 运算 密钥种类 数字证书类型 SIP 服务器认证 FDWSF 的单向身份认证 SIP 服务器与 FDWSF 的双向身份认证 管理平台","tags":["sip"],"title":"研读 GB35114","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 在命令模式下，输入 ctrl+v 状态栏出现 VISAUL BLOCK，进入纵向编辑模式，移动游标选择待编辑的区域  windows 下的 vim 纵向编辑模式是 ctrl+q  如果要选择至文件结尾，输入 G 多行行首插入  选择好以后输入大写 I，光标会自动跳转到所选择行的第一行的行首，并进入 insert 模式 输入想要插入的内容 输入 Esc，编辑完成  多行行首删除  选择好以后输入小写 d，编辑完成  多行行首缩进  选择好以后输入 \u0026gt; (shift+.)，则选择的内容向后缩进一个 tab 选择好以后输入\u0026lt; (shift+,)，则选择的内容向前缩进一个tab  多行行尾插入  选择好以后输入大写 A，光标会自动跳转到所选择行的第一行的行尾，并进入 insert 模式 输入想要输入的内容 输入 Esc，编辑完成  多行行尾删除  选择好以后输入小写 x 或小写 d，编辑完成  多行字符替换  选择好以后输入 小写 c，发现刚选中的字符消失，并进入 insert 模式 输入想要替换的字符 输入 Esc，编辑完成   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b1bb3b17159f1bbdf0e251e35251facd","permalink":"https://xueqing.github.io/blog/vim/vim_visual_block/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/vim/vim_visual_block/","section":"blog","summary":"在命令模式下，输入 ctrl+v 状态栏出现 VISAUL BLOCK，进入纵向编辑模式，移动游标选择待编辑的区域 windows 下的 vim 纵向编辑模式是 ctrl+q 如果要选择至文件结尾，输入 G 多","tags":["vim"],"title":"纵行编辑模式","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  需要了解的知识 在 C++ 中调用 C 语言函数 在 C 中调用 C++ 语言函数  在 C 中调用 C++ 非成员函数 在 C 中调用 C++ 成员函数 在 C 中调用 C++ 重载函数 C++ 名称重整 C++ 链接器处理 C 符号 测试  在 C++ 中包含一个标准的 C 头文件 在 C++ 中包含一个非系统的 C 头文件 修改自己的 C 头文件以便 C++ 容易使用 include 语句包含 在 C++ 中调用非系统的 C 函数 f(int,char,float) 创建一个可被 C 调用的 C++ 函数 f(int,char,float) 链接器在 C/C++ 调用 C++/C 函数时报错的原因 传递一个 C++ 类的对象给/从 C 函数 C 函数是否可以直接访问 C++ 类对象的数据 使用 C++ 比 C 更觉得远离机器代码 参考  需要了解的知识  有一些关键点(即使一些编译器尝试不要求，检查编译器厂商的文件)  当编译 main() 时必须使用 C++ 编译器(比如为了静态初始化) C++ 编译器应该管理链接过程(这样才可以得到指定的库) C 和 C++ 编译器可能需要来自同一厂商，且具有兼容版本(这样才有相同的调用惯例)  除此之外，你需要阅读剩余的章节以找到 可被 C/C++ 调用的 C++/C 函数 有一个方式可以解决所有的问题：即使用 C++ 编译器编译所有的代码(即使是 C 风格的代码)  优点：可以解决结合 C 和 C++ 代码的问题，也更容易发现 C 代码的错误 缺点：需要更新 C 风格的代码，原因 但是更细代码的代价可能比结合二者的代价更小，同时可以清除 C 风格的代码   在 C++ 中调用 C 语言函数  在 C++ 中用 extern \u0026quot;C\u0026quot; 声明 C 函数，然后在 C/C++ 中调用\nextern \u0026quot;C\u0026quot; void f(int);//方式1 extern \u0026quot;C\u0026quot; {//方式2 int g(double); double h(); }; void cppode(int i, double d) { f(i); int ii = g(d); double dd = h(); //... };  //c code void f(int i) { //... } int g(double d) { //... } double h() { //... }   在 C 中调用 C++ 语言函数 在 C 中调用 C++ 非成员函数  在 C++ 中用 extern \u0026quot;C\u0026quot; 声明 C++ 函数，然后在 C/C++ 中调用\nextern \u0026quot;C\u0026quot; void f(int); void f(int i) { //... }  void f(int); void ccode(int i) { f(i); //... }   在 C 中调用 C++ 成员函数  如果需要在 C 中调用成员函数(包括虚函数)，需要提供一个简单的封装\nclass C { //... virtual double f(int); }; //封装函数 extern \u0026quot;C\u0026quot; double call_C_f(C* p, int i) { return p-\u0026gt;f(i); }  struct C { //... }; double call_C_f(struct C*, int); void ccode(struct C* p, int i) { double d = call_C_f(p, i); //... }   在 C 中调用 C++ 重载函数  如果需要在 C 中调用重载函数，必须为 C 语言提供不同名称的封装函数\nvoid f(int); void f(double) extern \u0026quot;C\u0026quot; void f_i(int); extern \u0026quot;C\u0026quot; void f_d(double);  void f_i(int); void f_d(double); void ccode(int i, double d) { f_i(i); f_d(d); //... }  这种方式适用于在 C 中调用 C++ 库，即使不能修改 C++ 的头文件\n  C++ 名称重整  C++ 支持函数重载。比如可以有多个函数名称相同，但参数不同。当生成目标代码时，C++ 编译器通过添加参数信息修改名称来区分不同的函数。这个添加额外信息到函数名的技术叫做名称重整(name mangling) C++ 标准没有对名称重整指定任何详细的技术，因此不同编译器可能添加不同信息到函数名\nint f(void) {return 1;} int f(int) {return 0;} void g(void) (int i=f(), j=f(0);)  上述代码可能被 C++ 编译器改成\nint __f_v(void) {return 1;} int __f_i(int) {return 0;} void __g_v(void) (int i=__f_v(), j=__f_i(0);)   C++ 链接器处理 C 符号  C 不支持函数重载，名称不会被重整。当把代码放到 extern \u0026quot;C\u0026quot; 块时，C++ 编译器确保函数名不会被重整，即编译器生成一个二进制文件，且没有修改函数名 extern \u0026quot;C\u0026quot; 在 C++ 调用 C 时：告诉 g++ 预期得到 gcc 生成的未重整的符号 extern \u0026quot;C\u0026quot; 在 C 调用 C++ 时：告诉 g++ 生成未重整的符号给 gcc 使用  测试  反编译一个 g++ 生成的二进制代码\nvoid f() {} void g(); extern \u0026quot;C\u0026quot; { void ef() {} void eg(); } void h() { g(); eg();}  使用 g++ 编译 g++ -c main.cpp\n 反编译符号表 readelf -s main.o\nSymbol table '.symtab' contains 13 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS cppcode.cpp 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 5: 0000000000000000 0 SECTION LOCAL DEFAULT 6 6: 0000000000000000 0 SECTION LOCAL DEFAULT 7 7: 0000000000000000 0 SECTION LOCAL DEFAULT 5 8: 0000000000000000 7 FUNC GLOBAL DEFAULT 1 _Z1fv 9: 0000000000000007 7 FUNC GLOBAL DEFAULT 1 ef 10: 000000000000000e 17 FUNC GLOBAL DEFAULT 1 _Z1hv 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND _Z1gv 12: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND eg  可以看到：ef 和 eg 在符号表存储的名字和代码中的名字相同；其他的名称被重整过\n 解开(unmangle)这些名字\nkiki@ubuntu:/tmp/test$ c++filt _Z1fv f() kiki@ubuntu:/tmp/test$ c++filt _Z1hv h() kiki@ubuntu:/tmp/test$ c++filt _Z1gv g()   在 C++ 中包含一个标准的 C 头文件  直接使用 #include 包含所需头文件，比如 #include \u0026lt;cstdio\u0026gt;\n#include \u0026lt;cstdio\u0026gt; int main() { printf(\u0026quot;Hello!\\n\u0026quot;);// or std::printf return 0; }  如果使用 C++ 编译器编译 C 代码，又不希望将类似 printf 改成 std::printf，可以在 C 代码中使用旧风格的头文件 stdio.h 替换新风格的头文件 cstdio\n#include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026quot;Hello!\\n\u0026quot;); return 0; }   在 C++ 中包含一个非系统的 C 头文件  如果在 C++ 中包含一个非系统提供的 C 头文件，需要使用 extern \u0026quot;C\u0026quot; {/**/} 结构包裹 #include 语句，这个告诉 C++ 编译器此头文件声明的函数是 C 函数\nextern \u0026quot;C\u0026quot; { //get declaration for void sum(int, int) #include \u0026quot;my-c-code.h\u0026quot; } int main() { sum(1, 2); return 0; }   修改自己的 C 头文件以便 C++ 容易使用 include 语句包含  如果在 C++ 中包含一个非系统提供的 C 头文件，且 C 头文件可以修改，强烈建议在头文件添加 extern \u0026quot;C\u0026quot; {/**/} 语句使得 C++ 开发者更加容易使用 #include 包含此头文件到 C++ 代码 因为 C 编译器不理解 extern \u0026quot;C\u0026quot; {/**/} 结构，必须使用 #ifdef 包裹 extern \u0026quot;C\u0026quot; { 和 }，以便 C 编译器看不到这个结构\n//my-c-code.h //有且只有 C++ 编译器会定义 __cplusplus 符号 #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif //c code #ifdef __cplusplus } #endif }  #include \u0026quot;my-c-code.h\u0026quot; int main() { sum(1, 2); return 0; }   在 C++ 中调用非系统的 C 函数 f(int,char,float)  如果需要调用一个 C 函数，但是不需要或者不想包含声明此函数的 C 头文件，可以在 C++ 代码中使用 extern \u0026quot;C\u0026quot; 语法声明这一个 C 函数。一般需要使用完整的函数原型\nextern \u0026quot;C\u0026quot; void f(int,char,float); int main() { int i=1; char c='c'; float ff=2; f(i, c, ff); return 0; }  多个 C 函数可以使用 extern \u0026quot;C\u0026quot; {/**/}\n  创建一个可被 C 调用的 C++ 函数 f(int,char,float)  C++ 编译器必须通过 extern \u0026quot;C\u0026quot; 知道 f(int,char,float) 会被 C 编译器调用\nextern \u0026quot;C\u0026quot; void f(int,char,float); //define f(int,char,float) in some c++ module void f(int i, char c, float ff) [ //... ]  extern \u0026quot;C\u0026quot; 告诉编译器发送给链接器的外部信息应该使用 C 的调用管理和名称重整(name-mangling)(比如前置一个下划线)。因为 C 不支持名称重载，你不能在 C 程序中同时调用多个重载的函数\n  链接器在 C/C++ 调用 C++/C 函数时报错的原因  如果 `extern \u0026ldquo;C\u0026rdquo; 语法不正确，会有一些链接错误而不是编译器错误。因为 C++ 编译器通常会重整(mangle) 函数名称(比如为了支持函数重载)而跟 C 编译器不同  传递一个 C++ 类的对象给/从 C 函数 // fred.h: this header can be read by c/c++ compilers #ifndef FRED_H #define FRED_H #ifdef __cplusplus class Fred { public: Fred(); void wilma(int); private: int a_; }; #else typedef struct Fred Fred; #endif #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif #if defined(__STDC__) || defined(__cplusplus) extern void c_function(Fred*);///* ANSI C prototypes */ extern Fred* cplusplus_callback_function(Fred*); #else extern void c_function();///* K\u0026amp;R style */ extern Fred* cplusplus_callback_function(); #endif #ifdef __cplusplus } #endif #endif  // fred.cpp #include \u0026quot;fred.h\u0026quot; #include \u0026lt;stdio.h\u0026gt; Fred::Fred() : a_(0) { } void Fred::wilma(int a) { a_ = a; printf(\u0026quot;a=%d\\n\u0026quot;, a); } Fred* cplusplus_callback_function(Fred* fred) { fred-\u0026gt;wilma(123); return fred; }  // ccode.c #include \u0026quot;fred.h\u0026quot; void c_function(Fred* fred) { cplusplus_callback_function(fred); }  // cppcode.cpp #include \u0026quot;fred.h\u0026quot; int main() { Fred fred; c_function(\u0026amp;fred); return 0; }   编译命令 gcc fred.h fred.cpp ccode.c cppcode.cpp 或 gcc fred.h fred.cpp ccode.c cppcode.cpp，输出 a=123 和 C++ 代码不同，C 代码不能识别统一对象的两个指针，除非这两个指针完全是同一类型。比如，C++中容易检查指向同一对象的衍生类指针 dp 和基类指针 bp\n 判断 if(dp == bp)，C++ 编译器会自动转化两个指针到同一类型，这种情况下到基类指针，然后进行比较。这取决于 C++ 编译器的具体实现，有时候这种转化会改动一个指针值的比特位 技术层面上，大部分 C++ 编译器使用一个二进制对象格式以便多继承和/或虚继承的转换。但是 C++ 语言不会暴露对象格式，因此从原则上说，一个转化也会发生在非虚单继承 关键点是 C 编译器不知道如何做指针转换，所以从衍生类到基类指针的转换必须发生在 C++ 编译器编译的代码，而不是 C 编译器编译的代码 注意：当转换衍生类和基类指针到 void* 时必须要小心，因为这个不支持 C/C++ 编译器做适合的指针调整\nvoid f(Base* bp, Derived *dp) { if(bp ==dp) //valid to compare a Base* to Derived* { //... } void* xp = bp; void* yp = dp; if(x == y) //bad form! do not use this! { //... } }  如上所述，上述指针转换会发生在多继承和/或虚继承\n 使用 void* 指针的安全方式\nvoid f(Base* bp, Derived *dp) { void* xp = bp; // If conversion is needed, it will happen in the static_cast\u0026lt;\u0026gt; void* yp = static_cast\u0026lt;Base*\u0026gt;(dp); if(x == y)//valid to compare a Base* to Derived* { //.... } }    C 函数是否可以直接访问 C++ 类对象的数据  如果一个 C++ 类满足下面的条件，C 函数可以安全访问 C++ 对象的数据  没有虚函数(包括继承的虚函数) 所有数据的访问权限相同(private/protected/public) 不含带有虚函数的完全包含的子对象  如果 C++ 类由任何基类(或者其完全包含的子对象有基类)，对这些数据的访问都是不可移植的。因为语言不会暴露带有继承的类格式。但实际上，所以的 C++ 编译器的处理方式相同：基类对象在前面(多重继承时按照从左至右的顺序)，然后是成员对象 此外，如果该类(或任何基类)包含虚函数，几乎所有 C++ 编译器会在对象内放置一个 void*，或者是在第一个虚函数的位置，或者是在对象最开始的位置。这一点也不是语言要求的，但是每个语言都这样处理 如果类包含需基类，情况更加复杂且更难移植。一个通用的实现技术是在对象最后包含一个虚基类的对象(不管虚基类在继承中的层次结构)。对象的其他部分还是正常的顺序。每个衍生的类实际上有一个指向虚基类的指针？？？  使用 C++ 比 C 更觉得远离机器代码  作为面向对象(OO)的编程语言，C++ 支持模型化问题域，这支持在问题域的语言进行编程而不是使用解决方案域的语言编程 C 的一个很大优势是没有隐藏机制：看到的就是得到的。可以阅读一个 C 程序并看到每一个时钟周期。但 C++ 不支持。虽然 C++ 为编程者隐藏了一些机制，它也提供了一个抽象层和表达上的经济，以便降低维护成本且不会破坏运行时性能  参考  mixing c and cpp What is the effect of extern “C” in C++  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"0b23284ef78ab3e312115359564a7640","permalink":"https://xueqing.github.io/blog/cplusplus/mix_c_and_cpp/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/cplusplus/mix_c_and_cpp/","section":"blog","summary":"需要了解的知识 在 C++ 中调用 C 语言函数 在 C 中调用 C++ 语言函数 在 C 中调用 C++ 非成员函数 在 C 中调用 C++ 成员函数 在 C 中调用 C++ 重载函数 C++ 名称重整 C++ 链接器处理 C","tags":["c++"],"title":"结合 C 和 C++ 代码","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"  介绍 表驱动测试的例子 参考  参考 Go 维基官网——表驱动测试学习。\n原网页由 Martin Tournoij 在 2018/4/11 编辑。第 3 次修订。\n介绍 编写好的测试不是烦琐的，在很多情况下大量领域可以使用表驱动测试覆盖：每个表条目是一个包含输入和预期结果的测试用例，而且有时候包含一些额外的信息，比如测试名称，使得测试输出易于阅读。如果你曾经发现自己在编写测试时使用拷贝和粘贴，考虑是否重构为表驱动测试，或者把拷贝的代码放在一个辅助函数可能是一个更好的选择。\n给定一个测试用例表，真正的测试简单地迭代遍历所有表条目，且未每个条目执行必要的测试。测试代码只编写一次且被分摊到所有的表条目，因此精心编写一个带有好的错误消息的测试是有意义的。\n表驱动测试的例子 这里是一个来自 fmt 包测试代码的好例子：\nvar flagtests = []struct { in string out string }{ {\u0026quot;%a\u0026quot;, \u0026quot;[%a]\u0026quot;}, {\u0026quot;%-a\u0026quot;, \u0026quot;[%-a]\u0026quot;}, {\u0026quot;%+a\u0026quot;, \u0026quot;[%+a]\u0026quot;}, {\u0026quot;%#a\u0026quot;, \u0026quot;[%#a]\u0026quot;}, {\u0026quot;% a\u0026quot;, \u0026quot;[% a]\u0026quot;}, {\u0026quot;%0a\u0026quot;, \u0026quot;[%0a]\u0026quot;}, {\u0026quot;%1.2a\u0026quot;, \u0026quot;[%1.2a]\u0026quot;}, {\u0026quot;%-1.2a\u0026quot;, \u0026quot;[%-1.2a]\u0026quot;}, {\u0026quot;%+1.2a\u0026quot;, \u0026quot;[%+1.2a]\u0026quot;}, {\u0026quot;%-+1.2a\u0026quot;, \u0026quot;[%+-1.2a]\u0026quot;}, {\u0026quot;%-+1.2abc\u0026quot;, \u0026quot;[%+-1.2a]bc\u0026quot;}, {\u0026quot;%-1.2abc\u0026quot;, \u0026quot;[%-1.2a]bc\u0026quot;}, } func TestFlagParser(t *testing.T) { var flagprinter flagPrinter for _, tt := range flagtests { t.Run(tt.in, func(t *testing.T) { s := Sprintf(tt.in, \u0026amp;flagprinter) if s != tt.out { t.Errorf(\u0026quot;got %q, want %q\u0026quot;, s, tt.out) } }) } }  注意使用 t.Errorf 提供的详细的错误消息：提供了函数结果和预期结果；输入是子测试的名字。当测试失败时，哪个错误失败以及为什么失败是显然的，甚至不用阅读测试代码。\nt.Errorf 调用不是一个断言。即使打印一个错误日志，测试仍会继续。比如，当使用整数输入测试一些代码时，知道函数对所有输入失败，还是只对奇数失败，或者是对 2 的幂失败是有意义的。\n参考  如何编写 Go 代码——测试 常见问题解答——断言 常见问题解答——测试框架 testing 包  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"a1f96264fce369712603df16886fb318","permalink":"https://xueqing.github.io/translation/go-doc/wiki/table_driven_tests/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/wiki/table_driven_tests/","section":"translation","summary":"介绍 表驱动测试的例子 参考 参考 Go 维基官网——表驱动测试学习。 原网页由 Martin Tournoij 在 2018/4/11 编辑。第 3 次修订。 介绍 编写好的测试不是烦琐的，在很多情况下大量领域","tags":["go-doc-wiki"],"title":"表驱动测试","type":"translation"},{"authors":["kiki"],"categories":["translation"],"content":"  Unix 系统  Go 1.13 Bash Zsh fish  Windows  Go 1.13 (命令行) Windows 10 (图形用户界面) Windows 10 (命令行)   参考设置 GOPATH 维基学习。\n原网页由 Bryan C. Mills 在 2019/9/27 编辑。第 55 次修订。\nGOPATH 环境变量指定你的工作区的位置。如果没有设置 GOPATH，则认为 Unix 系统上是 $HOME/go 且 Windows 上是 %USERPROFILE%\\go。如果你想要使用自定义位置作为你的工作区，你可以设置 GOPATH 环境变量。此页解释如何在不同的平台上设置这个变量。\nUnix 系统 GOPATH 可以是你系统上的任一目录。在 Unix 系统上，我们将设置其为 $HOME/go (从 Go 1.8 其的默认值)。注意 GOPATH 一定不能和 Go 安装路径相同。另外一个常见的设置是设置 GOPATH=$HOME\nGo 1.13 go env -w GOPATH=$HOME/go\nBash 编辑 ~/.bash_profile，添加下面的行：\nexport GOPATH=$HOME/go  保存并退出编辑器。然后使 ~/.bash_profile 修改生效：\nsource ~/.bash_profile  Zsh 编辑 ~/.zshrc，添加下面的行：\nexport GOPATH=$HOME/go  保存并退出编辑器。然后使 ~/.zshrc 修改生效：\nsource ~/.zshrc  fish set -x -U GOPATH $HOME/go  -x 用于指定这个变量应被导出，且 -U 使其成为一个全局变量，对所有会话可用且是持久的。\nWindows 你的工作区可位于任何你喜欢的地方，但是我们在这个例子中使用 C:\\go-work。\n注意：GOPATH 一定不能和 Go 安装路径相同。\n 在 C:\\go-work 新建文件夹。 右击“开始”，并点击“控制面板”。选择“系统和安全”，然后点击“系统”。 从左边的菜单栏，选中“高级系统设置”。 点击底部的“环境变量”按钮。 从“用户变量”区域点击“新建”。 在“变量名”输入 GOPATH。 在“变量值”输入 C:\\go-work。 点击“确定”。  Go 1.13 (命令行)  打开一个命令提示符(Win+r 然后输入 cmd) 或者 powershell 窗口(Win+i)。 输入 go env -w GOPATH=c:\\go-work。  Windows 10 (图形用户界面) 有一个通过搜索编辑 环境变量 的快速方式：\n 左击“搜索”并输入 env 或 environment。 选择编辑账户的环境变量。 和上述步骤相同。  Windows 10 (命令行)  打开一个命令提示符(Win+r 然后输入 cmd) 或者 powershell 窗口(Win+i)。 输入 setx GOPATH %USERPROFILE%\\go。(这将会设置 GOPATH 为你的 [home folder]\\go，比如 C:\\Users\\yourusername\\go。) 关闭命令提示符或 powershell 窗口。(环境变量只对新的命令提示符或 powershell 窗口生效，当前窗口不生效。)  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"542d075e01a9ee8d5c182760bfa3138a","permalink":"https://xueqing.github.io/translation/go-doc/wiki/set_gopath/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/wiki/set_gopath/","section":"translation","summary":"Unix 系统 Go 1.13 Bash Zsh fish Windows Go 1.13 (命令行) Windows 10 (图形用户界面) Windows 10 (命令行) 参考设置 GOPATH 维基学习。 原网页由 Bryan C. Mills 在 2019/9/27 编辑。第 55 次修订。 GOPATH 环境变量指定你的","tags":["go-doc-wiki"],"title":"设置 GOPATH","type":"translation"},{"authors":["kiki"],"categories":["blog"],"content":"  1 描述 2 计算机安全 3 访问控制模型 4 基于角色的访问控制 vs 基于属性的访问控制  4.1 基于角色的访问控制 4.2 基于属性的访问控制 4.3 选择基于属性的访问控制/基于角色的访问控制 4.3.1 RBAC 的优缺点 4.3.2 ABAC 的优缺点 4.3.3 总结  5 参考  1 描述  在物理安全和信息安全领域，访问控制(Access Control, AC)是对一个地方或其他资源的一个选择性限制访问。访问的含义可能是消费、进入或者使用。授权访问一个资源叫做鉴权(authorization) 锁和登录凭证是访问控制两种类似的机制  2 计算机安全  在计算机安全领域，通常的访问控制包括身份认证、授权和审计。一个更狭义的访问控制值包含访问批准，即系统决定允许或拒绝一个已认证的主体的访问请求，基于该主体被授权访问的内容 身份认证和访问控制通常合并成一个操作，以便于基于成功的身份认证，或基于一个匿名的访问令牌批准访问。身份认证方法和令牌包括密码、生物扫描、物理钥匙、电子钥匙和设备、隐藏路径、社会障碍、人类和自动系统的监控 在所有的访问控制模型中，可以对系统执行操作的实体称为主体，访问需要控制的资源实体称作对象。主体和对象应当做软件实体，而不是人类用户：所有的人类用户只能通过他们控制的软件实体影响系统 从 2014 年起，访问控制模型趋于两类  基于能力的模型(capability-based model)：对一个对象持有不可伪造的引用或能力提供了对该对象的访问(差不多类似于持有一个房子的钥匙批准访问该房子)。通过一个安全的通道传递这个能力给另一个组来传递访问权限 基于 ACL(Access control lists) 的模型(ACL-based model)：主体访问一个对象取决于主体的身份是否出现在跟对象相关的列表(差不多类似于一个私人派对的门卫会检查 ID 看是否在客人名单上)。通过编辑列表传递访问权限。(不同的 ACL 系统对于谁或者什么负责编辑列表以及如何编辑列表有不同的惯例)  基于能力和基于 ACL 的模型都有机制允许将访问权限授予一组主体的所有成员 访问控制系统提供基本的服务，包括售授权(authorization)、身份识别和认证(identification and authentication, I\u0026amp;A)、访问批准(access approval)和问责(accountability)  授权：指定一个主体可以做的 身份识别和认证：确保只有合法的主体可以登录系统 访问批准：基于授权策略，介个用户可以访问的资源，在操作中授权访问 问责：识别一个主体(或与一个用户相关的所有主体)做过的   3 访问控制模型    访问控制模型 描述     基于属性的访问控制(Attribute-based access control, ABAC) 通过使用策略评估属性(用户属性、资源属性和环境条件)授予访问权限   自主访问控制(Discretionary access control, DAC) 由数据所有者确定谁可以访问指定的资源   基于历史的访问控制(History-based access control, HBAC) 根据请求组的历史活动(行为、请求时间间隔、请求内容等)实时评估授予或取消访问权限。比如，当请求间隔超过一秒一个时，可以授予或取消对服务或数据源的访问权限   基于身份的访问控制(Identity-based access control, IBAC) 网络管理员使用此模型可基于个人需求更加有效地管理活动和访问   强制访问控制(Mandatory access control, MAC) 用户没有太多自由确定谁可以访问他们的文件。由系统对用户创建的对象进行统一的强制性控制   基于组织的访问控制(Organization-based access control, OrBAC) 允许策略设计者定义一个与实现无关的安全策略   基于角色的访问控制(Role-based access control, RBAC) 根据工作标题允许访问。RBAC 在提供对对象的访问时很大程度上忽略了自由。例如，一个人类资源专家不应该允许创建网络账户，此角色应该保留给网络管理员   基于规则的访问控制(Rule-based access control, RAC) 大部分基于上下文。比如只允许学生在一天的一部分时间段使用实验室   基于责任的访问控制(Responsibility based access control) 基于分配给一个演员或业务角色的责任访问信息    4 基于角色的访问控制 vs 基于属性的访问控制 4.1 基于角色的访问控制  RBAC 是基于定义组织内的雇佣角色和对应特权的访问控制方法。模型的思想是每个雇员被分配一个角色。每个角色有一组权限和限制。一个雇员只有他们在系统中的角色有相关权限才可以访问对象和执行操作 例如：一个公司的会计应允许访问财务信息，但是不应访问客户联系信息或信用卡数据 一个用户可被分配一个或多个角色。当有新雇员时，很容易给他们分配一个角色。当有人离开公司，也不需要修改角色参数或中心策略 几个主要的组成部分  用户：可以访问系统的个人(有 UID) 角色：命名的工作职能(表明授权级别) 权限：等于访问权利 会话：用户和角色直接的映射，表明用户在一个工作时间上下文被分配的角色 对象：需要权限访问的系统资源 操作：在受保护的网络的任何操作  基本规则  只有一个主体被分配了对象，此用户才可以执行一个操作 身份识别和认证不属于操作 所有的用户行为通过操作完成  RBAC 的实现有 4 个等级  扁平的 RBAC：实现 RBAC 模型的基本功能。为所有的用户和权限分配角色。用户通过获得角色取得权限。可以根据公司需求有足够多的角色和权限。可分配一个用户多个角色，也可分配一个角色给多个用户 分层的 RBAC：在角色结构内实现分层。分层建立了角色之间的关系。高等级角色的用户拥有低等级角色用户的权限。高等级用户可将低等级角色分配给他的下属 受限的 RBAC：给安全系统增加了职责分离(SOD, separation of duties)。当一个单一的职责分布在几个雇员时，SOD 是一个众所周知的安全实践。这个对于大中型企业是十分重要的。职责分离保证没有工作会给系统引入虚假的改变，且这些改变没有人可以审计或修正 对称的 RBAC：支持权限-角色审查和用户-角色审查。它允许识别分配给已有角色的权限(反之亦然)。比如，通过识别一个终止雇员的权限，管理员可以撤回该雇员的权限，然后重新分配角色给其他用户，而权限是相同的或者不同的  难点在于定义角色。需要考虑一个用户完成任务需要的所有权限及该角色的层级。如果赋予一个角色太多权限，会破坏最小权限原则，导致权限误用 RBAC 通常应用在小型和中型企业。这些组织通常是简单的工作流、有限的角色和比较简单的等级，使得可以有效地确定和描述用户角色  4.2 基于属性的访问控制  ABAC 由 RBAC 演变而来。模型基于为系统内的元素创建一系列属性。中心策略定义了执行任何操所需的用户和对象属性的组合 主要的组件包括  属性：网络中所有元素的特点。一个属性可以是 用户特点：雇佣者位置，部门，IP 地址，许可级别等 对象特点：类型，创建者，敏感度，所需的许可级别等 行为类型：读，写，编辑，拷贝，粘贴等 环境特点：时间，星期，位置等 主体：网络中可执行操作的所有用户或资源。为一个主体分配属性以定义它的许可级别 对象：网络中存储的所有数据。为对象分配属性以描述和识别它们 操作：网络中任何主体执行的行为 策略：允许或限制信息检索系统中的所有行为的一系列规则。规则是基于所有元素(用户、资源、环境)的属性的“If/Then”语句  ABAC 适用于各种大小的奇特，但是更多应用域大型组织。ABAC 的部署和配置阶段比 RBAC 需要更多时间和经理，因为安全管理员需要定义系统的所有属性。一开始，需要为每个系统组件手动分配属性 与 RBAC 相比，ABAC 是一个更加细粒度的访问控制模型  4.3 选择基于属性的访问控制/基于角色的访问控制 4.3.1 RBAC 的优缺点  优点  主要的优点是公司不需要授予或废除个人的访问权限，而是基于角色将用户绑定到一起 为小中型公司创建一系列角色不是很难  缺点  为大公司创建一系列角色是困难的 在用户开始工作之前，不能使用系统未知的参数创建规则 权限只能分配给用户角色，而不包括对象和操作 可以限制系统内对一些行为的访问，但是不是限制对一些数据的访问   4.3.2 ABAC 的优缺点  优点  主要优点是基于每个系统组件的属性而不是用户的角色授权。因此，可以描述任何复杂度的业务规则。当需要限制一些数据是工作时间段内可访问的，可以通过简单的策略实现 可以评估授权系统还未创建的主体和资源属性  缺点  因为需要指定和维护策略，所以系统配置是困难的 几乎不可能确定所有给定的雇佣角色承担的风险   4.3.3 总结    特点 RBAC ABAC     灵活性 Y(适用于小中型组织) Y   可扩展性 - Y   简单性 易于为小公司建立角色和权限，但是对于大公司难以维护 开始的时候难以创建所有策略，易于维护和支持   对简单规则的支持 Y Y   对复杂规则的支持 Y Y   对包含动态参数的规则的支持 - Y   自定义用户权限 -(每个自定义都需要创建一个新角色) Y   粒度 低 高     结合 RBAC 和 ABAC：公司在开始通常实现一个扁平的 RBAC。这个模型易于设置和维护。随着组织成长以及管理更多敏感数据，公司意识到需要更加复杂的访问控制系统。RBAC 和 ABAC 可以一起使用，其中 RBAC 负责粗粒度的工作，ABAC 实现细粒度的部分 这个模型也称作 RBAC-A。有三个方法处理角色和属性之间的关系  以属性为中心：一个角色称为其中一个用户属性的名字。它类似一个工作标题。这个模型中的角色属性用于标记一个中心位置所需的一系列属性 以角色为中心：增加属性以限制角色。这个模型中的属性可以减少用户可得的权限。这个方式可以增加数据的安全性 动态角色：属性(例如一天的时间)可用于决定主体的角色。这种情况下，一个用户的角色可以由动态属性完全确定   5 参考  Access control wiki Role-based Access Control vs Attribute-based Access Control: How to Choose  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2bdde9ed7db391544f7cd474b3d4fa8c","permalink":"https://xueqing.github.io/blog/sip/access_control/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/access_control/","section":"blog","summary":"1 描述 2 计算机安全 3 访问控制模型 4 基于角色的访问控制 vs 基于属性的访问控制 4.1 基于角色的访问控制 4.2 基于属性的访问控制 4.3 选择基于属性的访问控制/基","tags":["sip"],"title":"访问控制","type":"blog"},{"authors":["kiki"],"categories":["translation"],"content":"一些导入路径也描述了如何使用版本控制系统获取包的源码。\n一些常见的代码托管网站有一些特殊的语法：\nBitbucket (Git, Mercurial) import \u0026quot;bitbucket.org/user/project\u0026quot; import \u0026quot;bitbucket.org/user/project/sub/directory\u0026quot; GitHub (Git) import \u0026quot;github.com/user/project\u0026quot; import \u0026quot;github.com/user/project/sub/directory\u0026quot; Launchpad (Bazaar) import \u0026quot;launchpad.net/project\u0026quot; import \u0026quot;launchpad.net/project/series\u0026quot; import \u0026quot;launchpad.net/project/series/sub/directory\u0026quot; import \u0026quot;launchpad.net/~user/project/branch\u0026quot; import \u0026quot;launchpad.net/~user/project/branch/sub/directory\u0026quot; IBM DevOps Services (Git) import \u0026quot;hub.jazz.net/git/user/project\u0026quot; import \u0026quot;hub.jazz.net/git/user/project/sub/directory\u0026quot;  对于托管在其他服务商的代码，导入路径或者具备版本控制类型，或者 go 工具可以通过 https/http 动态拉取导入路径，然后从 HTML 的 \u0026lt;meta\u0026gt; 标签代码位置。\n为了声明代码位置，具有形式 repository.vcs/path 的导入路径指定了给定的仓库(使用或不使用 .vcs 后缀，使用命名的版本控制系统)和该仓库内的路径。支持的版本控制系统是：\nBazaar .bzr Fossil .fossil Git .git Mercurial .hg Subversion .svn  比如，import \u0026quot;example.org/user/foo.hg\u0026quot; 表示根目录在 Mercurial 仓库的 example.org/user/foo 或 foo.hg，且 import \u0026quot;example.org/repo.git/foo/bar\u0026quot; 表示 Git 仓库的 foo/bar 目录在 example.org/repo 或 repo.git。\n当一个版本控制系统支持多个协议时，下载时轮流尝试每个协议。比如，一个 Git 下载尝试 https://，然后是 git+ssh://。\n默认的，下载受限于已知的安全协议(比如，https 和 ssh)。要覆盖 Git 下载的这个设置，可以设置 GIT_ALLOW_PROTOCOL 环境变量(查看 go help environment 获取更多信息)。\n如果导入路径不是已知的代码托管网站，且缺少版本控制限定符，go 工具尝试通过 https/http 查找 HTML \u0026lt;head\u0026gt; 的 \u0026lt;meta\u0026gt; 标签来拉取导入。\nmeta 标签有这样的形式 \u0026lt;meta name=\u0026quot;go-import\u0026quot; content=\u0026quot;import-prefix vcs repo-root\u0026quot;\u0026gt;。\nimport-prefix 是对应 repo-root 的导入路径。它必须是一个前缀，或者是借助 go get 拉取包的一个精确匹配。如果不是一个精确匹配，生成另外一个 http 请求来验证 meta 标签。\nmeta 标签应该尽早出现在文件中。特别地，它应该出现在任何原始的 JavaScript 或 CSS 之前，避免使 go 命令受限的解释器不能理解。\nvcs 是 bzr/fossil/git/hg/svn 中的一个。\nrepo-root 是版本控制系统的根，包含了一个体系，但是不包含 .vcs 限定符。\n比如，import \u0026quot;example.org/pkg/foo\u0026quot; 会导致下面的请求\nhttps://example.org/pkg/foo?go-get=1 (preferred) http://example.org/pkg/foo?go-get=1 (fallback, only with -insecure)  如果页面包含 meta 标签 \u0026lt;meta name=\u0026quot;go-import\u0026quot; content=\u0026quot;example.org git https://code.org/r/p/exproj\u0026quot;\u0026gt;，那么 go 工具会验证 https://example.org/pkg/foo?go-get=1 包含相同的 meta 标签，然后使用 git clone https://code.org/r/p/exproj 克隆源码到 GOPATH/src/example.org。\n当使用 GOPATH 时，下载的包被写到 GOPATH 环境变量列举的第一个目录。(查看 go help gopath-get 和 go help gopath。)\n当使用模块时，下载的包存储在模块缓存。(查看 go help module-get 和 go help goproxy。)\n当使用模块时，go-import meta 标签的额外的变量被识别且更倾向于通过这些列举的版本控制系统。比如，在 \u0026lt;meta name=\u0026quot;go-import\u0026quot; content=\u0026quot;example.org mod https://code.org/moduleproxy\u0026quot;\u0026gt; 中，该变量使用 “mod” 作为 vcs 内容的值。\n这个标签意味着使用以 example.org 开始的路径从 https://code.org/moduleproxy 可用的模块代理拉取模块。查看 go help goproxy 获取更多关于代理的信息。\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"7de00ef92eded468c631a45f7df81797","permalink":"https://xueqing.github.io/translation/go-doc/command/remote_import_path/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/translation/go-doc/command/remote_import_path/","section":"translation","summary":"一些导入路径也描述了如何使用版本控制系统获取包的源码。 一些常见的代码托管网站有一些特殊的语法： Bitbucket (Git, Mercurial) import \u0026quot;bitbucket.org/user/project\u0026quot; import \u0026quot;bitbucket.org/user/project/sub/directory\u0026quot; GitHub (Git) import \u0026quot;github.com/user/project\u0026quot; import \u0026quot;github.com/user/project/sub/directory\u0026quot; Launchpad (Bazaar) import \u0026quot;launchpad.net/project\u0026quot; import \u0026quot;launchpad.net/project/series\u0026quot; import \u0026quot;launchpad.net/project/series/sub/directory\u0026quot; import \u0026quot;launchpad.net/~user/project/branch\u0026quot;","tags":["go-command"],"title":"远程导入路径","type":"translation"},{"authors":["kiki"],"categories":["reading"],"content":" 凌晨四点，米拉得出这样的结论：一个可以倾吐心声的空间和一个可以倾听的人（即使这个人是不完美的），对人们来说足矣。即使不够，到头来，这也是我们能为彼此提供的唯一帮助了。\n ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b90cb3e6e07a104a4c8a5c7b5eb23692","permalink":"https://xueqing.github.io/reading/%E9%86%92%E6%9D%A5%E7%9A%84%E5%A5%B3%E6%80%A7/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/reading/%E9%86%92%E6%9D%A5%E7%9A%84%E5%A5%B3%E6%80%A7/","section":"reading","summary":"凌晨四点，米拉得出这样的结论：一个可以倾吐心声的空间和一个可以倾听的人（即使这个人是不完美的），对人们来说足矣。即使不够，到头来，这也是我们","tags":["women","dependence"],"title":"醒来的女性","type":"reading"},{"authors":["kiki"],"categories":["blog"],"content":"  git filter-branch 参考  git filter-branch # 从所有提交中删除文件 filename # 当提交中不包含此文件时，`rm filename`会失败提交，可使用`rm -f filename` git filter-branch --tree-filter 'rm filename' HEAD # 比 --tree-filter 更快 git filter-branch --index-filter 'git rm --cached --ignore-unmatch filename' HEAD  参考  git filter-branch doc  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"2fbf8a5c6c7662ac4e811d1ef5cb58ab","permalink":"https://xueqing.github.io/blog/git/git_filter_branch/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_filter_branch/","section":"blog","summary":"git filter-branch 参考 git filter-branch # 从所有提交中删除文件 filename # 当提交中不包含此文件时，`rm filename`会失败提交，可使用`rm -f filename` git filter-branch --tree-filter 'rm filename' HEAD # 比 --tree-filter 更快 git filter-branch","tags":["git"],"title":"重写分支","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  将当前分支的 HEAD 重设到指定的状态  语法  git reset [\u0026lt;mode\u0026gt;] [-q] [\u0026lt;commit\u0026gt;]  mode 包括--soft | --mixed [N] | --hard | --merge | --keep 设置当前分支的 HEAD 到 \u0026lt;commit\u0026gt; mixed 是默认模式  reset 之前，git 会保存原本的 HEAD 到 ORIG_HEAD\n git reset \u0026lt;commit\u0026gt; 之后可通过 git reset ORIG_HEAD 回到原来的地方\n# 重设暂存区和工作区, 丢弃所有改变, 把 HEAD 指向 commit git reset --hard # 暂存区和工作区内容不做任何改变, 仅把 HEAD 指向 commit, 可用于删除提交历史记录, 只生成一次提交 git reset --soft # 仅重设暂存区, 不改变工作区 git reset --mixed    git reset \u0026ndash;soft 合并提交 # 合并最近 3 次提交 git reset --soft HEAD~3 # 使用这 3 次提交的信息 git commit --edit -m\u0026quot;$(git log --format=%B --reverse HEAD..HEAD@{1})\u0026quot; # 重新编写提交信息 git add . \u0026amp;\u0026amp; git commit -m \u0026quot;new commit message\u0026quot;  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"b7b69349a64909ca69d87311d41c0a01","permalink":"https://xueqing.github.io/blog/git/git_reset/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/git/git_reset/","section":"blog","summary":"将当前分支的 HEAD 重设到指定的状态 语法 git reset [\u0026lt;mode\u0026gt;] [-q] [\u0026lt;commit\u0026gt;] mode 包括--soft | --mixed [N] | --hard | --merge | --keep 设置当前分支的 HEAD 到 \u0026lt;commit\u0026gt; mixed 是默认模式 reset 之前，git 会保存原本的 HEAD","tags":["git"],"title":"重设状态","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":"  登录/退出 拉取镜像 上传镜像  登录/退出 # 登陆到一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker login [OPTIONS] [SERVER] # 登出一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker logout [OPTIONS] [SERVER]  OPTIONS 说明：\n -u: 登陆的用户名 -p: 登陆的密码  登陆到 Docker Hub。\ndocker login -u username -p password  登出 Docker Hub。\ndocker logout  拉取镜像 从镜像仓库中拉取或者更新指定镜像。\ndocker pull [OPTIONS] NAME[:TAG|@DIGEST]  OPTIONS 说明：\n -a: 拉取所有 tagged 镜像 \u0026ndash;disable-content-trust: 忽略镜像的校验,默认开启  从 Docker Hub 下载 java 最新版镜像。\ndocker pull -a java  上传镜像 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库。\ndocker push [OPTIONS] NAME[:TAG]  OPTIONS 说明：\n \u0026ndash;disable-content-trust: 忽略镜像的校验,默认开启  上传本地镜像 myapache:v1 到镜像仓库中。\ndocker push myapache:v1  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"f383e1cb715c78c3b8ffa4c9915372d5","permalink":"https://xueqing.github.io/blog/docker/image_rep_cmd/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/docker/image_rep_cmd/","section":"blog","summary":"登录/退出 拉取镜像 上传镜像 登录/退出 # 登陆到一个 Docker 镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub docker login [OPTIONS] [SERVER] # 登出一个 Docker 镜像仓库，如果未指","tags":["docker"],"title":"镜像仓库命令","type":"blog"},{"authors":["kiki"],"categories":["blog"],"content":" 参考  GMT 0005-2012 随机性检测规范  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"zh","lastmod":-62135596800,"objectID":"c965740bb4bd0f5b2305c6bbd0be91d0","permalink":"https://xueqing.github.io/blog/sip/algo/random/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/blog/sip/algo/random/","section":"blog","summary":"参考 GMT 0005-2012 随机性检测规范","tags":["sip"],"title":"随机数生成算法","type":"blog"}]