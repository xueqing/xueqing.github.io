<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>shell | kiki</title>
    <link>https://xueqing.github.io/tags/shell/</link>
      <atom:link href="https://xueqing.github.io/tags/shell/index.xml" rel="self" type="application/rss+xml" />
    <description>shell</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language>
    <image>
      <url>https://xueqing.github.io/img/icon-192.png</url>
      <title>shell</title>
      <link>https://xueqing.github.io/tags/shell/</link>
    </image>
    
    <item>
      <title>bash</title>
      <link>https://xueqing.github.io/blog/shell/bash/bash_shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/shell/bash/bash_shell/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#description&#34;&gt;description&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#synopsis&#34;&gt;synopsis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#options&#34;&gt;options&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#single-character-options&#34;&gt;single character options&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multi-character-options&#34;&gt;multi character options&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arguments&#34;&gt;arguments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#invocation&#34;&gt;invocation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#definitions&#34;&gt;definitions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reserverdwords&#34;&gt;reserverd_words&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-grammar&#34;&gt;shell grammar&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#simple-commands&#34;&gt;simple commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pipelines&#34;&gt;pipelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lists&#34;&gt;lists&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#compound-commands&#34;&gt;compound commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#coprocesses&#34;&gt;coprocesses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89&#34;&gt;函数定义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#comments&#34;&gt;comments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#quoting&#34;&gt;quoting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#parameters&#34;&gt;parameters&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#positional-parameters&#34;&gt;positional parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#special-parameters&#34;&gt;special parameters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-variables&#34;&gt;shell variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#array&#34;&gt;array&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#expansion&#34;&gt;expansion&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#brace-expansion&#34;&gt;brace expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tilde-expansion&#34;&gt;tilde expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#parameter-expansion&#34;&gt;parameter expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#command-substitution&#34;&gt;command substitution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arithmetic-expansion&#34;&gt;arithmetic expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#process-substitution&#34;&gt;process substitution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#word-splitting&#34;&gt;word splitting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pathname-expansion&#34;&gt;pathname expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#quote-removal&#34;&gt;quote removal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#redirection&#34;&gt;redirection&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#input&#34;&gt;input&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#output&#34;&gt;output&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appending-redirected-output&#34;&gt;appending redirected output&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#redirecting-standard-output-and-standard-error&#34;&gt;redirecting standard output and standard error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#appending-standard-output-and-standard-error&#34;&gt;appending standard output and standard error&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#here-documents&#34;&gt;here documents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#here-strings&#34;&gt;here strings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#duplicating-file-descriptors&#34;&gt;duplicating file descriptors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#moving-file-descriptors&#34;&gt;moving file descriptors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#opening-file-descriptors-for-reading-and-writing&#34;&gt;opening file descriptors for reading and writing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#aliases&#34;&gt;aliases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#functions&#34;&gt;functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arithmetic-evaluation&#34;&gt;arithmetic evaluation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conditional-expressions&#34;&gt;conditional expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#simple-command-expansion&#34;&gt;simple command expansion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#command-execution&#34;&gt;command execution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#command-execution-environment&#34;&gt;command execution environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#environment&#34;&gt;environment&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exit-status&#34;&gt;exit status&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#signals&#34;&gt;signals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#job-control&#34;&gt;job control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#prompting&#34;&gt;prompting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#readline&#34;&gt;readline&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#readline-notation&#34;&gt;readline notation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#readline-initialization&#34;&gt;readline initialization&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#readline-key-bindings&#34;&gt;readline key bindings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#readline-variables&#34;&gt;readline variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#readline-conditional-constructs&#34;&gt;readline conditional constructs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#searching&#34;&gt;searching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#readline-command-names&#34;&gt;readline command names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#commands-for-moving&#34;&gt;commands for moving&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#commands-for-manipulating-the-history&#34;&gt;commands for manipulating the history&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#commands-for-changing-text&#34;&gt;commands for changing text&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#killing-and-yanking&#34;&gt;killing and yanking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#numeric-arguments&#34;&gt;numeric arguments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#completing&#34;&gt;completing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#keyboard-macros&#34;&gt;keyboard macros&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#miscellaneous&#34;&gt;miscellaneous&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#programmable-completion&#34;&gt;programmable completion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#history&#34;&gt;history&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#history-expansion&#34;&gt;history expansion&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#event-designators&#34;&gt;event designators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#word-designators&#34;&gt;word designators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#modifiers&#34;&gt;modifiers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-builtin-commands&#34;&gt;shell builtin commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#restricted-shell&#34;&gt;restricted shell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#files&#34;&gt;files&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;description&#34;&gt;description&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;bash(Bourne-Again SHell)，是一种 sh-兼容的命令语言解释器，执行从标准输入或文件读取的命令&lt;/li&gt;
&lt;li&gt;bash 也吸收了 knor 和 C shell(ksh 和 csh)的一些有用的特点&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;synopsis&#34;&gt;synopsis&lt;/h2&gt;

&lt;p&gt;总览&lt;code&gt;bash [options] [command_string | file]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;options&#34;&gt;options&lt;/h2&gt;

&lt;h3 id=&#34;single-character-options&#34;&gt;single character options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;表示从第一个非选项的&lt;code&gt;command_string&lt;/code&gt;读命令。如果&lt;code&gt;command_string&lt;/code&gt;之后有参数，赋值给对应位置的参数，从&lt;code&gt;$0&lt;/code&gt;开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;表示 shell 是交互式的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;表示 shell 是&lt;a href=&#34;#restricted-shell&#34;&gt;受限的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;或者选项后面没有参数，表示从标准输入读命令。这个选项允许在启动交互式 shell 时设置位置参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O [shopt option]&lt;/code&gt;shopt option 是由内置的&lt;a href=&#34;#shell-builtin-commands&#34;&gt;shopt&lt;/a&gt;接收的参数

&lt;ul&gt;
&lt;li&gt;如果有&lt;code&gt;shopt option&lt;/code&gt;，&lt;code&gt;-O&lt;/code&gt;设置该选项的值；&lt;code&gt;+O&lt;/code&gt;取消设置&lt;/li&gt;
&lt;li&gt;如果没有&lt;code&gt;shopt option&lt;/code&gt;，选项的名字和值被输出到标准输出&lt;/li&gt;
&lt;li&gt;如果调用选项是&lt;code&gt;+O&lt;/code&gt;，输出按一定格式展示可当做输入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--&lt;/code&gt;标记选择的终止，不再处理选项。后面的参数都当做文件名或参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;multi-character-options&#34;&gt;multi character options&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--rcfile file&lt;/code&gt;在交互式 shell 中，执行&lt;code&gt;file&lt;/code&gt;的命令，而不是系统范围的初始化文件&lt;code&gt;/etc/bash.bashrc&lt;/code&gt;或标准的个人初始化文件&lt;code&gt;~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--noprofile&lt;/code&gt;在启动一个交互式 shell 的时候，选项会根据几个默认的文件配置环境。此选项表示不要读这些文件

&lt;ul&gt;
&lt;li&gt;系统范围的开始文件&lt;code&gt;/etc/profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有的个人初始化文件&lt;code&gt;~/.bash_profile&lt;/code&gt;，&lt;code&gt;~/.bash_login&lt;/code&gt;和&lt;code&gt;~/.profile&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--norc&lt;/code&gt;在交互式 shell 中，不要读系统范围的初始化文件&lt;code&gt;/etc/bash.bashrc&lt;/code&gt;和标准的个人初始化文件&lt;code&gt;~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;arguments&#34;&gt;arguments&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果处理的选项之后还要参数，且没有&lt;code&gt;-c&lt;/code&gt;和&lt;code&gt;-s&lt;/code&gt;，第一个参数被认为是包含 shell 命令的文件。&lt;code&gt;$0&lt;/code&gt;设置成这个文件名，其他的位置参数设置为剩下的参数&lt;/li&gt;
&lt;li&gt;bash 从这个文件读并执行命令，然后退出&lt;/li&gt;
&lt;li&gt;bash 的退出状态是最后执行的命令的状态，没有执行命令则退出状态是 0&lt;/li&gt;
&lt;li&gt;bash 先尝试从当前目录查找文件，如果没有，则从&lt;code&gt;PATH&lt;/code&gt;中查找这个脚本文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;invocation&#34;&gt;invocation&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;当 bash 作为一个交互式的登录 shell，或非交互式的带有&lt;code&gt;--login&lt;/code&gt;的 shell

&lt;ul&gt;
&lt;li&gt;如果&lt;code&gt;/etc/profile&lt;/code&gt;存在则读并执行命令&lt;/li&gt;
&lt;li&gt;按照&lt;code&gt;~/.bash_profile&lt;/code&gt;，&lt;code&gt;~/.bash_login&lt;/code&gt;和&lt;code&gt;~/.profile&lt;/code&gt;的顺序查找文件，存在的话就读和执行命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果是一个登录 shell，如果&lt;code&gt;~/.bash_logout&lt;/code&gt;文件存在，则读和执行命令&lt;/li&gt;
&lt;li&gt;如果是一个交互式的非登录 shell如果&lt;code&gt;/etc/bash.bashrc&lt;/code&gt;和&lt;code&gt;~/.bashrc&lt;/code&gt;文件存在，则读和执行命令&lt;/li&gt;
&lt;li&gt;如果是非交互式 shell，比如运行一个 shell 脚本，查找环境的&lt;code&gt;BASH_ENV&lt;/code&gt;，如果存在则展开它的值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;definitions&#34;&gt;definitions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;blank 一个空格或制表符&lt;/li&gt;
&lt;li&gt;word shell 认为是一个整体的字符序列，也叫 token&lt;/li&gt;
&lt;li&gt;name 一个只包含字母和下划线的 word，而且以字母或下划线开头，也叫 identifier&lt;/li&gt;
&lt;li&gt;metacharacter 当未加引号时，用来分离 word 的字符，包括&lt;code&gt;| &amp;amp; ; ( ) &amp;lt; &amp;gt;&lt;/code&gt;、空格和制表符&lt;/li&gt;
&lt;li&gt;control operator 执行一个控制函数的 token，包括&lt;code&gt;|| &amp;amp; &amp;amp;&amp;amp; ; ;; ( ) | |&amp;amp;&lt;/code&gt;和换行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reserverd-words&#34;&gt;reserverd_words&lt;/h2&gt;

&lt;p&gt;保留字是对 shell 有特殊含义的单词。包括&lt;code&gt;! case coproc do done elif else esac fi for function if in select then until while { } time [[ ]]&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;shell-grammar&#34;&gt;shell grammar&lt;/h2&gt;

&lt;h3 id=&#34;simple-commands&#34;&gt;simple commands&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;简单命令的格式第一个 word 是要执行的命令，作为参数 0，即&lt;code&gt;$0&lt;/code&gt;，剩余的 word 作为命令的参数&lt;/li&gt;
&lt;li&gt;简单命令的返回值就是它的退出状态；如果是被信号&lt;code&gt;n&lt;/code&gt;终止的，则返回&lt;code&gt;128+n&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;pipelines&#34;&gt;pipelines&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个 pipeline 是一个或多个命令，使用控制操作符&lt;code&gt;|&lt;/code&gt;或&lt;code&gt;|&amp;amp;&lt;/code&gt;分割&lt;/li&gt;
&lt;li&gt;格式&lt;code&gt;[time [-p]] [ ! ] command [ [|或|&amp;amp;] command2 ... ]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;管道的连接在重定向之前执行&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;|&amp;amp;&lt;/code&gt;，前一个命令的标准错误和标准输出通过管道连接到下一个命令的标准输入，是&lt;code&gt;2&amp;gt;&amp;amp;1 |&lt;/code&gt;的简写&lt;/li&gt;
&lt;li&gt;返回值&lt;/li&gt;
&lt;li&gt;管道的返回值是最后一个目录的返回状态，除非开启了&lt;code&gt;pipefail&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许&lt;code&gt;pipefail&lt;/code&gt;，返回状态是最后一个最正确(rightmost)命令，退出一个非 0 状态，或者都正常退出的话返回 0&lt;/li&gt;
&lt;li&gt;管道之前有&lt;code&gt;!&lt;/code&gt;，则返回的是上述返回值的逻辑否定值&lt;/li&gt;
&lt;li&gt;shell 等待管道中的所有命令终止才会返回&lt;/li&gt;
&lt;li&gt;包括字&lt;code&gt;time&lt;/code&gt;使得管道终止的时候，报告所有花费的时间，包括用户和系统时间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;使用 POSIX 指定的输出格式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;管道中的每个命令都是一个单独的进程(比如，在一个子 shell 执行)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;lists&#34;&gt;lists&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;list 是值一个 pipeline 或由符号&lt;code&gt;; &amp;amp; &amp;amp;&amp;amp; ||&lt;/code&gt;分隔的多个 pipeline，以&lt;code&gt;; &amp;amp;&lt;/code&gt;或换行终止&lt;/li&gt;
&lt;li&gt;优先级：&lt;code&gt;&amp;amp;&amp;amp; = || &amp;gt; ; = &amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;&amp;amp;&lt;/code&gt;控制符结尾表示 shell 将在一个子 shell 中执行该命令，且在后台运行，不会等待该命令结束，返回状态是 0&lt;/li&gt;
&lt;li&gt;以&lt;code&gt;;&lt;/code&gt;分隔的命令按顺序执行，返回状态是最后执行的命令的返回状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command1 &amp;amp;&amp;amp; command2&lt;/code&gt;只有 command1 返回状态是 0 时才会执行 command2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command1 || command2&lt;/code&gt;只有 command1 返回状态非 0 时才会执行 command2&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;compound-commands&#34;&gt;compound commands&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;(list)&lt;/code&gt;在子 shell 中执行 list，返回状态是 list 的返回状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{ list; }&lt;/code&gt;在当前 shell 中执行 list，是&lt;code&gt;group command&lt;/code&gt;，返回状态是 list 的返回状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;((expression))&lt;/code&gt;以&lt;a href=&#34;#arithmetic-evaluation&#34;&gt;算术求值&lt;/a&gt;规则计算表达式，如果值非 0 则返回 0，否则返回 1，等同于&lt;code&gt;let &amp;quot;expression&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[ expression ]]&lt;/code&gt;根据&lt;a href=&#34;#conditional-expressions&#34;&gt;条件表达式&lt;/a&gt;的值确定返回状态是 0 还是 1

&lt;ul&gt;
&lt;li&gt;表达式中不会执行&lt;a href=&#34;#word-splitting&#34;&gt;word splitting&lt;/a&gt;和&lt;a href=&#34;#pathname-expansion&#34;&gt;pathname expansion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当使用&lt;code&gt;== !=&lt;/code&gt;时，操作符右边的字符串被认为是模式，根据模式匹配规则

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;等同于&lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 shell 选项&lt;code&gt;nocasematch&lt;/code&gt;设置的话，可以忽略大小写&lt;/li&gt;
&lt;li&gt;匹配返回 0，否则返回 1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二元操作符&lt;code&gt;=~&lt;/code&gt;和&lt;code&gt;== !=&lt;/code&gt;优先级相同，操作符右边的被视为扩展的正则表达式

&lt;ul&gt;
&lt;li&gt;如果正则表达式语法错误返回 2&lt;/li&gt;
&lt;li&gt;匹配的子串保存在&lt;code&gt;BASH_REMATCH&lt;/code&gt;中，下标为 0 表示匹配整个子串，下标为 n 表示匹配第 n 个圆括号的子表达式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表达式的形式包括

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;( expression )&lt;/code&gt;返回表达式的值，可用于修改操作符的优先级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;! expression&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expression1 &amp;amp;&amp;amp; expression2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expression1 || expression2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for name [ [ in [ word ... ] ] ; ] do list ; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt;后面的内容被扩展，生成一个元素列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;name&lt;/code&gt;每次循环设置成列表中的元素&lt;/li&gt;
&lt;li&gt;如果没有&lt;code&gt;in&lt;/code&gt;，&lt;code&gt;for&lt;/code&gt;对每个位置参数执行一次&lt;/li&gt;
&lt;li&gt;返回状态是最后一个执行命令的返回值&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;in&lt;/code&gt;生成的元素集合为空，则返回 0，不执行任何命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for (( expr1 ; expr2 ;  expr3 )) ; do list ; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以&lt;a href=&#34;#arithmetic-evaluation&#34;&gt;算术求值&lt;/a&gt;规则计算&lt;code&gt;expr1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重复计算算术表达式&lt;code&gt;expr2&lt;/code&gt;直到值是 0：每次得到一个非 0 值，执行&lt;code&gt;list&lt;/code&gt;，然后计算算术表达式&lt;code&gt;expr3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果对应位置的表达式没有，则认为值为 1&lt;/li&gt;
&lt;li&gt;返回值是&lt;code&gt;list&lt;/code&gt;最后一个执行的命令的返回状态；如果所有表达式都是无效的返回 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select name [ in word ] ; do list ; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;in&lt;/code&gt;后面的内容被扩展，生成一个元素列表&lt;/li&gt;
&lt;li&gt;扩展的单词背打印到标准错误，每个前面一个数字&lt;/li&gt;
&lt;li&gt;如果没有&lt;code&gt;in&lt;/code&gt;，则打印位置参数&lt;/li&gt;
&lt;li&gt;每次选择之后执行&lt;code&gt;list&lt;/code&gt;，知道遇到&lt;code&gt;break&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;返回值是&lt;code&gt;list&lt;/code&gt;最后一个执行的命令的返回状态；如果没有执行命令则返回 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;case word in [ [(] pattern [ | pattern ] ... ) list ;; ] ... esac&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;找到匹配，执行对应的&lt;code&gt;list&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;如果使用了&lt;code&gt;;;&lt;/code&gt;，则不会再继续&lt;/li&gt;
&lt;li&gt;如果使用了&lt;code&gt;;&amp;amp;&lt;/code&gt;，则继续执行后面的&lt;code&gt;list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果使用了&lt;code&gt;;;&amp;amp;&lt;/code&gt;，则继续尝试匹配后面的模式，如果匹配则执行对应的&lt;code&gt;list&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果没有匹配的模式返回 0，否则返回&lt;code&gt;list&lt;/code&gt;中最后执行的命令的状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if list; then list; [ elif list; then list; ] ... [ else list; ] fi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while list-1; do list-2; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;list-1&lt;/code&gt;的最后一个命令的返回状态为 0 时执行&lt;code&gt;list-2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回&lt;code&gt;list-2&lt;/code&gt;中最后执行的命令的返回状态，什么都没有执行则返回 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;until list-1; do list-2; done&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当&lt;code&gt;list-1&lt;/code&gt;的最后一个命令的返回状态非 0 时执行&lt;code&gt;list-2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;返回&lt;code&gt;list-2&lt;/code&gt;中最后执行的命令的返回状态，什么都没有执行则返回 0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;coprocesses&#34;&gt;coprocesses&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法&lt;code&gt;coproc [NAME] command [redirections]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建一个叫做&lt;code&gt;NAME&lt;/code&gt;的协同进程，如果不指定则是&lt;code&gt;COPROC&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是&lt;a href=&#34;#simple-commands&#34;&gt;简单命令&lt;/a&gt;则不能知道名字，名字就是简单命令的第一个单词&lt;/li&gt;
&lt;li&gt;协同进程在一个子 shell 中异步执行，类似于在后台执行命令，在执行的 shell 和协同进程之间建立了一个双向的 pipeline&lt;/li&gt;
&lt;li&gt;执行协同进程的时候，shell 在执行 shell 的上下文创建一个叫&lt;code&gt;NAME&lt;/code&gt;的&lt;a href=&#34;#array&#34;&gt;数组&lt;/a&gt;变量

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;command&lt;/code&gt;的标准输出通过管道连接到一个文件描述符，值为&lt;code&gt;NAME[0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command&lt;/code&gt;的标准输入通过管道连接到一个文件描述符，值为&lt;code&gt;NAME[1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;管道的建立在重定向之前完成&lt;/li&gt;
&lt;li&gt;文件描述符可以被 shell 命令和重定向用作参数，子 shell 中不能访问这个文件描述符&lt;/li&gt;
&lt;li&gt;执行协同进程的子 shell 的进程 ID可以通过变量&lt;code&gt;NAME_PID&lt;/code&gt;访问&lt;/li&gt;
&lt;li&gt;内置的&lt;code&gt;wait&lt;/code&gt;命令可用来等待协同进程终止&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;coproc&lt;/code&gt;命令总是返回成功，coprocess 的返回状态是&lt;code&gt;command&lt;/code&gt;的退出状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;函数定义&#34;&gt;函数定义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法支持两种

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;name () compound-command [redirection]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function name [()] compound-command [redirection]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定义了一个叫做&lt;code&gt;name&lt;/code&gt;的函数，关键字&lt;code&gt;function&lt;/code&gt;可选&lt;/li&gt;
&lt;li&gt;如果使用了关键字&lt;code&gt;function&lt;/code&gt;，则圆括号是可选的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;comments&#34;&gt;comments&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在非交互式的 shell 和开启了 interactive_comments 的交互式 shell 中，以&lt;code&gt;#&lt;/code&gt;开头到行末的内容视为注释&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;quoting&#34;&gt;quoting&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;引用用于移除单词或字符对于 shell 具有的特殊含义，也可用于防止参数扩展&lt;/li&gt;
&lt;li&gt;metacharacter(包括&lt;code&gt;| &amp;amp; ; ( ) &amp;lt; &amp;gt;&lt;/code&gt;)在加引号时可用来代表自身，而不是分离单词的字符&lt;/li&gt;
&lt;li&gt;一共有三种引用机制：反斜线、单引号和双引号

&lt;ul&gt;
&lt;li&gt;反斜线：保留它后面紧跟字符的含义，除了新行(此时代表一行的继续，在输入流中会忽视此反斜线)&lt;/li&gt;
&lt;li&gt;单引号：保留单引号&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;parameters&#34;&gt;parameters&lt;/h2&gt;

&lt;h3 id=&#34;positional-parameters&#34;&gt;positional  parameters&lt;/h3&gt;

&lt;h3 id=&#34;special-parameters&#34;&gt;special parameters&lt;/h3&gt;

&lt;h3 id=&#34;shell-variables&#34;&gt;shell variables&lt;/h3&gt;

&lt;h3 id=&#34;array&#34;&gt;array&lt;/h3&gt;

&lt;h2 id=&#34;expansion&#34;&gt;expansion&lt;/h2&gt;

&lt;h3 id=&#34;brace-expansion&#34;&gt;brace expansion&lt;/h3&gt;

&lt;h3 id=&#34;tilde-expansion&#34;&gt;tilde expansion&lt;/h3&gt;

&lt;h3 id=&#34;parameter-expansion&#34;&gt;parameter expansion&lt;/h3&gt;

&lt;h3 id=&#34;command-substitution&#34;&gt;command substitution&lt;/h3&gt;

&lt;h3 id=&#34;arithmetic-expansion&#34;&gt;arithmetic expansion&lt;/h3&gt;

&lt;h3 id=&#34;process-substitution&#34;&gt;process substitution&lt;/h3&gt;

&lt;h3 id=&#34;word-splitting&#34;&gt;word splitting&lt;/h3&gt;

&lt;h3 id=&#34;pathname-expansion&#34;&gt;pathname expansion&lt;/h3&gt;

&lt;h3 id=&#34;quote-removal&#34;&gt;quote removal&lt;/h3&gt;

&lt;h2 id=&#34;redirection&#34;&gt;redirection&lt;/h2&gt;

&lt;h3 id=&#34;input&#34;&gt;input&lt;/h3&gt;

&lt;h3 id=&#34;output&#34;&gt;output&lt;/h3&gt;

&lt;h3 id=&#34;appending-redirected-output&#34;&gt;appending redirected output&lt;/h3&gt;

&lt;h3 id=&#34;redirecting-standard-output-and-standard-error&#34;&gt;redirecting standard output and standard error&lt;/h3&gt;

&lt;h3 id=&#34;appending-standard-output-and-standard-error&#34;&gt;appending standard output and standard error&lt;/h3&gt;

&lt;h3 id=&#34;here-documents&#34;&gt;here documents&lt;/h3&gt;

&lt;h3 id=&#34;here-strings&#34;&gt;here strings&lt;/h3&gt;

&lt;h3 id=&#34;duplicating-file-descriptors&#34;&gt;duplicating file descriptors&lt;/h3&gt;

&lt;h3 id=&#34;moving-file-descriptors&#34;&gt;moving file descriptors&lt;/h3&gt;

&lt;h3 id=&#34;opening-file-descriptors-for-reading-and-writing&#34;&gt;opening file descriptors for reading and writing&lt;/h3&gt;

&lt;h2 id=&#34;aliases&#34;&gt;aliases&lt;/h2&gt;

&lt;h2 id=&#34;functions&#34;&gt;functions&lt;/h2&gt;

&lt;h2 id=&#34;arithmetic-evaluation&#34;&gt;arithmetic evaluation&lt;/h2&gt;

&lt;h2 id=&#34;conditional-expressions&#34;&gt;conditional expressions&lt;/h2&gt;

&lt;h2 id=&#34;simple-command-expansion&#34;&gt;simple command expansion&lt;/h2&gt;

&lt;h2 id=&#34;command-execution&#34;&gt;command execution&lt;/h2&gt;

&lt;h2 id=&#34;command-execution-environment&#34;&gt;command execution environment&lt;/h2&gt;

&lt;h2 id=&#34;environment&#34;&gt;environment&lt;/h2&gt;

&lt;h2 id=&#34;exit-status&#34;&gt;exit status&lt;/h2&gt;

&lt;h2 id=&#34;signals&#34;&gt;signals&lt;/h2&gt;

&lt;h2 id=&#34;job-control&#34;&gt;job control&lt;/h2&gt;

&lt;h2 id=&#34;prompting&#34;&gt;prompting&lt;/h2&gt;

&lt;h2 id=&#34;readline&#34;&gt;readline&lt;/h2&gt;

&lt;h3 id=&#34;readline-notation&#34;&gt;readline notation&lt;/h3&gt;

&lt;h3 id=&#34;readline-initialization&#34;&gt;readline initialization&lt;/h3&gt;

&lt;h3 id=&#34;readline-key-bindings&#34;&gt;readline key bindings&lt;/h3&gt;

&lt;h3 id=&#34;readline-variables&#34;&gt;readline variables&lt;/h3&gt;

&lt;h3 id=&#34;readline-conditional-constructs&#34;&gt;readline conditional constructs&lt;/h3&gt;

&lt;h3 id=&#34;searching&#34;&gt;searching&lt;/h3&gt;

&lt;h3 id=&#34;readline-command-names&#34;&gt;readline command names&lt;/h3&gt;

&lt;h3 id=&#34;commands-for-moving&#34;&gt;commands for moving&lt;/h3&gt;

&lt;h3 id=&#34;commands-for-manipulating-the-history&#34;&gt;commands for manipulating the history&lt;/h3&gt;

&lt;h3 id=&#34;commands-for-changing-text&#34;&gt;commands for changing text&lt;/h3&gt;

&lt;h3 id=&#34;killing-and-yanking&#34;&gt;killing and yanking&lt;/h3&gt;

&lt;h3 id=&#34;numeric-arguments&#34;&gt;numeric arguments&lt;/h3&gt;

&lt;h3 id=&#34;completing&#34;&gt;completing&lt;/h3&gt;

&lt;h3 id=&#34;keyboard-macros&#34;&gt;keyboard macros&lt;/h3&gt;

&lt;h3 id=&#34;miscellaneous&#34;&gt;miscellaneous&lt;/h3&gt;

&lt;h3 id=&#34;programmable-completion&#34;&gt;programmable completion&lt;/h3&gt;

&lt;h2 id=&#34;history&#34;&gt;history&lt;/h2&gt;

&lt;h2 id=&#34;history-expansion&#34;&gt;history expansion&lt;/h2&gt;

&lt;h3 id=&#34;event-designators&#34;&gt;event designators&lt;/h3&gt;

&lt;h3 id=&#34;word-designators&#34;&gt;word designators&lt;/h3&gt;

&lt;h3 id=&#34;modifiers&#34;&gt;modifiers&lt;/h3&gt;

&lt;h2 id=&#34;shell-builtin-commands&#34;&gt;shell builtin commands&lt;/h2&gt;

&lt;h2 id=&#34;restricted-shell&#34;&gt;restricted shell&lt;/h2&gt;

&lt;h2 id=&#34;files&#34;&gt;files&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>expect 脚本</title>
      <link>https://xueqing.github.io/blog/shell/expect_shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/shell/expect_shell/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;expect 是用来进行自动化控制和测试的工具，可以执行交互式的脚本&lt;/li&gt;
&lt;li&gt;在执行脚本过程中，一些交互式的过程可能需要用户输入等信息，这种情况下课使用 expect 脚本&lt;/li&gt;
&lt;li&gt;基本命令

&lt;ul&gt;
&lt;li&gt;send：向进程发送字符串，用于模拟用户的输入，一定要加 \r 回车&lt;/li&gt;
&lt;li&gt;expect：从进程接收字符串&lt;/li&gt;
&lt;li&gt;spawn：启动进程，spawn 启动的进程的输出可被 expect 捕获&lt;/li&gt;
&lt;li&gt;interact：用户交互&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的脚本可将文件 scp 远程拷贝到某台机器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/usr/bin/expect
set timeout 100                     ## 设置超时时间， -1 可无限等待
set filename [lindex $argv 0]       ## 接收输入参数，保存文件名
set machineURL [lindex $argv 1]     ## 接收输入参数，保存远程机器的上传的 URL，包括用户名，IP 地址和路径
set machinePWD [lindex $argv 2]     ## 接收输入参数，保存远程机器的密码
spawn scp $filename $machineURL     ## 执行 scp 命令
expect {
&amp;quot;yes/no&amp;quot; { send &amp;quot;yes\r&amp;quot;; exp_continue}  ## 如果出现&amp;quot;yes/no&amp;quot;，则输入&amp;quot;yes&amp;quot;，然后继续这个循环
&amp;quot;password:&amp;quot; { send &amp;quot;$machinePWD\r&amp;quot; }    ## 如果出现&amp;quot;password:&amp;quot;，则输入保存的密码，然后退出这个循环，继续往下
}
expect 100%                         ## 出现 100% 表明上传成功
expect eof                          ## 等待结束标记，由 spawn 启动的命令在结束时回产生一个 eof 标记
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; expect 不能正确解释 shell 的 glob 模式，所以执行类似 &lt;code&gt;spawn scp -r /home/user/dir1/ cluster_server:&lt;/code&gt; 的命令会出错。解决方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;spawn bash -c &amp;quot;scp -r /home/user/dir1/* cluster_server:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>perl 脚本解析 xml 文件</title>
      <link>https://xueqing.github.io/blog/shell/perl/perl%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/shell/perl/perl%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;1 使用模块 XML::Simple。XML::Simple 能够解析一个 XML 文件并在以一个 Perl 哈希引用返回数据。在这个哈希中，来自原始 XML 文件的元素作为键，而它们之间的 CDATA 作为值。一旦XML::Simple 处理完一个 XML 文件，XML 文件的内容就可以使用标准 Perl 数组表示法检索。&lt;/li&gt;
&lt;li&gt;2 安装步骤，进入命令行执行：

&lt;ul&gt;
&lt;li&gt;1 &lt;code&gt;perl -MCPAN -e shell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2 &lt;code&gt;install XML::Simple&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;3 脚本内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-perl&#34;&gt;#!/usr/bin/perl
  
# use module
use XML::Simple;
  
if($#ARGV &amp;lt; 1) {
print &amp;quot;Usage: ./parsexml.pl filename parseparam\n&amp;quot;;
exit(0);
}
  
$filename = $ARGV[0];
$parseparam = $ARGV[1];
#print &amp;quot;Input param [filename=$filename] [parseparam=$parseparam]\n&amp;quot;;
  
# create object
$xml = new XML::Simple;
  
# read XML file
my $doc = $xml-&amp;gt;XMLin($filename);
  
# access XML data
print &amp;quot;$doc-&amp;gt;{$parseparam}\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;4 执行脚本&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1 添加可执行权限：&lt;code&gt;chmod +x parsexml.pl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2 执行：&lt;code&gt;./parsexml.pl filename parseparam&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>shell 脚本</title>
      <link>https://xueqing.github.io/blog/shell/shell_script/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/shell/shell_script/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-shell-%e8%84%9a%e6%9c%ac%e4%b8%ad%e8%b0%83%e7%94%a8%e5%8f%a6%e4%b8%80%e4%b8%aa%e8%84%9a%e6%9c%ac&#34;&gt;在 shell 脚本中调用另一个脚本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e5%91%bd%e4%bb%a4%e8%a1%8c%e9%80%89%e9%a1%b9%e8%a7%a3%e6%9e%90&#34;&gt;shell 命令行选项解析&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#getopts&#34;&gt;getopts&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getopt&#34;&gt;getopt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e8%8e%b7%e5%8f%96%e8%84%9a%e6%9c%ac%e7%9a%84%e8%bf%9b%e7%a8%8b-id&#34;&gt;shell 获取脚本的进程 ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e8%84%9a%e6%9c%ac%e8%8e%b7%e5%8f%96%e5%bd%93%e5%89%8d%e6%97%b6%e9%97%b4&#34;&gt;shell 脚本获取当前时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e6%89%a7%e8%a1%8c%e5%a4%9a%e4%b8%aa%e5%91%bd%e4%bb%a4%e7%9a%84%e6%96%b9%e6%b3%95&#34;&gt;shell 执行多个命令的方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-test-%e5%91%bd%e4%bb%a4&#34;&gt;shell test 命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e5%80%bc%e6%b5%8b%e8%af%95&#34;&gt;数值测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%b5%8b%e8%af%95&#34;&gt;字符串测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%87%e4%bb%b6%e6%b5%8b%e8%af%95&#34;&gt;文件测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%9e%e6%8e%a5%e6%b5%8b%e8%af%95%e6%9d%a1%e4%bb%b6&#34;&gt;连接测试条件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e5%8f%98%e9%87%8f&#34;&gt;shell 变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e8%84%9a%e6%9c%ac%e4%b8%8a%e4%bc%a0-ftp&#34;&gt;shell 脚本上传 ftp&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8a%e4%bc%a0%e5%8d%95%e4%b8%aa%e6%96%87%e4%bb%b6%e8%84%9a%e6%9c%ac&#34;&gt;上传单个文件脚本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-if&#34;&gt;shell if&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;shell 操作符&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ae%97%e6%9c%af%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;算术操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e7%b3%bb%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;关系操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%83%e5%b0%94%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;布尔操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#string-%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;string 操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%87%e4%bb%b6%e6%b5%8b%e8%af%95%e8%bf%90%e7%ae%97%e7%ac%a6&#34;&gt;文件测试运算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-shell-%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;C Shell 操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#korn-shell-%e6%93%8d%e4%bd%9c%e7%ac%a6&#34;&gt;Korn Shell 操作符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%88%aa%e5%8f%96&#34;&gt;字符串截取&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#here-document&#34;&gt;here document&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83%e7%bd%91%e7%ab%99&#34;&gt;参考网站&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-shell-脚本中调用另一个脚本&#34;&gt;在 shell 脚本中调用另一个脚本&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;fork：直接调用&lt;code&gt;script_path/filename.sh&lt;/code&gt;(有可执行权限)或者&lt;code&gt;sh script_path/filename.sh&lt;/code&gt;(没有可执行权限)

&lt;ul&gt;
&lt;li&gt;运行时终端会新开一个子 shell 执行脚本，子 shell 执行的时候，父 shell 仍在。子 shell 执行完毕返回父 shell，但是父 shell 不能继承子 shell 的环境变量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;exec：&lt;code&gt;exec script_path/filename.sh&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;exec 不需要新开一个子 shell 来执行被调用的脚本，而是在同一个 shell 执行。但是父脚本中&lt;code&gt;exec&lt;/code&gt;行之后的内容不会被执行。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;source：&lt;code&gt;source script_path/filename.sh&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;source 不需要新开一个子 shell 来执行被调用的脚本，而是在同一个 shell 执行。即父脚本可以获取和使用子脚本中声明的变量和环境变量。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
A=1

echo &amp;quot;before exec/source/fork: PID for parent.sh = $$&amp;quot;

export A
echo &amp;quot;In parent.sh: var A=$A&amp;quot;

case $1 in
--exec)
    echo -e &amp;quot;==&amp;gt; using exec..\n&amp;quot;
    exec ./child.sh
    ;;
--source)
    echo -e &amp;quot;==&amp;gt; using source...\n&amp;quot;
    source ./child.sh
    ;;
*)
    echo -e &amp;quot;==&amp;gt; using fork by default...\n&amp;quot;
    ./child.sh
    ;;
esac

echo &amp;quot;after exec/source/fork: PID for parent.sh = $$&amp;quot;
echo -e &amp;quot;In parent.sh: var A=$A&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

echo &amp;quot;PID for child.sh = $$&amp;quot;
echo &amp;quot;In child.sh: get var A=$A from parent.sh&amp;quot;

A=2
export A
echo -e &amp;quot;In child.sh: var A=$A\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-命令行选项解析&#34;&gt;shell 命令行选项解析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getopts&lt;/code&gt;是 shell 内建命令，&lt;code&gt;getopt&lt;/code&gt;是一个独立外部工具&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopts&lt;/code&gt;语法简单，&lt;code&gt;getopt&lt;/code&gt;语法较复杂&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopts&lt;/code&gt;不支持长参数(如 -dir, &amp;ndash;dir)，&lt;code&gt;getopt&lt;/code&gt;支持&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopts&lt;/code&gt;不会重排所有参数顺序，&lt;code&gt;getopt&lt;/code&gt;会重排参数顺序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopts&lt;/code&gt;是为了代替&lt;code&gt;getopt&lt;/code&gt;较快捷的执行参数分析工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;getopts&#34;&gt;getopts&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;语法&lt;code&gt;getopts optstring name [args]&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;optstring&lt;/code&gt;代表可使用的选项列表，每个字母代码一个选项&lt;/li&gt;
&lt;li&gt;带&lt;code&gt;:&lt;/code&gt;意味着除了定义之外，还会带一个参数作为选项的值&lt;/li&gt;
&lt;li&gt;不带&lt;code&gt;:&lt;/code&gt;是一个开关型选项，不需要指定参数的值&lt;/li&gt;
&lt;li&gt;命令行中包含了没有在&lt;code&gt;getopts&lt;/code&gt;列表中的选项会有警告，在&lt;code&gt;optstring&lt;/code&gt;前加上&lt;code&gt;:&lt;/code&gt;可以消除警告&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopts&lt;/code&gt;中有个相对固定的常量&lt;code&gt;OPTARG&lt;/code&gt;和&lt;code&gt;OPTIND&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPTARG&lt;/code&gt;代表当前选项的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;OPTIND&lt;/code&gt;代表当前选项在参数列表中的位置&lt;/li&gt;
&lt;li&gt;出现不认识的选项参数为&lt;code&gt;?&lt;/code&gt;，&lt;code&gt;case&lt;/code&gt;中最后一个&lt;code&gt;?&lt;/code&gt;用于处理这种情况，因此选项中不应包含&lt;code&gt;?&lt;/code&gt;和&lt;code&gt;,&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopts&lt;/code&gt;解析完参数后，可以使用&lt;code&gt;shift&lt;/code&gt;把选项参数进行移位操作，左边的参数就丢失了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shift $(($OPTIND-1))&lt;/code&gt;，参数从 1 开始编号，处理一个开关型选项&lt;code&gt;OPTIND&lt;/code&gt;加 1，处理一个带值的选项参数&lt;code&gt;OPTIND&lt;/code&gt;加 2&lt;/li&gt;
&lt;li&gt;选项参数的格式是&lt;code&gt;-d val&lt;/code&gt;，中间需要一个空格&lt;/li&gt;
&lt;li&gt;选项参数必须放在其他参数前面，因为遇到非&lt;code&gt;-&lt;/code&gt;开头的参数或者选项参数结束标记&lt;code&gt;--&lt;/code&gt;就终止了&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中间遇到非选项的命令行参数，后面的选项参数取不到&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash

# echo &amp;quot;usage: ./`basename $0` [-d dir_name] [-f file_name] [-c commit_id] [-s service_name] [-N]&amp;quot;
# echo &amp;quot;initial index $OPTIND&amp;quot;
while getopts &#39;d:f:c:s:N&#39; opt;
do
case ${opt} in
    d)
        echo &amp;quot;directory name: $OPTARG&amp;quot;
        ;;
    f)
        echo &amp;quot;file name: $OPTARG&amp;quot;
        ;;
    c)
        echo &amp;quot;commit id: $OPTARG&amp;quot;
        ;;
    s)
        echo &amp;quot;service name: $OPTARG&amp;quot;
        ;;
    N)
        echo &amp;quot;use new rep url&amp;quot;
        ;;
    ?)
        echo &amp;quot;usage: ./`basename $0` [-d dir_name] [-f file_name] [-c commit_id] [-s service_name] [-N]&amp;quot;
        exit 1;
        ;;
esac
echo &amp;quot;opt is $opt, arg is $OPTARG, index is $OPTIND&amp;quot;
done

echo &amp;quot;After process arguments: OPTIND=$OPTIND&amp;quot;
echo &amp;quot;Remove processed arguments: number=$(($OPTIND-1))&amp;quot;
shift $(($OPTIND-1))
echo &amp;quot;Arguments index: OPTIND=$OPTIND&amp;quot;
echo &amp;quot;Remaing arguments: $@&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;getopt&#34;&gt;getopt&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法支持三种

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getopt optstring parameters&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopt [options] [--] optstring parameters&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getopt [options] -o|--options optstring [options] [--] parameters&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt;表示短选项，两个冒号表示该选项有一个可选参数，可选参数必须紧贴选项，中间没有空格&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l|--longoptions&lt;/code&gt;表示长选项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;$@&amp;quot;&lt;/code&gt;将命令行参数展开分别的单词&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;出错时打印的信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-获取脚本的进程-id&#34;&gt;shell 获取脚本的进程 ID&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参数&lt;code&gt;$$&lt;/code&gt;获取进程 ID&lt;/li&gt;
&lt;li&gt;参数&lt;code&gt;$PID&lt;/code&gt;获取父 shell 的进程 ID&lt;/li&gt;
&lt;li&gt;参数&lt;code&gt;$UID&lt;/code&gt;获取执行当前的当前用户 ID&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-脚本获取当前时间&#34;&gt;shell 脚本获取当前时间&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;获取当前时间&lt;code&gt;date +%Y%m%d&lt;/code&gt;或&lt;code&gt;date +%F&lt;/code&gt;或&lt;code&gt;date +%y%m%d&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;Y 年，如 2018&lt;/li&gt;
&lt;li&gt;y 年的最后两位，如 2018 显示 18&lt;/li&gt;
&lt;li&gt;m 月(01..12)&lt;/li&gt;
&lt;li&gt;d 每个月第几天(01..31)&lt;/li&gt;
&lt;li&gt;F 完整的日志(%Y-%m-%d)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输出另外一个时区的时间&lt;code&gt;env TZ=timezone date&lt;/code&gt;或&lt;code&gt;env TZ=timezone date  +%Y%m%d&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;timezone 是指定的时区，比如&lt;code&gt;America/Los_Angeles&lt;/code&gt;或&lt;code&gt;Asia/Shanghai&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;starttime=`date +%s`
sleep 10 #sleep 10 sec
endtime=`date +%s`
difftime=$(( endtime - starttime ))
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-执行多个命令的方法&#34;&gt;shell 执行多个命令的方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;|&lt;/code&gt;：命令之间用&lt;code&gt;|&lt;/code&gt;隔开，将前一个命令的标准输出(stdout)作为下一个命令的标准输入

&lt;ul&gt;
&lt;li&gt;标准错误(stderr)仍在默认的地方&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;|&amp;amp;&lt;/code&gt;：命令之间用&lt;code&gt;|&amp;amp;&lt;/code&gt;隔开，将前一个命令的标准输出和标准错误都作为下一个命令的标准输入

&lt;ul&gt;
&lt;li&gt;bash 版本不小于 4&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;;&lt;/code&gt;：命令之间用&lt;code&gt;;&lt;/code&gt;隔开，各命令执行结果不影响，即各个命令都会执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;：命令之间用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;隔开，只有前面的命令执行成功，才会执行后面的命令，保证执行过程都是成功的&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;||&lt;/code&gt;：命令之间用&lt;code&gt;||&lt;/code&gt;隔开，只有前面的命令执行失败，才会执行后面的命令，直到执行成功&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可用于捕获子 shell 的错误码，比如&lt;code&gt;output=&amp;quot;$( (cd &amp;quot;$FOLDER&amp;quot;; eval &amp;quot;$@&amp;quot;) 2&amp;gt;&amp;amp;1 )&amp;quot; || errcode=&amp;quot;$?&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重要的命令失败时退出自定义错误码，比如&lt;code&gt;output=&amp;quot;$( (cd &amp;quot;$FOLDER&amp;quot;; eval &amp;quot;$@&amp;quot;) 2&amp;gt;&amp;amp;1 )&amp;quot; || exit 12&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以定义函数在&lt;code&gt;||&lt;/code&gt;之后调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;handle_error() { #do staff }
output=&amp;quot;$( (cd &amp;quot;$FOLDER&amp;quot;; eval &amp;quot;$@&amp;quot;) 2&amp;gt;&amp;amp;1 )&amp;quot; || handle_error
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-test-命令&#34;&gt;shell test 命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;test 命令用于检查某个条件是否成立，可以进行数值、字符和文件三个方面的测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;数值测试&#34;&gt;数值测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运算符：-eq，-ne，-gt，-ge，-lt，-le&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;n1=1
n2=2
test $[n1] -eq $[n2] &amp;amp;&amp;amp; echo &#39;两个数相等！&#39;
test $[n1] -eq $[n2] || echo &#39;两个数不相等！&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;[]&lt;/code&gt;内执行基本的算术运算&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;n1=1
n2=2
n3=$[n1+n2]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;字符串测试&#34;&gt;字符串测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运算符： =，!=， -z(字符串长度是否为0)， -n(字符串长度是否不为0)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;s1=&amp;quot;s1&amp;quot;
s2=&amp;quot;s2&amp;quot;
test $s1 = $s2 &amp;amp;&amp;amp; echo &#39;两个字符串相等！&#39;
test $s1 = $s2 || echo &#39;两个字符串不相等！&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;文件测试&#34;&gt;文件测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;运算符：-e，-r，-w，-x，-s，-d，-f，-c，-b&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-r/w/x&lt;/code&gt;：如果文件存在且可读/可写/可执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;：如果文件存在且至少有一个字符&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-f/c/b&lt;/code&gt;：如果文件存在且是普通文件/字符型特殊文件/块特殊文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;test -e filename &amp;amp;&amp;amp; echo &amp;quot;文件已存在！&amp;quot;
test -e filename || echo &amp;quot;文件不存在！&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;连接测试条件&#34;&gt;连接测试条件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可用逻辑操作符将测试条件连接起来：与(-a)，huo(-o)，非(!)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;test -e filename -o -e anotherfile &amp;amp;&amp;amp; echo &amp;quot;至少存在一个文件！&amp;quot;
test -e filename -o -e anotherfile || echo &amp;quot;两个文件都不存在！&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-变量&#34;&gt;shell 变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;定义变量是变量名和等号之间不能有空格&lt;/li&gt;
&lt;li&gt;使用时在前面加上&lt;code&gt;$&lt;/code&gt;即可&lt;/li&gt;
&lt;li&gt;删除变量：&lt;code&gt;unset $VAR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置变量只读：&lt;code&gt;readonly $VAR&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;测试变量是否定义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if (set -u; : $VAR) ; then echo &amp;quot;set&amp;quot; ; else echo &amp;quot;unset&amp;quot; ; fi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set -u&lt;/code&gt;用于设置 shell 选项，u 是 nounset， 表示当使用未定义的变量时，输出错误并强制退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:&lt;/code&gt; 是不做任何事只是展开参数，单不会试图去执行&lt;/li&gt;
&lt;li&gt;没有&lt;code&gt;:&lt;/code&gt;则将变量解释成 shell 命令，并试图去执行&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;-z&lt;/code&gt;或&lt;code&gt;-n&lt;/code&gt;判断&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-z&lt;/code&gt;：字符串长度是否为0&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-n&lt;/code&gt;：字符串长度是否不为0&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &amp;quot;********************************set KK&amp;quot;
export KK=&amp;quot;kiki&amp;quot;
echo KK=$KK
if [ -z $KK ] ; then echo &amp;quot;unset&amp;quot; ; else echo &amp;quot;set&amp;quot; ; fi
if ( set -u; : $KK ) ; then echo &amp;quot;set&amp;quot; ; else echo &amp;quot;unset&amp;quot; ; fi
echo KK=$KK

echo &amp;quot;********************************unset KK&amp;quot;
unset KK
echo KK=$KK
if [ -z $KK ] ; then echo &amp;quot;unset&amp;quot; ; else echo &amp;quot;set&amp;quot; ; fi
if ( set -u; : $KK ) ; then echo &amp;quot;set&amp;quot; ; else echo &amp;quot;unset&amp;quot; ; fi
echo KK=$KK
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-脚本上传-ftp&#34;&gt;shell 脚本上传 ftp&lt;/h2&gt;

&lt;h3 id=&#34;上传单个文件脚本&#34;&gt;上传单个文件脚本&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#!/bin/bash
FILENAME=$1
ftp -n -p&amp;lt;&amp;lt;!
## ftp server ip
open ftpIp
## ftp username and password
user ftpUser ftpPwd
## transfer type
binary
## upload path
cd /VDMSSoftware/cppci
## interactive mode
prompt
## upload filename
put $FILENAME
close
## close connection
bye
!
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;传输文件类型包括：

&lt;ul&gt;
&lt;li&gt;ascii：默认值。网络 ASCII&lt;/li&gt;
&lt;li&gt;binary：二进制映像，需要使用二进制方式的文件类型包括 ISO 文件、可执行文件、压缩文件、图片等。此方式比 ascii 更有效&lt;/li&gt;
&lt;li&gt;ebcdic：&lt;/li&gt;
&lt;li&gt;image：&lt;/li&gt;
&lt;li&gt;local M：本地类型。M 参数定义每个计算机字位的十进制数&lt;/li&gt;
&lt;li&gt;tenex：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;交互式提示：使用 mget 或 mput 时，&lt;code&gt;prompt&lt;/code&gt;命令让 ftp 在文件传输前进行提示，防止覆盖已有的文件。若发出 prompt 命令时已经启动了提示，ftp 将关掉提示，此时再传输所有的文件则不会有任何提示&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-if&#34;&gt;shell if&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;shell 支持 3 中 if 语句&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if...fi&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;if...else...fi&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;if...elif...else...fi&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;if [ $useEncryption != &amp;quot;false&amp;quot; ] &amp;amp;&amp;amp; [ $softEncryption != &amp;quot;false&amp;quot; ]
then
# do sth
elif [ $useEncryption != &amp;quot;false&amp;quot; ] &amp;amp;&amp;amp; [ $softEncryption == &amp;quot;false&amp;quot; ]
then
# do sth
elif [ $useEncryption == &amp;quot;false&amp;quot; ] &amp;amp;&amp;amp; [ $softEncryption != &amp;quot;false&amp;quot; ]
then
# do sth
elif [ $useEncryption == &amp;quot;false&amp;quot; ] &amp;amp;&amp;amp; [ $softEncryption == &amp;quot;false&amp;quot; ] # or else
then
# do sth
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-操作符&#34;&gt;shell 操作符&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;讨论 Bourne shell（默认的 shell） 支持的操作符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;算术操作符&#34;&gt;算术操作符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Bourne shell 不支持运算符，但是可以使用&lt;code&gt;awk&lt;/code&gt;或者&lt;code&gt;expr&lt;/code&gt;外部程序，例如&lt;code&gt;res=`expr  2 + 2`; echo $res&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运算符和表达式之间必须有空格&lt;/li&gt;
&lt;li&gt;Bourne shell 支持的算术运算符包括：（假如&lt;code&gt;a=10; b=20&lt;/code&gt;）

&lt;ul&gt;
&lt;li&gt;加法&lt;code&gt;+&lt;/code&gt;，例如&lt;code&gt;expr $a + $b&lt;/code&gt;，结果是 30&lt;/li&gt;
&lt;li&gt;减法&lt;code&gt;-&lt;/code&gt;，例如&lt;code&gt;expr $a - $b&lt;/code&gt;，结果是 -10&lt;/li&gt;
&lt;li&gt;乘法&lt;code&gt;*&lt;/code&gt;，例如&lt;code&gt;expr $a \* $b&lt;/code&gt;，结果是 200&lt;/li&gt;
&lt;li&gt;除法&lt;code&gt;/&lt;/code&gt;，例如&lt;code&gt;expr $b / $a&lt;/code&gt;，结果是 2&lt;/li&gt;
&lt;li&gt;取模&lt;code&gt;%&lt;/code&gt;，例如&lt;code&gt;expr $a % $b&lt;/code&gt;，结果是 0&lt;/li&gt;
&lt;li&gt;赋值&lt;code&gt;=&lt;/code&gt;，例如&lt;code&gt;a = $b&lt;/code&gt;，结果是 a 被赋值 20&lt;/li&gt;
&lt;li&gt;等于&lt;code&gt;==&lt;/code&gt;，例如&lt;code&gt;[$a == $b]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;不等于&lt;code&gt;！=&lt;/code&gt;，例如&lt;code&gt;[$a != $b]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;条件表达式必须在方括号中，且两端有空格隔开&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关系操作符&#34;&gt;关系操作符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;只对数值生效，string 作为操作数是无效的，例如对&lt;code&gt;10&lt;/code&gt;和&lt;code&gt;20&lt;/code&gt;或者&lt;code&gt;&amp;quot;10&amp;quot;&lt;/code&gt;和&lt;code&gt;&amp;quot;10&amp;quot;&lt;/code&gt;生效，但是对&lt;code&gt;ten&lt;/code&gt;和&lt;code&gt;twenty&lt;/code&gt;无效

&lt;ul&gt;
&lt;li&gt;无效的 string 是指 string 中包含非数字的字符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Bourne shell 支持的关系型操作符包括：（假如&lt;code&gt;a=10; b=20&lt;/code&gt;）

&lt;ul&gt;
&lt;li&gt;等于&lt;code&gt;-eq&lt;/code&gt;，例如&lt;code&gt;[ $a -eq $b ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;不等于&lt;code&gt;-ne&lt;/code&gt;，例如&lt;code&gt;[ $a -ne $b ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;大于&lt;code&gt;-gt&lt;/code&gt;，例如&lt;code&gt;[ $a -gt $b ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;小于&lt;code&gt;-lt&lt;/code&gt;，例如&lt;code&gt;[ $a -lt $b ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;大于等于&lt;code&gt;-ge&lt;/code&gt;，例如&lt;code&gt;[ $a -ge $b ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;小于等于&lt;code&gt;-le&lt;/code&gt;，例如&lt;code&gt;[ $a -le $b ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;条件表达式必须在方括号内，且两端有空格分开&lt;/li&gt;
&lt;li&gt;其他 shell 可能支持的操作

&lt;ul&gt;
&lt;li&gt;等于&lt;code&gt;==&lt;/code&gt;，例如&lt;code&gt;(( $a == $b ))&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;不等于&lt;code&gt;!=&lt;/code&gt;，例如&lt;code&gt;[ $a != $b ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;大于&lt;code&gt;&amp;gt;&lt;/code&gt;，例如&lt;code&gt;(( $a &amp;gt; $b ))&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;小于&lt;code&gt;&amp;lt;&lt;/code&gt;，例如&lt;code&gt;(( $a &amp;lt; $b ))&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;大于等于&lt;code&gt;&amp;gt;=&lt;/code&gt;，例如&lt;code&gt;(( $a &amp;gt;= $b ))&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;小于等于&lt;code&gt;&amp;lt;=&lt;/code&gt;，例如&lt;code&gt;(( $a &amp;lt;= $b ))&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;布尔操作符&#34;&gt;布尔操作符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Bourne shell 支持的布尔操作符包括：（假如&lt;code&gt;a=10; b=20&lt;/code&gt;）

&lt;ul&gt;
&lt;li&gt;逻辑取否&lt;code&gt;!&lt;/code&gt;，例如&lt;code&gt;[ ! false ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;逻辑或&lt;code&gt;-o&lt;/code&gt;，例如&lt;code&gt;[ $a -lt 20 -o $b -gt 100 ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;逻辑与&lt;code&gt;-a&lt;/code&gt;，例如&lt;code&gt;[ $a -lt 20 -a $b -gt 100 ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;string-操作符&#34;&gt;string 操作符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Bourne shell 支持的字符串操作符包括：（假如&lt;code&gt;a=&amp;quot;abc&amp;quot;; b=&amp;quot;efg&amp;quot;&lt;/code&gt;）

&lt;ul&gt;
&lt;li&gt;等于&lt;code&gt;=&lt;/code&gt;，例如&lt;code&gt;[ $a = $b ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;不等于&lt;code&gt;!=&lt;/code&gt;，例如&lt;code&gt;[ $a != $b ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;字符串为 null，即长度为 0 &lt;code&gt;-z&lt;/code&gt;，例如&lt;code&gt;[ -z $a ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-z&lt;/code&gt;的字符串可以不被双引号引用&lt;/li&gt;
&lt;li&gt;字符串不为 null，即长度不为 0 &lt;code&gt;-n&lt;/code&gt;，例如&lt;code&gt;[ -n $a ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;的字符串建议用双引号引用，不加双引号可以使用&lt;code&gt;! -z&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串是否不是空串&lt;code&gt;str&lt;/code&gt;，例如&lt;code&gt;[ $a ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;其他 shell 可能支持的操作

&lt;ul&gt;
&lt;li&gt;大于&lt;code&gt;&amp;gt;&lt;/code&gt;，例如&lt;code&gt;[[ $a &amp;gt; $b ]]&lt;/code&gt;或&lt;code&gt;[ $a \&amp;gt; $b ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;小于&lt;code&gt;&amp;lt;&lt;/code&gt;，例如&lt;code&gt;[[ $a &amp;lt; $b ]]&lt;/code&gt;或&lt;code&gt;[ $a \&amp;lt; $b ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;文件测试运算符&#34;&gt;文件测试运算符&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;假设文件&lt;code&gt;test&lt;/code&gt;的大小是 100 Bytes，且有读写和可执行权限，&lt;code&gt;file=&amp;quot;test&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b file&lt;/code&gt;是否是块文件，例如&lt;code&gt;[ -b $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c file&lt;/code&gt;是否是字符文件，例如&lt;code&gt;[ -c $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d file&lt;/code&gt;是否是文件夹，例如&lt;code&gt;[ -d $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-f file&lt;/code&gt;是否是普通文件（不是块/字符文件，也不是文件夹），例如&lt;code&gt;[ -f $file ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g file&lt;/code&gt;是否设置了group ID 位，即 SGID，例如&lt;code&gt;[ -g $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-k file&lt;/code&gt;是否设置了 sticky 位，例如&lt;code&gt;[ -k $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p file&lt;/code&gt;是否是一个命名的管道，例如&lt;code&gt;[ -p $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t file&lt;/code&gt;文件描述符是否打开且和一个终端相关，例如&lt;code&gt;[ -t $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-u file&lt;/code&gt;是否设置了 user ID 位，即 SUID，例如&lt;code&gt;[ -u $file ]&lt;/code&gt;，结果是 false&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r file&lt;/code&gt;是否可读，例如&lt;code&gt;[ -r $file ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w file&lt;/code&gt;是否可写，例如&lt;code&gt;[ -w $file ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-x file&lt;/code&gt;是否可执行，例如&lt;code&gt;[ -x $file ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s file&lt;/code&gt;文件大小是否大于 0，例如&lt;code&gt;[ -s $file ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e file&lt;/code&gt;文件是否存在，如果是一个存在的文件夹也返回 true，例如&lt;code&gt;[ -e $file ]&lt;/code&gt;，结果是 true&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-shell-操作符-https-www-tutorialspoint-com-unix-unix-c-shell-operators-htm&#34;&gt;&lt;a href=&#34;https://www.tutorialspoint.com/unix/unix-c-shell-operators.htm&#34; target=&#34;_blank&#34;&gt;C Shell 操作符&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;korn-shell-操作符-https-www-tutorialspoint-com-unix-unix-korn-shell-operators-htm&#34;&gt;&lt;a href=&#34;https://www.tutorialspoint.com/unix/unix-korn-shell-operators.htm&#34; target=&#34;_blank&#34;&gt;Korn Shell 操作符&lt;/a&gt;&lt;/h3&gt;

&lt;h2 id=&#34;字符串截取&#34;&gt;字符串截取&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;按指定长度截取&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;${str:n1:n2}&lt;/code&gt;从左边第 n1+1 个字符串开始，长度为 n2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${str:0-n1:n2}&lt;/code&gt;从右边第 n1 个字符串开始，长度为 n2&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;${str:n1}&lt;/code&gt;从左边第 n1+1 个字符串开始到最后&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;var=&amp;quot;aa1c10e139bf750b3335e896f366665cfa40d95f&amp;quot;

echo ${var:1:3}   #a1c
echo ${var:0-1:3} #f
echo ${var:0-4:3} #d95
echo ${var:1}     #a1c10e139bf750b3335e896f366665cfa40d95f
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;here-document&#34;&gt;here document&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;here document 是一种重定向方式，基本形式如下&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将两个 delimiter 直接的内容传递给 cmd 作为输入参数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;是终端产生的提示输入信息的标识符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cmd &amp;lt;&amp;lt; delimiter
here document content
delimiter
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如在终端向一个文件写入多行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; output.sh
echo &amp;quot;hello&amp;quot;
echo &amp;quot;world&amp;quot;
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内容可以包括普通字符，也可以使用变量&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;执行脚本&lt;code&gt;sh output.sh haha&lt;/code&gt;，&lt;code&gt;$1&lt;/code&gt;被替换为&lt;code&gt;haha&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不想展开变量，则在起始的 delimiter 前后添加引号实现&lt;code&gt;cat &amp;lt;&amp;lt; &amp;quot;EOF&amp;quot; &amp;gt; output.sh&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; output.sh
echo &amp;quot;hello&amp;quot;
echo $1
EOF
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt;而不是&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，可以将 here document 的内容每行前面的制表符删掉，便于编写的时候将内容部分缩进&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考网站&#34;&gt;参考网站&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.gnu.org/software/bash/manual/bash.html&#34; target=&#34;_blank&#34;&gt;Bash Reference Manual&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>命令行创建文件</title>
      <link>https://xueqing.github.io/blog/ubuntu/shell_new_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/shell_new_file/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#cat&#34;&gt;cat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#touch&#34;&gt;touch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e5%87%86%e9%87%8d%e5%ae%9a%e5%90%91%e7%ac%a6%e5%8f%b7&#34;&gt;标准重定向符号 &amp;gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#echoprintf&#34;&gt;echo/printf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nano&#34;&gt;nano&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vivim&#34;&gt;vi/vim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cat&#34;&gt;cat&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 可用于创建文件。输入回车后，光标移到到下一行，可以开始输入文本。完成之后使用 Ctrl+D 退出，并返回到提示符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;gt; file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 也可以查看文件内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;touch&#34;&gt;touch&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;touch&lt;/code&gt; 支持一条命令创建多个文件，且不支持立刻输入文本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;touch file1 file2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标准重定向符号&#34;&gt;标准重定向符号 &amp;gt;&lt;/h2&gt;

&lt;p&gt;标准重定向符号通常用于重定向一个命令的输出到一个新文件。如果没有前置的命令，命令只创建一个新文件。类似于 &lt;code&gt;touch&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;touch&lt;/code&gt; 不同，&lt;code&gt;&amp;gt;&lt;/code&gt; 只能一次创建一个文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;gt; file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;echo-printf&#34;&gt;echo/printf&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;echo/printf&lt;/code&gt; 命令输入文本到指定文件，文件不存在则会被创建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &#39;hello&#39; &amp;gt; file1
printf &amp;quot;world\nI&#39;m kiki&amp;quot; &amp;gt; file2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nano&#34;&gt;nano&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;nano&lt;/code&gt; 是 GNU 项目的文本编辑器。输入回车之后可以开始输入文本。按照命令提示退出编辑界面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nano file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vi-vim&#34;&gt;vi/vim&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;vi/vim&lt;/code&gt; 文本编辑器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi file_name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
