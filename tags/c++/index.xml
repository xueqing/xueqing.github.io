<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; | kiki</title>
    <link>https://xueqing.github.io/tags/c&#43;&#43;/</link>
      <atom:link href="https://xueqing.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <description>c&#43;&#43;</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language>
    <image>
      <url>https://xueqing.github.io/img/icon-192.png</url>
      <title>c&#43;&#43;</title>
      <link>https://xueqing.github.io/tags/c&#43;&#43;/</link>
    </image>
    
    <item>
      <title>auto_ptr, unique_ptr, shared_ptr and weak_ptr</title>
      <link>https://xueqing.github.io/blog/cplusplus/smart_ptr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/smart_ptr/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#autoptr&#34;&gt;auto_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#uniqueptr&#34;&gt;unique_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sharedptr&#34;&gt;shared_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weakptr&#34;&gt;weak_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reference&#34;&gt;reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;auto-ptr&#34;&gt;auto_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++11 已经弃用。&lt;code&gt;unique_ptr&lt;/code&gt;是新的具有相似功能的智能指针，但是安全性更高。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;是管理对象的指针，通过&lt;code&gt;new&lt;/code&gt;的操作创建，当&lt;code&gt;auto_ptr&lt;/code&gt;销毁的时候会删除该对象。&lt;/li&gt;
&lt;li&gt;一个用&lt;code&gt;auto_ptr&lt;/code&gt;存储了一个指针指向一个被分配的对象，确保当代码运行到指针的范围之外时，指针指向的对象会自动销毁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto_ptr&lt;/code&gt;基于独有的所有权模型(exclusive ownership model)，也就是说，两个相同类型的指针不能同时指向同一个资源。复制或者赋值给指针会改变所有权，即源指针会把所有权移交给目的指针。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码可以看出复制指针的时候所有权的转移&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// C++ program to illustrate the use of auto_ptr
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

class A
{
public:
    void show() { cout &amp;lt;&amp;lt; &amp;quot;A::show()&amp;quot; &amp;lt;&amp;lt; endl; }
};

int main()
{
    // p1 is an auto_ptr of type A
    auto_ptr&amp;lt;A&amp;gt; p1(new A);
    p1-&amp;gt;show();

    // returns the memory address of p1
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;

    // copy constructor called, this makes p1 empty.
    auto_ptr &amp;lt;A&amp;gt; p2(p1);
    p2-&amp;gt;show();

    // p1 is empty now
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;

    // p1 gets copied in p2
    cout&amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输出结果如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;A::show()
0x1b42c20
A::show()
0           // NULL
0x1b42c20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;auto_ptr&lt;/code&gt;的拷贝构造函数和赋值运算符实际上不会拷贝存储的指针，而是转移指针，从而使得源指针为空。&lt;code&gt;auto_ptr&lt;/code&gt;实现了严格的所有权管理，使得同一时刻只有一个&lt;code&gt;auto_ptr&lt;/code&gt;对象可以拥有该指针。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;丢弃&lt;code&gt;auto_ptr&lt;/code&gt;的原因：&lt;code&gt;auto_ptr&lt;/code&gt;的赋值运算转移所有权，并且重置右值的&lt;code&gt;auto_ptr&lt;/code&gt;为空指针。因此，&lt;code&gt;auto_ptr&lt;/code&gt;不能用于 STL 容器。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;unique-ptr&#34;&gt;unique_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;是 C++11 开发用于替换&lt;code&gt;std::auto_ptr&lt;/code&gt;的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unique_ptr&lt;/code&gt;具有更好的安全性(没有“虚假”的拷贝赋值)，增加了特性(删除器)，支持数组。它是一个保存原始指针的容器。&lt;code&gt;unique_ptr&lt;/code&gt;显式地避免持有的指针拷贝赋值，它只允许指针有一个持有者。所以对于一个资源，至多只有一个&lt;code&gt;unique_ptr&lt;/code&gt;指向，当&lt;code&gt;unique_ptr&lt;/code&gt;销毁时，资源会自动释放。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对&lt;code&gt;unique_ptr&lt;/code&gt;拷贝赋值会导致编译错误。比如下面的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unique_ptr&amp;lt;A&amp;gt; ptr1 (new A);
unique_ptr&amp;lt;A&amp;gt; ptr2 = ptr1; // Error: can&#39;t copy unique_ptr
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以使用&lt;code&gt;std::move()&lt;/code&gt;语法转移持有指针的所有权给另外一个&lt;code&gt;unique_ptr&lt;/code&gt;。&lt;code&gt;unique_ptr&amp;lt;A&amp;gt; ptr2 = move(ptr1);&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码阐述了&lt;code&gt;unique_ptr&lt;/code&gt;的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt;

using namespace std;

class A
{
public:
    void show() { cout &amp;lt;&amp;lt; &amp;quot;A::show()&amp;quot; &amp;lt;&amp;lt; endl; }
};

int main()
{
    unique_ptr&amp;lt;A&amp;gt; p1(new A);
    p1-&amp;gt;show();

    // returns the memory address of p1
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;

    // transfers ownership to p2
    unique_ptr&amp;lt;A&amp;gt; p2 = move(p1);
    p2-&amp;gt;show();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    // transfers ownership to p3
    unique_ptr&amp;lt;A&amp;gt; p3 = move (p2);
    p3-&amp;gt;show();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p3.get() &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;A::show()
0x1c4ac20
A::show()
0          // NULL
0x1c4ac20
A::show()
0          // NULL
0          // NULL
0x1c4ac20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码返回一个资源，如果我们不显式的接收返回值，资源会被清理。反之，我们会得到对该资源的唯一所有权。因此，可以认为&lt;code&gt;unique_ptr&lt;/code&gt;比&lt;code&gt;auto_ptr&lt;/code&gt;更安全。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;unique_ptr&amp;lt;A&amp;gt; fun()
{
    unique_ptr&amp;lt;A&amp;gt; ptr(new A);
    // do something
    return ptr;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shared-ptr&#34;&gt;shared_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;shared_ptr&lt;/code&gt;是一个保存原始指针的容器。它是引用计数所有权模型(&lt;code&gt;reference counting ownership model&lt;/code&gt;)。&lt;code&gt;shared_ptr&lt;/code&gt;维护了持有指针的引用计数以及所有对&lt;code&gt;shared_ptr&lt;/code&gt;的拷贝。因此，当一个新的指针指向资源的时候计数增加，当指针析构的时候计数减少。&lt;/li&gt;
&lt;li&gt;引用计数(&lt;code&gt;reference counting&lt;/code&gt;)：是一种存储对于一个资源(比如对象，内存块，磁盘空间或者其他资源)的引用、指针或者句柄的数目的技术。&lt;/li&gt;
&lt;li&gt;当代码执行到指向资源的所有&lt;code&gt;shared_ptr&lt;/code&gt;的范围之外，资源才会销毁释放。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码阐述了&lt;code&gt;shared_ptr&lt;/code&gt;的使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;memory&amp;gt;
using namespace std;  
class A
{
public:
    void show() { cout &amp;lt;&amp;lt; &amp;quot;A::show()&amp;quot; &amp;lt;&amp;lt; endl; }
};

int main()
{
    shared_ptr&amp;lt;A&amp;gt; p1(new A);
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    p1-&amp;gt;show();
    shared_ptr&amp;lt;A&amp;gt; p2(p1);
    p2-&amp;gt;show();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    // Returns the number of shared_ptr objects referring to the same managed object.
    cout &amp;lt;&amp;lt; p1.use_count() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.use_count() &amp;lt;&amp;lt; endl;

    // Relinquishes ownership of p1 on the object and pointer becomes NULL
    p1.reset();
    cout &amp;lt;&amp;lt; p1.get() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.use_count() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; p2.get() &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;0x1c41c20
A::show()
A::show()
0x1c41c20
0x1c41c20
2
2
0          // NULL
1
0x1c41c20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;weak-ptr&#34;&gt;weak_ptr&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;weak_ptr&lt;/code&gt;是&lt;code&gt;shared_ptr&lt;/code&gt;的拷贝。它可以访问被一个或多个&lt;code&gt;shared_ptr&lt;/code&gt;实例持有的对象，但是不参与引用计数。&lt;code&gt;weak_ptr&lt;/code&gt;的存在或销毁对&lt;code&gt;shared_ptr&lt;/code&gt;及其拷贝没有影响。&lt;code&gt;weak_ptr&lt;/code&gt;对于打破&lt;code&gt;shared_ptr&lt;/code&gt;实例之间的循环引用必不可少。&lt;/li&gt;
&lt;li&gt;相互依赖(&lt;code&gt;Cyclic Dependency&lt;/code&gt;,&lt;code&gt;shared_ptr&lt;/code&gt;存在的问题)：考虑一个场景，类 A 和类 B，二者都有指针指向另外一个类。因此，如果有两个&lt;code&gt;shared_ptr&lt;/code&gt;的指针&lt;code&gt;ptr_A&lt;/code&gt;和&lt;code&gt;ptr_B&lt;/code&gt;分别指向 A 和 B的某个对象，总是&lt;code&gt;ptr_A&lt;/code&gt;持有 B 的对象而且&lt;code&gt;ptr_B&lt;/code&gt;持有 A 的对象。A 和 B 的对象引用计数一直不会变成 0，A 和 B 的对象都不会被删除。&lt;/li&gt;
&lt;li&gt;现在把&lt;code&gt;ptr_A&lt;/code&gt;换成&lt;code&gt;weak_ptr&lt;/code&gt;，&lt;code&gt;ptr_A&lt;/code&gt;可以访问 B 的对象但是不会持有该对象。B 对象的引用计数就是 0，可以先释放，之后 A 对象的引用计数变成 0 就可以释放内存。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;ptr_A&lt;/code&gt;之前需要检查 B 对象的有效性，因为 B 对象可能销毁。&lt;/li&gt;
&lt;li&gt;什么时候需要用&lt;code&gt;weak_ptr&lt;/code&gt;？当希望从不同的地方访问对象，且不关心这些引用的删除。但是尝试间接引用该对象的时候需要注意检查对象的有效性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reference&#34;&gt;reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/auto_ptr-unique_ptr-shared_ptr-weak_ptr-2/&#34; target=&#34;_blank&#34;&gt;auto_ptr, unique_ptr, shared_ptr and weak_ptr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/3451099/stdauto-ptr-to-stdunique-ptr&#34; target=&#34;_blank&#34;&gt;std::auto_ptr to std::unique_ptr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; new</title>
      <link>https://xueqing.github.io/blog/cplusplus/cplusplus_new/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/cplusplus_new/</guid>
      <description>

&lt;h2 id=&#34;关于-new-int-和-new-int&#34;&gt;关于 new int() 和 new int[]&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    #define LEN 100
    int *arr1 = new int(LEN);
    int *arr2 = new int[LEN];
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第一行的代码&lt;code&gt;arr1&lt;/code&gt;指向内存中&lt;code&gt;int = 100&lt;/code&gt;的一个数的地址&lt;/li&gt;
&lt;li&gt;第二行的代码&lt;code&gt;arr2&lt;/code&gt;指向长度为 100 的数组的内存块&lt;/li&gt;
&lt;li&gt;圆括号是对象赋值的意思；方括号是声明数组大小的意思&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; string 转换大小写</title>
      <link>https://xueqing.github.io/blog/cplusplus/cplusplus_string_case_convert/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/cplusplus_string_case_convert/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;string&amp;gt;
#include &amp;lt;algorithm&amp;gt;

void CString::StringToUpper(std::string &amp;amp;str)
{
    std::transform(str.begin(), str.end(), str.begin(), ::toupper);
}

void CString::StringToLower(std::string &amp;amp;str)
{
    std::transform(str.begin(), str.end(), str.begin(), ::tolower);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;提示出错&lt;code&gt;error: no matching function for call to ‘transform(__gnu_cxx::__normal_iterator&amp;lt;char*, std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;, __gnu_cxx::__normal_iterator&amp;lt;char*, std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;, __gnu_cxx::__normal_iterator&amp;lt;char*, std::basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt; &amp;gt;, &amp;lt;unknown type&amp;gt;)’&lt;/code&gt;的解决方法：既有 C 版本的&lt;code&gt;toupper/tolower&lt;/code&gt;函数，又有 STL 模板函数&lt;code&gt;toupper/tolower&lt;/code&gt;，二者存在冲突，在&lt;code&gt;toupper/tolower&lt;/code&gt;前加上&lt;code&gt;::&lt;/code&gt;表示强制指定 C 版本的&lt;/li&gt;
&lt;li&gt;::toloweer/::toupper 只用于单字节字符的替换，不适用于多字节编码（如 UTF-8）？&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可使用 boost 库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;boost/algorithm/string.hpp&amp;gt;
using namespace boost;
// use to_lower/to_upper function
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>C&#43;&#43; 未定义的行为</title>
      <link>https://xueqing.github.io/blog/cplusplus/undefined_behavior/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/undefined_behavior/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;UB(Undefined behavior):程序的行为没有限制。常见的未定义行为例子包括：数组访问内存越界，有符号数溢出，间接访问空指针，在一个表达式中无顺序多次修改标量，用不同类型的指针访问对象&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/language/ub&#34; target=&#34;_blank&#34;&gt;UB and optimization&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正确的 C++ 程序是没有未定义行为的，所以当编译器优化了含有 UB 的代码，程序会出现不可预料的结果&lt;/li&gt;
&lt;li&gt;有符号数溢出，下面是 C++ 代码和对应可能生成的机器语言&lt;/li&gt;

&lt;li&gt;&lt;p&gt;没有溢出时返回 1，溢出时是 UB，编译器可能优化，每次都返回 1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;int foo(int x)
{
return x+1 &amp;gt; x; // either true or UB due to signed overflow
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;foo(int):
movl    $1, %eax
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;访问越界，下面是 C++ 代码和对应可能生成的机器语言&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;访问下标在 0-3 时，如果存在元素 v 返回true，否则会访问越界，编译器可能优化，每次都返回 true，也不会访问越界&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;int table[4] = {};
bool exists_in_table(int v)
{
// return true in one of the first 4 iterations or UB due to out-of-bounds access
for (int i = 0; i &amp;lt;= 4; i++)
{
    if (table[i] == v) return true;
}
return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;exists_in_table(int):
movl    $1, %eax
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;未初始化的标量，下面是 C++ 代码和对应可能生成的机器语言&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当 x 非 0 时，a 会被赋值 42，否则 a 未初始化，编译器可能优化，每次都将 a 赋值42，然后返回&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;std::size_t f(int x)
{
std::size_t a;
if(x) // either x nonzero or UB
    a = 42;
return a;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;f(int):
mov     eax, 42
ret
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;间接访问空指针，下面是 C++ 代码和对应可能生成的机器语言&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数&lt;code&gt;foo&lt;/code&gt;：当 p 是空指针时，x 的赋值是间接访问空指针。否则返回 0。编译器可能优化，每次返回 0 而不会访问到空指针&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xorl %eax,%eax&lt;/code&gt;按位异或，相当于清 0，将寄存器&lt;code&gt;%eax&lt;/code&gt;设置为 0。也可以使用&lt;code&gt;movl $0,%eax&lt;/code&gt;，但是前者需要 2 个字节，后者需要 5 个字节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数&lt;code&gt;bar&lt;/code&gt;：直接访问空指针指向的值是 UB，编译器可能优化，每次直接执行下一行代码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;retq&lt;/code&gt;等同于&lt;code&gt;addq $8,%rsp; jmpq -8(%rsp)&lt;/code&gt;，&lt;code&gt;retq&lt;/code&gt;将&lt;code&gt;%esp&lt;/code&gt;指向的返回地址弹出，存入寄存器&lt;code&gt;%eip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;寄存器&lt;code&gt;%eip&lt;/code&gt;是程序计数器，存储了 CPU 要读取指令的地址，即 CPU 将要执行的指令的地址。每次 CPU执行完相应的汇编指令后，&lt;code&gt;%eip&lt;/code&gt;的值就会增加&lt;/li&gt;
&lt;li&gt;寄存器&lt;code&gt;%esp&lt;/code&gt;是栈指针指向栈顶元素。栈向低地址方向增长，可以通过增加栈指针来释放空间&lt;/li&gt;
&lt;li&gt;函数调用时会先将返回地址入栈，即程序中紧跟在调用函数后面的那条指令的地址，所以栈顶指针&lt;code&gt;%esp&lt;/code&gt;指向的就是调用函数后面的那条指令的地址，&lt;code&gt;retq&lt;/code&gt;会将该地址存入&lt;code&gt;%eip&lt;/code&gt;，CPU 就会继续往后执行&lt;/li&gt;
&lt;li&gt;在 64-bit 时，&lt;code&gt;ret&lt;/code&gt;会从栈中弹出四字节的地址保存到寄存器&lt;code&gt;%eip&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 32-bit 时，&lt;code&gt;ret&lt;/code&gt;会从栈中弹出两字节的地址保存到寄存器&lt;code&gt;%eip&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;int foo(int* p)
{
int x = *p;
if(!p) return x; // Either UB above or this branch is never taken
else return 0;
}
int bar()
{
int* p = nullptr;
return *p;        // Unconditional UB
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-code&#34;&gt;foo(int*):
xorl    %eax, %eax
ret
bar():
retq
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Effective C&#43;&#43;, 3rd</title>
      <link>https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%e8%ae%a9%e8%87%aa%e5%b7%b1%e4%b9%a0%e6%83%af-c&#34;&gt;1.让自己习惯 C++&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#01%e8%a7%86-c-%e4%b8%ba%e4%b8%80%e4%b8%aa%e8%af%ad%e8%a8%80%e8%81%94%e9%82%a6&#34;&gt;01.视 C++ 为一个语言联邦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#02%e5%b8%b8%e9%87%8f%e6%9e%9a%e4%b8%be%e5%92%8c%e5%86%85%e8%81%94%e4%bc%98%e4%ba%8e%e5%ae%8f%e5%ae%9a%e4%b9%89&#34;&gt;02.常量，枚举和内联优于宏定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#03%e5%b0%bd%e5%8f%af%e8%83%bd%e4%bd%bf%e7%94%a8%e5%b8%b8%e9%87%8f&#34;&gt;03.尽可能使用常量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#04%e7%a1%ae%e5%ae%9a%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%bd%bf%e7%94%a8%e5%89%8d%e5%b7%b2%e5%85%88%e8%a2%ab%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;04.确定对象被使用前已先被初始化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%e6%9e%84%e9%80%a0%e6%9e%90%e6%9e%84%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97&#34;&gt;2.构造/析构/赋值运算&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#05%e4%ba%86%e8%a7%a3-c-%e9%bb%98%e9%bb%98%e7%bc%96%e5%86%99%e5%b9%b6%e8%b0%83%e7%94%a8%e5%93%aa%e4%ba%9b%e5%87%bd%e6%95%b0&#34;&gt;05.了解 C++ 默默编写并调用哪些函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#06%e6%98%8e%e7%a1%ae%e6%8b%92%e7%bb%9d%e4%b8%8d%e6%83%b3%e7%94%a8%e7%9a%84%e7%bc%96%e8%af%91%e5%99%a8%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e7%9a%84%e5%87%bd%e6%95%b0&#34;&gt;06.明确拒绝不想用的编译器自动生成的函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#07%e5%a3%b0%e6%98%8e%e5%a4%9a%e6%80%81%e5%9f%ba%e7%b1%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%ba%e8%99%9a%e5%87%bd%e6%95%b0&#34;&gt;07.声明多态基类析构函数为虚函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#08%e5%88%ab%e8%ae%a9%e5%bc%82%e5%b8%b8%e9%80%83%e7%a6%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0&#34;&gt;08.别让异常逃离析构函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#09%e7%bb%9d%e4%b8%8d%e5%9c%a8%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e8%b0%83%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0&#34;&gt;09.绝不在构造和析构过程中调用虚函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10%e4%bd%bf-operator-%e8%bf%94%e5%9b%9e%e4%b8%80%e4%b8%aa-this-%e7%9a%84%e5%bc%95%e7%94%a8&#34;&gt;10.使 operator= 返回一个 *this 的引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11%e5%9c%a8-operator-%e4%b8%ad%e5%a4%84%e7%90%86%e8%87%aa%e6%88%91%e8%b5%8b%e5%80%bc&#34;&gt;11.在 operator= 中处理“自我赋值”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12%e5%a4%8d%e5%88%b6%e5%af%b9%e8%b1%a1%e7%9a%84%e6%89%80%e6%9c%89%e9%83%a8%e5%88%86&#34;&gt;12.复制对象的所有部分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86&#34;&gt;3.资源管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#13%e4%bb%a5%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86%e8%b5%84%e6%ba%90&#34;&gt;13.以对象管理资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e5%b0%8f%e5%bf%83%e5%a4%8d%e5%88%b6%e8%a1%8c%e4%b8%ba&#34;&gt;14.在资源管理类中小心复制行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e6%8f%90%e4%be%9b%e5%af%b9%e5%8e%9f%e5%a7%8b%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%bf%e9%97%ae&#34;&gt;15.在资源管理类中提供对原始资源的访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16%e5%9c%a8%e5%af%b9%e5%ba%94%e7%9a%84-new-%e5%92%8c-delete-%e9%87%87%e7%94%a8%e7%9b%b8%e5%90%8c%e5%bd%a2%e5%bc%8f&#34;&gt;16.在对应的 new 和 delete 采用相同形式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#17-%e4%bb%a5%e7%8b%ac%e7%ab%8b%e8%af%ad%e5%8f%a5%e5%b0%86-newed-%e5%af%b9%e8%b1%a1%e4%bf%9d%e5%ad%98%e5%88%b0%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88&#34;&gt;17. 以独立语句将 newed 对象保存到智能指针&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%a3%b0%e6%98%8e&#34;&gt;4.设计与声明&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#18%e8%ae%a9%e6%8e%a5%e5%8f%a3%e6%98%93%e8%a2%ab%e6%ad%a3%e5%b8%b8%e4%bd%bf%e7%94%a8%e4%b8%8d%e6%98%93%e8%a2%ab%e8%af%af%e7%94%a8&#34;&gt;18.让接口易被正常使用，不易被误用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#19%e6%8a%8a%e7%b1%bb%e8%ae%be%e8%ae%a1%e7%9c%8b%e4%bd%9c%e7%b1%bb%e5%9e%8b%e8%ae%be%e8%ae%a1&#34;&gt;19.把类设计看作类型设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#20%e5%b8%b8%e9%87%8f%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92%e4%bc%98%e4%ba%8e%e5%80%bc%e4%bc%a0%e9%80%92&#34;&gt;20.常量引用传递优于值传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#21%e5%bf%85%e9%a1%bb%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e6%97%b6%e4%b8%8d%e8%a6%81%e8%bf%94%e5%9b%9e%e5%bc%95%e7%94%a8&#34;&gt;21.必须返回对象时，不要返回引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22%e5%a3%b0%e6%98%8e%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98%e4%b8%ba%e7%a7%81%e6%9c%89%e7%9a%84&#34;&gt;22.声明数据成员为私有的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e4%bc%98%e4%ba%8e%e9%9d%9e%e6%88%90%e5%91%98%e9%9d%9e%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0&#34;&gt;23.成员函数优于非成员、非友元函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24%e5%bd%93%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e9%9c%80%e5%ba%94%e7%94%a8%e5%88%b0%e6%89%80%e6%9c%89%e5%8f%82%e6%95%b0%e5%a3%b0%e6%98%8e%e4%b8%ba%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;24.当类型转换需应用到所有参数，声明为非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25%e8%80%83%e8%99%91%e6%94%af%e6%8c%81%e4%b8%8d%e6%8a%9b%e5%bc%82%e5%b8%b8%e7%9a%84-swap-%e5%87%bd%e6%95%b0&#34;&gt;25.考虑支持不抛异常的 swap 函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%e5%ae%9e%e7%8e%b0&#34;&gt;5.实现&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#26%e5%b0%bd%e5%8f%af%e8%83%bd%e6%8e%a8%e8%bf%9f%e5%8f%98%e9%87%8f%e5%ae%9a%e4%b9%89&#34;&gt;26.尽可能推迟变量定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27%e6%9c%80%e5%b0%8f%e5%8c%96-cast-%e6%93%8d%e4%bd%9c&#34;&gt;27.最小化 cast 操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28%e9%81%bf%e5%85%8d%e8%bf%94%e5%9b%9e%e6%8c%87%e5%90%91%e5%af%b9%e8%b1%a1%e5%86%85%e9%83%a8%e7%9a%84%e5%8f%a5%e6%9f%84&#34;&gt;28.避免返回指向对象内部的句柄&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29%e5%8a%aa%e5%8a%9b%e5%86%99%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8%e7%9a%84%e4%bb%a3%e7%a0%81&#34;&gt;29.努力写异常安全的代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#30%e4%ba%86%e8%a7%a3%e5%86%85%e8%81%94%e7%9a%84%e7%bb%86%e8%8a%82&#34;&gt;30.了解内联的细节&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#31%e6%9c%80%e5%b0%8f%e5%8c%96%e6%96%87%e4%bb%b6%e7%bc%96%e8%af%91%e4%be%9d%e8%b5%96&#34;&gt;31.最小化文件编译依赖&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%e7%bb%a7%e6%89%bf%e4%b8%8e%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1&#34;&gt;6.继承与面向对象设计&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#32%e7%a1%ae%e4%bf%9d%e5%85%ac%e6%9c%89%e7%bb%a7%e6%89%bf%e6%98%af%22is-a%22%e5%85%b3%e7%b3%bb&#34;&gt;32.确保公有继承是&amp;rdquo;is-a&amp;rdquo;关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33%e9%81%bf%e5%85%8d%e9%9a%90%e8%97%8f%e7%bb%a7%e6%89%bf%e7%9a%84%e5%90%8d%e5%ad%97&#34;&gt;33.避免隐藏继承的名字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34%e5%8c%ba%e5%88%86%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf%e5%92%8c%e5%ae%9e%e7%8e%b0%e7%bb%a7%e6%89%bf&#34;&gt;34.区分接口继承和实现继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#35%e8%80%83%e8%99%91%e8%99%9a%e5%87%bd%e6%95%b0%e7%9a%84%e6%9b%bf%e4%bb%a3&#34;&gt;35.考虑虚函数的替代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#36%e7%bb%9d%e4%b8%8d%e9%87%8d%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e7%9a%84%e9%9d%9e%e8%99%9a%e5%87%bd%e6%95%b0&#34;&gt;36.绝不重定义继承的非虚函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#37%e7%bb%9d%e4%b8%8d%e9%87%8d%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0%e7%bb%a7%e6%89%bf%e7%9a%84%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0%e5%80%bc&#34;&gt;37.绝不重定义函数继承的默认参数值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#38%e9%80%9a%e8%bf%87%e7%bb%84%e5%90%88%e5%af%b9%22has-a%22%e6%88%96%22is-implemented-in-terms-of%22%e5%bb%ba%e6%a8%a1&#34;&gt;38.通过组合对&amp;rdquo;has-a&amp;rdquo;或&amp;rdquo;is-implemented-in-terms-of&amp;rdquo;建模&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#39%e6%85%8e%e9%87%8d%e4%bd%bf%e7%94%a8%e7%a7%81%e6%9c%89%e7%bb%a7%e6%89%bf&#34;&gt;39.慎重使用私有继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#40%e6%85%8e%e9%87%8d%e4%bd%bf%e7%94%a8%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf&#34;&gt;40.慎重使用多重继承&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7%e6%a8%a1%e6%9d%bf%e4%b8%8e%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b&#34;&gt;7.模板与泛型编程&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41%e7%90%86%e8%a7%a3%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%bc%96%e8%af%91%e6%9c%9f%e5%a4%9a%e6%80%81&#34;&gt;41.理解隐式接口和编译期多态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42%e7%90%86%e8%a7%a3-typename-%e7%9a%84%e5%8f%8c%e9%87%8d%e5%ae%9a%e4%b9%89&#34;&gt;42.理解 typename 的双重定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43%e4%ba%86%e8%a7%a3%e5%a6%82%e4%bd%95%e8%ae%bf%e9%97%ae%e6%a8%a1%e6%9d%bf%e5%8c%96%e5%9f%ba%e7%b1%bb%e5%86%85%e7%9a%84%e5%90%8d%e7%a7%b0&#34;&gt;43.了解如何访问模板化基类内的名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44%e6%8a%8a%e5%8f%82%e6%95%b0%e6%97%a0%e5%85%b3%e7%9a%84%e4%bb%a3%e7%a0%81%e5%88%86%e7%a6%bb%e5%87%ba%e6%a8%a1%e6%9d%bf&#34;&gt;44.把参数无关的代码分离出模板&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45%e4%bd%bf%e7%94%a8%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e6%9d%a5%e6%8e%a5%e5%8f%97%e6%89%80%e6%9c%89%e5%85%bc%e5%ae%b9%e7%b1%bb%e5%9e%8b&#34;&gt;45.使用成员函数模板来接受“所有兼容类型”&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#46%e9%9c%80%e8%a6%81%e7%b1%bb%e5%9e%8b%e8%bd%ac%e5%8c%96%e6%97%b6%e5%9c%a8%e6%a8%a1%e6%9d%bf%e5%86%85%e5%ae%9a%e4%b9%89%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;46.需要类型转化时在模板内定义非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#47%e4%bd%bf%e7%94%a8-traits-class-%e8%a1%a8%e7%8e%b0%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af&#34;&gt;47.使用 traits class 表现类型信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#48-%e8%ae%a4%e8%af%86%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b&#34;&gt;48. 认识模板元编程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8%e5%ae%9a%e5%88%b6-new-%e5%92%8c-delete&#34;&gt;8.定制 new 和 delete&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#49%e7%90%86%e8%a7%a3-new-handler-%e7%9a%84%e8%a1%8c%e4%b8%ba&#34;&gt;49.理解 new-handler 的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#50%e7%90%86%e8%a7%a3%e4%bd%95%e6%97%b6%e6%9b%bf%e6%8d%a2-new-%e5%92%8c-delete-%e6%9c%89%e6%84%8f%e4%b9%89&#34;&gt;50.理解何时替换 new 和 delete 有意义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#51%e5%86%99-new-%e5%92%8c-delete-%e6%97%b6%e9%81%b5%e5%be%aa%e6%83%af%e4%be%8b&#34;&gt;51.写 new 和 delete 时遵循惯例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52%e5%86%99%e4%ba%86-placement-new-%e4%b9%9f%e8%a6%81%e5%86%99-placement-delete&#34;&gt;52.写了 placement new 也要写 placement delete&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9%e6%9d%82%e9%a1%b9%e8%ae%a8%e8%ae%ba&#34;&gt;9.杂项讨论&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#53%e6%b3%a8%e6%84%8f%e7%bc%96%e8%af%91%e5%99%a8%e8%ad%a6%e5%91%8a&#34;&gt;53.注意编译器警告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54%e7%86%9f%e6%82%89%e5%8c%85%e6%8b%ac-tr1-%e5%9c%a8%e5%86%85%e7%9a%84%e6%a0%87%e5%87%86%e5%ba%93&#34;&gt;54.熟悉包括 TR1 在内的标准库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#55%e7%86%9f%e6%82%89-boost&#34;&gt;55.熟悉 Boost&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-让自己习惯-c&#34;&gt;1.让自己习惯 C++&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Accustoming yourself to C++&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;01-视-c-为一个语言联邦&#34;&gt;01.视 C++ 为一个语言联邦&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;View C++ as a federation of languages&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;面向对象的 C++：类、封装、继承、多态&lt;/li&gt;
&lt;li&gt;模板 C++：泛型编程&lt;/li&gt;
&lt;li&gt;STL：模板库&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;02-常量-枚举和内联优于宏定义&#34;&gt;02.常量，枚举和内联优于宏定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer consts, enums, inlines to #defines&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;对于单纯常量，以 const 对象或枚举&lt;/li&gt;
&lt;li&gt;对于形似函数的宏，用内联函数替换

&lt;ul&gt;
&lt;li&gt;常量、枚举和内联更具封装性，可以限定作用域&lt;/li&gt;
&lt;li&gt;枚举比常量约束更多，不能为该常量创建指针或引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;03-尽可能使用常量&#34;&gt;03.尽可能使用常量&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use const whenever possible&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;指定语义约束，即“不该被改动”的对象

&lt;ul&gt;
&lt;li&gt;可帮助编译器侦测错误用法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;const 在 * 左边，表示被指物是常量

&lt;ul&gt;
&lt;li&gt;也可将 const 放在类型之前&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;const widget *pw&lt;/code&gt;等同于&lt;code&gt;widget const *pw&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针所指东西不可被改动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;const 在 * 右边，表示指针自身是常量

&lt;ul&gt;
&lt;li&gt;指针不得指向不同的东西，但所指东西的值可以改动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;const 在 * 两侧，表示被指物和指针自身都是常量&lt;/li&gt;
&lt;li&gt;const 成员函数

&lt;ul&gt;
&lt;li&gt;可作用于 const 对象，不可更改对象内任何非静态成员变量&lt;/li&gt;
&lt;li&gt;成员变量前加&lt;code&gt;mutable&lt;/code&gt;，也可在 const 成员函数内部修改该成员变量&lt;/li&gt;
&lt;li&gt;当 const 和 non-const 成员函数有着实质等价的实现时，另 non-const 版本调用 const 版本避免代码重复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;04-确定对象被使用前已先被初始化&#34;&gt;04.确定对象被使用前已先被初始化&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Make sure that objects are initialized before they&amp;rsquo;re used&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;对于内置类型手动初始化&lt;/li&gt;
&lt;li&gt;对于类，在构造函数中初始化成员变量

&lt;ul&gt;
&lt;li&gt;赋值不等于初始化&lt;/li&gt;
&lt;li&gt;使用成员初始化列表列替换赋值动作，前者效率更高，后者先设初值再赋值&lt;/li&gt;
&lt;li&gt;可使用无参数构造函数来初始化&lt;/li&gt;
&lt;li&gt;对于多个构造函数，可添加私有成员函数，接收初始化参数，在函数内部使用赋值操作给成员变量“初始化”&lt;/li&gt;
&lt;li&gt;初始化顺序&lt;/li&gt;
&lt;li&gt;先基类再衍生类&lt;/li&gt;
&lt;li&gt;类内部，按照声明的顺序初始化，与成员初始化列表列操作顺序无关&lt;/li&gt;
&lt;li&gt;最好按照声明顺序初始化&lt;/li&gt;
&lt;li&gt;不同编译单元内的 non-local static 对象的初始化顺序未定义

&lt;ul&gt;
&lt;li&gt;static 对象包括全局对象、定义于命名空间作用域内的对象、类内、函数内，以及在文件作用域内被声明为 static 的对象&lt;/li&gt;
&lt;li&gt;函数内的 static 对象称为 local-static 对象，其他的则是 non-local static 对象&lt;/li&gt;
&lt;li&gt;程序结束时 static 对象会被自动销毁，即在 main 函数结束时调用他们的析构函数&lt;/li&gt;
&lt;li&gt;编译单元是产出单一目标文件的源码&lt;/li&gt;
&lt;li&gt;将每个 non-local static 对象移到自己的专属函数内，改函数返回对该对象的引用，保证该函数被调用期间，首次遇到该对象的定义时被初始化，即以函数调用替换直接访问 non-local static 对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-构造-析构-赋值运算&#34;&gt;2.构造/析构/赋值运算&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Contructors, destructors, and assignments operators&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;05-了解-c-默默编写并调用哪些函数&#34;&gt;05.了解 C++ 默默编写并调用哪些函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Know what functions C++ silently writes and calls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;编译器自动为类创建默认构造函数、拷贝构造函数、拷贝赋值操作和析构函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;06-明确拒绝不想用的编译器自动生成的函数&#34;&gt;06.明确拒绝不想用的编译器自动生成的函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Explicitly disallow the use of complier-generated functions you do not want&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果不想用编译器自动生成的函数，可将相应的成员函数声明为 private 并且不予实现&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以继承 Uncopyable 这样的基类，但是可能会多重继承&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Uncopyable {
protected: // allow constructor and destructor for derived object
Uncopyable() {}
~Uncopyable() {}
private:
Uncopyable(const Uncopyable&amp;amp;); //avoid copying
Uncopyable&amp;amp; operator=(const Uncopyable&amp;amp;);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;07-声明多态基类析构函数为虚函数&#34;&gt;07.声明多态基类析构函数为虚函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Declare destructors virtual in polymorphic base classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;包含虚函数的类需要额外的信息来实现虚函数：vptr(virtual table pointer)指向一个由函数指针构成的数组，称为 vtbl(virtual table)，每个有虚函数的类都有一个相应的 vtbl&lt;/li&gt;
&lt;li&gt;析构顺序：先父类再子类，构造函数的调用顺序相反&lt;/li&gt;
&lt;li&gt;带有多态性质的基类应声明一个虚析构函数&lt;/li&gt;
&lt;li&gt;如果一个类带有任何虚函数，就声明一个虚析构函数&lt;/li&gt;
&lt;li&gt;类的设计目的不是作为基类使用，或者不是为了多态性，不应该声明虚析构函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;08-别让异常逃离析构函数&#34;&gt;08.别让异常逃离析构函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prevent exceptions from leaving destructors&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果析构函数内可能抛出异常，应该在析构函数内捕获异常，然后不传播或结束程序&lt;/li&gt;
&lt;li&gt;如果需要客户自定义异常的反应，类应该提供接口执行该操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;09-绝不在构造和析构过程中调用虚函数&#34;&gt;09.绝不在构造和析构过程中调用虚函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Never call virtual functions during construction or destruction&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;在构造和析构中不要调用虚函数没因为这类调用不会下降到衍生类，即调用的仍然是基类的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;10-使-operator-返回一个-this-的引用&#34;&gt;10.使 operator= 返回一个 *this 的引用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Having assignment operators return a reference to *this&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;赋值相关运算(包括 operator=/+=、-=、*=)操作符返回一个 *this 的引用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;11-在-operator-中处理-自我赋值&#34;&gt;11.在 operator= 中处理“自我赋值”&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Handle assignment to self in operator=&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;确保对象自我赋值时，operator= 行为良好，包括比较源对象和目标对象的地址、精心周到的语句顺序(先复制源对象，再执行删除)，以及icopy-and-swap&lt;/li&gt;
&lt;li&gt;确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，行为仍然正确&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;12-复制对象的所有部分&#34;&gt;12.复制对象的所有部分&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Copy all parts of an object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;拷贝构造函数和拷贝赋值操作符都是 copying 函数&lt;/li&gt;
&lt;li&gt;copying 函数应该确保复制“对象内的所有成员变量”和“所有基类成分”&lt;/li&gt;
&lt;li&gt;不要尝试以某个 copying 函数实现另一个 copying 函数，应该将相同的东西抽象成一个函数，二者都调用这个函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-资源管理&#34;&gt;3.资源管理&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Resource management&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;13-以对象管理资源&#34;&gt;13.以对象管理资源&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use objects to manage resources&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;为防止内存泄漏，建议使用 RAII(Resource Acquisition Is Initialization，资源取得时机就是初始化时机) 对象，它们在构造函数中获得资源并在析构函数中释放资源&lt;/li&gt;
&lt;li&gt;常用的 RAII 类是 shared_ptr 和 auto_ptr。前者的拷贝行为比较直观，后者的复制动作会转移资源的所有权：shared_ptr 有引用计数，但是无法打破环装引用&lt;/li&gt;
&lt;li&gt;参考&lt;a href=&#34;./smart_ptr.md&#34;&gt;智能指针&lt;/a&gt;一文&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;14-在资源管理类中小心复制行为&#34;&gt;14.在资源管理类中小心复制行为&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Think carefully about copying behavior in resource-managing classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;复制 RAII 对象必须一并复制它锁管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为&lt;/li&gt;
&lt;li&gt;一般情况下，RAII 类的 copying 行为是：阻止 copying、实行引用计数法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;15-在资源管理类中提供对原始资源的访问&#34;&gt;15.在资源管理类中提供对原始资源的访问&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Provide access to raw resources in resource-managing classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;APIs 往往要求访问原始资源，所以每一个 RAII 类应该提供一个接口可以获得其管理的资源&lt;/li&gt;
&lt;li&gt;对原始资源的访问可以是显示转换或隐式转换：一般显示转换比较安全，隐式转换对客户比较方便&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;16-在对应的-new-和-delete-采用相同形式&#34;&gt;16.在对应的 new 和 delete 采用相同形式&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use the same form in corresponding uses of new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;调用 new 时使用&lt;code&gt;[]&lt;/code&gt;，那么对应调用 delete 时也调用&lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用 new 时没有使用&lt;code&gt;[]&lt;/code&gt;，那么也不该在调用 delete 时使用&lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;17-以独立语句将-newed-对象保存到智能指针&#34;&gt;17. 以独立语句将 newed 对象保存到智能指针&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Store newed onjects in smart pointers in standalone statements&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;以独立语句将 newed 对象保存在智能指针内。否则，抛出异常的时候，可能会导致内存泄漏&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-设计与声明&#34;&gt;4.设计与声明&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Designs and declarations&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;18-让接口易被正常使用-不易被误用&#34;&gt;18.让接口易被正常使用，不易被误用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Make interfaces easy to use correctly and hard to use incorrectly&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容&lt;/li&gt;
&lt;li&gt;“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任&lt;/li&gt;
&lt;li&gt;shared_ptr 支持自定义删除器，可以防止 DLL 问题，可被用来自动解除互斥锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;19-把类设计看作类型设计&#34;&gt;19.把类设计看作类型设计&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Treat class design as type design&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;在设计一个类之前，考虑以下问题&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;新类型的对象如何被创建和销毁&lt;/li&gt;
&lt;li&gt;对象的初始化和对象的赋值该有什么样的差别：区分构造函数和赋值操作符的行为&lt;/li&gt;
&lt;li&gt;新类型的对象如果以值传递，意味着什么：取决于拷贝构造函数&lt;/li&gt;
&lt;li&gt;什么是新类型的“合法值”：确定需要做的错误检查工作&lt;/li&gt;
&lt;li&gt;新类型需要配合某个继承图系吗：受继承类的约束，如果允许被继承，析构函数是否为虚函数&lt;/li&gt;
&lt;li&gt;新类型需要什么样的转换：显示类型转换和隐式类型转换&lt;/li&gt;
&lt;li&gt;什么样的操作符和函数对此新类型是合理的：确定需要声明的函数，哪些是成员函数，哪些不是成员函数&lt;/li&gt;
&lt;li&gt;谁该调用新类型的成员：确定成员的属性(public/protected/private)，也确定类之间的关系(所属，友元)&lt;/li&gt;
&lt;li&gt;什么是新类型的未声明接口&lt;/li&gt;
&lt;li&gt;新类型有多一般化：是否需要定义一个模板类&lt;/li&gt;
&lt;li&gt;真的需要一个新类型吗：是否可以为已有类添加非成员函数或模板来实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;20-常量引用传递优于值传递&#34;&gt;20.常量引用传递优于值传递&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer pass-by-reference-to-const to pass-by-value&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;值传递效率低，而且可能造成对象切割(slicing)：值传递一个衍生类对象时，如果函数声明的是基类，那么调用的是基类的拷贝构造函数&lt;/li&gt;
&lt;li&gt;C++ 编译器底层使用指针实现，不同情形使用不同的方式

&lt;ul&gt;
&lt;li&gt;内置类型(如 int)采用值传递&lt;/li&gt;
&lt;li&gt;STL 的迭代器和函数对象使用值传递&lt;/li&gt;
&lt;li&gt;其他的采用常量引用传递&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;21-必须返回对象时-不要返回引用&#34;&gt;21.必须返回对象时，不要返回引用&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t try to return a reference when you must return an object&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;绝不要返回指针或引用指向一个 local stack 对象&lt;/li&gt;
&lt;li&gt;绝不要返回引用指向一个 heap-allocated 对象&lt;/li&gt;
&lt;li&gt;绝不要返回指针或引用指向一个 local static 对象而有可能同时需要多个这样的对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;22-声明数据成员为私有的&#34;&gt;22.声明数据成员为私有的&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Declare data memebers private&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;语法一致性：public 接口内的所有东西都是函数&lt;/li&gt;
&lt;li&gt;可细微划分访问控制、允诺约束条件获得保证&lt;/li&gt;
&lt;li&gt;protected 并不比 public 更具封装性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;23-成员函数优于非成员-非友元函数&#34;&gt;23.成员函数优于非成员、非友元函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Prefer non-member non-friend functions to member function&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;将所有功能函数放在多个头文件内但隶属同一命名空间，使用者可以轻松扩展这一组功能函数

&lt;ul&gt;
&lt;li&gt;在命名空间添加非成员非友元函数，以便为使用者提供方便的接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;优先考虑非成员、非友元函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;24-当类型转换需应用到所有参数-声明为非成员函数&#34;&gt;24.当类型转换需应用到所有参数，声明为非成员函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Declare non-member functions when type conversions should apply to all parameters&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果需要为某个函数的所有参数(包括被 this 指针所指的隐喻参数)进行类型转换，那么这个函数必须是非成员函数

&lt;ul&gt;
&lt;li&gt;编译器可对每一个实参执行隐式类型转换&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;25-考虑支持不抛异常的-swap-函数&#34;&gt;25.考虑支持不抛异常的 swap 函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Consider support for a non-throwing swap&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果 std::swap 缺省实现对自定义的类或类模板的效率不足，试着做

&lt;ul&gt;
&lt;li&gt;提供一个 public swap 成员函数，在函数内高效地置换两个对象值&lt;/li&gt;
&lt;li&gt;在类或模板所在的命名空间提供一个非成员的 swap 函数，在函数内调用上述 swap 函数&lt;/li&gt;
&lt;li&gt;如果正在编写一个类或类模板，让该类特化 std::swap，另其调用上述的 swap 函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果调用 swap，确定包含&lt;code&gt;using std::swap&lt;/code&gt;，然后不加任何 namespace 修饰符，直接调用 swap，编译器就会查找适当的 swap 函数并调用&lt;/li&gt;
&lt;li&gt;警告：成员函数 swap 不可抛出异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-实现&#34;&gt;5.实现&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Implementations&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;26-尽可能推迟变量定义&#34;&gt;26.尽可能推迟变量定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Postpone variable definitions as long as possible&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;尽可能延后变量定义式的出现，最好是延后到可以用有意义的参数进行始化&lt;/li&gt;
&lt;li&gt;对于循环，如果构造和析构的代码大于赋值操作，则将定义放在循环外&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;27-最小化-cast-操作&#34;&gt;27.最小化 cast 操作&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Minimize casting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;C 风格的转换操作，将 expression 转换为 T：&lt;code&gt;(T)expression&lt;/code&gt;和&lt;code&gt;T(expression)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C++ 另外提供 4 种转换操作

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;用来移除对象的常量性，唯一可以实现这个目的的 C++ 风格的转换操作符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dynamic_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;用于执行“安全向下转换”，用于确定某对象是否归属继承体系中的某个类型，可能耗费重大运行成本，唯一一个 C 风格无法实现的转换操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reinterpret_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;意图执行低级转换，实际动作和结果可能取决于编译器，即不可移植&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static_cast&amp;lt;T&amp;gt;( expression )&lt;/code&gt;用于强迫隐式转换，例如 non-const 转换为 const，或者 int 转 double 等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;倾向使用 C++ 风格的转换操作，不要使用 C 风格的转换

&lt;ul&gt;
&lt;li&gt;易被辨识，因而得以简化查找类型被破坏的过程&lt;/li&gt;
&lt;li&gt;各转换工作有各自的局限，便于编译器诊断错误的运用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果可以，尽量避免转换操作，特别是在注重效率的代码中避免 dynamic_cast，如果有需要，尝试改成无需转换的设计

&lt;ul&gt;
&lt;li&gt;使用类型安全容器，确定是哪种衍生类或基类&lt;/li&gt;
&lt;li&gt;将虚函数放在父类，然后添加空实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果必须转换，试着用函数封装，可以调用函数，而无需将转换操作引入代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;28-避免返回指向对象内部的句柄&#34;&gt;28.避免返回指向对象内部的句柄&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid returning &amp;ldquo;handles&amp;rdquo; to object internals&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;避免返回 handles(包括引用、指针、迭代器)指向对象内部。一遍增加封装性，帮助 const 成员函数的行为像个 const，并将发生 dangling handles 的可能性降至最低&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;29-努力写异常安全的代码&#34;&gt;29.努力写异常安全的代码&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Strive for exception-safe code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;异常安全函数即使发生议程也不会内存泄漏或破坏任何数据结构。这样的函数分为三种可能的保证：基本型、强烈型、不抛异常型&lt;/li&gt;
&lt;li&gt;“强烈保证”往往以 copy-and-swap 实现，但“强烈保证”并非对所有函数都可实现或具备现实意义&lt;/li&gt;
&lt;li&gt;函数提供的“异常安全保证”通常最高只等于其调用的各个函数的“异常安全保证”中的最弱者&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;30-了解内联的细节&#34;&gt;30.了解内联的细节&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand the ins and outs of inlining&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;将大多数内联限制在小型、被频繁调用的函数。可使日后的调试过程和二进制升级更容易，也可最小化潜在的代码膨胀问题，最大化提升程序的速度

&lt;ul&gt;
&lt;li&gt;内联函数无法随着程序库的升级而升级：内联函数修改，用到该函数的程序必须重新编译&lt;/li&gt;
&lt;li&gt;大部分调试器不支持内联函数调试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;隐式内联：函数定义在类定义内&lt;/li&gt;
&lt;li&gt;显式内联：添加关键字 inline

&lt;ul&gt;
&lt;li&gt;没有要求每个函数都是内联，就避免声明一个模板是内联&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大多数编译拒绝复杂的函数内联：比如虚函数，带有循环或递归的函数。此时会有警告信息&lt;/li&gt;
&lt;li&gt;编译器通常不对“通过函数指针进行的调用”执行内联&lt;/li&gt;
&lt;li&gt;不要只因为函数模板出现在头文件，就将其声明为内联&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;31-最小化文件编译依赖&#34;&gt;31.最小化文件编译依赖&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Minimize compilation dependencies between files&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;pimply idiom(pointer to implementation)：将一个类分为两个，一个提供接口，一个负责实现接口，前者在类内包含一个后者的 shared_ptr，做到“接口与实现分离”&lt;/li&gt;
&lt;li&gt;使用接口类、衍生类和工厂模式进行实现&lt;/li&gt;
&lt;li&gt;分离的关键在于“声明的依存性”替换“定义的依存性”：让头文件尽可能自我满足，万一做不到，则使用前置声明&lt;/li&gt;
&lt;li&gt;设计策略

&lt;ul&gt;
&lt;li&gt;尽量使用对象引用或对象指针，而不是对象：可以在头文件中使用前置声明&lt;/li&gt;
&lt;li&gt;尽量使用 class 声明式而不是 class 定义式&lt;/li&gt;
&lt;li&gt;为声明式和定义式提供不同的头文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;程序头文件应该以“完全且仅有声明式”的形式存在&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-继承与面向对象设计&#34;&gt;6.继承与面向对象设计&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Inheritance and object-oriented design&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;32-确保公有继承是-is-a-关系&#34;&gt;32.确保公有继承是&amp;rdquo;is-a&amp;rdquo;关系&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Make sure public inheritance models &amp;ldquo;is-a&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;public 继承意味着 is-a。适用于基类的每一件事情一定适用于衍生类，每一个衍生类对象也都是一个基类对象&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;33-避免隐藏继承的名字&#34;&gt;33.避免隐藏继承的名字&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid hiding inherited names&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;衍生类内的名称会隐藏基类内的名称

&lt;ul&gt;
&lt;li&gt;如果继承基类并加上重载函数，又希望重新定义或覆盖其中一部分，必须为那些原本会被隐藏的名称引入一个 using 声明式，否则继承的名称会被隐藏&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为了让隐藏的名称仍然可见，可使用 using 声明式或 forwarding 函数

&lt;ul&gt;
&lt;li&gt;内置的 forwarding 函数的另一个用途是为那些不支持 using 声明式的编译器而用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;34-区分接口继承和实现继承&#34;&gt;34.区分接口继承和实现继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Differentiate between inheritance of interface and inhertance of implementation&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;接口继承和实现继承不同。在 public 继承时，衍生类会继承基类的接口，即成员函数&lt;/li&gt;
&lt;li&gt;声明纯虚函数的目的是让衍生类只继承函数接口&lt;/li&gt;
&lt;li&gt;声明非纯虚函数的目的是让衍生类继承该函数的接口和缺省实现&lt;/li&gt;
&lt;li&gt;声明非虚函数的目的是让衍生类继承函数的接口和一份强制性实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;35-考虑虚函数的替代&#34;&gt;35.考虑虚函数的替代&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Condider alternatives to virtual functions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;虚函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式

&lt;ul&gt;
&lt;li&gt;使用 non-virtual interface(NVI)手法，是 Template Method 设计模式的一种特殊形式。以 public non-virtual 成员函数包裹较低访问性的虚函数&lt;/li&gt;
&lt;li&gt;将虚函数替换为“函数指针成员变量”。是 Strategy 设计模式的一种分解表现形式&lt;/li&gt;
&lt;li&gt;以 function 成员变量替换虚函数，因而允许使用任何可调用实体(callable entities)搭配一个兼容与需求的签名式。这也是 Strategy 设计模式的某种形式&lt;/li&gt;
&lt;li&gt;将继承体系内的虚函数替换为另一继承体系的虚函数。这是 Strategy 设计模式的传统实现手法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将功能从成员函数移到类外部，缺点是非成员函数无法访问类的 non-public 成员&lt;/li&gt;
&lt;li&gt;function 对象的行为就像一般函数指针。这样的对象可接纳“与给定的目标签名式兼容”的所有可调用实体&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;36-绝不重定义继承的非虚函数&#34;&gt;36.绝不重定义继承的非虚函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Never redefine an inherited non-virtual function&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;非虚函数是静态绑定的，虚函数是动态绑定的&lt;/li&gt;
&lt;li&gt;任何情况下都不该重新定义一个继承而来的非虚函数，否则调用的函数取决于对象最开始的声明类型，跟实际所指类型无关&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;37-绝不重定义函数继承的默认参数值&#34;&gt;37.绝不重定义函数继承的默认参数值&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Never redefine a function&amp;rsquo;s inherited default parameter value&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;虚函数是动态绑定，但是缺省参数是静态绑定

&lt;ul&gt;
&lt;li&gt;调用虚函数时，默认参数可能是基类的默认参数，而不是实际指向的父类的默认参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;静态类型是声明的类型，动态类型是“目前所指对象的类型”

&lt;ul&gt;
&lt;li&gt;动态类型可以表现出一个对象将会有什么行为&lt;/li&gt;
&lt;li&gt;动态类型可在程序执行过程中改变&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以使用 NVI 手法：另基类内的一个 public 非虚函数调用 private 虚函数，后者可被衍生类重新定义。让非虚函数知道缺省参数，虚函数负责真正的工作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;38-通过组合对-has-a-或-is-implemented-in-terms-of-建模&#34;&gt;38.通过组合对&amp;rdquo;has-a&amp;rdquo;或&amp;rdquo;is-implemented-in-terms-of&amp;rdquo;建模&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Model &amp;ldquo;has-a&amp;rdquo; or &amp;ldquo;is-implemented-in-terms-of&amp;rdquo; through composition&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;复合是类型间的一种关系，当某种类型的对象内包含其他类型的对象，就是复合关系&lt;/li&gt;
&lt;li&gt;在应用域，复合意味着 has-a(有一个)。在实现域，复合以为着 is-implemented-in-terms-of(根据某物实现出)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;39-慎重使用私有继承&#34;&gt;39.慎重使用私有继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use private inheritance judiciously&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;private 继承意味着 is-implemented-in-terms-of。通常比复合的级别低，但是当衍生类需要访问基类的 protected 成员，或需要重新定义继承而来的虚函数时，private 继承是合理的

&lt;ul&gt;
&lt;li&gt;private 继承时，编译器不会自动将一个衍生类对象转换为一个基类对象&lt;/li&gt;
&lt;li&gt;由 private 继承而来的所有成员，在衍生类中都是 private 属性&lt;/li&gt;
&lt;li&gt;private 继承是一种实现技术，意味着只有实现部分被继承，接口部分应忽略&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;与复合相比，private 继承可以使得空白基类最优化(EBO, empty base optimization)。对致力于“对象尺寸最小化”的程序库开发者比较重要&lt;/li&gt;
&lt;li&gt;尽可能使用复合，必要时采用 private 继承

&lt;ul&gt;
&lt;li&gt;当想要访问一个类的 protected 成员，或需要重新定义该类的一个或多个虚函数&lt;/li&gt;
&lt;li&gt;当空间更加重要，衍生类的基类可以不包含任何 non-static 成员变量&lt;/li&gt;
&lt;li&gt;“独立(非附属)”对象的大小一定不为零，不适用于单一继承(多重继承不可以)衍生类对象的基类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;40-慎重使用多重继承&#34;&gt;40.慎重使用多重继承&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use multiple inheritance judiciously&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;多重继承是继承一个以上的基类，但这些基类并不常在继承体系中又有基类

&lt;ul&gt;
&lt;li&gt;虚继承：防止多重继承时，基类之间又有基类，从而上层的基类的成员变量被父类复制&lt;/li&gt;
&lt;li&gt;虚继承的类产生的对象体积更大，访问虚基类的成员变量速度慢，增加初始化(及赋值)的复杂度&lt;/li&gt;
&lt;li&gt;如果虚基类不带任何数据，是具有使用价值的情况&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多重继承比单一继承复杂，可能导致新的歧义性，以及对虚继承的需要&lt;/li&gt;
&lt;li&gt;多重继承的用途：涉及“public 继承某个接口类”和“private 继承某个协助实现的类”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-模板与泛型编程&#34;&gt;7.模板与泛型编程&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Templates and generic programming&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;41-理解隐式接口和编译期多态&#34;&gt;41.理解隐式接口和编译期多态&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand implicit interfaces and compile-time polymorphism&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;类和模板都支持接口和多态&lt;/li&gt;
&lt;li&gt;对类而言接口是显式的，以函数签名为中心。多态则是通过虚函数发生于运行期&lt;/li&gt;
&lt;li&gt;对模板参数而言，接口是隐式的，基于有效表达式。多态则是通过模板具体化和函数重载解析，发生于编译期&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;42-理解-typename-的双重定义&#34;&gt;42.理解 typename 的双重定义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand the two meanings of typename&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;声明模板类型参数的两种方式：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template&amp;lt;class T&amp;gt; class widget;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template&amp;lt;typename T&amp;gt; class widget;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从属名称：模板内的名称依赖于某个模板参数

&lt;ul&gt;
&lt;li&gt;非从属名称：模板内不依赖模板参数的名称&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;嵌套从属名称：从属名称在类内呈嵌套状&lt;/li&gt;
&lt;li&gt;嵌套从属类型名称：嵌套从属名称且指向某类型

&lt;ul&gt;
&lt;li&gt;想在模板中指定一个嵌套从属类型名称，就必须在紧邻它的前一个位置加上关键字 typename&lt;/li&gt;
&lt;li&gt;typename 不可出现在基类列表类的嵌套从属类型名称前，也不可在成员初始化列表中作为基类的修饰符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;43-了解如何访问模板化基类内的名称&#34;&gt;43.了解如何访问模板化基类内的名称&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Know how to access names in templatized base classes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;当基类从模板中被具体化时，它假设对基类的内容一无所知，即衍生类基类继承一个基类模板，不能再衍生类的实现中直接调用基类的成员(变量和函数)

&lt;ul&gt;
&lt;li&gt;可在衍生类模板内添加&lt;code&gt;this-&amp;gt;&lt;/code&gt;指向基类模板的成员(变量和函数)&lt;/li&gt;
&lt;li&gt;使用 using 声明式，假设已经存在这个成员(变量和函数)&lt;/li&gt;
&lt;li&gt;明确指出被调用的函数位于基类内，使用&lt;code&gt;基类::&lt;/code&gt;，如果是一个虚函数，会关闭虚函数的动态绑定行为&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;44-把参数无关的代码分离出模板&#34;&gt;44.把参数无关的代码分离出模板&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Factor parameter-independent code out of templates&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;模板生成多个类和多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生依赖关系&lt;/li&gt;
&lt;li&gt;因非类型模板参数造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数&lt;/li&gt;
&lt;li&gt;因类型参数造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表示的具体类型实现共享代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;45-使用成员函数模板来接受-所有兼容类型&#34;&gt;45.使用成员函数模板来接受“所有兼容类型”&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use member function templates to accept &amp;ldquo;all compatible types&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;具有基类-衍生类关系的两个类型分别具体化某个模板，生成的两个结构并不带有基类-衍生类关系&lt;/li&gt;
&lt;li&gt;使用成员函数模板生成“可接受所有兼容类型”的函数&lt;/li&gt;
&lt;li&gt;如果声明成员模板用于“泛化拷贝构造”或“泛化赋值操作”，必须声明正常的拷贝构造函数和拷贝赋值操作符

&lt;ul&gt;
&lt;li&gt;声明泛化拷贝构造函数和拷贝赋值操作符，不会阻止编译器生成默认的拷贝构造函数和拷贝赋值操作符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;46-需要类型转化时在模板内定义非成员函数&#34;&gt;46.需要类型转化时在模板内定义非成员函数&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Define non-member functions inside templates when type conversions are desired&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;模板实参推导过程中不会考虑隐式类型转换函数&lt;/li&gt;
&lt;li&gt;写类模板时，当它提供的“与此模板相关的”函数支持“所有参数的隐式类型转换”时，将那些函数定义为类模板内部的友元函数

&lt;ul&gt;
&lt;li&gt;在类内部声明非成员函数作为友元函数，成为内联函数&lt;/li&gt;
&lt;li&gt;为了将内联声明的影响最小化，在类外定义一个辅助函数模板，在友元函数内只调用辅助函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;47-使用-traits-class-表现类型信息&#34;&gt;47.使用 traits class 表现类型信息&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Use traits classes for information about types&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;STL 有 5 种迭代器

&lt;ul&gt;
&lt;li&gt;input 迭代器：只能向前移动，一次异步，只可读取(不能修改)所指的东西，且只能读取一次。模仿了指向输入文件的读指针。如 C++ 的 istream_iterator&lt;/li&gt;
&lt;li&gt;output 迭代器：只能向前移动，一次一步，只可修改所指的东西，且只能修改一次。模仿了指向输出文件的写指针。如 C++ 的 ostream_iterator&lt;/li&gt;
&lt;li&gt;input 和 output 迭代器都只适合“单步操作算法(one-pass algorithms)”&lt;/li&gt;
&lt;li&gt;forward 迭代器：既能完成上述两种迭代器的工作，且可以读或写所指对象一次以上。使得可以实施“多步操作算法(multi-pass algorithms)”。如单向链表的迭代器&lt;/li&gt;
&lt;li&gt;bidirectional 迭代器：既能完成 forward 迭代器的工作，还支持向后移动。STL 的 list/set/multiset/map/multimap 迭代器就属于这一分类&lt;/li&gt;
&lt;li&gt;random access 迭代器：可以执行“迭代器运算”，即可以在常量时间内向前或向后跳跃任意距离。如 array/vector/deque/string 提供的都是随机访问迭代器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如何设计一个 traits 类

&lt;ul&gt;
&lt;li&gt;确认若干希望将来可取得的类型相关信息。例如迭代器希望取得分类(category)&lt;/li&gt;
&lt;li&gt;为该信息选择一个名词。如迭代器是 iterator_category&lt;/li&gt;
&lt;li&gt;提供一个模板和一组特化版本，其中包含希望支持的类型相关信息&lt;/li&gt;
&lt;li&gt;traits 类的名称常以&amp;rdquo;traits&amp;rdquo;结束&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如何使用一个 traits 类

&lt;ul&gt;
&lt;li&gt;建立一组重载函数(类似劳工)或函数模板，彼此间的差异只在于各自的 traits 参数。令每个函数实现与其接受的 traits 信息相对应&lt;/li&gt;
&lt;li&gt;建立一个控制函数(类似工头)或函数模板，调用上述的函数并传递 traits 类所提供的信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;traits 类使得“类型相关信息”在编译期可用。它们以模板和一组“模板特化”完成实现&lt;/li&gt;
&lt;li&gt;整合重载技术后，traits 类可在编译期对类型执行 if&amp;hellip;else 测试&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;48-认识模板元编程&#34;&gt;48. 认识模板元编程&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Be aware of template metaprogramming&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;模板元编程(TMP, template metaprogramming)是编写基于模板的 C++ 程序并在编译期执行的过程

&lt;ul&gt;
&lt;li&gt;即以 C++ 写成、在 C++ 编译期内执行的程序&lt;/li&gt;
&lt;li&gt;TMP 程序结束执行，输出的 C++ 源码可以像往常一样编译&lt;/li&gt;
&lt;li&gt;优点：&lt;/li&gt;
&lt;li&gt;让某些事情更容易&lt;/li&gt;
&lt;li&gt;可将工作从运行期转移到编译期。使得原本在运行期才可以侦测的错误在编译期被找到&lt;/li&gt;
&lt;li&gt;TMP 的 C++ 程序在每一方面可能更加高效：较小的可执行文件、较短的运行期、较少的内存需求&lt;/li&gt;
&lt;li&gt;缺点：导致编译时间变长&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;TMP 主要是函数式语言，可以达到的目的

&lt;ul&gt;
&lt;li&gt;确保度量单位正确：在编译期确保程序所有度量单位的组合是正确的&lt;/li&gt;
&lt;li&gt;优化矩阵运算：使用 expression template，可能会消除中间计算生成的临时对象并合并循环&lt;/li&gt;
&lt;li&gt;可生成用户自定义设计模式的实现品。设计模式如 Strategy/Observer/Visitor 等都可以多种方式实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;问题：

&lt;ul&gt;
&lt;li&gt;语法不直观&lt;/li&gt;
&lt;li&gt;支持工具不充分，如没有调试器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-定制-new-和-delete&#34;&gt;8.定制 new 和 delete&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Customizing new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;只适合分配单一对象；&lt;code&gt;new []&lt;/code&gt;和&lt;code&gt;delete []&lt;/code&gt;用来分配数组&lt;/li&gt;
&lt;li&gt;STL 容器所使用的 heap 内存是由容器所拥有的分配器对象(allocator objects)管理，而不是 new 和 delete 管理&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;49-理解-new-handler-的行为&#34;&gt;49.理解 new-handler 的行为&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand the behavior of the new-handler&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;当 new 操作抛出异常以反映一个未获满足的内存需求之前，会先调研一个客户指定的错误处理函数，即 new-handler

&lt;ul&gt;
&lt;li&gt;可以用是&lt;code&gt;set_new_handler&lt;/code&gt;设置该函数&lt;/li&gt;
&lt;li&gt;参数是个指针，指向 new 无法分配足够内存时该调用的函数&lt;/li&gt;
&lt;li&gt;返回值是个指针，指向&lt;code&gt;set_new_handler&lt;/code&gt;被调用之前正在执行的 new_handler 函数&lt;/li&gt;
&lt;li&gt;new_handler 是个 typedef，定义一个指针指向函数，函数没有参数也没有返回值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设计良好的 new-handler 函数

&lt;ul&gt;
&lt;li&gt;让更多内存可被使用：程序一开始执行就分配一大块内存，而后第一次调用 new-handler，将该内存释放给程序使用&lt;/li&gt;
&lt;li&gt;设置另一个 new-handler：如果已知哪个 new-handler 可以获得更多可用内存，调用时设置该 new-handler 替换自己。比如令 new-handler 修改“会影响 new-handler 行为”的静态数据、命名空间数据或全局数据&lt;/li&gt;
&lt;li&gt;取消设置 new-handler：即将 null 指针传给&lt;code&gt;set_new_handler&lt;/code&gt;，内存分配不成功时就会抛异常&lt;/li&gt;
&lt;li&gt;抛出 bad_alloc 或派生自 bad_alloc 的异常：该异常不会被 new 操作捕获，但会传播给请求内存的代码&lt;/li&gt;
&lt;li&gt;不返回：通常调用 abort 或 exit&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nothrow new&lt;/code&gt;是一个有局限性的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;50-理解何时替换-new-和-delete-有意义&#34;&gt;50.理解何时替换 new 和 delete 有意义&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Understand when it makes sense to replace new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;三个替换编译器提供的 new 和 delete 理由：

&lt;ul&gt;
&lt;li&gt;检测运用上的错误：自定义 new 操作，可超额分配内存，以额外空间放置特定的 byte patterns(即签名，signature)。对应的 delete 操作可以检查上述签名是否原封不动，若否表示在分配区的某个声生命时间点发生了 overrun(写入点在分配区块尾端之后) 或 underrun(写入点在分配区块起点之前)。此时 delete 可以日志记录该时间和发生错误的指针&lt;/li&gt;
&lt;li&gt;强化效能：编译器的 new 和 delete 无法解决碎片问题，导致程序可能无法申请大区块内存。通常来说这种自定制的性能更好&lt;/li&gt;
&lt;li&gt;收集使用上的统计数据：先收集软件如何使用动态内存，包括分配区块的大小分布、寿命分布、分配和释放的次序(FIFO/LIFO/随机)、任何时刻内存分配上限&lt;/li&gt;
&lt;li&gt;增加分配和释放的速度：当定制型分配器专门针对某特定类型的对象设计时，往往比泛用型分配器更快&lt;/li&gt;
&lt;li&gt;降低缺省内存管理器带来的空间额外开销：泛用型内存管理器往往使用更多内存&lt;/li&gt;
&lt;li&gt;弥补缺省分配器中的非最佳对齐：缺省的分配器一般是 4 字节对齐，但是对于 x86 最好是 8 字节对齐&lt;/li&gt;
&lt;li&gt;将相关对象成簇集中：将往往被一起使用某个数据结构放在一起创建，可以减少 page fault 的错误&lt;/li&gt;
&lt;li&gt;获得非传统的行为：比如添加数据初始化工作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;51-写-new-和-delete-时遵循惯例&#34;&gt;51.写 new 和 delete 时遵循惯例&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Adhere to convention when writing new and delete&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;new 操作

&lt;ul&gt;
&lt;li&gt;应该包含一个无穷循环，并在其中尝试分配内存&lt;/li&gt;
&lt;li&gt;如果无法满足需求，调用 new-handler&lt;/li&gt;
&lt;li&gt;也应该可以处理 0 字节申请&lt;/li&gt;
&lt;li&gt;类的自定义版本还应该处理“比正确大小更大的(错误)申请”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;delete 操作

&lt;ul&gt;
&lt;li&gt;收到 null 指针不做任何事&lt;/li&gt;
&lt;li&gt;类的自定义版本还应该处理“比正确大小更大的(错误)申请”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;52-写了-placement-new-也要写-placement-delete&#34;&gt;52.写了 placement new 也要写 placement delete&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Write placement delete if you write placement new&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;如果自己实现一个 placement operator new，也要写出对应的 placement operator delete。否则会发生隐蔽时断时续的内存泄漏&lt;/li&gt;
&lt;li&gt;当声明 placement new 和 placement delete，确定不要无意识地遮掩它们的正常版本&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-杂项讨论&#34;&gt;9.杂项讨论&lt;/h2&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Miscellany&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;53-注意编译器警告&#34;&gt;53.注意编译器警告&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Pay attention to compiler warnings&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;严肃对待编译器发出的警告信息。努力在编译器的最高(最严苛)警告级别下争取“无任何警告”&lt;/li&gt;
&lt;li&gt;不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度不相同。一旦移植到另一个编译器上，原本依赖的警告信息有可能消失&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;54-熟悉包括-tr1-在内的标准库&#34;&gt;54.熟悉包括 TR1 在内的标准库&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Familiarize yourself with the standard library, including TR1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;55-熟悉-boost&#34;&gt;55.熟悉 Boost&lt;/h3&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Familiarize yourself with Boost&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>hash map</title>
      <link>https://xueqing.github.io/blog/cplusplus/hash_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/hash_map/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class hash_map {
  hash_map() {set_load(); v.reserve(max_load*b.size());}
  // 表“太满”(如 75% 满)时性能会恶化
  void set_load(float m=0.7, float g=1.6) {max_load=m; grow=g;}

  // 查找
  mapped_type&amp;amp; operator[] (const key_type&amp;amp; k) {
    // 先计算散列值，查找表索引
    size_type i = hash(k) % b.size();
    // 找到之后遍历散列链匹配
    for(Entry* p=b[i]; p; p=p-&amp;gt;next) {
      if(eq(k, p-&amp;gt;key)) { // 找到则插入表
        if(p-&amp;gt;erased) {
          p-&amp;gt;erased = false;
          no_of_erased--;
          return p-&amp;gt;val = default_value;
        }
        return p-&amp;gt;val;
      }
    }
    // 找不到则插入散列表
    // 若表已经“满”了，增大存储
    if(size_tye(b.size() * max_load) &amp;lt;= v.size()) {
      resize(b.size() * grow);
      return operator[](k);
    }
    // 插入元素
    v.push_back(Entry(k, default_value, b[i]));
    b[i] = &amp;amp;v.back();
    return b[i]-&amp;gt;val;
  }

  // 调整散列表大小
  void resize(size_type s) {
    // 计算 erased 元素数目，同时从存储中删除对应元素
    size_type i = v.size()
    while(no_of_erased) {
      if(v[--i].erased) {
        v.erase(&amp;amp;v[i]);
        --no_of_erased;
      }
    }
    // 如果 b.size() &amp;gt;= s，返回
    if(s &amp;lt;= b.size()) return;
    // 如果 b.size() &amp;lt; s，增大 b，b 全部清 0，重新计算
    b.resize(s);
    fill(b.begin(), b.end(), 0);
    // 重新分配底层存储
    v.reserve(s * max_load);
    // 重新计算元素散列值
    for(size_type i=0; i&amp;lt;v.size(); i++) {
      size_type ii = hash(v[i].key) % b.size();
      v[i].next = b[ii];
      b[ii] = &amp;amp;v[i];
    }
  }

private:
  struct Entry {
    key_type key;
    mapped_type val;
    bool erased;
    Entry* next;          // 散列链
  };
  vector&amp;lt;Entry&amp;gt; v;        // 实际存储
  vector&amp;lt;Entry*&amp;gt; b;       // 散列表，保存实际存储的指针

  float max_load;         // 保持 v.size() &amp;lt;= b.size()*max_load
  float grow;             // 接近太满时自动改变大小 resize(bucket_count() * grow)
  size_type no_of_erased; // erased 元素项的数目
  Hasher hash;            // 散列函数
  key_equal eq;           // 相等判断

  const T default_value;  // entry 默认值
};
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>lambda 表达式</title>
      <link>https://xueqing.github.io/blog/cplusplus/lambda/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/lambda/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%b3%95&#34;&gt;解决方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%94%e5%9b%9e%e7%b1%bb%e5%9e%8b&#34;&gt;返回类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%22%e6%8d%95%e8%8e%b7%22%e5%8f%98%e9%87%8f&#34;&gt;&amp;ldquo;捕获&amp;rdquo;变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-lambda-%e4%bd%9c%e4%b8%ba%e5%8f%98%e9%87%8f&#34;&gt;使用 lambda 作为变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C++ 包含一些有用的通用函数，比如 &lt;code&gt;std::for_each&lt;/code&gt; 和 &lt;code&gt;std::transform&lt;/code&gt;，用起来很方便。但是使用比较复杂，尤其是使用的仿函数(functor)是唯一的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

namespace {
struct f {
    void operator()(int i) {
        std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;
    }
};
}

void func(std::vector&amp;lt;int&amp;gt;&amp;amp; v) {
f f;
std::for_each(v.begin(), v.end(), f);
}

int main()
{
int arr[] = {1,10,9};
std::vector&amp;lt;int&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果只使用上述 &lt;code&gt;f&lt;/code&gt; 一次，看起来写一个完整的类来完成一些微小的事情是过犹不及的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++11 介绍了 lambda，支持写一个内联、匿名仿函数来替换 &lt;code&gt;struct f&lt;/code&gt;。对于简单的例子代码会更易读，且易于维护&lt;/li&gt;

&lt;li&gt;&lt;p&gt;形式定义 &lt;code&gt;[]() {}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;int&amp;gt;&amp;amp; v) {
std::for_each(v.begin(), v.end(), [](int i) {std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; std::endl;});
}

int main()
{
int arr[] = {1,10,9};
std::vector&amp;lt;int&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;返回类型&#34;&gt;返回类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单的例子中，lambda 的返回类型是编译器推断出来的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;double&amp;gt; &amp;amp;v) {
std::transform(v.begin(), v.end(), v.begin(),
               [](double d) {return d &amp;lt; 0.00001 ? 0 : d;}
);
std::for_each(v.begin(), v.end(), [](double d) {std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;});
}

int main()
{
double arr[] = {0.000001,1.0,0.000009};
std::vector&amp;lt;double&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是当实现更加复杂的 lambda 时，会遇到一些情况，编译器不能推断返回类型。此时可以显式地指明lambda 函数的返回值，使用 &lt;code&gt;-&amp;gt; T&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;double&amp;gt; &amp;amp;v) {
std::transform(v.begin(), v.end(), v.begin(),
               [](double d) -&amp;gt; double {
                    if(d &amp;lt; 0.00001)
                        return 0;
                    else
                        return d;
                }
);
std::for_each(v.begin(), v.end(), [](double d) {std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;});
}

int main()
{
double arr[] = {0.000001,1.0,0.000009};
std::vector&amp;lt;double&amp;gt; v(arr,arr+3);
func(v);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;捕获-变量&#34;&gt;&amp;ldquo;捕获&amp;rdquo;变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;也可以使用 lambda 内部的变量。如果想要是有其他变量可以使用捕获语句 &lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

void func(std::vector&amp;lt;double&amp;gt; &amp;amp;v, const double &amp;amp;val) {
std::transform(v.begin(), v.end(), v.begin(),
               [val](double d) -&amp;gt; double {
                    if(d &amp;lt; val)
                        return 0;
                    else
                        return d;
                }
);
std::for_each(v.begin(), v.end(), [](double d) {std::cout &amp;lt;&amp;lt; d &amp;lt;&amp;lt; std::endl;});
}

int main()
{
double arr[] = {0.000001,1.0,0.000009};
std::vector&amp;lt;double&amp;gt; v(arr,arr+3);
double val = 0.000005;
func(v, val);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以捕获引用和值，分别使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;=&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[&amp;amp;val]&lt;/code&gt; 捕获引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;amp;]&lt;/code&gt; 捕获当前范围使用的所有变量的引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[=]&lt;/code&gt; 捕获当前范围使用的所有变量的值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&amp;amp;, val]&lt;/code&gt; 类似于 &lt;code&gt;[&amp;amp;]&lt;/code&gt;，但是 val 捕获值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[=, &amp;amp;val]&lt;/code&gt; 类似于 &lt;code&gt;[=]&lt;/code&gt;，但是 val 捕获引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;生成的操作符 &lt;code&gt;()&lt;/code&gt; 默认是 &lt;code&gt;const&lt;/code&gt;，捕获默认也是 &lt;code&gt;const&lt;/code&gt;，使得每次相同的输入产生相同的结果&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;[]() mutable -&amp;gt; T {}&lt;/code&gt;，允许改变以值捕获的值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用-lambda-作为变量&#34;&gt;使用 lambda 作为变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用 &lt;code&gt;functional&lt;/code&gt; 头文件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::function&amp;lt;double(int, bool)&amp;gt; f = [](int a, bool b) -&amp;gt; double {//...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通常可让编译器推断类型 &lt;code&gt;auto f = [](int a, bool b) -&amp;gt; double {//...}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11&#34; target=&#34;_blank&#34;&gt;What is a lambda expression in C++11?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>RAII 资源获取即初始化</title>
      <link>https://xueqing.github.io/blog/cplusplus/raii/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/raii/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-raii&#34;&gt;使用 RAII&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%8b%e5%ad%90&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e5%87%86%e5%ba%93&#34;&gt;标准库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e8%a7%a3&#34;&gt;注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;p&gt;资源获取即初始化（Resource Acquisition Is Initialization），或称 RAII，是一种 C++ 编程技术，它将必须在使用前请求的资源（分配的堆内存、执行线程、打开的套接字、打开的文件、锁定的互斥体、磁盘空间、数据库连接等——任何存在受限供给中的事物）的生命周期绑定与一个对象的生存期相绑定。&lt;/p&gt;

&lt;h2 id=&#34;使用-raii&#34;&gt;使用 RAII&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RAII 保证资源可用于任何会访问该对象的函数（资源可用性是一种&lt;a href=&#34;https://en.wikipedia.org/wiki/Class_invariant&#34; target=&#34;_blank&#34;&gt;类不变式&lt;/a&gt;，这会消除冗余的运行时测试）。它亦保证所有资源在其控制对象的生存期结束时，以获取顺序的逆序释放。类似地，若资源获取失败（构造函数以异常退出），则为已构造完成的对象和基类子对象所获取的所有资源，会以初始化顺序的逆序释放。这有效地利用了语言特性（对象生存期、退出作用域、初始化顺序以及栈回溯）以消除内存泄漏并保证异常安全。根据 RAII 对象的生存期在退出作用域时结束这一基本状况，此技术的另一名称是作用域界定的资源管理（ Scope-Bound Resource Management，SBRM）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RAII 可总结如下:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;将每个资源封装入一个类，其中&lt;/li&gt;
&lt;li&gt;构造函数请求资源，并建立所有类不变式，或在它无法完成时抛出异常&lt;/li&gt;
&lt;li&gt;析构函数释放资源并决不抛出异常&lt;/li&gt;
&lt;li&gt;始终经由 RAII 类的实例使用满足要求的资源，该资源&lt;/li&gt;
&lt;li&gt;自身拥有自动存储期或临时生存期，或&lt;/li&gt;
&lt;li&gt;具有与自动或临时对象的生存期绑定的生存期&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动语义使得在对象间、跨作用域，以及在线程内外安全地移动所有权，而同时维护资源安全成为可能。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;

&lt;p&gt;拥有 open()/close()、lock()/unlock()，或 init()/copyFrom()/destroy() 成员函数的类是非 RAII 类的典型的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::mutex m;

void bad()
{
    m.lock();                    // 请求互斥体
    f();                         // 若 f() 抛异常，则互斥体永远不被释放
    if(!everything_ok()) return; // 提早返回，互斥体永远不被释放
    m.unlock();                  // 若 bad() 抵达此语句，互斥才被释放
}

void good()
{
    std::lock_guard&amp;lt;std::mutex&amp;gt; lk(m); // RAII类：互斥体的请求即是初始化
    f();                               // 若 f() 抛异常，则释放互斥体
    if(!everything_ok()) return;       // 提早返回，互斥体被释放
}                                      // 若 good() 正常返回，则释放互斥体
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标准库&#34;&gt;标准库&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++ 标准库遵循 RAII 管理其自身的资源：&lt;code&gt;std::string&lt;/code&gt;、&lt;code&gt;std::vector&lt;/code&gt;、&lt;code&gt;std::thread&lt;/code&gt;，以及多数其他类在构造函数中获取其资源（错误时抛出异常），并在其析构函数中释放之（决不抛出），而不要求显式清理。&lt;/li&gt;
&lt;li&gt;另外，标准库提供几种 RAII 包装器以管理用户提供的资源：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;std::unique_ptr&lt;/code&gt; 及 &lt;code&gt;std::shared_ptr&lt;/code&gt; 用于管理动态分配的内存，或以用户提供的删除器管理任何以普通指针表示的资源&lt;/li&gt;
&lt;li&gt;&lt;code&gt;std::lock_guard&lt;/code&gt;、&lt;code&gt;std::unique_lock&lt;/code&gt;、&lt;code&gt;std::shared_lock&lt;/code&gt; 用于管理互斥体&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;注解&#34;&gt;注解&lt;/h2&gt;

&lt;p&gt;RAII 不适用于并非在使用前请求的资源：CPU 时间、核心，以及缓存容量、熵池容量、网络带宽、电力消费、栈内存等。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.cppreference.com/w/cpp/language/raii&#34; target=&#34;_blank&#34;&gt;RAII&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sizeof vs strlen</title>
      <link>https://xueqing.github.io/blog/cplusplus/sizeof_strlen/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/sizeof_strlen/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#sizeof&#34;&gt;sizeof&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#strlen&#34;&gt;strlen&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;sizeof&#34;&gt;sizeof&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;sizeof 是编译时一元运算符，可用于计算运算元的大小&lt;/li&gt;
&lt;li&gt;sizeof 作用于 unsigned int 时，结果一般表示为 size_t&lt;/li&gt;
&lt;li&gt;sizeof 可用于任何数据类型，包括基本类型(比如整型、浮点型、指针类型)或符合数据类型(比如结构体、联合体等)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;sizeof 计算结构体的大小时，并不一定等于结构体每个成员 sizeof 计算结果之和&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原因：编译器因为对齐问题会给结构体增加填充。不同编译器的对齐约束可能不同，所以填充大小也不确定。当结构体的一个成员之和有一个更大的成员，或者在结构体最后时，前者可能会被填充&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C 编译器不允许编译器重排结构体的成员来减小填充。为了最下滑填充，结构体的成员必须按照从大到小的顺序排列&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
struct A {
int x;      //sizeof(int)=4, Padding of 4 bytes
double z;   //sizeof(double)=8
short int y;//sizeof(short int)=2, Padding of 6 bytes
};
printf(&amp;quot;Size of struct: %d&amp;quot;, sizeof(struct A));//24

struct B {
double z;   //sizeof(double)=8
int x;      //sizeof(int)=4
short int y;//sizeof(short int)=2, Padding of 2 bytes
};
printf(&amp;quot;Size of struct: %d&amp;quot;, sizeof(struct B));//16

struct C {
double z;   //sizeof(double)=8
short int y;//sizeof(short int)=2, Padding of 2 bytes
int x;      //sizeof(int)=4
};
printf(&amp;quot;Size of struct: %d&amp;quot;, sizeof(struct C));//16

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;strlen&#34;&gt;strlen&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;strlen 是 C 语言预定义的函数，包含在头文件 &lt;code&gt;string.h&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;strlen 接受指向数组的指针作为参数，并在运行时从该地址开始遍历查找 &lt;code&gt;NULL&lt;/code&gt; 字符，然后计算在找到 &lt;code&gt;NULL&lt;/code&gt; 字符钱经过的内存大小&lt;/li&gt;

&lt;li&gt;&lt;p&gt;strlen 的主要用于计算一个数组或字符串的长度&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
  
int main()
{
char ch[]={&#39;g&#39;, &#39;e&#39;, &#39;e&#39;, &#39;k&#39;, &#39;s&#39;, &#39;\0&#39;};
printf(&amp;quot;Length of string is: %d&amp;quot;, strlen(ch));//5

char str[]= &amp;quot;geeks&amp;quot;;
printf(&amp;quot;Length of string is: %d&amp;quot;, strlen(str));//5

char *str1 = &amp;quot;geeks&amp;quot;;
printf(&amp;quot;Length of string is: %d&amp;quot;, strlen(str1));//5
  
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;差异&lt;/th&gt;
&lt;th&gt;sizeof&lt;/th&gt;
&lt;th&gt;strlen&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;原型&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;&lt;code&gt;size_t strlen(const char * str);&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;一元运算符&lt;/td&gt;
&lt;td&gt;C 预定义的函数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;支持的数据类型&lt;/td&gt;
&lt;td&gt;返回任何数据(分配的)的实际大小，单位是 Byte，包含 null 值&lt;/td&gt;
&lt;td&gt;返回字符串或字符数组的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;计算大小&lt;/td&gt;
&lt;td&gt;sizeof 是编译时表达式，返回一个类型或变量的大小，并不关心变量的值&lt;/td&gt;
&lt;td&gt;strlen 是运行时计算，返回一个 C 风格的以 NULL 结尾的字符串的长度&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;C++ 中&lt;/td&gt;
&lt;td&gt;sizeof 常用作 &lt;code&gt;malloc/memcpy/memset&lt;/code&gt; 的参数，C++ 可用 &lt;code&gt;new/std::copy/std::fill&lt;/code&gt; 或构造函数替换&lt;/td&gt;
&lt;td&gt;C 风格的字符串使用 &lt;code&gt;char_traits::length&lt;/code&gt; 获取长度，也可用 &lt;code&gt;std::string&lt;/code&gt; 类型保存计算&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int main()
{
    char str[] = &amp;quot;November&amp;quot;;
    printf(&amp;quot;Length of String is %d\n&amp;quot;, strlen(str));//8
    printf(&amp;quot;Size of String is %d\n&amp;quot;, sizeof(str));//9
}

// 字符串以 NULL 字符，即 &#39;\0&#39; 结束，strlen 计算找到 NULL 字符经过的内存大小，不会计算 NULL。而 sizeof 返回为运算元实际分配的内存，也会计算 NULL
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string.h&amp;gt;
using namespace std;
  
int main()
{
    char a[] = {&amp;quot;Geeks for&amp;quot;};
    char b[] = {&#39;G&#39;,&#39;e&#39;,&#39;e&#39;,&#39;k&#39;,&#39;s&#39;,&#39; &#39;,&#39;f&#39;,&#39;o&#39;,&#39;r&#39;};
    cout &amp;lt;&amp;lt; &amp;quot;sizeof(a) = &amp;quot; &amp;lt;&amp;lt; sizeof(a);//10
    cout &amp;lt;&amp;lt; &amp;quot;\nstrlen(a) = &amp;quot;&amp;lt;&amp;lt; strlen(a);//9
    cout&amp;lt;&amp;lt;  &amp;quot;\nsizeof(b) = &amp;quot; &amp;lt;&amp;lt; sizeof(b);//9
    cout&amp;lt;&amp;lt;  &amp;quot;\nstrlen(b) = &amp;quot; &amp;lt;&amp;lt; strlen(b);//18，不确定

    return 0;
}
// strlen 找不到 NULL 字符，返回结果是不确定的
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/difference-strlen-sizeof-string-c-reviewed/&#34; target=&#34;_blank&#34;&gt;Difference between strlen() and sizeof() for string in C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/9937181/sizeof-vs-strlen&#34; target=&#34;_blank&#34;&gt;Sizeof vs Strlen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>STL</title>
      <link>https://xueqing.github.io/blog/cplusplus/stl/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/stl/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ae%97%e6%b3%95&#34;&gt;算法&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%b4%e6%96%87%e4%bb%b6-algorithm&#34;&gt;头文件 algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%92%e5%ba%8f&#34;&gt;排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%90%9c%e7%b4%a2&#34;&gt;搜索&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%87%8d%e8%a6%81%e7%9a%84-stl-%e7%ae%97%e6%b3%95&#34;&gt;重要的 STL 算法&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%aa%e5%8a%a0%e5%b7%a5%e7%ae%97%e6%b3%95&#34;&gt;未加工算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8a%a0%e5%b7%a5%e7%ae%97%e6%b3%95&#34;&gt;加工算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%89%e7%94%a8%e7%9a%84-array-%e7%ae%97%e6%b3%95&#34;&gt;有用的 Array 算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%92%e5%88%86%e6%93%8d%e4%bd%9c&#34;&gt;划分操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%b4%e6%96%87%e4%bb%b6-valarray&#34;&gt;头文件 valarray&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%b9%e5%99%a8&#34;&gt;容器&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%a1%ba%e5%ba%8f%e5%ae%b9%e5%99%a8&#34;&gt;顺序容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#array&#34;&gt;array&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vector&#34;&gt;vector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#deque&#34;&gt;deque&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#forwardlist&#34;&gt;forward_list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#list&#34;&gt;list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%b9%e5%99%a8%e9%80%82%e9%85%8d%e5%99%a8&#34;&gt;容器适配器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stack&#34;&gt;stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#queue&#34;&gt;queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#priorityqueue&#34;&gt;priority_queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e8%81%94%e5%ae%b9%e5%99%a8&#34;&gt;关联容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#set&#34;&gt;set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multiset&#34;&gt;multiset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#map&#34;&gt;map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#multimap&#34;&gt;multimap&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%97%a0%e5%ba%8f%e5%85%b3%e8%81%94%e5%ae%b9%e5%99%a8&#34;&gt;无序关联容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedset&#34;&gt;unordered_set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedmultiset&#34;&gt;unordered_multiset&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedmap&#34;&gt;unordered_map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unorderedmultimap&#34;&gt;unordered_multimap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%bf%e5%87%bd%e6%95%b0&#34;&gt;仿函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%ad%e4%bb%a3%e5%99%a8&#34;&gt;迭代器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;STL(Standard Template Library，标准模板库)是 C++ 模板类集合，提供了统一的编程书籍结构和函数。&lt;/li&gt;
&lt;li&gt;STL 是容器类、算法和迭代器的库，是一个通用的库，组件都是参数化的。&lt;/li&gt;
&lt;li&gt;STL 有 4 个组件：算法、容器、函数和迭代器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;定义了 STL 的基础性的算法(均为函数模板)，用于给定范围的元素。 C++98 中有 70 个算法模板函数，C++11 增加了 20 个算法模板函数，其中有 5 个定义在 &lt;code&gt;numeric&lt;/code&gt; 头文件，其他定义在 &lt;code&gt;algorithm&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;numeric&lt;/code&gt; 头文件包含的算法模板函数

&lt;ul&gt;
&lt;li&gt;accumulate：累加序列值&lt;/li&gt;
&lt;li&gt;adjacent_difference：计算相邻两项的差值&lt;/li&gt;
&lt;li&gt;inner_product：计算输入序列的内积&lt;/li&gt;
&lt;li&gt;partial_sum：计算序列的部分累加值&lt;/li&gt;
&lt;li&gt;iota：保存增加的连续值序列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;头文件-algorithm&#34;&gt;头文件 algorithm&lt;/h3&gt;

&lt;h4 id=&#34;排序&#34;&gt;排序&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;函数原型：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator&amp;gt;  void sort (RandomAccessIterator first, RandomAccessIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator, class Compare&amp;gt;  void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;底层使用快排实现。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;算法复杂度： O(N*lgN)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;algorithm&amp;gt;

using namespace std;

void show(int a[])
{
for(int i=0; i&amp;lt;10; ++i)
    cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
cout &amp;lt;&amp;lt; endl;
}

int main()
{
int a[10]={1, 5, 8, 9, 6, 7, 3, 4, 2, 0};

cout &amp;lt;&amp;lt; &amp;quot;\n The array before sorting is : &amp;quot;;
show(a);

sort(a,a+10);

cout &amp;lt;&amp;lt; &amp;quot;\n The array after sorting is : &amp;quot;;
show(a);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;搜索&#34;&gt;搜索&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;广泛使用的搜索算法是二分搜索，前提是数组已经排好序。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数原型：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt;  bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

void show(int a[], int arraysize)
{
for(int i=0; i&amp;lt;arraysize; ++i)
cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
cout &amp;lt;&amp;lt; endl;
}

int main()
{
int a[] = { 1, 5, 8, 9, 6, 7, 3, 4, 2, 0 };
int asize = sizeof(a) / sizeof(a[0]);
cout &amp;lt;&amp;lt; &amp;quot;The array is : &amp;quot;;
show(a, asize);

cout &amp;lt;&amp;lt; &amp;quot;Let&#39;s say we want to search for 2 in the array&amp;quot; &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;So, we first sort the array&amp;quot; &amp;lt;&amp;lt; endl;
sort(a, a + asize);
cout &amp;lt;&amp;lt; &amp;quot;The array after sorting is : &amp;quot;;
show(a, asize);

cout &amp;lt;&amp;lt; &amp;quot;Now, we do the binary search for 2&amp;quot; &amp;lt;&amp;lt; endl;
if(binary_search(a, a + 10, 2))
cout &amp;lt;&amp;lt; &amp;quot;Element found in the array&amp;quot; &amp;lt;&amp;lt; endl;
else
cout &amp;lt;&amp;lt; &amp;quot;Element not found in the array&amp;quot; &amp;lt;&amp;lt; endl;

cout &amp;lt;&amp;lt; &amp;quot;Now, say we want to search for 10&amp;quot; &amp;lt;&amp;lt; endl;
if(binary_search(a, a + 10, 10))
cout &amp;lt;&amp;lt; &amp;quot;Element found in the array&amp;quot; &amp;lt;&amp;lt; endl;
else
cout &amp;lt;&amp;lt; &amp;quot;Element not found in the array&amp;quot; &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;重要的-stl-算法&#34;&gt;重要的 STL 算法&lt;/h4&gt;

&lt;h5 id=&#34;未加工算法&#34;&gt;未加工算法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;排序

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator&amp;gt; void sort (RandomAccessIterator first, RandomAccessIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class RandomAccessIterator, class Compare&amp;gt; void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;逆序

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator&amp;gt; void reverse (BidirectionalIterator first, BidirectionalIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回序列中最大值的迭代器

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator&amp;gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class Compare&amp;gt; ForwardIterator max_element (ForwardIterator first, ForwardIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回序列中最小值的迭代器

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator&amp;gt; ForwardIterator min_element (ForwardIterator first, ForwardIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class Compare&amp;gt; ForwardIterator min_element (ForwardIterator first, ForwardIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算序列元素的累加值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T&amp;gt; T accumulate (InputIterator first, InputIterator last, T init);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T, class BinaryOperation&amp;gt; T accumulate (InputIterator first, InputIterator last, T init, BinaryOperation binary_op);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;numeric&amp;gt; //For accumulate operation

using namespace std;

int main()
{
int arr[] = {10, 20, 5, 23 ,42 , 15};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
cout &amp;lt;&amp;lt; &amp;quot;Vector is: &amp;quot;;
for(int i=0; i&amp;lt;n; i++) cout &amp;lt;&amp;lt; vect[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;

sort(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after sorting is: &amp;quot;;
for(int i=0; i&amp;lt;n; i++) cout &amp;lt;&amp;lt; vect[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;

reverse(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after reversing is: &amp;quot;;
for(int i=0; i&amp;lt;6; i++) cout &amp;lt;&amp;lt; vect[i] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;

cout &amp;lt;&amp;lt; &amp;quot;\nMaximum element of vector is: &amp;quot;;
cout &amp;lt;&amp;lt; *max_element(vect.begin(), vect.end());

cout &amp;lt;&amp;lt; &amp;quot;\nMinimum element of vector is: &amp;quot;;
cout &amp;lt;&amp;lt; *min_element(vect.begin(), vect.end());

cout &amp;lt;&amp;lt; &amp;quot;\nThe summation of vector elements is: &amp;quot;;
cout &amp;lt;&amp;lt; accumulate(vect.begin(), vect.end(), 0);
cout&amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算给定元素出现的次数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T&amp;gt; typename iterator_traits&amp;lt;InputIterator&amp;gt;::difference_type count (InputIterator first, InputIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回指向第一个等于给定元素的指针&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class InputIterator, class T&amp;gt; InputIterator find (InputIterator first, InputIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {10, 20, 5, 23 ,42, 20, 15};
int n = sizeof(arr)/sizeof(arr[0]);
vector&amp;lt;int&amp;gt; vect(arr, arr+n);

cout &amp;lt;&amp;lt; &amp;quot;Occurrences of 20 in vector : &amp;quot;;
cout &amp;lt;&amp;lt; count(vect.begin(), vect.end(), 20) &amp;lt;&amp;lt; endl;

find(vect.begin(), vect.end(), 5) != vect.end()?
cout &amp;lt;&amp;lt; &amp;quot;Element 5 found\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;Element 5 not found\n&amp;quot;;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;二分查找指定元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; bool binary_search (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回指向第一个不小于指定元素的迭代器(序列有序)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回指向第一个大于指定元素的迭代器(序列有序)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T, class Compare&amp;gt; ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T&amp;amp; val, Compare comp);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
sort(vect.begin(), vect.end());
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

auto q = lower_bound(vect.begin(), vect.end(), 20);
cout &amp;lt;&amp;lt; &amp;quot;The lower bound for 20 is at position: &amp;quot;;
cout &amp;lt;&amp;lt; q-vect.begin() &amp;lt;&amp;lt; endl;

auto p = upper_bound(vect.begin(), vect.end(), 20);
cout &amp;lt;&amp;lt; &amp;quot;The upper bound for 20 is at position: &amp;quot;;
cout &amp;lt;&amp;lt; p-vect.begin() &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;加工算法&#34;&gt;加工算法&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过滤连续相等的元素&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator&amp;gt; ForwardIterator unique (ForwardIterator first, ForwardIterator last);&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class BinaryPredicate&amp;gt; ForwardIterator unique (ForwardIterator first, ForwardIterator last, BinaryPredicate pred);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vect.erase(vect.begin()+1);
cout &amp;lt;&amp;lt; &amp;quot;\nVector after erasing the second element: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

sort(vect.begin(), vect.end());

cout &amp;lt;&amp;lt; &amp;quot;\nVector before removing duplicate occurrences: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vect.erase(unique(vect.begin(),vect.end()),vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after deleting duplicates: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回下一个置换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator&amp;gt; bool next_permutation (BidirectionalIterator first, BidirectionalIterator last);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator, class Compare&amp;gt; bool next_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;返回前一个置换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator&amp;gt; bool prev_permutation (BidirectionalIterator first, BidirectionalIterator last );&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator, class Compare&amp;gt; bool prev_permutation (BidirectionalIterator first, BidirectionalIterator last, Compare comp);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);

vector&amp;lt;int&amp;gt; vect(arr, arr+n);
cout &amp;lt;&amp;lt; &amp;quot;Given Vector is: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

next_permutation(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after performing next permutation: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

prev_permutation(vect.begin(), vect.end());
cout &amp;lt;&amp;lt; &amp;quot;\nVector after performing prev permutation: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;计算迭代器之间的距离。用于查找下标&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;包含在头文件 &lt;code&gt;iterator&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;template&amp;lt;class InputIterator&amp;gt; typename iterator_traits&amp;lt;InputIterator&amp;gt;::difference_type distance (InputIterator first, InputIterator last);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;

using namespace std;

int main()
{
int arr[] = {5, 10, 15, 20, 20, 23, 42, 45};
int n = sizeof(arr)/sizeof(arr[0]);
vector&amp;lt;int&amp;gt; vect(arr, arr+n);

cout &amp;lt;&amp;lt; &amp;quot;Given Vector is: &amp;quot;;
for_each(vect.begin(), vect.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nDistance between first to max element: &amp;quot; &amp;lt;&amp;lt; distance(vect.begin(), max_element(vect.begin(), vect.end())) &amp;lt;&amp;lt; endl;
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;有用的-array-算法&#34;&gt;有用的 Array 算法&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;以下算法在 C++11 开始支持&lt;/li&gt;
&lt;li&gt;测试序列是否都满足某个条件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool all_of (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测试序列是否存在一个元素满足某个条件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool any_of (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测试序列是否都不满足某个条件

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool none_of (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拷贝序列元素

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class Size, class OutputIterator&amp;gt; OutputIterator copy_n (InputIterator first, Size n, OutputIterator result);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;存储增加的序列&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class T&amp;gt; void iota (ForwardIterator first, ForwardIterator last, T val);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;numeric&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
int arr1[] = {1, 2, 3, 4, 5, -6};
all_of(arr1, arr1+6, [](int x) {return x&amp;gt;0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;All are positive elments\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;Not all are positive elments\n&amp;quot;;
any_of(arr1, arr1+6, [](int x) {return x&amp;lt;0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;There exists a negative element\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;All are positive elments\n&amp;quot;;

int arr2[] = {1, 2, 3, 4, 5, 6};
none_of(arr2, arr2+6, [](int x) {return x&amp;lt;0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;No negative elements\n&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;There exists a negative element\n&amp;quot;;

int arrc[6];
copy_n(arr2, 6, arrc);
cout &amp;lt;&amp;lt; &amp;quot;Copyed array: &amp;quot;;
for_each(arrc, arrc+6, [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

int arr3[6] = {0};
iota(arr3, arr3+6, 20);
cout &amp;lt;&amp;lt; &amp;quot;Assigned array: &amp;quot;;
for_each(arr3, arr3+6, [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;划分操作&#34;&gt;划分操作&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;根据条件重排序列，返回第一个不满足条件的迭代器

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class UnaryPredicate&amp;gt; ForwardIterator partition (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据条件重排序列，且两组元素内部的相对顺序保持不变。一般是用临时缓冲区实现

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class BidirectionalIterator, class UnaryPredicate&amp;gt; BidirectionalIterator stable_partition (BidirectionalIterator first, BidirectionalIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;判断序列是否是根据条件划分的

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class InputIterator, class UnaryPredicate&amp;gt; bool is_partitioned (InputIterator first, InputIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输入队列已经是分割过的，二分查找分界点

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;template &amp;lt;class ForwardIterator, class UnaryPredicate&amp;gt; ForwardIterator partition_point (ForwardIterator first, ForwardIterator last, UnaryPredicate pred);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输入序列中满足条件和不满足条件的分别拷贝到两个序列中&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;template &amp;lt;class InputIterator, class OutputIterator1, class OutputIterator2, class UnaryPredicate pred&amp;gt; pair&amp;lt;OutputIterator1,OutputIterator2&amp;gt; partition_copy (InputIterator first, InputIterator last, OutputIterator1 result_true, OutputIterator2 result_false, UnaryPredicate pred);&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
vector&amp;lt;int&amp;gt; vect1 = { 2, 1, 5, 6, 8, 7 };

cout &amp;lt;&amp;lt; &amp;quot;The vector is: &amp;quot;;
for_each(vect1.begin(), vect1.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

is_partitioned(vect1.begin(), vect1.end(), [](int i) {return i%2==0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;\nVector is partitioned&amp;quot; : cout &amp;lt;&amp;lt; &amp;quot;\nVector is not partitioned&amp;quot;;

partition(vect1.begin(), vect1.end(), [](int i){return i%2==0;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe partitioned vector is: &amp;quot;;
for_each(vect1.begin(), vect1.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

is_partitioned(vect1.begin(), vect1.end(), [](int i) {return i%2==0;}) ?
        cout &amp;lt;&amp;lt; &amp;quot;\nNow, vector is partitioned after partition operation&amp;quot;:
                cout &amp;lt;&amp;lt; &amp;quot;\nVector is still not partitioned after partition operation&amp;quot;;

vector&amp;lt;int&amp;gt; vect2 = { 2, 1, 5, 6, 8, 7 };
cout &amp;lt;&amp;lt; &amp;quot;\n\nThe vector is: &amp;quot;;
for_each(vect2.begin(), vect2.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

stable_partition(vect2.begin(), vect2.end(), [](int i) {return i%2==0;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe stable partitioned vector is: &amp;quot;;
for_each(vect2.begin(), vect2.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

auto it = partition_point(vect2.begin(), vect2.end(), [](int i) {return i%2==0;});
cout &amp;lt;&amp;lt; &amp;quot;\nBefore the partition point: &amp;quot;;
for_each(vect2.begin(), it, [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nAfter the partition point: &amp;quot;;
for_each(it, vect2.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vector&amp;lt;int&amp;gt; vect3 = { 2, 1, 5, 6, 8, 7 };
cout &amp;lt;&amp;lt; &amp;quot;\n\nThe vector is: &amp;quot;;
for_each(vect3.begin(), vect3.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

vector&amp;lt;int&amp;gt; vecteven, vectodd;
int n = count_if(vect3.begin(), vect3.end(), [](int i) {return i%2==0;});
vecteven.resize(n);
vectodd.resize(vect3.size()-n);

partition_copy(vect3.begin(), vect3.end(), vecteven.begin(),
           vectodd.begin(), [](int i) {return i%2==0;});

cout &amp;lt;&amp;lt; &amp;quot;\nThe elements that return true for condition are : &amp;quot;;
for_each(vecteven.begin(), vecteven.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe elements that return false for condition are : &amp;quot;;
for_each(vectodd.begin(), vectodd.end(), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;头文件-valarray&#34;&gt;头文件 valarray&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;valarray 类：C++98 引入的特殊容器，用于保存和提供对 array 的高效算术操作&lt;/li&gt;
&lt;li&gt;应用操作到所有的元素，返回一个新的 valarray

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;valarray apply (T func(T)) const;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;valarray apply (T func(const T&amp;amp;)) const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回所有元素的和

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T sum() const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回元素的最小值

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T min() const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回元素的最大值

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T max() const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将 valarray 的元素移位，返回新的 valarray。如果参数为正数，左移；否则右移

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;valarray shift (int n) const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;将 valarray 的元素循环移位，返回新的 valarray。如果参数为正数，循环左移；否则循环右移

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;valarray cshift (int n) const;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和另外一个 valarray 交换&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;void swap (valarray&amp;amp; x) noexcept;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;valarray&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

int main()
{
valarray&amp;lt;int&amp;gt; varr1 = { 10, 2, 20, 1, 30 };
cout &amp;lt;&amp;lt; &amp;quot;The varr1 is: &amp;quot;;
for_each(begin(varr1), end(varr1), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe sum of varr1 is: &amp;quot; &amp;lt;&amp;lt; varr1.sum();
cout &amp;lt;&amp;lt; &amp;quot;\nThe max of varr1 is: &amp;quot; &amp;lt;&amp;lt; varr1.max();
cout &amp;lt;&amp;lt; &amp;quot;\nThe min of varr1 is: &amp;quot; &amp;lt;&amp;lt; varr1.min();

valarray&amp;lt;int&amp;gt; varr2;
varr2 = varr1.apply([](int i){return i=i+5;});
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr2 (varr1 add 5 for each element) is: &amp;quot;;
for_each(begin(varr2), end(varr2), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

valarray&amp;lt;int&amp;gt; varr3;
varr3 = varr1.shift(2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 shift 2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr3 = varr1.shift(-2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 shift -2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr3 = varr1.cshift(2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 cshift 2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr3 = varr1.cshift(-2);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr3 (varr1 cshift -2) is: &amp;quot;;
for_each(begin(varr3), end(varr3), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

valarray&amp;lt;int&amp;gt; varr4 = {2, 4, 6, 8};
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr4 is: &amp;quot;;
for_each(begin(varr4), end(varr4), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

varr1.swap(varr4);
cout &amp;lt;&amp;lt; &amp;quot;\nThe varr4 after swap with varr1 is: &amp;quot;;
for_each(begin(varr4), end(varr4), [](int i) {cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot;;});

cout &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;容器&#34;&gt;容器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;容器是一个对象，保存了其他对象或对象元素的集合&lt;/li&gt;
&lt;li&gt;容器自己管理元素的存储空间，并且提供成员函数来访问元素，直接访问或通过迭代器访问&lt;/li&gt;
&lt;li&gt;容器类模板：包括顺序容器、容器适配器、关联容器和无序关联容器&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;顺序容器&#34;&gt;顺序容器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;实现的数据结构可以按顺序访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;array&#34;&gt;array&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;C++11 引入，替换 C 风格数组。相比 C 风格数组的优点包括

&lt;ul&gt;
&lt;li&gt;array 知道自己的大小，因此传递参数时不需要单独传递 array 的大小&lt;/li&gt;
&lt;li&gt;C 风格的数组会有退化成指针的风险，但是 array 不会&lt;/li&gt;
&lt;li&gt;相比 C 风格数组，array 更加高效、轻量和可靠&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;at&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get&lt;/code&gt;：不是 array 的类成员函数，而是重载 tuple 类的函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;: 类似于 C 风格的数组访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;front/back&lt;/code&gt;：返回第一个/最后一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size/max_size&lt;/code&gt;：返回 array 的元素数目/可以承载的最大元素数目。二者返回值相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;swap&lt;/code&gt;：和另外一个 array 交换元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;empty&lt;/code&gt;：array 的大小是否是 0&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fill&lt;/code&gt;：使用指定值填充正哥 array&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;固定大小数组，顺序连续存储，可使用偏移量访问&lt;/li&gt;
&lt;li&gt;大小为 0 是有效的，但是不能间接引用，比如 front，back，data&lt;/li&gt;
&lt;li&gt;交换是按顺序交换每个元素，效率低&lt;/li&gt;
&lt;li&gt;可以当做 tuple（可以存储不同类型的元素的集合），重载了 get 接口等&lt;/li&gt;
&lt;li&gt;访问快，可使用偏移量访问，常数时间&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;vector&#34;&gt;vector&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;大小可变数组，顺序连续存储，可使用偏移量访问&lt;/li&gt;
&lt;li&gt;一开始分配额外的存储空间，容量一般不等于实际大小&lt;/li&gt;
&lt;li&gt;使用动态分配数组存储元素，插入元素时可能需要重新分配数组，将所有元素移到新的数组，效率低&lt;/li&gt;
&lt;li&gt;访问快，和 array 一样，在尾部插入和删除也快。删除元素是常数时间，不会重新调整大小&lt;/li&gt;
&lt;li&gt;在其他位置插入和删除低效，需要线性时间。没有随机访问迭代器&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;deque&#34;&gt;deque&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;双端队列，顺序存储，可在两端增加或减小大小&lt;/li&gt;
&lt;li&gt;可用随机访问迭代器直接访问单个元素&lt;/li&gt;
&lt;li&gt;vs vector

&lt;ul&gt;
&lt;li&gt;存储可以是不连续的块，在容器增加或减小时内存分配效率更高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;forward-list&#34;&gt;forward_list&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;C++11 引入&lt;/li&gt;
&lt;li&gt;顺序存储，在任意位置插入和删除都是常数时间&lt;/li&gt;
&lt;li&gt;单向链表，存储位置可以是不同的没有关系的&lt;/li&gt;
&lt;li&gt;vs array/vector/deque

&lt;ul&gt;
&lt;li&gt;list 和 forward_list 的插入、删除更有效，对于排序算法也更快（交换更快）&lt;/li&gt;
&lt;li&gt;list 和 forward_list 没有根据位置直接访问元素的方法，同时每个节点需要额外的存储存储链接的相关信息&lt;/li&gt;
&lt;li&gt;list 和 forward_list 遍历较慢&lt;/li&gt;
&lt;li&gt;list 和 forward_list 没有 size 方法，因为很耗时，可以使用 distance 算法（包含在头文件&lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;）计算 begin 和 end 之间的距离，消耗时间是线性的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;list&#34;&gt;list&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;双向链表&lt;/li&gt;
&lt;li&gt;forward_list vs list： 前者只存储一个指向后面对象的链接，后者存储两个链接分别指向前一个和后一个对象，因此两个方向的迭代都比较搞笑，但同时每个节点需要额外的存储，且插入和删除也有额外的时间负载&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;容器适配器&#34;&gt;容器适配器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不完全是容器类，而是依赖某一个容器类提供特定的接口，封装之后提供不同于顺序容器的接口&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;stack&#34;&gt;stack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;后进先出（LIFO），使用标准的容器（vector/deque/list）类模板实现接口，如果初始化未指定容器类，则使用 deque 实现相关接口&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;std::stack&amp;lt;int, std::vector&amp;lt;int&amp;gt; &amp;gt; mystack&lt;/code&gt;使用 vector 实现的空的 stack&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;queue&#34;&gt;queue&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;先进先出（FIFO）队列，使用标准的容器（deque/list）类模板实现接口，默认使用 deque&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;std::queue&amp;lt;int, std::list&amp;lt;int&amp;gt; &amp;gt; myqueue&lt;/code&gt;使用 list 实现的空的 queue&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;priority-queue&#34;&gt;priority_queue&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;依据严格的弱排序（strict weak ordering）标准第一个元素总是最大的元素，所有元素是非增序的&lt;/li&gt;
&lt;li&gt;使用标准的容器（vector/deque）类模板实现接口，，默认是 vector&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ 默认为 priority_queue 创建最大堆&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

void showpq(priority_queue&amp;lt;int&amp;gt; &amp;amp;gq)
{
priority_queue&amp;lt;int&amp;gt; g = gq;
while (!g.empty())
{
    cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; g.top();
    g.pop();
}
cout &amp;lt;&amp;lt; endl;
}

int main ()
{
priority_queue&amp;lt;int&amp;gt; gquiz;
gquiz.push(10);
gquiz.push(30);
gquiz.push(20);
gquiz.push(5);
gquiz.push(1);

cout &amp;lt;&amp;lt; &amp;quot;The priority queue gquiz is: &amp;quot;;
showpq(gquiz);

cout &amp;lt;&amp;lt; &amp;quot;gquiz.size(): &amp;quot; &amp;lt;&amp;lt; gquiz.size() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;gquiz.top(): &amp;quot; &amp;lt;&amp;lt; gquiz.top() &amp;lt;&amp;lt; endl;

gquiz.pop();
cout &amp;lt;&amp;lt; &amp;quot;after gquiz.pop(): &amp;quot;;
showpq(gquiz);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为 priority_queue 创建最小堆 &lt;code&gt;priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; g=gq;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;下面的语法难记，因此对于数字的值，可以给每个元素乘以 -1，然后使用最大值堆达到最小值堆的效果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;

using namespace std;

void showpq(priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; &amp;amp;gq)
{
priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; g = gq;
while(!g.empty())
{
cout &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; g.top();
g.pop();
}
cout &amp;lt;&amp;lt; endl;
}

int main ()
{
priority_queue&amp;lt;int, vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt;&amp;gt; gquiz;
gquiz.push(10);
gquiz.push(30);
gquiz.push(20);
gquiz.push(5);
gquiz.push(1);

cout &amp;lt;&amp;lt; &amp;quot;The priority queue gquiz is: &amp;quot;;
showpq(gquiz);

cout &amp;lt;&amp;lt; &amp;quot;gquiz.size(): &amp;quot; &amp;lt;&amp;lt; gquiz.size() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; &amp;quot;gquiz.top(): &amp;quot; &amp;lt;&amp;lt; gquiz.top() &amp;lt;&amp;lt; endl;

gquiz.pop();
cout &amp;lt;&amp;lt; &amp;quot;after gquiz.pop(): &amp;quot;;
showpq(gquiz);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;关联容器&#34;&gt;关联容器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;实现排好序的数据结构，可以达到快速查询的时间复杂度 O(logn)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;set&#34;&gt;set&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;保存的值都是唯一的，不能修改，只能插入或删除，key 和 value 相同&lt;/li&gt;
&lt;li&gt;存储的元素总是依照严格的弱排序标准排序，通过内部的比较对象&lt;/li&gt;
&lt;li&gt;在通过 key 访问单个元素的时候通常比 unordered_set 慢，但是可以访问有序集合的一个子集&lt;/li&gt;
&lt;li&gt;通常实现为二分搜索树&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;multiset&#34;&gt;multiset&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;可以存储相同值的元素&lt;/li&gt;
&lt;li&gt;在通过 key 访问的那个元素的时候比 unordered_multiset 慢&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;map&#34;&gt;map&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;关联容器，存储的对象包括一个 key 和映射的 value&lt;/li&gt;
&lt;li&gt;通过 key 排序和标记唯一元素，存储的元素总是依照严格的弱排序标准排序，通过内部的比较对象&lt;/li&gt;
&lt;li&gt;在通过 key 访问单个元素的时候通常比 unordered_map 慢，但是可以访问有序集合的一个子集&lt;/li&gt;
&lt;li&gt;通常实现为二分搜索树&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;multimap&#34;&gt;multimap&lt;/h4&gt;

&lt;h3 id=&#34;无序关联容器&#34;&gt;无序关联容器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;实现无序数据结构，可以快速查询&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;unordered-set&#34;&gt;unordered_set&lt;/h4&gt;

&lt;h4 id=&#34;unordered-multiset&#34;&gt;unordered_multiset&lt;/h4&gt;

&lt;h4 id=&#34;unordered-map&#34;&gt;unordered_map&lt;/h4&gt;

&lt;h4 id=&#34;unordered-multimap&#34;&gt;unordered_multimap&lt;/h4&gt;

&lt;h2 id=&#34;仿函数&#34;&gt;仿函数&lt;/h2&gt;

&lt;h2 id=&#34;迭代器&#34;&gt;迭代器&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/cpp-stl-tutorial/&#34; target=&#34;_blank&#34;&gt;C++ STL Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/the-c-standard-template-library-stl/&#34; target=&#34;_blank&#34;&gt;The C++ Standard Template Library (STL)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikibooks.org/wiki/C%2B%2B/STL/Algorithm&#34; target=&#34;_blank&#34;&gt;C++/STL/Algorithm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikibooks.org/wiki/C%2B%2B/Numeric&#34; target=&#34;_blank&#34;&gt;C++/Numeric&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>STL 的 push 和 emplace</title>
      <link>https://xueqing.github.io/blog/cplusplus/stl_push_emplace/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/stl_push_emplace/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdqueueemplace&#34;&gt;std::queue::emplace&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stddequeemplaceback&#34;&gt;std::deque::emplace_back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdallocatortraitsconstruct&#34;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdallocator&#34;&gt;std::allocator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stddequeallocator&#34;&gt;std::deque::allocator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdqueuepush&#34;&gt;std::queue::push&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stddequepushback&#34;&gt;std::deque::push_back&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdvector-%e7%9a%84-emplaceback-%e5%92%8c-pushback&#34;&gt;std::vector 的 emplace_back 和 push_back&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%ba%a7%e7%94%9f%e6%97%b6%e9%97%b4&#34;&gt;产生时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e4%b8%8d%e6%ad%a2-1-%e4%b8%aa&#34;&gt;类型的构造函数不止 1 个&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%88%e7%8e%87&#34;&gt;效率&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stdmap-%e7%9a%84-emplace-%e5%92%8c-insert&#34;&gt;std::map 的 emplace 和 insert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96%e5%8f%82%e8%80%83&#34;&gt;其他参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;下面的说明以 STL 的 queue 为实例，其他 STL 还有 push_back/emplace_back 等，各自的影响不尽相同

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/&#34; target=&#34;_blank&#34;&gt;deque&lt;/a&gt;: emplace/emplace_back/emplace_front/insert/push_back/push_front&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/forward_list/forward_list/&#34; target=&#34;_blank&#34;&gt;forward_list&lt;/a&gt;: emplace_after/emplace_front/insert_after/push_front&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/list/list/&#34; target=&#34;_blank&#34;&gt;list&lt;/a&gt;: emplace/emplace_back/emplace_front/insert/push_back/push_front&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/map/map/&#34; target=&#34;_blank&#34;&gt;map&lt;/a&gt;: emplace/emplace_hint/insert&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/queue/queue/&#34; target=&#34;_blank&#34;&gt;queue&lt;/a&gt;: emplace/push&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/set/set/&#34; target=&#34;_blank&#34;&gt;set&lt;/a&gt;: emplace/emplace_hint/insert&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/stack/stack/&#34; target=&#34;_blank&#34;&gt;stack&lt;/a&gt;: emplace/push&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cplusplus.com/reference/vector/vector/&#34; target=&#34;_blank&#34;&gt;vector&lt;/a&gt;: emplace/emplace_back/insert/push_back&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-queue-emplace&#34;&gt;std::queue::emplace&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/queue/queue/emplace/&#34; target=&#34;_blank&#34;&gt;std::queue::emplace&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;： &lt;code&gt;template &amp;lt;class... Args&amp;gt; void emplace (Args&amp;amp;&amp;amp;... args);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;args：被传递作为新元素构造函数的参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：构造并插入一个元素。增加新元素到 queue 的末尾，即当前最后一个元素之后。将传入的参数作为新元素的构造函数的参数。&lt;/li&gt;
&lt;li&gt;底层容器对象调用 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/emplace_back/&#34; target=&#34;_blank&#34;&gt;emplace_back&lt;/a&gt;，并传递参数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;std-deque-emplace-back&#34;&gt;std::deque::emplace_back&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/emplace_back/&#34; target=&#34;_blank&#34;&gt;std::deque::emplace_back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;template &amp;lt;class... Args&amp;gt; void emplace_back (Args&amp;amp;&amp;amp;... args);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;args：被传递作为新元素构造函数的参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：构造并在末尾插入一个元素。增加新元素到 deque 的末尾，即当前最后一个元素之后。将传入的参数作为新元素的构造函数的参数。&lt;/li&gt;
&lt;li&gt;这个操作将容器大小高效增加 1&lt;/li&gt;
&lt;li&gt;元素通过调用 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator_traits/construct/&#34; target=&#34;_blank&#34;&gt;std::allocator_traits::construct&lt;/a&gt; 和参数构造。

&lt;ul&gt;
&lt;li&gt;新元素的存储通过 &lt;code&gt;allocator_traits&amp;lt;allocator_type&amp;gt;::construct()&lt;/code&gt; 分配，失败时可能会抛异常(对于默认的 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator/&#34; target=&#34;_blank&#34;&gt;std::allocator&lt;/a&gt;，分配失败会抛 bad_alloc 异常)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迭代器有效性&lt;/strong&gt;：容器相关的所有迭代器无效，但是指针和引用是有效的，和调用函数之前指向的元素相同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常安全性&lt;/strong&gt;：强保证。如果抛出异常，则容器没有改变。如果 &lt;code&gt;std::allocator_traits::construct&lt;/code&gt; 对于传递的参数不支持，会导致未定义的行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;std-allocator-traits-construct&#34;&gt;std::allocator_traits::construct&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator_traits/construct/&#34; target=&#34;_blank&#34;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;静态成员函数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;template &amp;lt;class T, class... Args&amp;gt; static void construct (allocator_type alloc, T* p, Args&amp;amp;&amp;amp;... args );&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：构造一个元素。在指针 p 指向的位置传递参数给构造函数构造一个元素对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：对象被 in-place 构造，而不用为元素分配存储。如果不可行，则调用 &lt;code&gt;::new (static_cast&amp;lt;void*&amp;gt;(p)) T (forward&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;std-allocator&#34;&gt;std::allocator&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator/&#34; target=&#34;_blank&#34;&gt;std::allocator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;template &amp;lt;class T&amp;gt; class allocator;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;T：对象分配的元素类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：默认分配器。

&lt;ul&gt;
&lt;li&gt;分配器：定义内存模型的类，被标准库的一些部分使用，大多数情况是被 STL 容器使用。&lt;/li&gt;
&lt;li&gt;allocator 是默认分配器模板，这是所有标准容器未指定最后一个(可选的)模板参数时会使用的分配器，也是标准库中唯一一个预定义的分配器。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;std-deque-allocator&#34;&gt;std::deque::allocator&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;参考&lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/get_allocator/&#34; target=&#34;_blank&#34;&gt;std::deque::get_allocator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;allocator_type get_allocator() const noexcept;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;allocator_type：是容器使用的分配器的类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：返回和 deque 对象相关的分配器对象的拷贝。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常安全性&lt;/strong&gt;：保证没有异常。拷贝默认分配器的任何实例也保存不会抛异常&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-queue-push&#34;&gt;std::queue::push&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/queue/queue/push/&#34; target=&#34;_blank&#34;&gt;std::queue::push&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;void push (const value_type&amp;amp; val);&lt;/code&gt;或&lt;code&gt;void push (value_type&amp;amp;&amp;amp; val);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;val：经过初始化的新插入元素的值&lt;/li&gt;
&lt;li&gt;value_type：是容器元素的类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：插入一个新元素到 queue 末尾，即当前最后一个元素之后。新元素的内容被初始化为 &lt;code&gt;val&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;底层容器对象调用 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/push_back/&#34; target=&#34;_blank&#34;&gt;push_back&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;std-deque-push-back&#34;&gt;std::deque::push_back&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/push_back/&#34; target=&#34;_blank&#34;&gt;std::deque::push_back&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数原型&lt;/strong&gt;：&lt;code&gt;void push_back (const value_type&amp;amp; val);&lt;/code&gt;或&lt;code&gt;void push_back (value_type&amp;amp;&amp;amp; val);&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;val：将要拷贝或移动给新对象的值&lt;/li&gt;
&lt;li&gt;value_type：是容器元素的类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新元素的存储通过容器的 &lt;a href=&#34;http://www.cplusplus.com/reference/deque/deque/get_allocator/&#34; target=&#34;_blank&#34;&gt;allocator&lt;/a&gt; 分配，失败时可能会抛异常(对于默认的&lt;a href=&#34;http://www.cplusplus.com/reference/memory/allocator/&#34; target=&#34;_blank&#34;&gt;std::allocator&lt;/a&gt;，分配失败会抛 bad_alloc 异常)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;迭代器有效性&lt;/strong&gt;：容器相关的所有迭代器无效，但是指针和引用是有效的，和调用函数之前指向的元素相同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异常安全性&lt;/strong&gt;：强保证。如果抛出异常，则容器没有改变。如果 &lt;code&gt;std::allocator_traits::construct&lt;/code&gt; 对于传递的参数不支持，会导致未定义的行为。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-vector-的-emplace-back-和-push-back&#34;&gt;std::vector 的 emplace_back 和 push_back&lt;/h2&gt;

&lt;h3 id=&#34;产生时间&#34;&gt;产生时间&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;push_back 是标准 C++ 创建之初就有的；emplace_back 是在 C++11 特性前提下增加的&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;类型的构造函数不止-1-个&#34;&gt;类型的构造函数不止 1 个&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当类型的构造函数不止 1 个时：push_back 只接收类型的对象，emplace_back 接收类型构造函数的参数&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ 11 支持从参数构造对象，因此当类型的构造函数参数只有一个时，push_back 可以传入构造函数参数，C++ 11 会构造对象，并传递对象给容器&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class OneParam
{
int m_i;
public:
OneParam(int ii) : m_i(ii) { cout &amp;lt;&amp;lt; &amp;quot;OneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
OneParam(const OneParam &amp;amp;copy) : m_i(copy.m_i) { cout &amp;lt;&amp;lt; &amp;quot;OneParam::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~OneParam( ) { cout &amp;lt;&amp;lt; &amp;quot;~OneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }

int get() const { return m_i; }
};

class MoreThanOneParam
{
int m_i;
string m_s;
public:
MoreThanOneParam(int ii, string s) : m_i(ii), m_s(s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
MoreThanOneParam(const MoreThanOneParam &amp;amp;copy) : m_i(copy.m_i), m_s(copy.m_s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~MoreThanOneParam( ) { cout &amp;lt;&amp;lt; &amp;quot;~MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }

int getInt() const { return m_i; }
string getString() const { return m_s; }
};

int main( )
{
vector&amp;lt;OneParam&amp;gt; vec1={ 21 , 45 }; //对于每个元素，构造一次，拷贝一次，析构一次
vec1.push_back( OneParam(34) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec1.push_back( 901 ); //构造一次，拷贝一次，析构一次
vec1.emplace_back( OneParam(7889) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec1.emplace_back( 4156 ); //构造一次
//21; 45; 34; 901; 7889; 4156;
for( auto &amp;amp;elem:vec1 ) { cout &amp;lt;&amp;lt; elem.get() &amp;lt;&amp;lt; &amp;quot;; &amp;quot;; } //21; 45; 34; 901; 7889; 4156;
cout &amp;lt;&amp;lt; endl;

vector&amp;lt;MoreThanOneParam&amp;gt; vec2={ {21,&amp;quot;String&amp;quot;} , MoreThanOneParam{45 , &amp;quot;tinger&amp;quot;} }; //对于每个元素，构造一次，拷贝一次，析构一次
vec2.push_back( MoreThanOneParam(34 , &amp;quot;Happy&amp;quot; ) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
//    vec2.push_back( 901 , &amp;quot;Doer&amp;quot; ); //Error!!
vec2.emplace_back( MoreThanOneParam(78 , &amp;quot;Gomu gomu&amp;quot; )); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec2.emplace_back( 41 , &amp;quot;Shanks&amp;quot; ); //构造一次
//21 String; 45 tinger; 34 Happy; 78 Gomu gomu; 41 Shanks;
for( auto &amp;amp;elem:vec2 ) { cout &amp;lt;&amp;lt; elem.getInt( ) &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; elem.getString( ) &amp;lt;&amp;lt; &amp;quot;; &amp;quot;; }
cout &amp;lt;&amp;lt; endl;

cin.get( );
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;效率&#34;&gt;效率&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;这里的效率指的是：代码工作更快，生成的负载更小&lt;/li&gt;
&lt;li&gt;当 vector 的类型是内置类型时，push_back 和 emplace_back 没有区别&lt;/li&gt;
&lt;li&gt;当 vector 的类型是用户自定义类型时，emplace_back 比 push_back 更高效

&lt;ul&gt;
&lt;li&gt;当尝试直接添加对象 (在对象被创建之前) 到 vector，使用 push_back 的流程是&lt;/li&gt;
&lt;li&gt;调用构造函数创建临时对象&lt;/li&gt;
&lt;li&gt;在 vector 中创建临时对象的拷贝&lt;/li&gt;
&lt;li&gt;拷贝对象完成之后，调用析构函数销毁临时对象&lt;/li&gt;
&lt;li&gt;使用 emplace_back 将不会创建临时对象，而是直接在 vector 中创建对象。因此提高了性能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;std-map-的-emplace-和-insert&#34;&gt;std::map 的 emplace 和 insert&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;insert 需要先创建临时对象，然后拷贝到 &lt;code&gt;std::pair&amp;lt;key, val&amp;gt;&lt;/code&gt; 中，再将 pair 拷贝到 map 中&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Complicated
{
int m_i;
double m_d;
string m_s;
public:
Complicated(int i, double d, string s) : m_i(i), m_d(d), m_s(s) { cout &amp;lt;&amp;lt; &amp;quot;Complicated::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
Complicated(const Complicated &amp;amp;copy) : m_i(copy.m_i), m_d(copy.m_d), m_s(copy.m_s) { cout &amp;lt;&amp;lt; &amp;quot;Complicated::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~Complicated() { cout &amp;lt;&amp;lt; &amp;quot;~Complicated::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
};

int main()
{
map&amp;lt;int, Complicated&amp;gt; m;

m.insert( make_pair(4, Complicated(4, 4.0, &amp;quot;C++4&amp;quot;)) ); //构造一次，拷贝两次，析构两次
m.insert( 5, {5, 5.0, &amp;quot;C++5&amp;quot;} ); //构造一次，拷贝两次，析构两次
m.insert( pair&amp;lt;int, Complicated&amp;gt;(7, {7, 7.0, &amp;quot;C++7&amp;quot;}) ); //构造一次，拷贝两次，析构两次
m.emplace( piecewise_construct, forward_as_tuple(6), forward_as_tuple(6, 6.0, &amp;quot;C++6&amp;quot;) ); //构造一次

//4; 5; 6; 7;
for( auto &amp;amp;elem:m )  cout &amp;lt;&amp;lt; elem.first &amp;lt;&amp;lt; &amp;quot;; &amp;quot;;
cout &amp;lt;&amp;lt; endl;

cin.get();
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他参考&#34;&gt;其他参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://candcplusplus.com/c-difference-between-emplace_back-and-push_back-function&#34; target=&#34;_blank&#34;&gt;C++ difference between emplace_back and push_back function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/4303513/push-back-vs-emplace-back&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>string</title>
      <link>https://xueqing.github.io/blog/cplusplus/string/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/string/</guid>
      <description>

&lt;h2 id=&#34;find-vs-find-first-of&#34;&gt;find vs find_first_of&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;find 函数原型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// c++11
string (1)    size_t find (const string&amp;amp; str, size_t pos = 0) const noexcept;
c-string (2)  size_t find (const char* s, size_t pos = 0) const;
buffer (3)    size_t find (const char* s, size_t pos, size_type n) const;
character (4) size_t find (char c, size_t pos = 0) const noexcept;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find_first_of 函数原型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// c++11
string (1)    size_t find_first_of (const string&amp;amp; str, size_t pos = 0) const noexcept;
c-string (2)  size_t find_first_of (const char* s, size_t pos = 0) const;
buffer (3)    size_t find_first_of (const char* s, size_t pos, size_t n) const;
character (4) size_t find_first_of (char c, size_t pos = 0) const noexcept;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对比&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;find：匹配查找整个字符串&lt;/li&gt;
&lt;li&gt;find_first_of：匹配查找指定参数的&lt;strong&gt;任意一个&lt;/strong&gt;字符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>using 关键字</title>
      <link>https://xueqing.github.io/blog/cplusplus/using/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/using/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%af%b9%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e7%9a%84-using-%e6%8c%87%e4%bb%a4&#34;&gt;1 对命名空间的 using 指令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4&#34;&gt;命名空间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#using-%e6%8c%87%e4%bb%a4&#34;&gt;using 指令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e5%af%b9%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e6%88%90%e5%91%98%e7%9a%84-using-%e5%a3%b0%e6%98%8e&#34;&gt;2 对命名空间成员的 using 声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e5%af%b9%e7%b1%bb%e6%88%90%e5%91%98%e7%9a%84-using-%e5%a3%b0%e6%98%8e&#34;&gt;3 对类成员的 using 声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d%e4%b8%8e%e5%88%ab%e5%90%8d%e6%a8%a1%e6%9d%bf%e5%a3%b0%e6%98%8e&#34;&gt;4 类型别名与别名模板声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-对命名空间的-using-指令&#34;&gt;1 对命名空间的 using 指令&lt;/h2&gt;

&lt;h3 id=&#34;命名空间&#34;&gt;命名空间&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;命名空间提供了在大项目中避免名字冲突的一种方法。&lt;/li&gt;
&lt;li&gt;声明于命名空间块内的符号被放入一个具名的作用域中，避免这些符号被误认为其他作用域中的同名符号。&lt;/li&gt;
&lt;li&gt;允许具有相同名字的多个命名空间块。这些块中的所有声明声明于该具名作用域。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;using-指令&#34;&gt;using 指令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;attr(可选) using namespace 嵌套名说明符(可选) 命名空间名;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;attr(C++11)：应用到此 using 指令的任意数量的属性&lt;/li&gt;
&lt;li&gt;嵌套名说明符：名字与作用域解析运算符 &lt;code&gt;::&lt;/code&gt; 的序列，以作用域解析运算符结束。单个 &lt;code&gt;::&lt;/code&gt; 代表全局命名空间&lt;/li&gt;
&lt;li&gt;命名空间名：命名空间名。查找此名时，查找只考虑命名空间声明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从 using 指令之后到指令出现的作用域结尾为止，以对任何名字的无限定名字查找的视点来说，来自 &lt;code&gt;命名空间名&lt;/code&gt; 的任何名字均可见，如同它声明于同时含有该 using 指令和 &lt;code&gt;命名空间名&lt;/code&gt; 两者的最接近外围命名空间作用域一样。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-对命名空间成员的-using-声明&#34;&gt;2 对命名空间成员的 using 声明&lt;/h2&gt;

&lt;h2 id=&#34;3-对类成员的-using-声明&#34;&gt;3 对类成员的 using 声明&lt;/h2&gt;

&lt;h2 id=&#34;4-类型别名与别名模板声明&#34;&gt;4 类型别名与别名模板声明&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.cppreference.com/w/cpp/keyword/using&#34; target=&#34;_blank&#34;&gt;C++ keywords: using&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>vector 的 resize 和 reserve</title>
      <link>https://xueqing.github.io/blog/cplusplus/vector_resize_reserve/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/vector_resize_reserve/</guid>
      <description>

&lt;h2 id=&#34;resize&#34;&gt;resize&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;原型

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void resize (size_type n);&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void resize (size_type n, const value_type&amp;amp; val);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;resize 方法(传递参数来构造是一样的)调整容器大小使得包含 n 个元素

&lt;ul&gt;
&lt;li&gt;如果当前大小大于 n，会从尾部删除多余的元素&lt;/li&gt;
&lt;li&gt;如果当前大小小于 n，会在尾部插入适量的元素到 vector 达到指定的大小(有第二个可选参数指定元素的值)。如果指定值，新元素初始化为 val 的拷贝，否则使用默认构造函数初始化&lt;/li&gt;
&lt;li&gt;如果当前容量(capacity) 小于 n，需要重新分配内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;它会影响 &lt;code&gt;size()&lt;/code&gt;，如果不需要重新分配内存，则 &lt;code&gt;capacity()&lt;/code&gt; 也不会改变&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;reserver&#34;&gt;reserver&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;原型

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void reserve (size_type n);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;reserve 方法请求修改容量(capacity)，即容量需要足够包含 n 个元素

&lt;ul&gt;
&lt;li&gt;如果当前容量小于 n，需要重新分配内存，使得容量&lt;strong&gt;不小于&lt;/strong&gt; n&lt;/li&gt;
&lt;li&gt;如果当前容量不小于 n，不会重新分配内存，也不会影响容量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;它只会影响 &lt;code&gt;capacity()&lt;/code&gt;，&lt;code&gt;size()&lt;/code&gt; 不会改变，也不会修改元素。只分配内存，但是没有初始化。容器中没有添加任何元素。如果之后插入元素，容器不会发生重新分配内存。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;取舍&#34;&gt;取舍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果需要初始化内存，使用 resize&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果知道需要保存元素的大小，只是为了避免多次分配，使用 reserve&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

using namespace std;

class MoreThanOneParam
{
int m_i;
string m_s;
public:
MoreThanOneParam() : m_i(-1) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::default::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
MoreThanOneParam(int ii, string s) : m_i(ii), m_s(s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
MoreThanOneParam(const MoreThanOneParam &amp;amp;copy) : m_i(copy.m_i), m_s(copy.m_s) { cout &amp;lt;&amp;lt; &amp;quot;MoreThanOneParam::copy::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }
~MoreThanOneParam( ) { cout &amp;lt;&amp;lt; &amp;quot;~MoreThanOneParam::&amp;quot; &amp;lt;&amp;lt; m_i &amp;lt;&amp;lt; endl; }

int getInt() const { return m_i; }
string getString() const { return m_s; }
};

int main( )
{
vector&amp;lt;MoreThanOneParam&amp;gt; vec2={ {1,&amp;quot;s1&amp;quot;} , MoreThanOneParam{2 , &amp;quot;s2&amp;quot;} }; //对于每个元素，构造一次，拷贝一次，析构一次
cout &amp;lt;&amp;lt; &amp;quot;=============at first, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.reserve(6);
cout &amp;lt;&amp;lt; &amp;quot;=============after reserve(6), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.push_back( MoreThanOneParam(3 , &amp;quot;s3&amp;quot; ) ); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec2.emplace_back( MoreThanOneParam(4 , &amp;quot;s4&amp;quot; )); //构造一次，拷贝一次，析构一次【底层可能会对 vector 重新分配内存，导致对之前元素的拷贝和析构】
vec2.emplace_back( 5 , &amp;quot;s5&amp;quot; ); //构造一次
cout &amp;lt;&amp;lt; &amp;quot;=============after push_back/emplace_back 3 elements, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.emplace_back( 6 , &amp;quot;s6&amp;quot; ); //构造一次
cout &amp;lt;&amp;lt; &amp;quot;=============after push_back/emplace_back 1 elements, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.emplace_back( 7 , &amp;quot;s7&amp;quot; ); //构造一次
cout &amp;lt;&amp;lt; &amp;quot;=============after push_back/emplace_back 1 elements, size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.reserve(6);
cout &amp;lt;&amp;lt; &amp;quot;=============after reserve(6), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.resize(14);
cout &amp;lt;&amp;lt; &amp;quot;=============after resize(14), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
vec2.resize(6);
cout &amp;lt;&amp;lt; &amp;quot;=============after resize(6), size=&amp;quot; &amp;lt;&amp;lt; vec2.size() &amp;lt;&amp;lt; &amp;quot;; cap=&amp;quot; &amp;lt;&amp;lt; vec2.capacity() &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; endl;

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/7397768/choice-between-vectorresize-and-vectorreserve&#34; target=&#34;_blank&#34;&gt;Choice between vector::resize() and vector::reserve()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>二进制兼容的 C&#43;&#43; 接口</title>
      <link>https://xueqing.github.io/translation/cplusplus/binary_compatible_cpp_interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/cplusplus/binary_compatible_cpp_interface/</guid>
      <description>

&lt;p&gt;原文参考 &lt;a href=&#34;https://chadaustin.me/cppinterface.html&#34; target=&#34;_blank&#34;&gt;Binary-compatible C++ Interfaces&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作者：Chad Austin, 2002.02.15&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E7%9A%84-C-%E6%8E%A5%E5%8F%A3&#34;&gt;二进制兼容的 C++ 接口&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%BF%B0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%83%8C%E6%99%AF&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E5%BF%B5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95&#34;&gt;初次尝试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95&#34;&gt;第二次尝试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BF%AE%E6%AD%A3&#34;&gt;第三次修正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BF%AE%E6%AD%A3&#34;&gt;第四次修正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%8C%E6%88%90%E6%B6%A6%E8%89%B2&#34;&gt;完成润色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0&#34;&gt;最终实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;本文解释如何生成跨编译器和配置(发布/调试等)的 C++ DLL API。&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;许多平台对他们偏好的编程语言有自己的 ABI。比如，BeOS 的主要语言是 C++，所以 C++ 编译器一定可以生成保持操作系统 C++ 系统调用二(还有类等)进制兼容的代码。&lt;/p&gt;

&lt;p&gt;Windows 为 C 语言定义 API 和 ABI，因此 C++ 编译器的开发者可以自由控制 C++ ABI 的实现。但是，MS 最后为 Windows 创建面向对象的 ABI，称为 COM。为了简化 COM 的使用，他们使 C++ ABI 的虚表(vtables)映射到 COM 接口所需的虚表。由于不能使用 COM 的 Windows 编译器非常受限，其他的编译器强制执行 COM 虚表和 C++ 虚表之前的映射。&lt;/p&gt;

&lt;p&gt;ABI 包含多个方面。这篇文章只讨论在 Windows 下使用 C++ 的问题。其他平台要求不一样。(幸运的是，因为大部分其他平台不如 Windows 流行，这些平台只有一或两个编译器，因此不是很大的问题。)&lt;/p&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ABI&lt;/strong&gt;(Application Binary Interface，应用程序二进制接口)：系统之间的二进制接口。如果一个二进制接口改变，接口两端(使用者和实现)必须被重新编译。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API&lt;/strong&gt;(Application Program Interface，应用程序编程接口)：系统之间的源接口。如果一个源接口改变，使用这个接口的代码必须修改。API 改变通常暗示 ABI 改变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interface&lt;/strong&gt;(接口)：一个所有方法都是纯虚的类，因此没有内在实现。一个接口只是对象之间通讯的协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Factory&lt;/strong&gt;(工厂)：用于创建对象。在这篇文章中，我们使用一个全局的函数作为我们的工厂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLL Boundary&lt;/strong&gt;(DLL 界限)：DLL 中被实例化的代码和调用进程的代码之间的线被称为 DLL 界限。在一些情况下，代码可以在界限两侧：一个头文件中的一个内联函数在 DLL 和可执行文件中被使用。这个函数实际上在界限两侧被实例化。因此，如果内联函数有一个静态变量，会创建两个变量，分别在可执行文件和 DLL 中，&lt;strong&gt;哪个变量被使用取决于 DLL 还是可执行文件中的代码调用了这个函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;初次尝试&#34;&gt;初次尝试&lt;/h2&gt;

&lt;p&gt;假设想要创建一个可移植的 windowing API，而且想要把实现放在 DLL 中。我会创建一个名为 Window 的类，这个类可以表示不同的 windowing 系统的一个窗口，Win32，MFC，wxWindows，Qt，Gtk，Aqua，X11，Swing(gasp)等。我们会多次尝试创建一个接口直到它可以在不同的实现、编译器和编译器设置上工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

#include &amp;lt;string&amp;gt;

#ifdef WIN32
  #ifdef EXPORTING
    #define DLLIMPORT _declspec(dllexport)
  #endif
  #else
    #define DLLIMPORT _declspec(dllimport)
  #endif
  #define CALL __stdcall
#else
  #define DLLIMPORT
  #define CALL
#endif

class DLLIMPORT Window {
public:
  Window(std::string title);
  ~Window();

  void setTitle(std::string title);
  std::string getTitle();

  //...

private:
  HWND m_window;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我不会展示实现，因为我假定你已经知道如何实现。关于这个接口有一个明显的问题：它假定你使用基础的 Win32 API。即它持有一个 HWND 作为私有成员，因此引入了 Window 类和 WIn32 SDK 的依赖。一个可能的解决方案是使用 pImpl 语法从类的定义中移除这个私有成员。参考文档&lt;a href=&#34;http://www.gotw.ca/publications/mill04.htm&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;、&lt;a href=&#34;http://www.gotw.ca/publications/mill05.htm&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;、&lt;a href=&#34;http://www.gotw.ca/gotw/028.htm&#34; target=&#34;_blank&#34;&gt;3&lt;/a&gt;和&lt;a href=&#34;http://wiki.c2.com/?PimplIdiom&#34; target=&#34;_blank&#34;&gt;4&lt;/a&gt;。同时，你不能在不破坏二进制兼容的条件下向这个类增加新成员，因为这个类的大小会改变。&lt;/p&gt;

&lt;p&gt;可能这个方法最重要的问题是成员方法不是纯虚的。因此，这些成员方法被实现为专门命名的函数，且函数使用 &lt;code&gt;this&lt;/code&gt; 指针作为第一个参数。不幸的是，我不知道有哪两种编译器对方法的名称重整(name mangling)是一样的。因此不要认为你用一个编译器生成的的 DLL 可被另一个编译器编译的可执行文件使用。&lt;/p&gt;

&lt;h2 id=&#34;第二次尝试&#34;&gt;第二次尝试&lt;/h2&gt;

&lt;p&gt;对于面向对象编程，你知道每个类可以分为两个概念：接口和工厂。工厂是创建对象的一种机制，接口支持对象之间通讯。下个版本的 Window.h 会分离这些概念。注意你不再需要导出类(你需要导出工厂函数)，因为这个是抽象类：所有的方法调用经过对象的虚表(vtables)，而不是通过一个直接的链接到 DLL。只有调用这个工厂函数会直接调用 DLL。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

#include &amp;lt;string&amp;gt;

class Window {
public:
  virtual ~Window() {}
  virtual void setTitle(std::string title) = 0;
  virtual std::string getTitle() = 0;
};

Window* DLLIMPORT CreateWindow(std::string title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码更好。使用 Window 对象的代码不关心 Window 对象实际的类型，只要实现 Window 接口的类型都可以。但是，还有一个问题：不同的编译器重整符号名称不同，因此不同编译器生成的 DLL 中的 &lt;code&gt;CreateWindow&lt;/code&gt; 函数名称不同。这意味着如果你使用 Visual C++ 6 编译 windowing DLL，不能再 Bor兰 C++ 中使用，反之亦然。幸运的是，C++ 标准通过 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 使得禁用符号重整成特殊的名称。&lt;/p&gt;

&lt;p&gt;一些人可能注意到代码的另一个问题。不同的编译器对 C++ 库的实现不同。在一些不明显的情况下，一些人会用其他的(如 &lt;a href=&#34;http://stlport.org/&#34; target=&#34;_blank&#34;&gt;STLPort&lt;/a&gt;)替代编译器的库实现……由此你不能依赖跨编译器的 STL 对象是二进制兼容的，你不能在 DLL 接口中安全使用它们。&lt;/p&gt;

&lt;p&gt;如果一个 C++ ABI 曾为 Windows 创建，需要明确指定如何与标准库中的每个类交互，但是我马上就不会再看到这个事情发生了。&lt;/p&gt;

&lt;p&gt;最后一个问题比较小。出于惯例，COM 方法和 DLL 函数使用 &lt;code&gt;__stdcall&lt;/code&gt; 调用惯例。我们可以使用前面定义的 &lt;code&gt;CALL&lt;/code&gt; 宏解决这个问题。(可以在工程中重命名)&lt;/p&gt;

&lt;h2 id=&#34;第三次修正&#34;&gt;第三次修正&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

class Window {
public:
  virtual ~Window() {}
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;马上就完成了！这个特殊的接口可能在大多数情况下会有效。但是，虚析构函数使得事情有趣了……因为 COM 不使用虚析构函数，你不能依赖不同的编译器使用是一样的。然而，你可以使用一个虚方法取代虚析构函数。即在实现类中通过 &lt;code&gt;delete this&lt;/code&gt; 实现；这个方式会在 DLL 界限同一侧实现构造和析构函数。比如，如果尝试使用 VC++6 的发布版可执行程序调试 DLL，程序会崩溃或遇到类似“Value of ESP not saved across function call”的警告。发生这个错误是因为 VC++ 运行时库的调试版本和发布版的分配器(allocator)不同。因为两个分配器不兼容，我们不能在 DLL 界限一侧申请内存然后再另一侧释放这个内存。&lt;/p&gt;

&lt;p&gt;但是一个虚析构函数和一个虚方法是什么不同呢？虚析构函数不负责释放这个对象使用的内存：它们只是在释放对象之前简单地被调用执行必要的清理。使用 DLL 的可执行程序不会尝试释放对象本身的内存。另一方面， &lt;code&gt;destroy()&lt;/code&gt; 函数负责释放内存，因此所有的 new 和 delete 调用在 DLL 界限的同一侧。&lt;/p&gt;

&lt;p&gt;可以将接口的析构函数设为受保护的，以便使用接口的地方在析构函数中不小心删除它。&lt;/p&gt;

&lt;h2 id=&#34;第四次修正&#34;&gt;第四次修正&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.h

class Window {
protected:
  virtual ~Window() {} //use destroy()

public:
  virtual void CALL destroy() = 0;
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为这段代码不使用 COM 定义的语义，它可以跨编译器和配置工作。不幸的是，它不是完美的。你必须记住使用 &lt;code&gt;object-&amp;gt;destroy()&lt;/code&gt; 删除对象，这个不如 &lt;code&gt;delete object&lt;/code&gt; 直观。可能更重要的是，你不能在这个对象类型上使用 &lt;code&gt;std::auto_ptr&lt;/code&gt;，&lt;code&gt;autho_ptr&lt;/code&gt; 会使用 &lt;code&gt;delete object&lt;/code&gt; 删除它拥有的对象。有一种方式实现 &lt;code&gt;delete object&lt;/code&gt; 语法吗，实际上调用 &lt;code&gt;object-&amp;gt;destroy()&lt;/code&gt;？有的。这正使得事情有点奇怪……你可以为这个接口重载 &lt;code&gt;operator delete&lt;/code&gt;，在内部调用 &lt;code&gt;destroy()&lt;/code&gt;。因为运算符 delete 持有一个 void 指针，你需要记得你永远不会对任何非 Window 调用 &lt;code&gt;Window::operator delete&lt;/code&gt;。这是一个相当安全的假设。下面是运算符的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//...
void operator delete(void *p) {
  if(p) {
    Window* w = static_cast&amp;lt;Window*&amp;gt;(p);
    w-&amp;gt;destroy();
  }
}
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来相当好……你现在可以再使用 &lt;code&gt;autho_ptr&lt;/code&gt;，而且你仍然有一个稳定的二进制接口。当你重新编译和测试你的新代码，你会注意到在 &lt;code&gt;WindowImpl::destroy&lt;/code&gt; 有一个栈溢出！发生了什么？如果你记得 destroy 方法如何被实现，你会发现它只是简单的执行 &lt;code&gt;delete this&lt;/code&gt;。由于这个接口重载了 &lt;code&gt;operator delete&lt;/code&gt;，&lt;code&gt;WindowImpl::destroy&lt;/code&gt; 调用 &lt;code&gt;Window::operator delete&lt;/code&gt; 会调用 &lt;code&gt;WindowImpl::destroy&lt;/code&gt;……无限循环。这个特别问题的解决方法是在实现类中重载运算符 delete 来调用全局的运算符 delete&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//...
void operator delete(void *p) {
  ::operator delete(p);
}
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完成润色&#34;&gt;完成润色&lt;/h2&gt;

&lt;p&gt;如果你的系统有很多接口和实现，你会发现你想要一些方式自动化取消定义运算符 delete。幸运的是，这个也是可能的。简单地创建一个模板类叫做 DefaultDelete，然后不要从接口类 I 衍生，而是从 &lt;code&gt;class DefaultDelete&amp;lt;I&amp;gt;&lt;/code&gt; 衍生实现类。下面是 DefaultDelete 的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;typename T&amp;gt;
class DefaultDelete : public T {
public:
  void operator delete(void *p) {
    ::operator delete(p);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;最终实现&#34;&gt;最终实现&lt;/h2&gt;

&lt;p&gt;下面是最终版本的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.h

#ifdef WIN32
  #define CALL __stdcall
#else
  #define CALL
#endif

class Window {
public:
  virtual void CALL destroy() = 0;
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;

  void operator delete(void* p) {
    if(p) {
      Window* p = static_cast&amp;lt;Window*&amp;gt;(p);
      w-&amp;gt;destroy();
    }
  }
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//DefaultDelete.h

template&amp;lt;typename T&amp;gt;
class DefaultDelete : public T {
public:
  void operator delete(void* p) {
    ::operator delete(p);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.cpp

#include &amp;quot;Window.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;windows.h&amp;gt;
#include &amp;quot;DefaultDelete.h&amp;quot;

class WindowImpl : public DefaultDelete&amp;lt;Window&amp;gt; {
public:
  WindowImpl(HWND window) {
    m_window = window;
  }

  ~WindowImpl() {
    DestroyWindow(m_window);
  }

  void CALL destroy() {
    delete this;
  }

  void CALL setTitle(const char* title) {
    SetWindowtext(m_window, title);
  }

  const char* CALL getTitle() {
    char title[512];
    GetWindowText(m_window, title, 512);
    m_title = title; //save the title past the call
    return m_title.c_str();
  }

private:
  HWND m_window;
  std::string m_title;
}

Window* CALL CreateWindow(const char* title) {
  // create Win32 window object
  HWND window = ::CreateWindow(..., title, ...);
  return (window ? new WindowImple(window) : 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我会枚举一些指导方针，在创建 C++ 接口的时候需要记得。你可以回顾作为一个参考或者使用它帮助巩固你的知识。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有的接口类应该是完全抽象的。每个方法应该是纯虚的(或者内联的……你可以安全地编写内联方法调用其他方法)。&lt;/li&gt;
&lt;li&gt;所有的全局函数应该是 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 以避免不兼容的名称重整。并且，导出的函数和方法应该使用。&lt;code&gt;__stdcall&lt;/code&gt; 调用惯例，因为 DLL 函数和 COM 习惯上使用这种调用惯例。这种方式，如果这个库的使用者使用默认的 &lt;code&gt;__cdecl&lt;/code&gt; 编译，对 DLL 的调用仍然使用正确的惯例。&lt;/li&gt;
&lt;li&gt;不要使用标准 C++ 库。&lt;/li&gt;
&lt;li&gt;不要使用异常处理。&lt;/li&gt;
&lt;li&gt;不要使用虚析构函数。相反地，创建一个 &lt;code&gt;destroy()&lt;/code&gt; 方法和一个重载的 &lt;code&gt;operator delete&lt;/code&gt; 调用 &lt;code&gt;destroy()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;不要在 DLL 界限的一侧申请内存，在另一侧释放它。不同的 DLL 和 可执行文件可以使用不同的堆编译，并且使用不同的堆申请和释放内存块肯定会导致崩溃。比如，不要内联内存申请函数以便函数不会编译到不同的可执行文件和 DLL。&lt;/li&gt;
&lt;li&gt;不要在接口使用重载的方法。不同的编译器在虚表中排序不同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stlport.org/&#34; target=&#34;_blank&#34;&gt;STLPort&lt;/a&gt; 是 STL 的替代&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/&#34; target=&#34;_blank&#34;&gt;SGI&lt;/a&gt; 有另外一个标准的 C++ 库实现&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://corona.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;Corona&lt;/a&gt; 图片 I/O 库使用了本文引入的技术&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于 boost 库</title>
      <link>https://xueqing.github.io/blog/cplusplus/boost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/boost/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;使用对应功能需要的库

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apt-get install mpi-default-dev&lt;/code&gt;安装 mpi 库&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-get install libicu-dev&lt;/code&gt;支持正则表达式的 UNICODE 字符集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-get install python-dev&lt;/code&gt;需要 python 的话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;apt-get install libbz2-dev&lt;/code&gt;如果编译出现错误&lt;code&gt;bzlib.h: No such file or directory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解压源代码安装包，切换到对应文件夹：&lt;code&gt;./bootstrap.sh&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;生成 bjam，上述命令可以带有各种选项，具体可参考帮助文档：&lt;code&gt;./bootstrap.sh --help&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--prefix&lt;/code&gt;参数，可以指定安装路径，如果不带&lt;code&gt;--prefix&lt;/code&gt;参数的话（推荐），默认路径是&lt;code&gt;/usr/local/include&lt;/code&gt;和&lt;code&gt;/usr/local/lib&lt;/code&gt;，分别存放头文件和各种库。&lt;/li&gt;
&lt;li&gt;当前目录下，生成两个文件 bjam 和 b2，这两个是一样的，所以接下来的步骤，可以用这两个中的任意一个来执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using mpi&lt;/code&gt;如果需要 MPI 功能，需要在 /tools/build/v2/user-config.jam 文件的末尾添加&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;利用生成的 bjam 脚本编译源代码

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./b2 -a -sHAVE_ICU=1&lt;/code&gt;，&lt;code&gt;-a&lt;/code&gt;参数，代表重新编译，&lt;code&gt;-sHAVE_ICU=1&lt;/code&gt;代表支持 Unicode/ICU&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编译完成后，进行安装，也就是将头文件和生成的库，放到指定的路径（&amp;ndash;prefix）下

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;./b2 install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关于 const</title>
      <link>https://xueqing.github.io/blog/cplusplus/const/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/const/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%b8%b8%e9%87%8f%e6%ad%a3%e7%a1%ae%e6%80%a7const-correctness&#34;&gt;1 常量正确性(const correctness)&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e6%a6%82%e8%bf%b0&#34;&gt;1.1 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-const-%e5%92%8c&#34;&gt;1.2 const 和 *&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-const-%e5%92%8c&#34;&gt;1.3 const 和 &amp;amp;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;1.4 成员函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e4%ba%8c%e9%87%8d%e6%8c%87%e9%92%88&#34;&gt;2 二重指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e4%bf%ae%e6%94%b9-const&#34;&gt;3 修改 const&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-x-const-x&#34;&gt;4 X&lt;strong&gt;-&amp;gt;const X&lt;/strong&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-reference&#34;&gt;5 reference&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-常量正确性-const-correctness&#34;&gt;1 常量正确性(const correctness)&lt;/h2&gt;

&lt;h3 id=&#34;1-1-概述&#34;&gt;1.1 概述&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;常量正确性：即使用关键字&lt;code&gt;const&lt;/code&gt;避免常量对象被修改&lt;/li&gt;

&lt;li&gt;&lt;p&gt;函数接收一个参数，且在调用过程中不能修改参数，实现方式有三种&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;f1/f2 中不能修改传入参数，否则会有编译警告&lt;/li&gt;
&lt;li&gt;f3 值传递，只修改局部拷贝&lt;/li&gt;

&lt;li&gt;&lt;p&gt;f1/f2 中不能调用 g1/g2，否则会有编译警告&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f1(const std::string&amp;amp; s);  //pass by reference-to-const
void f2(const std::string* sp); //pass by pointer-to-const
void f3(std::string s);         //pass by value

void g1(std::string&amp;amp; s);        //pass by reference-to-non-const
void g2(std::string* sp);       //pass by pointer-to-non-const
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常量正确性：避免意外修改不希望修改的东西&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一般来说，&lt;code&gt;const&lt;/code&gt; 作用于离它最近的左侧的类型，否则，作用于离它最近的右侧的类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;规则：&lt;code&gt;read it backwards&lt;/code&gt;，即倒着读&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建议：X 放在修饰符的右边&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-2-const-和&#34;&gt;1.2 const 和 *&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const X * ptr&lt;/code&gt;：ptr is a pointer to an X that is const

&lt;ul&gt;
&lt;li&gt;ptr 是一个指针变量，指向一个 X 的对象，但不能通过指针修改 X 对象, *ptr 只读&lt;/li&gt;
&lt;li&gt;不能通过 ptr 调用 X 非 const 的成员方法，否则会有编译警告&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;声明&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const int const0=96;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;int is const&lt;/td&gt;
&lt;td&gt;const1 是整型常量，不可再赋值&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a pointer to an X&lt;/td&gt;
&lt;td&gt;X 对象实例的指针&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a pointer to an X that is const&lt;/td&gt;
&lt;td&gt;ptr 是一个指针变量，指向一个 X 的对象，但不能通过指针修改 X 对象, *ptr 只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const const * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X const * ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X * const ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a const pointer to an X&lt;/td&gt;
&lt;td&gt;ptr 是一个常量指针，指向一个 X 的对象，不能给指针再赋值，但是可以通过指针修改 X 对象，ptr 只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const * const ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;ptr is a const pointer to a const X&lt;/td&gt;
&lt;td&gt;ptr 是一个常量指针，指向一个 X 的对象，但不能给指针再赋值，也不能通过指针修改 X 对象&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X * const ptr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;const char *Function1() { return &amp;quot;Some text&amp;quot;; }
Function1()[1]=&#39;a&#39;; //error
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;常量指针指向变量：变量可修改，且未从内存移除&lt;/li&gt;
&lt;li&gt;指向常量的指针变量：函数返回常量字符串数组，防止修改返回值错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-3-const-和&#34;&gt;1.3 const 和 &amp;amp;&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const X &amp;amp; obj&lt;/code&gt;：obj is a reference to an X that is const

&lt;ul&gt;
&lt;li&gt;obj 是一个 X 对象的引用，但不能通过 obj 修改 X 对象&lt;/li&gt;
&lt;li&gt;不能通过 obj 调用 X 非 const 的成员方法，否则会有编译警告&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;声明&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;const X &amp;amp; obj&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;obj is a reference to an X that is const&lt;/td&gt;
&lt;td&gt;obj 是一个 X 对象的引用，但不能通过 obj 修改 X 对象, obj 只读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;X const &amp;amp; obj&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-4-成员函数&#34;&gt;1.4 成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在成员函数后加&lt;code&gt;const&lt;/code&gt;避免在内部修改成员变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass{
int m_var;
  
// modify m_var is not allowed
void SomeMethod() const;

// the var pointed to by returned pointer and returned pointer is not allowed to altered
// the var pointed to by given pointer and given pointer is const
// modify m_var is not allowed
const int * const AnotherMethod(const int * const &amp;amp;) const;

// the return value must not be reference to a member of MyClass
std::string&amp;amp; BadMethod() const;

// the return value can be reference to a member of MyClass
const std::string&amp;amp; GoodMethod() const;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-二重指针&#34;&gt;2 二重指针&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;声明&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int ** pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a pointer to a pointer to an int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int ** const pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a const pointer to a pointer to an int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int * const * pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a pointer to a const pointer to an int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int const ** pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a pointer to a pointer to a const int&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int * const * const pp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;pp is a const pointer to a const pointer to an int&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-修改-const&#34;&gt;3 修改 const&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个对象或变量被声明成&lt;code&gt;const&lt;/code&gt;，后续可以使用&lt;code&gt;const_cast&lt;/code&gt;修改其为可变&lt;/li&gt;
&lt;li&gt;将类的某些成员变量声明为&lt;code&gt;mutable&lt;/code&gt;，可在&lt;code&gt;const&lt;/code&gt;成员函数中修改它们&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-x-const-x&#34;&gt;4 X&lt;strong&gt;-&amp;gt;const X&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;X*&lt;/code&gt;转成&lt;code&gt;const X*&lt;/code&gt;是安全的&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将&lt;code&gt;X**&lt;/code&gt;转成&lt;code&gt;const X**&lt;/code&gt;会有编译警告，因为可能会不经 cast 操作修改一个&lt;code&gt;const X&lt;/code&gt;对象&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyClass {
public:
void Modify();
}

int main()
{
const MyClass obj;
MyClass * ptr;
const MyClass ** pptr = &amp;amp;ptr; // compile error
*pptr = &amp;amp;obj; // ptr points to obj
ptr-&amp;gt;Modify();  // ptr modifies const obj
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-reference&#34;&gt;5 reference&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/const-correctness&#34; target=&#34;_blank&#34;&gt;const correctness&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const&#34; target=&#34;_blank&#34;&gt;What is the difference between const int*, const int * const, and int const *&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://duramecho.com/ComputerInformation/WhyHowCppConst.html&#34; target=&#34;_blank&#34;&gt;The C++ &amp;lsquo;const&amp;rsquo; Declaration: Why &amp;amp; How&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>关键字 extern 在 C 语言的使用</title>
      <link>https://xueqing.github.io/blog/cplusplus/extren_c/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/extren_c/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%89%8d%e8%a8%80&#34;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%98%e9%87%8f%e6%88%96%e5%87%bd%e6%95%b0%e7%9a%84%e5%a3%b0%e6%98%8e%e5%92%8c%e5%ae%9a%e4%b9%89&#34;&gt;变量或函数的声明和定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a3%b0%e6%98%8e%e5%92%8c%e5%ae%9a%e4%b9%89%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e7%9a%84%e6%9c%80%e5%a5%bd%e6%96%b9%e5%bc%8f&#34;&gt;声明和定义全局变量的最好方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-1%e5%8f%af%e4%bb%a5%e5%a3%b0%e6%98%8e%e5%a4%9a%e6%ac%a1%e4%bd%86%e5%88%9d%e5%a7%8b%e5%8c%96%e4%b8%80%e6%ac%a1&#34;&gt;关键点 1：可以声明多次但初始化一次&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-2%e9%bb%98%e8%ae%a4%e5%ad%98%e5%82%a8%e7%b1%bb%e6%98%af-extern&#34;&gt;关键点 2：默认存储类是 extern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-3extern-%e5%8f%98%e9%87%8f%e6%88%96%e7%a8%8b%e5%ba%8f%e5%af%b9%e6%95%b4%e4%b8%aa%e7%a8%8b%e5%ba%8f%e5%8f%af%e8%a7%81&#34;&gt;关键点 3：extern 变量或程序对整个程序可见&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b3%e9%94%ae%e7%82%b9-4extern-%e4%bd%9c%e7%94%a8%e4%ba%8e%e5%8f%98%e9%87%8f&#34;&gt;关键点 4：extern 作用于变量&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%aa%e7%94%a8%e4%ba%8e%e5%a3%b0%e6%98%8e%e5%8f%98%e9%87%8f&#34;&gt;只用于声明变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e8%87%aa%e5%8a%a8%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;全局变量自动初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8d%e8%83%bd%e5%b1%80%e9%83%a8%e5%9c%b0%e5%88%9d%e5%a7%8b%e5%8c%96-extern-%e5%8f%98%e9%87%8f&#34;&gt;不能局部地初始化 extern 变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8d%e8%83%bd%e5%86%99%e5%85%a8%e5%b1%80%e7%9a%84%e8%b5%8b%e5%80%bc%e8%af%ad%e5%8f%a5&#34;&gt;不能写全局的赋值语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%b9%e7%b1%bb%e6%88%90%e5%91%98%e6%97%a0%e6%95%88&#34;&gt;对类成员无效&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e8%a7%81%e9%94%99%e8%af%af&#34;&gt;常见错误&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%aa%e5%ae%9a%e4%b9%89%e7%9a%84%e8%a1%8c%e4%b8%ba&#34;&gt;未定义的行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%96%e9%83%a8%e5%ae%9a%e4%b9%89&#34;&gt;外部定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%9a%e9%87%8d%e5%a4%96%e9%83%a8%e5%ae%9a%e4%b9%89&#34;&gt;多重外部定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%b4%e6%96%87%e4%bb%b6%e4%b8%ad%e5%8f%98%e9%87%8f%e7%9a%84%e5%a3%b0%e6%98%8e&#34;&gt;头文件中变量的声明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 用于声明 C 语言中的外部变量和函数。这个修饰符用于所有数据类型，比如 int，float，double，array，pointer，structure，function 等&lt;/li&gt;
&lt;li&gt;范围(scope)：不绑定到任何函数。作用域整个程序，是全局的&lt;/li&gt;
&lt;li&gt;默认值(default value)：全局变量的默认初始化值是 0(或 null)&lt;/li&gt;
&lt;li&gt;生命周期(lifetime)：直到整个程序执行结束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 告诉编译器变量或函数(非静态的)都可以在链接时找到。适用于在模块之间共享某些全局变量，但是不想把它们放在一个头文件，或者在一个头文件中定义它们

&lt;ul&gt;
&lt;li&gt;大部分编译器编译器会优化程序确保它们不会为 &lt;code&gt;extern&lt;/code&gt; 对象保留内存，因为编译器知道定义它们的模块会保留内存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;变量或函数的声明和定义&#34;&gt;变量或函数的声明和定义&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明(declaration)：声明变量或函数存在程序的某个地方，但是不为它们分配内存。确定了变量或函数的类型

&lt;ul&gt;
&lt;li&gt;声明一个变量时，程序知道这个变量的类型；声明一个函数时，程序知道函数的参数、数据类型、参数顺序和函数返回类型&lt;/li&gt;
&lt;li&gt;声明是编译器需要的用于接受对标识符的引用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定义(definition)：既包含声明的作用，也为变量或函数分配内存。可以认为定义是声明的一个超集&lt;/li&gt;
&lt;li&gt;因此一个函数或变量可以声明多次，但是只能定义一次(即同一个函数或变量不能存在两个位置)

&lt;ul&gt;
&lt;li&gt;定义是对标识符的实例化/实现&lt;/li&gt;
&lt;li&gt;定义时链接器需要的用于链接对这些实体的引用&lt;/li&gt;
&lt;li&gt;单一定义原则(One Definition Rule)：编译单元不应该对任意变量、函数、类类型、枚举类型或模板有多余一个的定义&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;声明和定义全局变量的最好方式&#34;&gt;声明和定义全局变量的最好方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;声明和定义全局变量的清晰、可靠的方式是使用一个头文件，该头文件包含变量的 &lt;code&gt;extern&lt;/code&gt; 声明

&lt;ul&gt;
&lt;li&gt;定义这些变量的源文件和引用这些变量的源文件包含此头文件&lt;/li&gt;
&lt;li&gt;对于每一个程序，有且只有一个源文件定义这些变量&lt;/li&gt;
&lt;li&gt;对于每一个程序，有且只有一个头文件声明这些变量&lt;/li&gt;
&lt;li&gt;这个头文件时重要的，它使能在独立的翻译单元(TU，translation units，源文件)之间交叉检查，同时确保一致性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;完整的程序可能还需要全局函数。C99 和 C11 要求函数在使用之前必须是已经声明或定义过的。使用一个头文件包含全局函数的 &lt;code&gt;extern&lt;/code&gt; 声明。也可以不加 &lt;code&gt;extern&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;尽量避免使用全局函数——可以使用全局变量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-1-可以声明多次但初始化一次&#34;&gt;关键点 1：可以声明多次但初始化一次&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一个特殊的 &lt;code&gt;extern&lt;/code&gt; 变量或函数可以声明多次，但是只初始化一次。但是不可以声明一次，初始化多次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int i=25;//initializing variable i
extern int i;//again declaring variable i
int main() {
extern int i;//again declaring variable i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：25
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern void sum(int,int);//by default it is extern function
int main() {
extern void sum(int,int);//by default it is extern function
int a=5,b=10;
sum(a,b);
return 0;
}
void sum(int a, int b) {
printf(&amp;quot;%d\n&amp;quot;, a+b);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int i=25;//initializing variable i
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
int i=20;//again initializing variable i
// 输出：编译错误(error: redefinition of ‘i’)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-2-默认存储类是-extern&#34;&gt;关键点 2：默认存储类是 extern&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 是所有全局变量和函数的默认存储类(storage class)，即全局变量和函数默认对整个程序可见，不需要声明或定义 &lt;code&gt;extern&lt;/code&gt; 函数。使用 &lt;code&gt;extern&lt;/code&gt; 关键字是多余的&lt;/li&gt;
&lt;li&gt;编译器会在全局函数的声明和定义前面自动加上 &lt;code&gt;extern&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在下面两个测试代码中，变量 &lt;code&gt;i&lt;/code&gt; 都是 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test1.c
#include &amp;lt;stdio.h&amp;gt;
int i;//definition of i: by default it is extern variable
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：0
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test2.c
#include &amp;lt;stdio.h&amp;gt;
extern int i;//extern variable
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误，未定义的引用(undefined reference to i)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// test3.c
#include &amp;lt;stdio.h&amp;gt;
void sum(int,int);//by default it is extern function
int main() {
int a=5,b=10;
sum(a,b);
return 0;
}
void sum(int a, int b) {
printf(&amp;quot;%d\n&amp;quot;, a+b);
}
// 输出：15
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-3-extern-变量或程序对整个程序可见&#34;&gt;关键点 3：extern 变量或程序对整个程序可见&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 关键字用于扩展变量或函数的可见性。如果全局声明一个 &lt;code&gt;extern&lt;/code&gt; 变量或函数，那么它的可见性是整个程序，这个程序可能包含一个或多个文件。比如一个 C 程序，包含两个文件 &lt;code&gt;one.c&lt;/code&gt; 和 &lt;code&gt;two.c&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面程序的输出是 30&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//one.c
#include &amp;lt;conio.h&amp;gt;
int i=25;//by default extern variable
int j=5;//by default extern variable
//above two lines is initialization of variable i and j
void main() {
clrscr();
sum();
getch();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//two.c
#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaration of variable i
extern int j;//declaration of variable j
//above tow lines will search the initialization statement of variable i and j either in two.c(if initialized variable id static and static)
// or one.c(if initialized variable is extern)
void sum() {//by default extern function
int s;
s = i + j;
printf(&amp;quot;%d\n&amp;quot;, s);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个 &lt;code&gt;extern&lt;/code&gt; 变量或函数有外部(external)链接，一个外部链接的变量或函数对所有文件可见&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern&lt;/code&gt; 作用于函数只是告诉编译链接是外部的；作用于变量只声明变量而不会定义(初始化或实例化)变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;关键点-4-extern-作用于变量&#34;&gt;关键点 4：extern 作用于变量&lt;/h2&gt;

&lt;h3 id=&#34;只用于声明变量&#34;&gt;只用于声明变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当对变量使用 &lt;code&gt;extern&lt;/code&gt; 修饰符时，它只用于声明(比如不会为这些变量分配内存)。因此在上述 &lt;code&gt;test2.c&lt;/code&gt; 中，编译器报错&lt;code&gt;undefined symbol&lt;/code&gt;。如果要定义变量(比如为 &lt;code&gt;extern&lt;/code&gt; 变量分配内存)，必须初始化变量&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化 &lt;code&gt;extern&lt;/code&gt; 变量即是定义 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i=10;//extern variable
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：10
// warning: ‘i’ initialized and declared ‘extern’
// 如果声明时也提供了初始化，那么会为变量分配内存，该变量认为是被定义过的
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编译警告参考&lt;a href=&#34;https://stackoverflow.com/questions/4268589/warning-in-extern-declaration&#34; target=&#34;_blank&#34;&gt;warning in extern declaration&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//extern variable
int main() {
return 0;
}
// 编译成功。只声明变量 i 但是未使用，不会报错
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果我们声明一个变量是 &lt;code&gt;extern&lt;/code&gt;，那么编译器会搜索这个变量是否已经初始化。如果已经初始化为 &lt;code&gt;extern&lt;/code&gt; 或 &lt;code&gt;static&lt;/code&gt; 则成功。否则编译器会报错&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;修正：初始化为 static 仍然报错????&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//it will search the initialization of i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
int i=20;//initialization of extern variable i
// 输出：20
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//it will search the initialization of i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
static int i=20;//initialization of static variable i
// 输出：编译错误(error: static declaration of ‘i’ follows non-static declaration)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;全局变量自动初始化&#34;&gt;全局变量自动初始化&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果全局变量不适用 &lt;code&gt;extern&lt;/code&gt; 关键字，编译器会使用默认值自动初始化 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;extern&lt;/code&gt; 整数类型变量的默认初始化值是 0 或者 null&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
char c;
int i;
float f;
char *str;
int main() {
printf(&amp;quot;%d %d %f %s\n&amp;quot;, c, i, f, str);
return 0;
}
// 输出：0 0 0.000000 (null)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;不能局部地初始化-extern-变量&#34;&gt;不能局部地初始化 extern 变量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不能在任何代码块内部局部地初始化 &lt;code&gt;extern&lt;/code&gt; 变量，不论是声明时初始化还是初始化和声明分开。我们只能全局地初始化 &lt;code&gt;extern&lt;/code&gt; 变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i=10;
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(error: ‘i’ has both ‘extern’ and initializer)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//declaration of extern variable i
int i=10;//try to locally initialize extern variable i
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(error: declaration of ‘i’ with no linkage follows extern declaration)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaration of extern variable i
int main() {
int i=10;//declare and define a local variable
printf(&amp;quot;%d\n&amp;quot;, i);//the i is local
return 0;
}
// 输出：10
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
int main() {
extern int i;//declaration of extern variable i, its memory is not allocated
i=10;//try to change the value of variable i to 10, but it doesn&#39;t exist
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(两处错误：undefined reference to i)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;不能写全局的赋值语句&#34;&gt;不能写全局的赋值语句&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;在声明变量时给变量赋值叫做初始化(initialization)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不在变量声明时给变量赋值叫做赋值(assignment)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int i=25;//initializing variable i
i=20;
int main() {
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
// 输出：编译错误(error: redefinition of ‘i’)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
extern int i;//declaring variable i
int main() {
i=20;//assignment
printf(&amp;quot;%d\n&amp;quot;, i);
return 0;
}
int i=25;//initialization
// 输出：20
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;对类成员无效&#34;&gt;对类成员无效&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 被类成员忽略&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;常见错误&#34;&gt;常见错误&lt;/h2&gt;

&lt;h3 id=&#34;未定义的行为&#34;&gt;未定义的行为&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://port70.net/~nsz/c/c11/n1570.html#6.9&#34; target=&#34;_blank&#34;&gt;Undefined behavior&lt;/a&gt;：使用了一个带外部链接的标识符，但是程序中不存在该标识符的外部定义，或者没有使用此标识符但是有多处定义此标识符&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;外部定义&#34;&gt;外部定义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://port70.net/~nsz/c/c11/n1570.html#6.9p5&#34; target=&#34;_blank&#34;&gt;External definitions&lt;/a&gt;：外部定义指一个外部声明，同事也是函数(除了内联函数)或对象的定义。如果一个表达式中使用了一个有外部链接的标识符(除了作为 &lt;code&gt;sizeof&lt;/code&gt;或&lt;code&gt;_Alignof&lt;/code&gt;运算符的操作数的一部分，这些运算符的结果是一个证书常数)，程序的其它地方应该有且仅有一个对此标识符的外部定义&lt;/li&gt;
&lt;li&gt;因此，如果一个声明为外部链接的标识符未在表达式中被使用，不应该有它的外部定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;多重外部定义&#34;&gt;多重外部定义&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://port70.net/~nsz/c/c11/n1570.html#J.5.11&#34; target=&#34;_blank&#34;&gt;Multiple external definitions&lt;/a&gt;：对于一个对象的标识符可能有多于一处的外部定义，这些定义可能有也可能没有显式使用 &lt;code&gt;extern&lt;/code&gt; 关键字；如果这些定义不一致，或者多于一处有初始化，就会导致 undefined behavior&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;头文件中变量的声明&#34;&gt;头文件中变量的声明&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;声明 &lt;code&gt;int some_var;&lt;/code&gt;：如果一个头文件不使用 &lt;code&gt;extern&lt;/code&gt; 定义一个变量，那么每个包含此头文件的文件都会尝试创建一个此变量的一个定义。但是 C 标准不确保这个一定会正常工作&lt;/li&gt;
&lt;li&gt;声明 &lt;code&gt;int some_var = 13;&lt;/code&gt;：如果头文件定义并初始化一个变量，那么在给定的程序中只有一个源文件可以使用这个头文件。因为头文件主要是用来共享信息的，创建一个只能使用一次的头文件不是好的做法&lt;/li&gt;
&lt;li&gt;声明 &lt;code&gt;static int some_var =3;&lt;/code&gt;：如果头文件定义一个静态变量(不论是否初始化)，那么每个源文件都会有此“全局”变量的一份私有拷贝。而且，如果这个变量是一个复杂的数组，那么会导致大量代码的拷贝&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cquestions.com/2011/02/extern-keyword-in-c.html&#34; target=&#34;_blank&#34;&gt;extern keyword in c&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/understanding-extern-keyword-in-c/&#34; target=&#34;_blank&#34;&gt;Understanding “extern” keyword in C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1433204/how-do-i-use-extern-to-share-variables-between-source-files&#34; target=&#34;_blank&#34;&gt;How do I use extern to share variables between source files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.dreamincode.net/forums/topic/171468-declarations-vs-definitions/&#34; target=&#34;_blank&#34;&gt;DECLARATIONS V.S. DEFINITIONS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>内联</title>
      <link>https://xueqing.github.io/blog/cplusplus/inline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/inline/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8f%8f%e8%bf%b0&#34;&gt;描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%af%e8%af%ad%e5%92%8c%e5%ae%9a%e4%b9%89&#34;&gt;术语和定义&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e8%af%91%e5%8d%95%e5%85%83&#34;&gt;编译单元&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8d%95%e5%ae%9a%e4%b9%89%e8%a7%84%e5%88%99&#34;&gt;单定义规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e8%81%94%e5%a3%b0%e6%98%8e&#34;&gt;内联声明&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;成员函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8d%e9%80%82%e5%90%88%e5%86%85%e8%81%94%e6%9b%bf%e6%8d%a2%e7%9a%84%e7%94%a8%e6%b3%95&#34;&gt;不适合内联替换的用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cc-staticextern--inline&#34;&gt;C/C++ static/extern + inline&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#c8990-inline&#34;&gt;C89/90 inline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c99-inline&#34;&gt;C99 inline&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-inline&#34;&gt;C++ inline&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gcc-%e7%bc%96%e8%af%91%e9%80%89%e9%a1%b9&#34;&gt;GCC 编译选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0%e5%af%b9%e5%ae%89%e5%85%a8%e6%80%a7%e5%92%8c%e9%80%9f%e5%ba%a6%e7%9a%84%e5%8f%96%e8%88%8d&#34;&gt;内联函数对安全性和速度的取舍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#inline-vs-micro&#34;&gt;inline vs micro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;问题&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98c99-inline-without-static-or-extern&#34;&gt;问题：C99 inline without static or extern&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++ 提出，C99 引入支持，C89 支持内联扩展&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;用于需要某个函数的定义对调用者可见的程序优化

&lt;ul&gt;
&lt;li&gt;可见性：函数需要有内部链接，或者外部链接且和调用者在同一个编译单元。此时，函数声明或定义中的&lt;code&gt;inline&lt;/code&gt;只用于指示对这个函数的调用可被展开优化&lt;/li&gt;
&lt;li&gt;当调用者和被调用的函数定义位于不同的编译单元时，&lt;code&gt;inline&lt;/code&gt;支持包含调用者的编译单元也包含一个局部(内联)的函数的定义&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;用于声明一个内联函数，可使 GCC 直接更快地调用此函数

&lt;ul&gt;
&lt;li&gt;GCC 可以将内联函数代码展开插入到调用者代码内部，因此减少了函数调用(寄存器状态的修改保存)的负载&lt;/li&gt;
&lt;li&gt;如果实参的值是常量，可在编译时计算简化，因此不是所有内联函数代码都会被包含&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可使用&lt;code&gt;-finline-functions&lt;/code&gt;选项指定 GCC 将所有“足够简单”的函数展开插入到调用者内部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inline&lt;/code&gt;用于多个编译单元调用某个函数，但是只想暴露该函数的定义在一个头文件&lt;/li&gt;
&lt;li&gt;在关闭优化时，GCC 不会内联任何函数，必须在某处定义符号，&lt;code&gt;inline&lt;/code&gt;声明定义的函数才是可见的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;术语和定义&#34;&gt;术语和定义&lt;/h2&gt;

&lt;h3 id=&#34;编译单元&#34;&gt;编译单元&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c&#34; target=&#34;_blank&#34;&gt;What is a “translation unit” in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;编译单元(compilation/translation unit): C++ 编译的基础单元。包括一个单独的源文件，以及直接或间接包含的头文件的内容，减去条件预处理忽视的内容&lt;/li&gt;
&lt;li&gt;一个编译单元可被编译成一个目标文件、库或可执行程序&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;单定义规则&#34;&gt;单定义规则&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/4192170/what-exactly-is-one-definition-rule-in-c&#34; target=&#34;_blank&#34;&gt;What exactly is One Definition Rule in C++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;单定义规则(one-definition rule)：每个程序对于其使用的每个非内联函数或对象应该只包含一个定义。定义可以显式出现在该程序中，可在标准库或用户定义的库中查找，或者隐式定义。内联函数应在每个使用的编译单元中定义&lt;/li&gt;
&lt;li&gt;每个编译单元对于所有的变量、函数、类的类型、枚举类型或模板不超过一个定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内联声明&#34;&gt;内联声明&lt;/h2&gt;

&lt;h3 id=&#34;非成员函数&#34;&gt;非成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;GCC 实现三种语法来声明内联函数

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;-finline-functions&lt;/code&gt;，同时指定参数&lt;code&gt;-std=gnu89/fgnu89-inline&lt;/code&gt;，或所有内联函数声明处有&lt;code&gt;gnu-inline&lt;/code&gt;属性&lt;/li&gt;
&lt;li&gt;指定参数&lt;code&gt;-std=c99/-std=gnu99&lt;/code&gt;，或者使用更新的 C 版本&lt;/li&gt;
&lt;li&gt;编译 C++ 代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用&lt;code&gt;inline&lt;/code&gt;关键字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static inline int inc(int *a)
{
return (*a)++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果在 ISO C90 程序的头文件中声明内联，使用&lt;code&gt;__inline__&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上述三种类型的内联行为再两种情况下是行为是类似的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用于&lt;code&gt;static&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;第一次声明时未使用&lt;code&gt;inline&lt;/code&gt;关键字，定义时使用&lt;code&gt;inline&lt;/code&gt;关键字&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;除了速度，上述两种方式和不使用&lt;code&gt;inline&lt;/code&gt;关键字行为相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;extern int inc(int *a);
inline int inc(int *a)
{
return (*a)++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个函数是&lt;code&gt;static inline&lt;/code&gt;时，如果所有调用函数的地方展开插入了此函数的代码，而且函数的地址从未被使用，那么函数自己的汇编代码从未被引用。这种情况下，除非使用&lt;code&gt;-fkeep-inline-functions&lt;/code&gt;，GCC 实际上不会为此函数生成汇编代码。如果有一处调用未展开插入代码，那么正常生成汇编代码；如果程序引用了该地址，函数必须正常编译，因为此处不能被内联&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：除非是在一个&lt;code&gt;.cpp&lt;/code&gt;文件使用，必须将内联函数定义放在一个头文件，然后从其他&lt;code&gt;.cpp&lt;/code&gt;调用，否则会有链接错误&lt;code&gt;unresolved external&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;成员函数&#34;&gt;成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GCC 将定义在类内的成员函数视作内联函数(可没有&lt;code&gt;inline&lt;/code&gt;)。可使用&lt;code&gt;-fno-default-inline&lt;/code&gt;覆盖&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Fred {
public:
void f(int i, char c)
{
  // ...
}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类似声明非成员函数：声明时不带&lt;code&gt;inline&lt;/code&gt;，定义时使用&lt;code&gt;inline&lt;/code&gt;，在类外部定义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;建议使用此方式，以隐藏类的实现&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Foo {
public:
void method();  // Best practice: Don&#39;t put the inline keyword here
// ...
};

inline void Foo::method()  // Best practice: Put the inline keyword here
{
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：必须将内联函数定义放在一个头文件，然后从其他&lt;code&gt;.cpp&lt;/code&gt;调用，否则会有链接错误&lt;code&gt;unresolved external&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;不适合内联替换的用法&#34;&gt;不适合内联替换的用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;函数定义包含下面用法的不适合内联替换

&lt;ul&gt;
&lt;li&gt;可变参数函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;alloca&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;使用计算的&lt;code&gt;goto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用非本地的&lt;code&gt;goto&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用嵌入函数&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;setjmp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;__builtin_longjmp&lt;/code&gt;/&lt;code&gt;__builtin_return&lt;/code&gt;/&lt;code&gt;__built_apply_args&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c-c-static-extern-inline&#34;&gt;C/C++ static/extern + inline&lt;/h2&gt;

&lt;h3 id=&#34;c89-90-inline&#34;&gt;C89/90 inline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;inline：可能会被内联展开。总会生成非内联版本且对外部可见。只在一个编译单元定义，其他编译单元可见且视为非内联函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;每个编译单元只会拥有该函数的拷贝，每个拷贝只对编译单元内部可见，且拷贝之间不会有冲突。缺点包括两部分&lt;/li&gt;
&lt;li&gt;大型工程中，可能包含很多相同函数的拷贝，导致目标代码增大&lt;/li&gt;
&lt;li&gt;不太可能比较函数指针，因为不确定是哪份拷贝版本&lt;/li&gt;
&lt;li&gt;C89 编译器支持内联扩展&lt;/li&gt;
&lt;li&gt;MVC++：&lt;code&gt;__forceinline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GCC/Clang：在不优化时，除非指定&lt;code&gt;always_inline&lt;/code&gt;属性，GCC 不会内联任何函数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__attribute__((always_inline))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__attribute__((__always_inline__))&lt;/code&gt;：可避免与用户定义的宏&lt;code&gt;always_inline&lt;/code&gt;冲突&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;编译器在某些情况下不能内联替换，此时会有编译警告&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建议使用下面的可移植代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#ifdef _MSC_VER
#define forceinline __forceinline
#elif defined(__GNUC__)
#define forceinline inline __attribute__((__always_inline__))
#elif defined(__CLANG__)
#if __has_attribute(__always_inline__)
    #define forceinline inline __attribute__((__always_inline__))
#else
    #define forceinline inline
#endif
#else
#define forceinline inline
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;extern inline：不会生成非内联版本对外部可见，但是可以调用(必须在其他编译单元定义，且调用的代码和内联代码相同)，&lt;code&gt;one-definition&lt;/code&gt;的原则适用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;原因：C89 中定义为&lt;code&gt;extern&lt;/code&gt;的存储不会被保留，而不带&lt;code&gt;extern&lt;/code&gt;的存储一定会保留；C99 的&lt;code&gt;extern inline&lt;/code&gt;会生成非内联函数&lt;/li&gt;
&lt;li&gt;类似宏。使用方式是将函数定义(同时指定&lt;code&gt;inline&lt;/code&gt;和&lt;code&gt;extern&lt;/code&gt;关键字)放在一个头文件中，把另一个定义的拷贝(不指定&lt;code&gt;inline&lt;/code&gt;和&lt;code&gt;extern&lt;/code&gt;关键字)放在一个库文件中。头文件的定义使得大部分函数调用都是内联展开的。如果存在其他编译单元的函数调用，引用这个库文件的唯一拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static inline：不会生成外部可见的非内联版本，但是可能会生成一个局部可见的函数，&lt;code&gt;one-definition&lt;/code&gt;的原则不适用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c99-inline&#34;&gt;C99 inline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;inline：类似 C89/90的&lt;code&gt;extern inline&lt;/code&gt;，不会生成外部可见代码，但是可以调用(必须在其他编译单元定义，且调用的代码和内联代码相同)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在头文件(.h)中使用&lt;code&gt;inline&lt;/code&gt;定义，在一个编译单元的源文件(.c)中使用&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;inline&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//.h
inline double dabs(double x) {return x &amp;lt; 0.0 ? -x : x;}
//.c
extern inline double dabs(double x);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;extern inline：类似 C89/90的&lt;code&gt;inline&lt;/code&gt;，不会生成外部可见代码，至多一个编译单元可以使用此函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;定义为&lt;code&gt;inline&lt;/code&gt;的函数要求：程序的其他地方有且只有一处需要声明该函数为&lt;code&gt;extern inline&lt;/code&gt;或没有修饰符&lt;/li&gt;
&lt;li&gt;如果有多处声明，链接器会报重复的符号错误&lt;/li&gt;
&lt;li&gt;其他地方没有声明，链接器不会报错&lt;/li&gt;
&lt;li&gt;建议：在头文件定义&lt;code&gt;inline&lt;/code&gt;函数，为每个函数创建一个&lt;code&gt;.c&lt;/code&gt;文件，包含该函数的&lt;code&gt;extern inline&lt;/code&gt;声明以及对应的头文件：声明和包含头文件的语句先后无关&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static inline：类似 C89/90，二者之间相同&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-inline&#34;&gt;C++ inline&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;inline：一处内联其他所有地方都会内联。编译器/链接器会排序该符号的多个实例

&lt;ul&gt;
&lt;li&gt;在头文件定义，对整个工程可见；且如果不能展开替换，只会生成一个外部符号&lt;/li&gt;
&lt;li&gt;在所有地方有相同的定义，必须有&lt;code&gt;inline&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;类内定义的函数会自动添加&lt;code&gt;inline&lt;/code&gt;修饰符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;extern inline：没有此定义，支持的编译器行为类似 C89/90&lt;/li&gt;
&lt;li&gt;static inline：没有此定义，支持的编译器行为类似 C89/90&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gcc-编译选项&#34;&gt;GCC 编译选项&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;GCC 版本大于等于 4.2：使用 C89 的&lt;code&gt;inline&lt;/code&gt;语法，即使显式指定了&lt;code&gt;-std=c99&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;GCC 版本是 5：GCC 使用 gnu11 的语法，默认使用 C99 的&lt;code&gt;inline&lt;/code&gt;语法

&lt;ul&gt;
&lt;li&gt;显式指定&lt;code&gt;-std=gnu89&lt;/code&gt;：使用 C89 语法&lt;/li&gt;
&lt;li&gt;指定&lt;code&gt;-fgnu89-inline&lt;/code&gt;或在所有&lt;code&gt;inline&lt;/code&gt;声明处增加&lt;code&gt;gnu_inline&lt;/code&gt;属性：使用 C89 语法，只会影响内联&lt;/li&gt;
&lt;li&gt;指定&lt;code&gt;-std=c99&lt;/code&gt;或&lt;code&gt;-std=c11&lt;/code&gt;或&lt;code&gt;-std=gnu99&lt;/code&gt;(不带&lt;code&gt;-fgnu89-inline&lt;/code&gt;)：确定使用 C99 语法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;-winline&lt;/code&gt;：当标记为&lt;code&gt;inline&lt;/code&gt;的函数不可替换时，编译警告&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内联函数对安全性和速度的取舍&#34;&gt;内联函数对安全性和速度的取舍&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C 语言中，可以通过在结构体中放一个&lt;code&gt;void*&lt;/code&gt;实现对结构体的封装，即结构体的使用者不知道&lt;code&gt;void*&lt;/code&gt;指向的真正的数据，但可以通过调用函数将&lt;code&gt;void*&lt;/code&gt;转成合适的隐藏类型。这个做法会破坏类型的安全性，也会包括对结构体其他字段的访问(如果允许直接访问结构体的域，需要知道如何解释&lt;code&gt;void*&lt;/code&gt;的使用者就可以直接访问结构体，使得很难修改底层的数据结构)&lt;/li&gt;
&lt;li&gt;包含内联函数的目标代码的大小和执行速度的影响是不可预测的

&lt;ul&gt;
&lt;li&gt;时间性能：以空间换时间&lt;/li&gt;
&lt;li&gt;可使程序变快

&lt;ul&gt;
&lt;li&gt;减少函数调用的代价&lt;/li&gt;
&lt;li&gt;可移除函数调用所需的指令：栈和寄存器的使用&lt;/li&gt;
&lt;li&gt;不需要寄存器传递参数&lt;/li&gt;
&lt;li&gt;在引用调用、地址调用或共享调用时，不需要引用和解引用&lt;/li&gt;
&lt;li&gt;支持高级优化和调度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可使程序变慢：内联展开会增加代码大小，在内存页有限的情况下，可能增加内存页的置换和磁盘的读写&lt;/li&gt;
&lt;li&gt;目标代码大小&lt;/li&gt;
&lt;li&gt;可使程序变大：通常状况下展开代码类似于拷贝代码&lt;/li&gt;
&lt;li&gt;可使程序变小：展开函数时，编译器可能会优化代码，移除不必要的代码&lt;/li&gt;
&lt;li&gt;内存性能&lt;/li&gt;
&lt;li&gt;系统抖动(内存页置换)

&lt;ul&gt;
&lt;li&gt;调用的内联函数和当前函数可能位于不同的页，内联展开可能使其位于同一个页，可避免系统抖动&lt;/li&gt;
&lt;li&gt;可能增大二进制可执行文件大小，导致系统抖动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缓存未命中

&lt;ul&gt;
&lt;li&gt;内联通常改善了二进制代码内部引用的局部性，可减少使用缓存行来存储内部循环，使得 CPU 受限的应用运行更快&lt;/li&gt;
&lt;li&gt;可能导致对多个缓存行的循环处理，导致缓存抖动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可能和运行速度无关：大部分系统不是 CPU 受限的，而是 I/O、数据库或网络受限的，即系统整个性能的瓶颈在于文件系统、数据库或网络。因此，除非 CPU 固定在 100%，内联函数不会使得程序运行更快&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;inline-vs-micro&#34;&gt;inline vs micro&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;展开时间不同

&lt;ul&gt;
&lt;li&gt;内联展开发生在编译时，不会修改源码(text)&lt;/li&gt;
&lt;li&gt;宏展开发生在编译之前，生成不同的 text 再给编译器处理，会污染命名空间和代码，不利于调试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类型检查：C 语言中宏调用没有类型检查；内联函数会检查参数类型，必须正确执行类型转换&lt;/li&gt;
&lt;li&gt;C 语言中，宏不能像函数一样调用&lt;code&gt;return&lt;/code&gt;关键字，不能终止调用者&lt;/li&gt;
&lt;li&gt;编译错误：宏内的编译错误很难理解，因为指向的是展开的代码，而不是源代码&lt;/li&gt;
&lt;li&gt;递归：很多编译器可以内联递归函数，但是递归宏是不允许的

&lt;ul&gt;
&lt;li&gt;有的编译器可控制递归展开的深度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码的可维护性：随着函数改进，函数的内联属性可能会变化，一个函数内联与否比宏的修改要简单&lt;/li&gt;
&lt;li&gt;宏的其他问题

&lt;ul&gt;
&lt;li&gt;含&lt;a href=&#34;https://isocpp.org/wiki/faq/misc-technical-issues#macros-with-if&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;含&lt;a href=&#34;https://isocpp.org/wiki/faq/misc-technical-issues#macros-with-multi-stmts&#34; target=&#34;_blank&#34;&gt;多个语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;含&lt;a href=&#34;https://isocpp.org/wiki/faq/misc-technical-issues#macros-with-token-pasting&#34; target=&#34;_blank&#34;&gt;令牌黏贴&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内联函数避免上述问题：内联函数检查每个参数一次，类似于调用普通函数，但是更快&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// A macro that returns the absolute value of i
#define unsafe(i) ( (i) &amp;gt;= 0 ? (i) : -(i) )

// An inline function that returns the absolute value of i
inline int safe(int i) { return i &amp;gt;= 0 ? i : -i; }

int f();

void userCode(int x)
{
int ans;

ans = unsafe(x++);   // Error! x is incremented twice
ans = unsafe(f());   // Danger! f() is called twice

ans = safe(x++);     // Correct! x is incremented once
ans = safe(f());     // Correct! f() is called once
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;编译器不一定会内联程序员指定的函数

&lt;ul&gt;
&lt;li&gt;模板方法/函数不是总被内联展开&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;内联函数的代码暴露给调用者&lt;/li&gt;
&lt;li&gt;传统的 C 编译系统会增加内联编译时间，因为会拷贝函数体到调用者&lt;/li&gt;
&lt;li&gt;C99 的要求

&lt;ul&gt;
&lt;li&gt;如果在别处使用某内联函数，只能有一个&lt;code&gt;extern&lt;/code&gt;声明。当关掉优化禁止内联时，如果没有会有链接错误&lt;/li&gt;
&lt;li&gt;如果增加声明，放到一个库进行链接，使用链接时优化或&lt;code&gt;static inline&lt;/code&gt;，可能导致不能到达的代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C++中，普通函数只需要在一个模块中定义，但是需要在每个模块中定义使用的内联函数，否则不能编译某个单独的模块(依赖其他模块)。视编译器而定，可能会导致不能内联替换的模块的对象文件包含函数的拷贝&lt;/li&gt;
&lt;li&gt;在嵌入式软件中，可能通过类似&lt;code&gt;pragma&lt;/code&gt;编译指令将一些函数放到代码段。如果一个内存段的代码调用另一个内存段的代码，如果被调用函数内部有内联，那么可能会停到一个不应该的段。比如高性能的内存段代码空间有限，如果内部函数调用另一个高性能内存之外的函数，且被调用函数较大，内部有内联的话，可能会超出高性能内存的空间&lt;/li&gt;
&lt;li&gt;C++ 编译时链接，因此如果修改了内联函数，必须重新编译使用此函数的所有代码&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;问题-c99-inline-without-static-or-extern&#34;&gt;问题：C99 inline without static or extern&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/26503235/c-inline-function-and-gcc&#34; target=&#34;_blank&#34;&gt;C, inline function and GCC [duplicate]&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/6312597/is-inline-without-static-or-extern-ever-useful-in-c99&#34; target=&#34;_blank&#34;&gt;Is “inline” without “static” or “extern” ever useful in C99&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/16245521/c99-inline-function-in-c-file/16245669#16245669&#34; target=&#34;_blank&#34;&gt;C99 inline function in .c file&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// main.cpp
inline int foo() {return 10 + 3;}

int main() {foo(); return 0;}
// g++ -std=c99 -x c main.cpp
// gcc -std=c99 -o a main.cpp
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;GCC 链接错误&lt;code&gt;undefined reference to foo&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;问题：&lt;code&gt;inline&lt;/code&gt;只是声明内联函数，不会生成实际的代码，但是&lt;code&gt;extern&lt;/code&gt;和&lt;code&gt;static&lt;/code&gt;用于告诉编译器将函数放在哪个对象文件，用于编译生成对应的代码(可能是拷贝)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解决方案：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;增加&lt;code&gt;extern inline int foo();&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;增加&lt;code&gt;static&lt;/code&gt;修饰符，告诉编译器&lt;code&gt;有且只在这里&lt;/code&gt;，以便生成对应代码&lt;/li&gt;
&lt;li&gt;或使用&lt;code&gt;-O&lt;/code&gt;优化代码，编译器将标记为&lt;code&gt;inline&lt;/code&gt;的代码内联展开，在这里会忽略这部分代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Inline_function&#34; target=&#34;_blank&#34;&gt;Inline function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gcc.gnu.org/onlinedocs/gcc/Inline.html&#34; target=&#34;_blank&#34;&gt;An Inline Function is As Fast As a Macro&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/inline-functions&#34; target=&#34;_blank&#34;&gt;inline functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gustedt.wordpress.com/2010/11/29/myth-and-reality-about-inline-in-c99/&#34; target=&#34;_blank&#34;&gt;Myth and reality about inline in C99&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>可重入性</title>
      <link>https://xueqing.github.io/blog/cplusplus/reentrant/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/reentrant/</guid>
      <description>&lt;p&gt;常见的线程不安全函数和对应的 unix 下的线程安全函数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;保持跨越多个调用状态的函数

&lt;ul&gt;
&lt;li&gt;rand，对应 rand_r&lt;/li&gt;
&lt;li&gt;strtok，对应 strtok_r&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;返回指向静态变量的指针的函数

&lt;ul&gt;
&lt;li&gt;asctime，对应 asctime_r&lt;/li&gt;
&lt;li&gt;ctime，对应 ctime_r&lt;/li&gt;
&lt;li&gt;gethostbyaddr，对应 gethostbyaddr_r&lt;/li&gt;
&lt;li&gt;gethostbyname，对应 gethostbyname_r&lt;/li&gt;
&lt;li&gt;inet_ntoa，&lt;/li&gt;
&lt;li&gt;localtime，对应 localtime_r&lt;/li&gt;
&lt;li&gt;gmtime，对应 gmtime_r&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可重入性

&lt;ul&gt;
&lt;li&gt;可重入函数（reentrant function）：当被多个线程调用时，不会引入任何共享数据&lt;/li&gt;
&lt;li&gt;可重入函数是线程安全函数的一个真子集&lt;/li&gt;
&lt;li&gt;显式可重入（explicitly reentrant）：函数都是传值传递的（即没有指针），并且所有的数据引用都是本地的自动栈变量（即没有引用静态或全局变量）&lt;/li&gt;
&lt;li&gt;隐式可重入（implicitly reentrant）：函数的一些参数是引用传递的（允许传递指针），传递的是非共享数据的指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>异常</title>
      <link>https://xueqing.github.io/blog/cplusplus/exception/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/exception/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8&#34;&gt;为什么使用异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8&#34;&gt;C++ 使用异常&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8%e7%9a%84%e5%8f%8d%e5%af%b9%e8%a7%82%e7%82%b9&#34;&gt;使用异常的反对观点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%bf%e4%bb%a3%e6%96%b9%e6%a1%88%e9%80%9a%e8%bf%87%e5%88%a4%e6%96%ad%e6%88%96%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc%e6%a3%80%e6%9f%a5%e9%94%99%e8%af%af&#34;&gt;替代方案：通过判断或函数返回值检查错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-trycatchthrow-%e8%80%8c%e4%b8%8d%e6%98%af%e6%9d%a1%e4%bb%b6%e5%88%a4%e6%96%ad%e5%92%8c%e8%bf%94%e5%9b%9e%e9%94%99%e8%af%af%e7%a0%81%e6%9d%a5%e6%94%b9%e5%96%84%e8%bd%af%e4%bb%b6%e8%b4%a8%e9%87%8f&#34;&gt;使用 try/catch/throw 而不是条件判断和返回错误码来改善软件质量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e4%be%bf%e4%ba%8e%e4%bc%a0%e9%80%92%e9%94%99%e8%af%af%e4%bf%a1%e6%81%af&#34;&gt;异常便于传递错误信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e4%bd%bf%e5%be%97%e4%bb%a3%e7%a0%81%e6%9b%b4%e7%ae%80%e6%b4%81&#34;&gt;异常使得代码更简洁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%82%e5%b8%b8%e6%9b%b4%e6%98%93%e5%8c%ba%e5%88%86%e6%ad%a3%e5%b8%b8%e6%89%a7%e8%a1%8c%e7%9a%84%e4%bb%a3%e7%a0%81&#34;&gt;异常更易区分正常执行的代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%bc%82%e5%b8%b8%e5%a4%84%e7%90%86%e9%94%99%e8%af%af%e6%98%af%e5%80%bc%e5%be%97%e7%9a%84&#34;&gt;使用异常处理错误是值得的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%8f%af%e4%bb%a5%e6%8a%9b%e5%bc%82%e5%b8%b8&#34;&gt;构造函数可以抛异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%8d%e6%8a%9b%e5%bc%82%e5%b8%b8&#34;&gt;析构函数不抛异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8a%9b%e5%87%ba%e4%bb%80%e4%b9%88%e5%bc%82%e5%b8%b8&#34;&gt;抛出什么异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8d%95%e8%8e%b7%e4%bb%80%e4%b9%88%e5%bc%82%e5%b8%b8&#34;&gt;捕获什么异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#throw-%e5%86%8d%e6%ac%a1%e6%8a%9b%e5%bc%82%e5%b8%b8&#34;&gt;throw 再次抛异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e8%a7%a3&#34;&gt;注解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;为什么使用异常&#34;&gt;为什么使用异常&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用异常处理错误使得代码更简单、更干净，并且更不可能错过错误。使用 &lt;code&gt;errno&lt;/code&gt; 和 &lt;code&gt;if&lt;/code&gt; 语句使得错误处理和普通代码紧密缠绕，因此代码更加凌乱，也更难确保已经处理了所有的错误。&lt;/li&gt;
&lt;li&gt;构造函数的工作是创建类的不变性(创建成员函数运行的环境)，这经常需要获取如内存、锁、文件、套接字等资源，即 &lt;a href=&#34;https://zh.cppreference.com/w/cpp/language/raii&#34; target=&#34;_blank&#34;&gt;RAII&lt;/a&gt;(Resource Acquisition Is Initialization)。&lt;/li&gt;
&lt;li&gt;报告一个构造函数检查到的错误需要抛异常实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c-使用异常&#34;&gt;C++ 使用异常&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;C++ 中，异常用于指示内部不能处理的错误，比如构造函数内部获取资源失败。&lt;/li&gt;
&lt;li&gt;不要使用异常作为函数的返回值。&lt;/li&gt;
&lt;li&gt;C++ 使用异常来支持错误处理：

&lt;ul&gt;
&lt;li&gt;使用 &lt;code&gt;throw&lt;/code&gt; 指示错误(函数不能处理错误，或者暴露错误的后置条件)。&lt;/li&gt;
&lt;li&gt;在知道可以处理错误的时候使用 &lt;code&gt;catch&lt;/code&gt; 指定错误处理行为(可以翻译成另一种类型并且重新抛出)。&lt;/li&gt;
&lt;li&gt;不要使用 &lt;code&gt;throw&lt;/code&gt; 指示调用函数的代码错误。而是使用 &lt;code&gt;assert&lt;/code&gt; 或其他机制，或者发送进程给调试器，或者使得进程崩溃并收集崩溃日志以便程序员调试。&lt;/li&gt;
&lt;li&gt;当发现对组件不变式的意外违反时，不要使用 &lt;code&gt;throw&lt;/code&gt;，使用 &lt;code&gt;throw&lt;/code&gt; 或其他机制来终止程序。抛出异常不能解决内存崩溃甚至会导致后续使用数据的错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用异常的反对观点&#34;&gt;使用异常的反对观点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;异常是昂贵的：和没有错误处理相比，现代 C++ 实现已经将异常的负载降到 3% 左右。正常情况不抛异常，比使用返回值和检查代码运行更快。只有出现错误才会有负载。&lt;/li&gt;
&lt;li&gt;JSF++ 禁止异常：JSF++ 是&lt;a href=&#34;https://stackoverflow.com/questions/17308956/differences-between-hard-real-time-soft-real-time-and-firm-real-time&#34; target=&#34;_blank&#34;&gt;硬实时&lt;/a&gt;和严格安全性的应用(飞机控制系统)。我们必须保证响应时间，所以我们不能使用异常，甚至禁止使用释放分配的存储。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 new 调用构造函数抛异常会导致内存泄漏：这是旧编译器的 bug，现在早已经解决了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;T *p= new T;//将被编译器转换给类似下面的代码
void  allocate_and_construct()
{
// 第一步，分配原始内存，若失败则抛出bad_alloc异常
try
{
    // 第二步，调用构造函数构造对象
    new (p)T;       // placement new: 只调用T的构造函数
}
catch(...)
{
    delete p;     // 释放第一步分配的内存
    throw;          // 重抛异常，通知应用程序
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;替代方案-通过判断或函数返回值检查错误&#34;&gt;替代方案：通过判断或函数返回值检查错误&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;ofstream os(&amp;quot;myfile&amp;quot;);//需要打开一个文件
if(os.bad()) { /*打开失败需要处理错误*/ }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可以通过函数返回一个错误码或设置一个局部变量(如 errno)。

&lt;ul&gt;
&lt;li&gt;不使用全局变量：全局变量需要立即检查，因为其他函数可能会重置它；多线程也会有问题。&lt;/li&gt;
&lt;li&gt;这就需要测试每个对象。当类由许多对象组成，尤其是这些子对象互相依赖时，会导致代码一团糟。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;但是检查返回值要求智慧甚至不可能达到目的。比如下面的代码&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对于 my_negate 函数，每一个 int 返回值都是正确的，但是当使用二进制补码表示的时候，是没有最大负数的，可参考&lt;a href=&#34;http://blog.sina.com.cn/s/blog_624e65810100xm3m.html&#34; target=&#34;_blank&#34;&gt;C语言中INT_MIN的一些问题&lt;/a&gt;。这种情况下，就需要返回值对，分别表示错误码和运算结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double d = my_sqrt(-1);//错误返回 -1
if(d == -1) { /*处理错误*/ }
int x = my_negate(INT_MIN);//额。。。
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-try-catch-throw-而不是条件判断和返回错误码来改善软件质量&#34;&gt;使用 try/catch/throw 而不是条件判断和返回错误码来改善软件质量&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;条件语句更易犯错&lt;/li&gt;
&lt;li&gt;延迟发布时间：白盒测试需要覆盖所有条件分支&lt;/li&gt;
&lt;li&gt;增加开发花费：非必须的条件控制增加了发现 bug、解决 bug 和测试的复杂度&lt;/li&gt;
&lt;li&gt;检测到错误的代码通常需要传递错误信息，这可能是多层函数调用，这种情况下每一层调用函数都需要添加判断代码和返回值；而异常可以更简洁、干净地传递错误信息到可以处理错误的调用者&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;异常便于传递错误信息&#34;&gt;异常便于传递错误信息&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f1()
{
try {
// ...
f2();
// ...
} catch (some_exception&amp;amp; e) {
// ...code that handles the error...
}
}

void f2() { ...; f3(); ...; }
// f3 到 f9 逐层调用，f9 调用 f10

void f10()
{
// ...
if ( /*...some error condition...*/ )
throw some_exception();
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f1()
{
// ...
int rc = f2();
if (rc == 0) {
// ...
} else {
// ...code that handles the error...
}
}

int f2()
{
// ...
int rc = f3();
if (rc != 0)
return rc;
// ...
return 0;
}

// f3 到 f9 都需要增加判断代码

int f10()
{
// ...
if (...some error condition...)
return some_nonzero_error_code;
// ...
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;异常使得代码更简洁&#34;&gt;异常使得代码更简洁&lt;/h4&gt;

&lt;p&gt;Number 类支持加减乘除 4 种基本运算，但是加会溢出，除会导致除 0 错误或向下溢出等等&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(Number x, Number y)
{
try {
// ...
Number sum  = x + y;
Number diff = x - y;
Number prod = x * y;
Number quot = x / y;
// ...
}
catch (Number::Overflow&amp;amp; exception) {
// ...code that handles overflow...
}
catch (Number::Underflow&amp;amp; exception) {
// ...code that handles underflow...
}
catch (Number::DivideByZero&amp;amp; exception) {
// ...code that handles divide-by-zero...
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f(Number x, Number y)
{
// ...

Number::ReturnCode rc;
Number sum = x.add(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

Number diff = x.sub(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

Number prod = x.mul(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

Number quot = x.div(y, rc);
if (rc == Number::Overflow) {
// ...code that handles overflow...
return -1;
} else if (rc == Number::Underflow) {
// ...code that handles underflow...
return -1;
} else if (rc == Number::DivideByZero) {
// ...code that handles divide-by-zero...
return -1;
}

// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;异常更易区分正常执行的代码&#34;&gt;异常更易区分正常执行的代码&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f()  // Using exceptions
{
try {
GResult gg = g();
HResult hh = h();
IResult ii = i();
JResult jj = j();
// ...
}
catch (FooError&amp;amp; e) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
}
catch (BarError&amp;amp; e) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不使用异常&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int f()  // Using return-codes
{
int rc;  // &amp;quot;rc&amp;quot; stands for &amp;quot;return code&amp;quot;

GResult gg = g(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

HResult hh = h(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

IResult ii = i(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

JResult jj = j(rc);
if (rc == FooError) {
// ...code that handles &amp;quot;foo&amp;quot; errors...
} else if (rc == BarError) {
// ...code that handles &amp;quot;bar&amp;quot; errors...
} else if (rc != Success) {
return rc;
}

// ...

return Success;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用异常处理错误是值得的&#34;&gt;使用异常处理错误是值得的&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用异常处理错误需要付出

&lt;ul&gt;
&lt;li&gt;异常处理要求原则和严谨：需要学习；&lt;/li&gt;
&lt;li&gt;异常处理不是万能药：如果团队是草率没有纪律的，那么使用异常和返回值都会有问题&lt;/li&gt;
&lt;li&gt;异常处理不是通用的：应当知道什么条件应该使用返回值，什么条件使用异常&lt;/li&gt;
&lt;li&gt;异常处理会鞭策学习新技术&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;构造函数可以抛异常&#34;&gt;构造函数可以抛异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;当不能正确初始化或构造一个对象时，&lt;strong&gt;应该&lt;/strong&gt;在构造函数内部抛出异常

&lt;ul&gt;
&lt;li&gt;构造函数没有返回值，所以不能使用返回错误码的方式&lt;/li&gt;
&lt;li&gt;最差的方式是使用一个内部状态码来判断是否构造成功，但是需要在每次调用构造函数的时候使用 &lt;code&gt;if&lt;/code&gt; 检查状态码，或者在成员函数内部增加 &lt;code&gt;if&lt;/code&gt; 检查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造函数抛异常也不会有内存泄漏&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;构造函数抛异常时，对象的析构函数不会运行。因为对象的生命周期是构造函数成功完成或返回，抛异常表示构造失败，生命周期没有开始。因此需要将 undone 的东西保存在对象的数据成员&lt;/li&gt;

&lt;li&gt;&lt;p&gt;比如使用智能指针保存分配的成员对象，而不是保存到原始的 Fred* 数据成员&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Fred.h
#include &amp;lt;memory&amp;gt;

class Fred {
public:
//typedef 简化了使用 Fred 对象的语法，可以使用Fred::Ptr 取代 std::unique_ptr&amp;lt;Fred&amp;gt;
typedef std::unique_ptr&amp;lt;Fred&amp;gt; Ptr;
// ...
};

//调用者 cpp
#include &amp;quot;Fred.h&amp;quot;

void f(std::unique_ptr&amp;lt;Fred&amp;gt; p);  // explicit but verbose
void f(Fred::Ptr             p);  // simpler

void g()
{
std::unique_ptr&amp;lt;Fred&amp;gt; p1( new Fred() );  // explicit but verbose
Fred::Ptr             p2( new Fred() );  // simpler
// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;析构函数不抛异常&#34;&gt;析构函数不抛异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;析构函数抛异常会导致异常点之后的代码不能指向，可能造成内存泄漏问题&lt;/li&gt;
&lt;li&gt;可以在析构函数抛异常，但是该异常不能出析构函数，即需要在析构函数内部使用 &lt;code&gt;catch&lt;/code&gt; 捕获异常。否则会破坏标准库和语言的规则。&lt;/li&gt;
&lt;li&gt;处理方式是：

&lt;ul&gt;
&lt;li&gt;可以写信息到日志文件，终止进程。&lt;/li&gt;
&lt;li&gt;提供一个普通函数执行可能抛异常的操作，给客户处理错误。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;C++ 规则是异常的 “栈展开(stack unwinding)” 进程中调用的析构函数不能抛异常：

&lt;ul&gt;
&lt;li&gt;“stack unwinding”：当抛出一个异常时，栈是 “unwound” 的，因此在 &lt;code&gt;throw&lt;/code&gt; 和 &lt;code&gt;catch&lt;/code&gt; 之间的&lt;a href=&#34;https://www.techopedia.com/definition/22304/stack-frame&#34; target=&#34;_blank&#34;&gt;栈帧&lt;/a&gt;会被弹出。&lt;/li&gt;
&lt;li&gt;在 “stack unwinding” 过程中，这些栈帧中的所有局部变量会被析构。如果其中一个析构函数抛出异常，C++ 运行时系统将进入 “no-win” 状态：两个异常只能处理一个，忽视任何一个都会丢失信息。&lt;/li&gt;
&lt;li&gt;此时 C++ 会调用 &lt;code&gt;terminate()&lt;/code&gt; 终止进程。即在发生异常的情况下调用析构函数抛出异常会导致程序崩溃。因此避免的方法就是永远不要在析构函数抛异常。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;抛出什么异常&#34;&gt;抛出什么异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;抛出对象。如果可以，写子类继承自 &lt;code&gt;std::exception&lt;/code&gt; 类，可以提供更多关于异常的信息&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;捕获什么异常&#34;&gt;捕获什么异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;可以的话，捕获异常的引用：拷贝可能会有不同的行为；指针则不确定是否需要删除指向异常的指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;throw-再次抛异常&#34;&gt;throw 再次抛异常&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可用于实现简单的 “stack-trace”，即堆栈跟踪，在程序重要函数内部增加 &lt;code&gt;catch&lt;/code&gt; 语句&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class MyException {
public:
// ...
void addInfo(const std::string&amp;amp; info);
// ...
};

void f()
{
try {
// ...
}
catch (MyException&amp;amp; e) {
e.addInfo(&amp;quot;f() failed&amp;quot;);
throw;//再次抛出当前异常
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;也可用于 “exception dispatcher”，即异常分发&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void handleException()
{
try {
throw;
}
catch (MyException&amp;amp; e) {
// ...code to handle MyException...
}
catch (YourException&amp;amp; e) {
// ...code to handle YourException...
}
}

void f()
{
try {
// ...something that might throw...
}
catch (...) {
handleException();
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注解&#34;&gt;注解&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不是所有编译器支持异常捕获(exception-try-block)，只有 GCC 和大多数新版本的 MSVC 支持。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;初始化的异常不能被隐藏：构造函数内的异常处理部分必须抛出一个异常，或重新抛出捕获的异常。下面两个版本的代码是等价的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// Version 1
struct A
{
Buf b_;

A(int n)
try
    : b_(n)
{
    cout &amp;lt;&amp;lt; &amp;quot;A initialized&amp;quot; &amp;lt;&amp;lt; endl;
}
catch(BufError&amp;amp; )
{
    cout &amp;lt;&amp;lt; &amp;quot;BufError caught&amp;quot; &amp;lt;&amp;lt; endl;
}
};

// Version 2
struct A
{
Buf b_;

A(int n)
try
    : b_(n)
{
    cout &amp;lt;&amp;lt; &amp;quot;A initialized&amp;quot; &amp;lt;&amp;lt; endl;
}
catch(BufError&amp;amp; be)
{
    cout &amp;lt;&amp;lt; &amp;quot;BufError caught&amp;quot; &amp;lt;&amp;lt; endl;
    throw;
}
};
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cs.technion.ac.il/~imaman/programs/throwingctor.html&#34; target=&#34;_blank&#34;&gt;Throwing Catch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/810839/throwing-exceptions-from-constructors&#34; target=&#34;_blank&#34;&gt;Throwing exceptions from constructors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://writeulearn.com/exception-constructor/&#34; target=&#34;_blank&#34;&gt;Exception in constructor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/exceptions#ctors-can-throw&#34; target=&#34;_blank&#34;&gt;exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.tutorialspoint.com/can-a-constructor-throw-an-exception-in-java#&#34; target=&#34;_blank&#34;&gt;Can a constructor throw an exception in Java?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1371369/can-constructors-throw-exceptions-in-java&#34; target=&#34;_blank&#34;&gt;Can constructors throw exceptions in Java?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/hellogiser/p/constructor-destructor-exceptions.html&#34; target=&#34;_blank&#34;&gt;C++构造函数、析构函数与抛出异常&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>数组退化问题</title>
      <link>https://xueqing.github.io/blog/cplusplus/array_decay/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/array_decay/</guid>
      <description>

&lt;h2 id=&#34;数组退化&#34;&gt;数组退化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;类型和纬度丢失就是数组退化。通常发生在通过值或指针传递数组。这种情况下，数组发送的是它的首地址，因此数组的大小不是原始大小，而是首地址在内存中占用的大小。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面的代码中，实际数组有 7 个 int 元素，因此大小是 28。但是调用时传递值和指针，数组退化成指针，打印的是 1 个指针的大小&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

void decayByPassVal(int *p)
{
cout &amp;lt;&amp;lt; &amp;quot;Modified size of array by passing by value: &amp;quot; &amp;lt;&amp;lt; sizeof(p) &amp;lt;&amp;lt; endl;
}

void decayByPassPointer(int (*p)[7])
{
cout &amp;lt;&amp;lt; &amp;quot;Modified size of array by passing by pointer: &amp;quot; &amp;lt;&amp;lt; sizeof(p) &amp;lt;&amp;lt; endl;
}

int main()
{
int a[7] = {1, 2, 3, 4, 5, 6, 7,};
cout &amp;lt;&amp;lt; &amp;quot;Actual size of array is: &amp;quot; &amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt;endl;
decayByPassVal(a);
decayByPassPointer(&amp;amp;a);

return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;如何避免数组退化&#34;&gt;如何避免数组退化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;典型的方法避免数组退化是传递数组的大小作为单独的参数，而不是使用 &lt;code&gt;sizeof&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;另外一个方法避免数组退化是传递引用，这个可以避免数组转化为指针，因此避免了退化&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;

void avoidByPassReference(int (&amp;amp;p)[7])
{
cout &amp;lt;&amp;lt; &amp;quot;Modified size of array by passing by reference: &amp;quot; &amp;lt;&amp;lt; sizeof(p) &amp;lt;&amp;lt; endl;
}

int main()
{
int a[7] = {1, 2, 3, 4, 5, 6, 7,};
cout &amp;lt;&amp;lt; &amp;quot;Actual size of array is: &amp;quot; &amp;lt;&amp;lt; sizeof(a) &amp;lt;&amp;lt;endl;
avoidByPassReference(a);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/what-is-array-decay-in-c-how-can-it-be-prevented/&#34; target=&#34;_blank&#34;&gt;What is Array Decay in C++? How can it be prevented?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>结合 C 和 C&#43;&#43; 代码</title>
      <link>https://xueqing.github.io/blog/cplusplus/mix_c_and_cpp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/cplusplus/mix_c_and_cpp/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9c%80%e8%a6%81%e4%ba%86%e8%a7%a3%e7%9a%84%e7%9f%a5%e8%af%86&#34;&gt;需要了解的知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e8%af%ad%e8%a8%80%e5%87%bd%e6%95%b0&#34;&gt;在 C++ 中调用 C 语言函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e8%af%ad%e8%a8%80%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 语言函数&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 非成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 成员函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8-c-%e9%87%8d%e8%bd%bd%e5%87%bd%e6%95%b0&#34;&gt;在 C 中调用 C++ 重载函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e5%90%8d%e7%a7%b0%e9%87%8d%e6%95%b4&#34;&gt;C++ 名称重整&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e9%93%be%e6%8e%a5%e5%99%a8%e5%a4%84%e7%90%86-c-%e7%ac%a6%e5%8f%b7&#34;&gt;C++ 链接器处理 C 符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e5%8c%85%e5%90%ab%e4%b8%80%e4%b8%aa%e6%a0%87%e5%87%86%e7%9a%84-c-%e5%a4%b4%e6%96%87%e4%bb%b6&#34;&gt;在 C++ 中包含一个标准的 C 头文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e5%8c%85%e5%90%ab%e4%b8%80%e4%b8%aa%e9%9d%9e%e7%b3%bb%e7%bb%9f%e7%9a%84-c-%e5%a4%b4%e6%96%87%e4%bb%b6&#34;&gt;在 C++ 中包含一个非系统的 C 头文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bf%ae%e6%94%b9%e8%87%aa%e5%b7%b1%e7%9a%84-c-%e5%a4%b4%e6%96%87%e4%bb%b6%e4%bb%a5%e4%be%bf-c-%e5%ae%b9%e6%98%93%e4%bd%bf%e7%94%a8-include-%e8%af%ad%e5%8f%a5%e5%8c%85%e5%90%ab&#34;&gt;修改自己的 C 头文件以便 C++ 容易使用 include 语句包含&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8-c-%e4%b8%ad%e8%b0%83%e7%94%a8%e9%9d%9e%e7%b3%bb%e7%bb%9f%e7%9a%84-c-%e5%87%bd%e6%95%b0-fintcharfloat&#34;&gt;在 C++ 中调用非系统的 C 函数 f(int,char,float)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8f%af%e8%a2%ab-c-%e8%b0%83%e7%94%a8%e7%9a%84-c-%e5%87%bd%e6%95%b0-fintcharfloat&#34;&gt;创建一个可被 C 调用的 C++ 函数 f(int,char,float)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%93%be%e6%8e%a5%e5%99%a8%e5%9c%a8-cc-%e8%b0%83%e7%94%a8-cc-%e5%87%bd%e6%95%b0%e6%97%b6%e6%8a%a5%e9%94%99%e7%9a%84%e5%8e%9f%e5%9b%a0&#34;&gt;链接器在 C/C++ 调用 C++/C 函数时报错的原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bc%a0%e9%80%92%e4%b8%80%e4%b8%aa-c-%e7%b1%bb%e7%9a%84%e5%af%b9%e8%b1%a1%e7%bb%99%e4%bb%8e-c-%e5%87%bd%e6%95%b0&#34;&gt;传递一个 C++ 类的对象给/从 C 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e5%87%bd%e6%95%b0%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e7%9b%b4%e6%8e%a5%e8%ae%bf%e9%97%ae-c-%e7%b1%bb%e5%af%b9%e8%b1%a1%e7%9a%84%e6%95%b0%e6%8d%ae&#34;&gt;C 函数是否可以直接访问 C++ 类对象的数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-c-%e6%af%94-c-%e6%9b%b4%e8%a7%89%e5%be%97%e8%bf%9c%e7%a6%bb%e6%9c%ba%e5%99%a8%e4%bb%a3%e7%a0%81&#34;&gt;使用 C++ 比 C 更觉得远离机器代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;需要了解的知识&#34;&gt;需要了解的知识&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;有一些关键点(即使一些编译器尝试不要求，检查编译器厂商的文件)

&lt;ul&gt;
&lt;li&gt;当编译 &lt;code&gt;main()&lt;/code&gt; 时必须使用 C++ 编译器(比如为了静态初始化)&lt;/li&gt;
&lt;li&gt;C++ 编译器应该管理链接过程(这样才可以得到指定的库)&lt;/li&gt;
&lt;li&gt;C 和 C++ 编译器可能需要来自同一厂商，且具有兼容版本(这样才有相同的调用惯例)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;除此之外，你需要阅读剩余的章节以找到 可被 C/C++ 调用的 C++/C 函数&lt;/li&gt;
&lt;li&gt;有一个方式可以解决所有的问题：即使用 C++ 编译器编译所有的代码(即使是 C 风格的代码)

&lt;ul&gt;
&lt;li&gt;优点：可以解决结合 C 和 C++ 代码的问题，也更容易发现 C 代码的错误&lt;/li&gt;
&lt;li&gt;缺点：需要更新 C 风格的代码，&lt;a href=&#34;https://isocpp.org/wiki/faq/big-picture#back-compat-with-c&#34; target=&#34;_blank&#34;&gt;原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;但是更细代码的代价可能比结合二者的代价更小，同时可以清除 C 风格的代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中调用-c-语言函数&#34;&gt;在 C++ 中调用 C 语言函数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 C++ 中用 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 声明 C 函数，然后在 C/C++ 中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int);//方式1
extern &amp;quot;C&amp;quot; {//方式2
int g(double);
double h();
};

void cppode(int i, double d)
{
f(i);
int ii = g(d);
double dd = h();
//...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//c code
void f(int i)
{
//...
}
int g(double d)
{
//...
}
double h() {
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中调用-c-语言函数-1&#34;&gt;在 C 中调用 C++ 语言函数&lt;/h2&gt;

&lt;h3 id=&#34;在-c-中调用-c-非成员函数&#34;&gt;在 C 中调用 C++ 非成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在 C++ 中用 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 声明 C++ 函数，然后在 C/C++ 中调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int);

void f(int i)
{
//...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f(int);

void ccode(int i)
{
f(i);
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;在-c-中调用-c-成员函数&#34;&gt;在 C 中调用 C++ 成员函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果需要在 C 中调用成员函数(包括虚函数)，需要提供一个简单的封装&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class C {
//...
virtual double f(int);
};

//封装函数
extern &amp;quot;C&amp;quot; double call_C_f(C* p, int i)
{
return p-&amp;gt;f(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;struct C
{
//...
};
double call_C_f(struct C*, int);

void ccode(struct C* p, int i)
{
double d = call_C_f(p, i);
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;在-c-中调用-c-重载函数&#34;&gt;在 C 中调用 C++ 重载函数&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果需要在 C 中调用重载函数，必须为 C 语言提供不同名称的封装函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void f(int);
void f(double)

extern &amp;quot;C&amp;quot; void f_i(int);
extern &amp;quot;C&amp;quot; void f_d(double);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void f_i(int);
void f_d(double);

void ccode(int i, double d)
{
f_i(i);
f_d(d);
//...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这种方式适用于在 C 中调用 C++ 库，即使不能修改 C++ 的头文件&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-名称重整&#34;&gt;C++ 名称重整&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;C++ 支持函数重载。比如可以有多个函数名称相同，但参数不同。当生成目标代码时，C++ 编译器通过添加参数信息修改名称来区分不同的函数。这个添加额外信息到函数名的技术叫做名称重整(name mangling)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C++ 标准没有对名称重整指定任何详细的技术，因此不同编译器可能添加不同信息到函数名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int f(void) {return 1;}
int f(int) {return 0;}
void g(void) (int i=f(), j=f(0);)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上述代码可能被 C++ 编译器改成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int __f_v(void) {return 1;}
int __f_i(int) {return 0;}
void __g_v(void) (int i=__f_v(), j=__f_i(0);)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;c-链接器处理-c-符号&#34;&gt;C++ 链接器处理 C 符号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;C 不支持函数重载，名称不会被重整。当把代码放到 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 块时，C++ 编译器确保函数名不会被重整，即编译器生成一个二进制文件，且没有修改函数名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 在 C++ 调用 C 时：告诉 g++ 预期得到 gcc 生成的未重整的符号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 在 C 调用 C++ 时：告诉 g++ 生成未重整的符号给 gcc 使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;反编译一个 g++ 生成的二进制代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void f() {}
void g();

extern &amp;quot;C&amp;quot; {
void ef() {}
void eg();
}

void h() { g(); eg();}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 g++ 编译 &lt;code&gt;g++ -c main.cpp&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;反编译符号表 &lt;code&gt;readelf -s main.o&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Symbol table &#39;.symtab&#39; contains 13 entries:
Num:    Value          Size Type    Bind   Vis      Ndx Name
 0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
 1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS cppcode.cpp
 2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1
 3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3
 4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4
 5: 0000000000000000     0 SECTION LOCAL  DEFAULT    6
 6: 0000000000000000     0 SECTION LOCAL  DEFAULT    7
 7: 0000000000000000     0 SECTION LOCAL  DEFAULT    5
 8: 0000000000000000     7 FUNC    GLOBAL DEFAULT    1 _Z1fv
 9: 0000000000000007     7 FUNC    GLOBAL DEFAULT    1 ef
10: 000000000000000e    17 FUNC    GLOBAL DEFAULT    1 _Z1hv
11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z1gv
12: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND eg
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以看到：&lt;code&gt;ef&lt;/code&gt; 和 &lt;code&gt;eg&lt;/code&gt; 在符号表存储的名字和代码中的名字相同；其他的名称被重整过&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;解开(unmangle)这些名字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;kiki@ubuntu:/tmp/test$ c++filt _Z1fv
f()
kiki@ubuntu:/tmp/test$ c++filt _Z1hv
h()
kiki@ubuntu:/tmp/test$ c++filt _Z1gv
g()
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中包含一个标准的-c-头文件&#34;&gt;在 C++ 中包含一个标准的 C 头文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接使用 &lt;code&gt;#include&lt;/code&gt; 包含所需头文件，比如 &lt;code&gt;#include &amp;lt;cstdio&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;cstdio&amp;gt;

int main()
{
printf(&amp;quot;Hello!\n&amp;quot;);// or std::printf
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果使用 C++ 编译器编译 C 代码，又不希望将类似 &lt;code&gt;printf&lt;/code&gt; 改成 &lt;code&gt;std::printf&lt;/code&gt;，可以在 C 代码中使用旧风格的头文件 &lt;code&gt;stdio.h&lt;/code&gt; 替换新风格的头文件 &lt;code&gt;cstdio&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;

int main()
{
printf(&amp;quot;Hello!\n&amp;quot;);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中包含一个非系统的-c-头文件&#34;&gt;在 C++ 中包含一个非系统的 C 头文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果在 C++ 中包含一个非系统提供的 C 头文件，需要使用 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt; 结构包裹 &lt;code&gt;#include&lt;/code&gt; 语句，这个告诉 C++ 编译器此头文件声明的函数是 C 函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; {
//get declaration for void sum(int, int)
#include &amp;quot;my-c-code.h&amp;quot;
}

int main()
{
sum(1, 2);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;修改自己的-c-头文件以便-c-容易使用-include-语句包含&#34;&gt;修改自己的 C 头文件以便 C++ 容易使用 include 语句包含&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果在 C++ 中包含一个非系统提供的 C 头文件，且 C 头文件可以修改，强烈建议在头文件添加 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt; 语句使得 C++ 开发者更加容易使用 &lt;code&gt;#include&lt;/code&gt; 包含此头文件到 C++ 代码&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为 C 编译器不理解 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt; 结构，必须使用 &lt;code&gt;#ifdef&lt;/code&gt; 包裹 &lt;code&gt;extern &amp;quot;C&amp;quot; {&lt;/code&gt; 和 &lt;code&gt;}&lt;/code&gt;，以便 C 编译器看不到这个结构&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;//my-c-code.h
//有且只有 C++ 编译器会定义 __cplusplus 符号
#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

//c code

#ifdef __cplusplus
}
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;quot;my-c-code.h&amp;quot;

int main()
{
sum(1, 2);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;在-c-中调用非系统的-c-函数-f-int-char-float&#34;&gt;在 C++ 中调用非系统的 C 函数 f(int,char,float)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果需要调用一个 C 函数，但是不需要或者不想包含声明此函数的 C 头文件，可以在 C++ 代码中使用 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 语法声明这一个 C 函数。一般需要使用完整的函数原型&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int,char,float);

int main()
{
int i=1;
char c=&#39;c&#39;;
float ff=2;
f(i, c, ff);
return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多个 C 函数可以使用 &lt;code&gt;extern &amp;quot;C&amp;quot; {/**/}&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;创建一个可被-c-调用的-c-函数-f-int-char-float&#34;&gt;创建一个可被 C 调用的 C++ 函数 f(int,char,float)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C++ 编译器必须通过 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 知道 &lt;code&gt;f(int,char,float)&lt;/code&gt; 会被 C 编译器调用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;extern &amp;quot;C&amp;quot; void f(int,char,float);

//define f(int,char,float) in some c++ module
void f(int i, char c, float ff)
[
//...
]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 告诉编译器发送给链接器的外部信息应该使用 C 的调用管理和名称重整(name-mangling)(比如前置一个下划线)。因为 C 不支持名称重载，你不能在 C 程序中同时调用多个重载的函数&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;链接器在-c-c-调用-c-c-函数时报错的原因&#34;&gt;链接器在 C/C++ 调用 C++/C 函数时报错的原因&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果 `extern &amp;ldquo;C&amp;rdquo; 语法不正确，会有一些链接错误而不是编译器错误。因为 C++ 编译器通常会重整(mangle) 函数名称(比如为了支持函数重载)而跟 C 编译器不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;传递一个-c-类的对象给-从-c-函数&#34;&gt;传递一个 C++ 类的对象给/从 C 函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// fred.h: this header can be read by c/c++ compilers
#ifndef FRED_H
#define FRED_H

#ifdef __cplusplus
class Fred {
public:
  Fred();
  void wilma(int);

private:
  int a_;
};
#else
typedef struct Fred Fred;
#endif

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

#if defined(__STDC__) || defined(__cplusplus)
  extern void c_function(Fred*);///* ANSI C prototypes */
  extern Fred* cplusplus_callback_function(Fred*);
#else
  extern void c_function();///* K&amp;amp;R style */
  extern Fred* cplusplus_callback_function();
#endif

#ifdef __cplusplus
}
#endif

#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// fred.cpp
#include &amp;quot;fred.h&amp;quot;

#include &amp;lt;stdio.h&amp;gt;

Fred::Fred() : a_(0)
{

}

void Fred::wilma(int a)
{
  a_ = a;
  printf(&amp;quot;a=%d\n&amp;quot;, a);
}

Fred* cplusplus_callback_function(Fred* fred)
{
  fred-&amp;gt;wilma(123);
  return fred;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;// ccode.c
#include &amp;quot;fred.h&amp;quot;

void c_function(Fred* fred)
{
  cplusplus_callback_function(fred);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// cppcode.cpp
#include &amp;quot;fred.h&amp;quot;

int main()
{
  Fred fred;
  c_function(&amp;amp;fred);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;编译命令 &lt;code&gt;gcc fred.h fred.cpp ccode.c cppcode.cpp&lt;/code&gt; 或 &lt;code&gt;gcc fred.h fred.cpp ccode.c cppcode.cpp&lt;/code&gt;，输出 &lt;code&gt;a=123&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;和 C++ 代码不同，C 代码不能识别统一对象的两个指针，除非这两个指针完全是同一类型。比如，C++中容易检查指向同一对象的衍生类指针 dp 和基类指针 bp&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;判断 &lt;code&gt;if(dp == bp)&lt;/code&gt;，C++ 编译器会自动转化两个指针到同一类型，这种情况下到基类指针，然后进行比较。这取决于 C++ 编译器的具体实现，有时候这种转化会改动一个指针值的比特位&lt;/li&gt;
&lt;li&gt;技术层面上，大部分 C++ 编译器使用一个二进制对象格式以便多继承和/或虚继承的转换。但是 C++ 语言不会暴露对象格式，因此从原则上说，一个转化也会发生在非虚单继承&lt;/li&gt;
&lt;li&gt;关键点是 C 编译器不知道如何做指针转换，所以从衍生类到基类指针的转换必须发生在 C++ 编译器编译的代码，而不是 C 编译器编译的代码&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;当转换衍生类和基类指针到 void* 时必须要小心，因为这个不支持 C/C++ 编译器做适合的指针调整&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(Base* bp, Derived *dp)
{
if(bp ==dp) //valid to compare a Base* to Derived*
{
//...
}
void* xp = bp;
void* yp = dp;
if(x == y) //bad form! do not use this!
{
//...
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如上所述，上述指针转换会发生在多继承和/或虚继承&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 void* 指针的安全方式&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void f(Base* bp, Derived *dp)
{
void* xp = bp;
// If conversion is needed, it will happen in the static_cast&amp;lt;&amp;gt;
void* yp = static_cast&amp;lt;Base*&amp;gt;(dp);
if(x == y)//valid to compare a Base* to Derived*
{
//....
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c-函数是否可以直接访问-c-类对象的数据&#34;&gt;C 函数是否可以直接访问 C++ 类对象的数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如果一个 C++ 类满足下面的条件，C 函数可以安全访问 C++ 对象的数据

&lt;ul&gt;
&lt;li&gt;没有虚函数(包括继承的虚函数)&lt;/li&gt;
&lt;li&gt;所有数据的访问权限相同(private/protected/public)&lt;/li&gt;
&lt;li&gt;不含带有虚函数的完全包含的子对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果 C++ 类由任何基类(或者其完全包含的子对象有基类)，对这些数据的访问都是不可移植的。因为语言不会暴露带有继承的类格式。但实际上，所以的 C++ 编译器的处理方式相同：基类对象在前面(多重继承时按照从左至右的顺序)，然后是成员对象&lt;/li&gt;
&lt;li&gt;此外，如果该类(或任何基类)包含虚函数，几乎所有 C++ 编译器会在对象内放置一个 void*，或者是在第一个虚函数的位置，或者是在对象最开始的位置。这一点也不是语言要求的，但是每个语言都这样处理&lt;/li&gt;
&lt;li&gt;如果类包含需基类，情况更加复杂且更难移植。一个通用的实现技术是在对象最后包含一个虚基类的对象(不管虚基类在继承中的层次结构)。对象的其他部分还是正常的顺序。每个衍生的类实际上有一个指向虚基类的指针？？？&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;使用-c-比-c-更觉得远离机器代码&#34;&gt;使用 C++ 比 C 更觉得远离机器代码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作为面向对象(OO)的编程语言，C++ 支持模型化问题域，这支持在问题域的语言进行编程而不是使用解决方案域的语言编程&lt;/li&gt;
&lt;li&gt;C 的一个很大优势是没有隐藏机制：看到的就是得到的。可以阅读一个 C 程序并看到每一个时钟周期。但 C++ 不支持。虽然 C++ 为编程者隐藏了一些机制，它也提供了一个抽象层和表达上的经济，以便降低维护成本且不会破坏运行时性能&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://isocpp.org/wiki/faq/mixing-c-and-cpp&#34; target=&#34;_blank&#34;&gt;mixing c and cpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/1041866/what-is-the-effect-of-extern-c-in-c&#34; target=&#34;_blank&#34;&gt;What is the effect of extern “C” in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
