<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux | kiki</title>
    <link>https://xueqing.github.io/tags/linux/</link>
      <atom:link href="https://xueqing.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    <description>linux</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language>
    <image>
      <url>https://xueqing.github.io/img/icon-192.png</url>
      <title>linux</title>
      <link>https://xueqing.github.io/tags/linux/</link>
    </image>
    
    <item>
      <title>0 安装</title>
      <link>https://xueqing.github.io/blog/linux/0_%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/0_%E5%AE%89%E8%A3%85/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#01-dd-%e5%91%bd%e4%bb%a4%e5%ae%89%e8%a3%85&#34;&gt;0.1 dd 命令安装&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#011-%e6%97%a0%e4%ba%ba%e5%80%bc%e5%ae%88%e5%ae%89%e8%a3%85&#34;&gt;0.1.1 无人值守安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#012-%e4%bd%bf%e7%94%a8-dd-%e5%91%bd%e4%bb%a4%e5%ae%9e%e7%8e%b0%e7%a1%ac%e7%9b%98%e5%a4%8d%e5%88%b6&#34;&gt;0.1.2 使用 dd 命令实现硬盘复制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#0121-dd-%e5%91%bd%e4%bb%a4&#34;&gt;0.1.2.1 dd 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#0122-dd-%e5%91%bd%e4%bb%a4%e5%ae%89%e8%a3%85%e6%ad%a5%e9%aa%a4&#34;&gt;0.1.2.2 dd 命令安装步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#02-linux-livecd%e4%bb%8e-cd-%e5%85%89%e7%9b%98%e8%bf%90%e8%a1%8c-linux&#34;&gt;0.2 Linux LiveCD：从 CD 光盘运行 Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#03-%e8%bf%9c%e7%a8%8b%e7%ae%a1%e7%90%86%e5%8d%8f%e8%ae%ae&#34;&gt;0.3 远程管理协议&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#031-rdp-vs-rfb&#34;&gt;0.3.1 RDP vs RFB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#032-telnet-vs-ssh&#34;&gt;0.3.2 Telnet vs SSH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-1-dd-命令安装&#34;&gt;0.1 dd 命令安装&lt;/h2&gt;

&lt;h3 id=&#34;0-1-1-无人值守安装&#34;&gt;0.1.1 无人值守安装&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;面对大批量服务器的安装，人们往往热衷于选择“无人值守安装”的方式，而此方式需要对服务器进行过多配置&lt;/li&gt;
&lt;li&gt;无人值守安装(Kickstart)，又称全自动安装，其工作原理是，创建一个名为 ks.cfg 的文件记录 Linux 系统在安装过程中需要人工干预填写的各种参数

&lt;ul&gt;
&lt;li&gt;当安装过程中出现要填写参数时，安装程序会自行去 ks.cfg 文件中查找合适的参数，如果没找到，还是需要手工干预&lt;/li&gt;
&lt;li&gt;在 ks.cfg 文件涵盖安装过程所有可能需要填写的参数的前提下，安装者只需要告诉安装程序 ks.cfg 文件的位置，就可实现全自动安装&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0-1-2-使用-dd-命令实现硬盘复制&#34;&gt;0.1.2 使用 dd 命令实现硬盘复制&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用 dd 命令实现硬盘复制，间接实现安装 Linux 系统的方法，类似 Windows 下用 GHOST 软件进行硬盘克隆&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0-1-2-1-dd-命令&#34;&gt;0.1.2.1 dd 命令&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;dd 命令用于复制文件。它可以用指定大小的数据块复制一个文件，并在复制的同时进行指定的转换&lt;/li&gt;
&lt;li&gt;简单地理解，dd 命令可用于进行两块硬盘之间的复制(完整复制出一块和原系统盘一样的硬盘)&lt;/li&gt;
&lt;li&gt;格式 &lt;code&gt;dd if=输入文件 of=输出文件 bs=字节数 count=个数&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;if=输入文件：指定源文件或源设备&lt;/li&gt;
&lt;li&gt;of=输出文件：指定目标文件或目标设备&lt;/li&gt;
&lt;li&gt;bs=字节数：指定一次输入/输出多少字节，即把这些字节看作一个数据块&lt;/li&gt;

&lt;li&gt;&lt;p&gt;count=个数：指定输入/输出多少个数据块&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建一个 100MB 大小的文件 testfile
# /dev/zero是一个输入设备，可以使用它来初始化文件，该设备无穷尽地输出 0
# 可以理解为向 testfile 中不停地写 0，直到写满 100MB
[root@localhost ~]# dd if=/dev/zero of=/root/testfile bs=1k count=100000

# 把第一块硬盘中的数据复制到第二块硬盘中
[root@localhost ~]# dd if=/dev/sda of=/dev/sdb

# 把第一块硬盘中的数据复制到 image 文件中
[root@localhost ~]# dd if=/dev/hda of=/root/image
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用 dd 命令复制硬盘，需满足以下两个前提条件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;需要批量复制的服务器硬件配置一致。通常，采购服务器都是批量采购的，服务器的配置都是一样的&lt;/li&gt;
&lt;li&gt;复制硬盘的时候，需要手工更换被复制盘。服务器上一般都是 SCSI 硬盘，SCSI 硬盘支持热插拔，而且不需要拆卸机箱，更换被复制盘非常方便&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;0-1-2-2-dd-命令安装步骤&#34;&gt;0.1.2.2 dd 命令安装步骤&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用 dd 命令安装 Linux，实际上就是硬盘之间的完整拷贝，其实现过程如下

&lt;ul&gt;
&lt;li&gt;把母盘插入服务器的第一个硬盘插口，把被复制盘插入服务器的第二个硬盘插口，注意不要插反&lt;/li&gt;
&lt;li&gt;执行复制命令&lt;code&gt;dd if=/dev/sda of=/dev/sdb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;/dev/sda 代表第一块 SCSI 盘，/dev/sdb 代表第二块 SCSI 盘&lt;/li&gt;
&lt;li&gt;这条命令会把第一块硬盘中的数据完整地复制到第二块硬盘中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;经过以上两步，即可实现将服务器之间的复制&lt;/li&gt;
&lt;li&gt;此方法的效率：由于复制的速度和服务器的配置及安装软件的多少相关，因此每台服务器的复制时间约为15〜25分钟。选择无人值守安装的方式，也要受到服务器端配置和网络带宽的影响&lt;/li&gt;
&lt;li&gt;硬盘复制也可以多台服务器同时操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-2-linux-livecd-从-cd-光盘运行-linux&#34;&gt;0.2 Linux LiveCD：从 CD 光盘运行 Linux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一些 Linux 发行版创建了含有 Linux 样本系统的可引导 CD，称为 Linux LiveCD&lt;/li&gt;
&lt;li&gt;由于单张 CD 容量的限制，这个样本并非完整的 Linux 系统，不过可以自己加入各种软件。结果就是，可以通过 CD 来启动 PC，并且无需在硬盘安装任何东西就能运行 Linux 发行版&lt;/li&gt;
&lt;li&gt;这是一个不弄乱 PC 就体验各种 Linux 发行版的绝妙方法。只需插入 CD 就能引导。所有的 Linux 软件都将直接从 CD 上运行。可以从互联网上下载各种 Linux LiveCD，刻录，体验&lt;/li&gt;
&lt;li&gt;Linux LiveCD 也有一些不足之处

&lt;ul&gt;
&lt;li&gt;由于要从 CD 上访问所有东西，应用程序会运行得更慢，而如果再搭配上陈旧缓慢的 PC 和光驱，那更是慢上加慢&lt;/li&gt;
&lt;li&gt;由于无法向 CD 写入数据，对 Linux 系统作的任何修改都会在重启后失效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;0-3-远程管理协议&#34;&gt;0.3 远程管理协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;远程管理，通常指远程管理服务器，而非个人计算机。个人计算机可以随时拿来用，服务器通常放置在机房中，用户无法直接接触到服务器硬件，只能采用远程管理的方式&lt;/li&gt;
&lt;li&gt;远程管理，实际上就是计算机(服务器)之间通过网络进行数据传输(信息交换)的过程，与浏览器需要 HTTP 协议(超文本传输协议)浏览网页一样，远程管理同样需要远程管理协议的支持&lt;/li&gt;
&lt;li&gt;目前，常用的远程管理协议有 4 种&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;协议&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;RDP(remote desktop protocol)协议&lt;/td&gt;
&lt;td&gt;远程桌面协议，大部分 Windows 系统都默认支持此协议&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;Windows 系统中的远程桌面管理就基于该协议&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;RFB(Remote FrameBuffer)协议&lt;/td&gt;
&lt;td&gt;图形化远程管理协议&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;VNC 远程管理工具就基于此协议&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Telnet&lt;/td&gt;
&lt;td&gt;命令行界面远程管理协议，几乎所有操作系统都默认支持此协议&lt;/td&gt;
&lt;td&gt;在进行数据传送时使用明文传输的方式，也就是不对数据进行加密&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SSH(Secure Shell)协议&lt;/td&gt;
&lt;td&gt;命令行界面远程管理协议，几乎所有操作系统都默认支持此协议&lt;/td&gt;
&lt;td&gt;和 Telnet 不同，该协议在数据传输时会对数据进行加密并压缩，因此使用此协议传输数据既安全速度又快&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;0-3-1-rdp-vs-rfb&#34;&gt;0.3.1 RDP vs RFB&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;都允许用户通过图形用户界面访问远程系统&lt;/li&gt;
&lt;li&gt;RFB 协议倾向于传输图像，RDP 协议倾向于传输指令

&lt;ul&gt;
&lt;li&gt;RFB 协议会在服务器端将窗口在显存中画好，然后将图像传给客户端，客户端只需将得到的图像解码显示&lt;/li&gt;
&lt;li&gt;RDP 会将画图的工作交给客户端，服务器端需要根据客户端的显示能力做适当的调整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因此，完成相同的操作，使用 RFB 协议传输的数据量会比 RDP 大，而 RDP 对客户端的要求比 RFB 更苛刻，RFB 适用于瘦客户端，而 RDP 适用于低速网络

&lt;ul&gt;
&lt;li&gt;瘦客户端是相对于胖客户端而言的，比如，人们使用 QQ 需要下载客户端，这属于“胖客户”&lt;/li&gt;
&lt;li&gt;反之，通过浏览器就可查阅网络上各种资料，无需再下载其他任何软件，这属于“瘦客户”&lt;/li&gt;
&lt;li&gt;简单理解，瘦客户端指的是最大可能减轻客户端的负担，多数工作由服务器端完成；胖客户端则相反&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;0-3-2-telnet-vs-ssh&#34;&gt;0.3.2 Telnet vs SSH&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;都是命令行远程管理协议，有共同的应用领域，常用于远程访问服务器&lt;/li&gt;
&lt;li&gt;相比 Telnet 协议，SSH 协议在发送数据时会对数据进行加密操作，数据传输更安全&lt;/li&gt;
&lt;li&gt;因此 SSH 协议几乎在所有应用领域代替了 Telnet 协议&lt;/li&gt;
&lt;li&gt;在一些测试、无需加密的场合（如局域网），Telnet协议仍常被使用&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1 简介</title>
      <link>https://xueqing.github.io/blog/linux/1_%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/1_%E7%AE%80%E4%BB%8B/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%bf%b0&#34;&gt;1.1 操作系统概述&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f&#34;&gt;1.1.1 操作系统&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-unix-vs-linux&#34;&gt;1.2 UNIX vs Linux&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121-unixlinux-%e7%b3%bb%e7%bb%9f%e7%bb%93%e6%9e%84&#34;&gt;1.2.1 UNIX/Linux 系统结构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-linux-%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9&#34;&gt;1.3 Linux 系统的优缺点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-linux-%e7%9a%84%e5%8f%91%e8%a1%8c%e7%89%88&#34;&gt;1.4 Linux 的发行版&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#141-linux-%e5%8f%91%e8%a1%8c%e7%89%88%e5%8f%8a%e7%89%b9%e7%82%b9%e6%b1%87%e6%80%bb&#34;&gt;1.4.1 Linux 发行版及特点汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#142-linux-%e5%8f%91%e8%a1%8c%e7%89%88%e6%9c%ac%e7%9a%84%e9%80%89%e6%8b%a9&#34;&gt;1.4.2 Linux 发行版本的选择&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-linux-%e5%ba%94%e7%94%a8%e9%a2%86%e5%9f%9f&#34;&gt;1.5 Linux 应用领域&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#151-%e6%9c%8d%e5%8a%a1%e5%99%a8&#34;&gt;1.5.1 服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#152-%e7%94%b5%e5%bd%b1%e5%b7%a5%e4%b8%9a&#34;&gt;1.5.2 电影工业&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#153-%e5%b5%8c%e5%85%a5%e5%bc%8f%e5%ba%94%e7%94%a8&#34;&gt;1.5.3 嵌入式应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16-%e5%bc%80%e6%ba%90%e8%bd%af%e4%bb%b6&#34;&gt;1.6 开源软件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#17-%e5%bc%80%e6%ba%90%e5%8d%8f%e8%ae%ae&#34;&gt;1.7 开源协议&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#171-apache-%e8%ae%b8%e5%8f%af%e8%af%81%e7%89%88%e6%9c%acapache-license-version%e5%8d%8f%e8%ae%ae&#34;&gt;1.7.1 Apache 许可证版本(Apache License Version)协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#172-bsdberkeley-software-distribution%e4%bc%af%e5%85%8b%e5%88%a9%e8%bd%af%e4%bb%b6%e5%8f%91%e5%b8%83%e7%89%88%e5%8d%8f%e8%ae%ae&#34;&gt;1.7.2 BSD(Berkeley Software Distribution，伯克利软件发布版)协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#173-gnu-gplgnu-general-public-licensegnu-%e9%80%9a%e7%94%a8%e5%85%ac%e5%85%b1%e8%ae%b8%e5%8f%af%e8%af%81&#34;&gt;1.7.3 GNU GPL(GNU General Public License，GNU 通用公共许可证)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#174-gun-lgplgnu-lesser-general-public-licensegnu-%e5%ae%bd%e9%80%9a%e7%94%a8%e5%85%ac%e5%85%b1%e8%ae%b8%e5%8f%af%e8%af%81&#34;&gt;1.7.4 GUN LGPL(GNU Lesser General Public License，GNU 宽通用公共许可证)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#175-mitmassachusetts-institute-of-technology%e5%8d%8f%e8%ae%ae&#34;&gt;1.7.5 MIT(Massachusetts Institute of Technology)协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#176-%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e5%bc%80%e6%ba%90%e5%8d%8f%e8%ae%ae&#34;&gt;1.7.6 如何选择开源协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-linux-vs-windows&#34;&gt;1.3 Linux vs Windows&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-1-操作系统概述&#34;&gt;1.1 操作系统概述&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;计算机是一台机器，它按照用户的要求接收信息、存储数据、处理数据，然后再将处理结果输出(文字、图片、音频、视频等)。计算机由硬件和软件组成

&lt;ul&gt;
&lt;li&gt;硬件是计算机赖以工作的实体，包括显示器、键盘、鼠标、硬盘、CPU、主板等&lt;/li&gt;
&lt;li&gt;软件会按照用户的要求协调整台计算机的工作，比如 Windows、Linux、Mac OS、Android 等操作系统，以及 Office、QQ、迅雷、微信等应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-1-1-操作系统&#34;&gt;1.1.1 操作系统&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;操作系统(Operating System，OS)是软件的一部分，是硬件基础上的第一层软件，是硬件和其它软件沟通的桥梁(或者说接口、中间人、中介等)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;操作系统会控制其他程序运行，管理系统资源，提供最基本的计算功能。如管理及配置内存、决定系统资源供需的优先次序等，同时还提供一些基本的服务程序，例如&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;文件系统&lt;/strong&gt;：提供计算机存储信息的结构，信息存储在文件中，文件主要存储在计算机的内部硬盘里，在目录的分层结构中组织文件。文件系统为操作系统提供了组织管理数据的方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;设备驱动程序&lt;/strong&gt;：提供连接计算机的每个硬件设备的接口，设备驱动器使程序能够写入设备，而不需要了解执行每个硬件的细节&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户接口&lt;/strong&gt;：操作系统需要为用户提供一种运行程序和访问文件系统的方法。如常用的 Windows 图形界面，可以理解为一种用户与操作系统交互的方式；智能手机的 Android 或 iOS 系统，也是一种操作系统的交互方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统服务程序&lt;/strong&gt;：当计算机启动时，会自启动许多系统服务程序，执行安装文件系统、启动网络服务、运行预定任务等操作&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/linux/images/computer_arch.gif&#34; alt=&#34;操作系统在计算机架构中的位置&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;目前流行的服务器和 PC 端操作系统有 Linux、Windows、UNIX 等，手机操作系统有 Android、iOS、Windows Phone(简称 WP)，嵌入式操作系统有 Windows CE、PalmOS、eCos、uClinux 等&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-unix-vs-linux&#34;&gt;1.2 UNIX vs Linux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;区别

&lt;ul&gt;
&lt;li&gt;UNIX 系统大多是与硬件配套的，即大多数 UNIX 系统如 AIX、HP-UX 等是无法安装在 x86 服务器和个人计算机上的，而 Linux 则可以运行在多种硬件平台上&lt;/li&gt;
&lt;li&gt;UNIX 是商业软件，而 Linux 是开源软件，是免费、公开源代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;联系

&lt;ul&gt;
&lt;li&gt;Linux 是一套免费使用和自由传播的类 Unix 操作系统，Unix 要早于 Linux，Linux 的初衷就是要替代 UNIX，并在功能和用户体验上进行优化&lt;/li&gt;
&lt;li&gt;Linux 是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统&lt;/li&gt;
&lt;li&gt;Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件&lt;/li&gt;
&lt;li&gt;Linux 继承了 UNIX 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-2-1-unix-linux-系统结构&#34;&gt;1.2.1 UNIX/Linux 系统结构&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;UNIX/Linux 系统可以粗糙地抽象为 3 个层次，如图所示。底层是 UNIX/Linux 操作系统，即系统内核(Kernel)；中间层是 Shell 层，即命令解释层；高层则是应用层
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/linux/images/UNIX_Linux_arch.jpg&#34; alt=&#34;UNIX/Linux 系统结构&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内核层：UNIX/Linux 系统的核心和基础，它直接附着在硬件平台之上，控制和管理系统内各种资源(硬件资源和软件资源)，有效地组织进程的运行，从而扩展硬件的功能，提高资源的利用效率，为用户提供方便、高效、安全、可靠的应用环境&lt;/li&gt;
&lt;li&gt;Shell 层：与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作&lt;/li&gt;
&lt;li&gt;应用层：提供基于 X Window 协议的图形环境。X Window 协议定义了一个系统所必须具备的功能(就如同 TCP/IP 是一个协议，定义软件所应具备的功能)，系统能满足此协议及符合 X 协会其他的规范，便可称为 X Window&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-3-linux-系统的优缺点&#34;&gt;1.3 Linux 系统的优缺点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 不可比拟的优势

&lt;ul&gt;
&lt;li&gt;大量的可用软件及免费软件：比如 Apache、Samba、PHP、MySQL 等，构建成本低廉，是 Linux 被众多企业青睐的原因之一。当然，这和 Linux 出色的性能是分不开的，否则，节约成本就没有任何意义&lt;/li&gt;
&lt;li&gt;良好的可移植性及灵活注：几乎支持所有的 CPU 平台，使得它便于裁剪和定制。可以把 Linux 放在 U 盘、光盘等存储介质中，也可以在嵌入式领域广泛应用&lt;/li&gt;
&lt;li&gt;如果希望不进行安装就体验 Linux 系统，可在网上下载一个 Live DVD 版的 Linux 镜像，刻成光盘放入光驱或者用虚拟机软件直接载入镜像文件，设置 CMOS/BIOS 为光盘启动，系统就会自动载入光盘文件，启动进入 Linux 系统&lt;/li&gt;
&lt;li&gt;优良的稳定性和安全性：Linux 开放源代码，将所有代码放在网上，全世界的程序员都看得到，有什么缺陷和漏洞，很快就会被发现，从而成就了它的稳定性和安全注&lt;/li&gt;
&lt;li&gt;支持几乎所有的网络协议及开发语言：UNIX 系统是与 C 语言、TCP/IP 协议一同发展起来的，而 Linux 是 UNIX 的一种，C 语言又衍生出了现今主流的语言 PHP、Java、C++ 等，而网络协议都与 TCP/IP 有关。所以，Linux 对网络协议和开发语言的支持很好&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux 的缺点：桌面应用还有待完善(Linux 在办公应用和游戏娱乐方面的软件相比 Windows 系统还很匮乏)、Linux 的标准统一还需要推广、开源软件的盈利模式与发展还有待考验等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-4-linux-的发行版&#34;&gt;1.4 Linux 的发行版&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;从技术上来说，李纳斯•托瓦兹开发的 Linux 只是一个内核。内核指的是一个提供设备驱动、文件系统、进程管理、网络通信等功能的系统软件，内核并不是一套完整的操作系统，它只是操作系统的核心&lt;/li&gt;
&lt;li&gt;Linux 的发行版：一些组织或厂商将 Linux 内核与各种软件和文档包做一个打包，并提供系统安装界面和系统配置、设定与管理工具&lt;/li&gt;
&lt;li&gt;Linux 的各个发行版本使用的是同一个 Linux 内核，因此在内核层不存在什么兼容性问题，每个版本有不一样的感觉，只是在发行版本的最外层(由发行商整合开发的应用)才有所体现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/linux/images/linux_dist.jpg&#34; alt=&#34;Linux 发行版&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Linux 的发行版本可以大体分为两类

&lt;ul&gt;
&lt;li&gt;商业公司维护的发行版本，以著名的 Red Hat 为代表&lt;/li&gt;
&lt;li&gt;社区组织维护的发行版本，以 Debian 为代表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;知名的发行版

&lt;ul&gt;
&lt;li&gt;Ubuntu：基于知名的 Debian Linux 发展而来，界面友好，容易上手，对硬件的支持非常全面，是目前最适合做桌面系统的 Linux 发行版本，而且 Ubuntu 的所有发行版本都免费提供&lt;/li&gt;
&lt;li&gt;Red Hat：公司的产品主要包括 RHEL(Red Hat Enterprise Linux，收费版本)和 CentOS(RHEL 的社区克隆版本，免费版本)、Fedora Core(由 Red Hat 桌面版发展而来，免费版本)&lt;/li&gt;
&lt;li&gt;CentOS 是基于 Red Hat Enterprise Linux 源代码重新编译、去除 Red Hat 商标的产物，各种操作使用和付费版本没有区别，且完全免费。缺点是不向用户提供技术支持，也不负任何商业责任&lt;/li&gt;
&lt;li&gt;SuSE Linux：可以非常方便地实现与 Windows 的交互，硬件检测非常优秀，拥有界面友好的安装过程、图形管理工具，对于终端用户和管理员来说使用非常方便&lt;/li&gt;
&lt;li&gt;Gentoo Linux：所有 Linux 发行版本里安装最复杂的，到目前为止仍采用源码包编译安装操作系统。不过，它是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。具有高度的自定制性(基于源代码的发行版)。尽管安装时可以选择预先编译好的软件包，但是大部分使用 Gentoo 的用户都选择自己手动编译，因此适合比较有 Linux 使用经验的用户使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-4-1-linux-发行版及特点汇总&#34;&gt;1.4.1 Linux 发行版及特点汇总&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;版本名称&lt;/th&gt;
&lt;th&gt;网址&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;th&gt;软件包管理器&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Debian Linux&lt;/td&gt;
&lt;td&gt;www.debian.org&lt;/td&gt;
&lt;td&gt;开放的开发模式，且易于进行软件包升级&lt;/td&gt;
&lt;td&gt;apt&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Ubuntu&lt;/td&gt;
&lt;td&gt;www.ubuntu.com&lt;/td&gt;
&lt;td&gt;优秀易用的桌面环境，基于 Debian 构建&lt;/td&gt;
&lt;td&gt;apt&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Fedora Core&lt;/td&gt;
&lt;td&gt;www.redhat.com&lt;/td&gt;
&lt;td&gt;拥有数量庞人的用户，优秀的社区技术支持。并且有许多创新&lt;/td&gt;
&lt;td&gt;up2date(rpm)，yum (rpm)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;CentOS&lt;/td&gt;
&lt;td&gt;www.centos.org&lt;/td&gt;
&lt;td&gt;CentOS 就是将商业的 Linux 操作系统 RHEL 进行源代码再编译后分发，并在 RHEL 的基础上修正了不少已知的漏洞&lt;/td&gt;
&lt;td&gt;rpm&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;SuSE Linux&lt;/td&gt;
&lt;td&gt;www.suse.com&lt;/td&gt;
&lt;td&gt;专业的操作系统，易用的 YaST 软件包管理系统&lt;/td&gt;
&lt;td&gt;YaST(rpm)，第三方 apt (rpm)软件库(repository)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Gentoo Linux&lt;/td&gt;
&lt;td&gt;www.gentoo.org&lt;/td&gt;
&lt;td&gt;高度的可定制性，使用手册完整&lt;/td&gt;
&lt;td&gt;portage&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;1-4-2-linux-发行版本的选择&#34;&gt;1.4.2 Linux 发行版本的选择&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linux 的发行版本众多，选择 Linux 发行版本的建议

&lt;ul&gt;
&lt;li&gt;如果只是需要一个桌面系统，而且既不想使用盗版，又不想花大价钱购买商业软件，不想自己定制，也不想在系统上浪费太多时间，则可以选择 Ubuntu&lt;/li&gt;
&lt;li&gt;如果需要一个服务器系统，且已经厌烦了各种 Linux 的配置，只是想要一个比较稳定的服务器系统，那么建议选择 CentOS 或 RHEL&lt;/li&gt;
&lt;li&gt;如果需要使用数据库高级服务和电子邮件网络应用，则可以选择 SuSE&lt;/li&gt;
&lt;li&gt;如果想深入摸索一下 Linux 各个方面的知识，而且想非常灵活地定制自己的 Linux 系统，选择 Gentoo&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-5-linux-应用领域&#34;&gt;1.5 Linux 应用领域&lt;/h2&gt;

&lt;h3 id=&#34;1-5-1-服务器&#34;&gt;1.5.1  服务器&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;通常服务器使用 LAMP(Linux + Apache + MySQL + PHP)或 LNMP(Linux + Nginx+ MySQL + PHP)组合&lt;/li&gt;
&lt;li&gt;服务器使用 Linux 而不使用 UNIX 或 Windows：使用 Linux 成本较低，而 UNIX 和 Windows 都是商业软件；而且 Linux 服务器非常高效和稳定&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-5-2-电影工业&#34;&gt;1.5.2 电影工业&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linux 作为开源软件，可以节省大量成本&lt;/li&gt;
&lt;li&gt;Linux 具有商业软件不具备的功能定制化特点，各家电影厂商都可依据自己的制片需要铺设相关平台&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-5-3-嵌入式应用&#34;&gt;1.5.3 嵌入式应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;嵌入式系统是以应用为中心，以计算机技术为基础，并且软硬件可定制，适用于各种应用场合，对功能、可靠注、成本、体积、功耗有严格要求的专用计算机系统。它一般由嵌入式微处理器、外围硬件设备、嵌入式操作系统及用户的应用程序 4 部分组成，用于实现对其他设备的控制、监视或管理等&lt;/li&gt;
&lt;li&gt;安卓是基于 Linux 的开源系统，主要适用于便携设备，如智能手机和平板电脑等，是Google公司为移动终端打造的真正开放和完整的移动软件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-6-开源软件&#34;&gt;1.6 开源软件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 是一款开源软件，我们可以随意浏览和修改它的源代码&lt;/li&gt;
&lt;li&gt;开源软件就是把软件程序与源代码文件一起打包提供给用户，用户既可以不受限制地使用该软件的全部功能，也可以根据自己的需求修改源代码，甚至编制成衍生产品再次发布出去&lt;/li&gt;
&lt;li&gt;开源软件的优点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;| 优点 | 说明 |
  | &amp;mdash; | &amp;mdash; |
  | 低风险 | 一旦封闭的源代码没有人来维护，你将进退维谷；而且相较于商业软件公司，开源社区很少存在倒闭的问题 |
  | 高品质 | 相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的 bug 还没有等爆发就已经被修补 |
  | 低成本 | 开源工作者都是在幕后默默且无偿地付出劳动成果，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力 |
  | 更透明 | 没有人会把木马、后门等放到开放的源代码中，这样无疑是把自己的罪行暴露在阳光之下 |&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;典型的开源软件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;| 软件 | 说明 |
  | &amp;mdash; | &amp;mdash; |
  | Linux | Linux 是一款开源的操作系统，它的内核由多名极客共同维护。Linux 是开源软件的经典之作、代表之作、巅峰之作 |
  | Apache | 世界使用排名第一的 Web 服务器软件 |
  | MySQL | 世界上最流行的关系型数据库，适合中小型网站 |
  | Firefox | 火狐浏览器。在 Chrome 推出之前，Firefox 几乎是最快速的浏览器，直到现在也是 Web 开发人员的调试利器 |
  | OpenOffice | 一套跨平台的办公软件套件，类似 Microsoft Office |
  | GCC | C语言/C++编译器 |
  | Java、PHP、Python | 开源的编程语言 |&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;国内外开源社区推荐：开源中国、ChinaUnix、GitHub、Apache、SourceForge&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-7-开源协议&#34;&gt;1.7 开源协议&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;开源软件在追求“自由”的同时，不能牺牲程序员的利益，否则将会影响程序员的创造激情，因此世界上现在有 60 多种被开源促进组织(Open Source Initiative)认可的开源许可协议来保证开源工作者的权益&lt;/li&gt;
&lt;li&gt;开源协议规定了你在使用开源软件时的权利和责任，也就是规定了你可以做什么，不可以做什么&lt;/li&gt;
&lt;li&gt;开源协议虽然不一定具备法律效力，但是当涉及软件版权纠纷时，开源协议也是非常重要的证据之一&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-7-1-apache-许可证版本-apache-license-version-协议&#34;&gt;1.7.1 Apache 许可证版本(Apache License Version)协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Apache 和 BSD 类似，都适用于商业软件。Apache 协议在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由&lt;/li&gt;
&lt;li&gt;现在热门的 Hadoop、Apache HTTP Server、MongoDB 等项目都是基于该许可协议研发的，程序开发人员在开发遵循该协议的软件时，要严格遵守下面的四个条件

&lt;ul&gt;
&lt;li&gt;该软件及其衍生品必须继续使用 Apache 许可协议&lt;/li&gt;
&lt;li&gt;如果修改了程序源代码，需要在文档中进行声明&lt;/li&gt;
&lt;li&gt;若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息&lt;/li&gt;
&lt;li&gt;如果再发布的软件中有声明文件，则需在此文件中标注 Apache 许可协议及其他许可协议&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-7-2-bsd-berkeley-software-distribution-伯克利软件发布版-协议&#34;&gt;1.7.2 BSD(Berkeley Software Distribution，伯克利软件发布版)协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BSD 协议基本上允许用户“为所欲为”，用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面三个条件

&lt;ul&gt;
&lt;li&gt;如果再发布的软件中包含源代码，则源代码必须继续遵循 BSD 许可协议&lt;/li&gt;
&lt;li&gt;如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了 BSD 协议&lt;/li&gt;
&lt;li&gt;不允许用原始软件的名字、作者名字或机构名称进行市场推广&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;BSD 对商业比较友好，很多公司在选用开源产品的时候都首选 BSD 协议，因为可以完全控制这些第三方的代码，甚至在必要的时候可以修改或者二次开发&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-7-3-gnu-gpl-gnu-general-public-license-gnu-通用公共许可证&#34;&gt;1.7.3 GNU GPL(GNU General Public License，GNU 通用公共许可证)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;只要软件中包含了遵循 GPL 协议的产品或代码，该软件就必须也遵循 GPL 许可协议，也就是必须开源免费，不能闭源收费，因此这个协议并不适合商用软件&lt;/li&gt;
&lt;li&gt;遵循 GPL 协议的开源软件数量极其庞大，包括 Linux 系统在内的大多数的开源软件都是基于这个协议的&lt;/li&gt;
&lt;li&gt;GPL 开源协议的主要特点&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;| 特点 | 说明 |
  | &amp;mdash; | &amp;mdash; |
  | 复制自由 | 允许把软件复制到任何人的电脑中，并且不限制复制的数量 |
  | 传播自由 | 允许软件以各种形式进行传播 |
  | 收费传播 | 允许在各种媒介上出售该软件，但必须提前让买家知道这个软件可以免费获得；因此，开源软件一般是通过为用户提供有偿服务的形式盈利 |
  | 修改自由 | 允许开发人员增加或删除软件的功能，但软件修改后必须依然基于 GPL 许可协议授权 |&lt;/p&gt;

&lt;h3 id=&#34;1-7-4-gun-lgpl-gnu-lesser-general-public-license-gnu-宽通用公共许可证&#34;&gt;1.7.4 GUN LGPL(GNU Lesser General Public License，GNU 宽通用公共许可证)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;LGPL 是 GPL 的一个衍生版本，也被称为 GPL V2，该协议主要是为类库设计的开源协议&lt;/li&gt;
&lt;li&gt;LGPL 允许商业软件通过类库引用(link)的方式使用 LGPL 类库，而不需要开源商业软件的代码。这使得采用 LGPL 协议的开源代码可以被商业软件作为类库引用并发布和销售&lt;/li&gt;
&lt;li&gt;但是如果修改 LGPL 协议的代码或者衍生品，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用 LGPL 协议&lt;/li&gt;
&lt;li&gt;因此 LGPL 协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以 LGPL 协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-7-5-mit-massachusetts-institute-of-technology-协议&#34;&gt;1.7.5 MIT(Massachusetts Institute of Technology)协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;目前限制最少的开源许可协议之一(比 BSD 和 Apache 的限制都少)，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用&lt;/li&gt;
&lt;li&gt;使用 MIT 协议的软件有 PuTTY、X Window System、Ruby on Rails、Lua 5.0 onwards、Mono 等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-7-6-如何选择开源协议&#34;&gt;1.7.6 如何选择开源协议&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/linux/images/open_source_protocol.gif&#34; alt=&#34;开源协议比较&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-3-linux-vs-windows&#34;&gt;1.3 Linux vs Windows&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较&lt;/th&gt;
&lt;th&gt;Windows&lt;/th&gt;
&lt;th&gt;Linux&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;界面&lt;/td&gt;
&lt;td&gt;界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同&lt;/td&gt;
&lt;td&gt;图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;驱动程序&lt;/td&gt;
&lt;td&gt;驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛&lt;/td&gt;
&lt;td&gt;由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题(是否存在和安装方法)会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;使用&lt;/td&gt;
&lt;td&gt;使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利&lt;/td&gt;
&lt;td&gt;图形界面使用简单，容易入门。文字界面，需要学习才能掌握&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;学习&lt;/td&gt;
&lt;td&gt;系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难&lt;/td&gt;
&lt;td&gt;系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;软件&lt;/td&gt;
&lt;td&gt;每一种特定功能可能都需要商业软件的支持，需要购买相应的授权&lt;/td&gt;
&lt;td&gt;大部分软件都可以自由获取，同样功能的软件选择较少&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;大小写&lt;/td&gt;
&lt;td&gt;不区分&lt;/td&gt;
&lt;td&gt;区分&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;扩展名&lt;/td&gt;
&lt;td&gt;依赖以区分文件类型&lt;/td&gt;
&lt;td&gt;不区分。通过权限位标识确定文件类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;Linux 中的一些特殊文件要求写&amp;rdquo;扩展名&amp;rdquo;，但并不是 Linux 一定要靠扩展名来识别文件类型，写这些扩展名是为了帮助管理员来区分不同的文件类型。这样的文件扩展名主要有

&lt;ul&gt;
&lt;li&gt;压缩包：Linux 下常见的压缩文件名有 gz/bz2/zip/tar.gz/tar.bz2/tgz 等。就算没写扩展名，在 Linux 中一样可以解压缩，不影响使用&lt;/li&gt;
&lt;li&gt;二进制软件包：CentOS 中所使用的二进制安装包是 RPM 包，所有 RPM 包用 rpm 扩展名结尾，目的同样是让管理员一目了然&lt;/li&gt;
&lt;li&gt;程序文件：Shell 脚本一般用 sh 扩展名结尾，其他还有用 c 扩展名结尾的 C 语言文件等&lt;/li&gt;
&lt;li&gt;网页文件：网页文件一般使用 php 等结尾，不过这是网页服务器的要求，而不是 Linux 的要求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2 Linux 系统启动过程</title>
      <link>https://xueqing.github.io/blog/linux/2_%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/2_%E5%90%AF%E5%8A%A8/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e5%86%85%e6%a0%b8%e5%bc%95%e5%af%bc&#34;&gt;2.1 内核引导&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%e8%bf%90%e8%a1%8cinit&#34;&gt;2.2 运行init&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#221-%e8%bf%90%e8%a1%8c%e7%ba%a7%e5%88%ab&#34;&gt;2.2.1 运行级别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%e7%b3%bb%e7%bb%9f%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;2.3 系统初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%e5%bb%ba%e7%ab%8b%e7%bb%88%e7%ab%af&#34;&gt;2.4 建立终端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25-%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e7%b3%bb%e7%bb%9f&#34;&gt;2.5 用户登录系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#251-%e5%9b%be%e5%bd%a2%e6%a8%a1%e5%bc%8f%e4%b8%8e%e6%96%87%e5%ad%97%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%88%87%e6%8d%a2%e6%96%b9%e5%bc%8f&#34;&gt;2.5.1 图形模式与文字模式的切换方式&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#26-linux-%e5%85%b3%e6%9c%ba&#34;&gt;2.6 Linux 关机&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux 系统的启动过程可以分为 5 个阶段&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内核的引导&lt;/li&gt;
&lt;li&gt;运行 init&lt;/li&gt;
&lt;li&gt;系统初始化&lt;/li&gt;
&lt;li&gt;建立终端&lt;/li&gt;
&lt;li&gt;用户登录系统&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;init 程序的类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;SysV: init，CentOS 5之前，配置文件：&lt;code&gt;/etc/inittab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Upstart: init，CentOS 6，配置文件：&lt;code&gt;/etc/inittab&lt;/code&gt;，&lt;code&gt;/etc/init/*.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Systemd： systemd，CentOS 7，配置文件：&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;，&lt;code&gt;/etc/systemd/system&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-1-内核引导&#34;&gt;2.1 内核引导&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;当计算机打开电源后，首先是 BIOS 开机自检，按照 BIOS 中设置的启动设备(通常是硬盘)来启动&lt;/li&gt;
&lt;li&gt;操作系统接管硬件以后，首先读入&lt;code&gt;/boot&lt;/code&gt;目录下的内核文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-运行init&#34;&gt;2.2 运行init&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动&lt;/li&gt;
&lt;li&gt;init 程序首先是需要读取配置文件&lt;code&gt;/etc/inittab&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-1-运行级别&#34;&gt;2.2.1 运行级别&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;许多程序需要开机启动。它们在 Windows 叫做&amp;rdquo;服务&amp;rdquo;(service)，在Linux就叫做&amp;rdquo;守护进程&amp;rdquo;(daemon)&lt;/li&gt;
&lt;li&gt;init 进程的一大任务，就是去运行这些开机启动的程序&lt;/li&gt;
&lt;li&gt;但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动 Apache，用作桌面就不需要&lt;/li&gt;
&lt;li&gt;Linux 允许为不同的场合，分配不同的开机启动程序，这就叫做&amp;rdquo;运行级别&amp;rdquo;(runlevel)。也就是说，启动时根据&amp;rdquo;运行级别&amp;rdquo;，确定要运行哪些程序。Linux 系统有 7 个运行级别(runlevel)

&lt;ul&gt;
&lt;li&gt;运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动&lt;/li&gt;
&lt;li&gt;运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆&lt;/li&gt;
&lt;li&gt;运行级别 2：多用户状态(没有NFS)&lt;/li&gt;
&lt;li&gt;运行级别 3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式&lt;/li&gt;
&lt;li&gt;运行级别 4：系统未使用，保留&lt;/li&gt;
&lt;li&gt;运行级别 5：X11 控制台，登陆后进入图形 GUI 模式&lt;/li&gt;
&lt;li&gt;运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-3-系统初始化&#34;&gt;2.3 系统初始化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 init 的配置文件中有这么一行：&lt;code&gt;si::sysinit:/etc/rc.d/rc.sysinit&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;它调用执行了&lt;code&gt;/etc/rc.d/rc.sysinit&lt;/code&gt;，而&lt;code&gt;rc.sysinit&lt;/code&gt;是一个 bash shell 的脚本，它主要是完成一些系统初始化的工作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rc.sysinit&lt;/code&gt;是每一个运行级别都要首先运行的重要脚本&lt;/li&gt;
&lt;li&gt;它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l5:5:wait:/etc/rc.d/rc 5&lt;/code&gt;这一行表示以 5 为参数运行&lt;code&gt;/etc/rc.d/rc&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/rc.d/rc&lt;/code&gt;是一个 Shell 脚本，它接受 5 作为参数，去执行&lt;code&gt;/etc/rc.d/rc5.d/&lt;/code&gt;目录下的所有的 rc 启动脚本&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/rc.d/rc5.d/&lt;/code&gt;目录中的这些启动脚本实际上都是一些链接文件，而不是真正的 rc 启动脚本，真正的 rc 启动脚本实际上都是放在&lt;code&gt;/etc/rc.d/init.d/&lt;/code&gt;目录下&lt;/li&gt;
&lt;li&gt;而这些 rc 启动脚本有着类似的用法，它们一般能接受 start、stop、restart、status 等参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/rc.d/rc5.d/&lt;/code&gt;中的 rc 启动脚本通常是 K 或 S 开头的链接文件&lt;/li&gt;
&lt;li&gt;对于以 S 开头的启动脚本，将以 start 参数来运行&lt;/li&gt;
&lt;li&gt;而如果发现存在相应的脚本也存在 K 打头的链接，而且已经处于运行态了(以&lt;code&gt;/var/lock/subsys/&lt;/code&gt;下的文件作为标志)，则将首先以 stop 为参数停止这些已经启动了的守护进程，然后再重新运行&lt;/li&gt;
&lt;li&gt;这样做是为了保证是当 init 改变运行级别时，所有相关的守护进程都将重启&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;至于在每个运行级中将运行哪些守护进程，用户可以通过&lt;code&gt;chkconfig&lt;/code&gt;或&lt;code&gt;setup&lt;/code&gt;中的&amp;rdquo;System Services&amp;rdquo;来自行设定&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-4-建立终端&#34;&gt;2.4 建立终端&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;rc 执行完毕后，返回 init。这时基本系统环境已经设置好了，各种守护进程也已经启动了&lt;/li&gt;

&lt;li&gt;&lt;p&gt;init 接下来会打开 6 个终端，以便用户登录系统。在&lt;code&gt;inittab&lt;/code&gt;中的以下 6 行就是定义了 6 个终端&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;1:2345:respawn:/sbin/mingetty tty1
2:2345:respawn:/sbin/mingetty tty2
3:2345:respawn:/sbin/mingetty tty3
4:2345:respawn:/sbin/mingetty tty4
5:2345:respawn:/sbin/mingetty tty5
6:2345:respawn:/sbin/mingetty tty6
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从上面可以看出在 2、3、4、5 的运行级别中都将以&lt;code&gt;respawn&lt;/code&gt;方式运行&lt;code&gt;mingetty&lt;/code&gt;程序&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mingetty&lt;/code&gt;程序能打开终端、设置模式&lt;/li&gt;
&lt;li&gt;同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给 login 程序来验证用户的身份&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-5-用户登录系统&#34;&gt;2.5 用户登录系统&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一般来说，用户的登录方式有三种

&lt;ul&gt;
&lt;li&gt;命令行登录&lt;/li&gt;
&lt;li&gt;ssh 登录&lt;/li&gt;
&lt;li&gt;图形界面登录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于运行级别为 5 的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器&lt;/li&gt;
&lt;li&gt;文本方式登录：当我们看到 mingetty 的登录界面时，我们就可以输入用户名和密码来登录系统了&lt;/li&gt;
&lt;li&gt;Linux 的账号验证程序是 login

&lt;ul&gt;
&lt;li&gt;login 会接收 mingetty 传来的用户名作为用户名参数&lt;/li&gt;
&lt;li&gt;然后 login 会对用户名进行分析：如果用户名不是 root，且存在&lt;code&gt;/etc/nologin&lt;/code&gt;文件，login 将输出 nologin 文件的内容，然后退出&lt;/li&gt;
&lt;li&gt;这通常用来系统维护时防止非 root 用户登录。只有/&lt;code&gt;etc/securetty&lt;/code&gt;中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/usertty&lt;/code&gt;文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-5-1-图形模式与文字模式的切换方式&#34;&gt;2.5.1 图形模式与文字模式的切换方式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 预设提供了六个命令窗口终端机让我们来登录&lt;/li&gt;
&lt;li&gt;默认我们登录的就是第一个窗口，也就是 tty1，这个六个窗口分别为 tty1,tty2 … tty6，你可以按下&lt;code&gt;Ctrl + Alt + F1 ~ F6&lt;/code&gt; 来切换它们。&lt;/li&gt;
&lt;li&gt;如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按&lt;code&gt;Ctrl + Alt + F1 ~ F6&lt;/code&gt;来进入其中一个命令窗口界面&lt;/li&gt;
&lt;li&gt;当你进入命令窗口界面后再返回图形界面只要按下&lt;code&gt;Ctrl + Alt + F7&lt;/code&gt;就回来了&lt;/li&gt;
&lt;li&gt;如果你用的 vmware 虚拟机，命令窗口切换的快捷键为&lt;code&gt;Alt + Space + F1~F6&lt;/code&gt;。如果你在图形界面下请按&lt;code&gt;Alt + Shift + Ctrl + F1~F6&lt;/code&gt;切换至命令窗口&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-6-linux-关机&#34;&gt;2.6 Linux 关机&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 Linux 领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情-况下，不得已才会关机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;| 命令 | 功能 | 备注 | 命令示例 |
| sync | 将数据由内存同步到硬盘中 | 重启或关闭系统前运行&lt;code&gt;sync&lt;/code&gt;命令，把内存数据写到磁盘 | - |
| shutdown | 给系统计划一个时间关机 | 如果使用了时间参数，系统关机前 5 分钟会创建&lt;code&gt;/run/nologin&lt;/code&gt;文件。以确保没有人可以再登录 | &lt;code&gt;shutdown [-h|-r] now&lt;/code&gt; 现在停止(默认)/关闭/重启机器 |
| halt | 关闭系统，通知硬件来停止所有的 CPU 功能，但仍然保持通电。你可以用它使系统处于低层维护状态。一般需要手动重启或关机。注意在有些情况会它会完全关闭系统(某些Linux 发布版的微调) | 等同于&lt;code&gt;shutdown –h now&lt;/code&gt;和 &lt;code&gt;poweroff&lt;/code&gt; | &lt;code&gt;halt -p&lt;/code&gt; 关闭系统后关闭电源 |
| poweroff | 会发送一个 ACPI 信号来通知系统关机(关闭计算机操作系统并切断系统电源) | 等同于&lt;code&gt;shutdown now&lt;/code&gt;| &lt;code&gt;poweroff -h&lt;/code&gt; 关闭操作系统之前将系统中所有的硬件设置为备用模式 |
| reboot | 重新启动正在运行的操作系统 | 等同于&lt;code&gt;shutdown –r now&lt;/code&gt; | &lt;code&gt;reboot&lt;/code&gt; |&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正确的关机流程为：&lt;code&gt;sync &amp;gt; shutdown &amp;gt; reboot &amp;gt; halt&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;最好在重启前执行几次&lt;code&gt;sync&lt;/code&gt;命令，可以让暂时保存在内存中的数据同步到硬盘上&lt;/li&gt;
&lt;li&gt;建议使用&lt;code&gt;shutdown –r now&lt;/code&gt;重启。在重启时会正常保存和中止服务器中正在运行的程序，是安全命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以运行如下命令关机&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;shutdown
shutdown now
shutdown 20:25
# 10 分钟后关机
shutdown –h +10
# 10 分钟后关机，并且会显示在登陆用户的当前屏幕中
shutdown –h 10
# 在 20:25 关机
shutdown –h 20:25
# 10 分钟后重启
shutdown –r +10
# 要取消即将进行的关机
shutdown -c
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关机的命令有&lt;code&gt;shutdown –h now&lt;/code&gt;/&lt;code&gt;halt&lt;/code&gt;/&lt;code&gt;poweroff&lt;/code&gt;/&lt;code&gt;init 0&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重启系统的命令有&lt;code&gt;shutdown –r now&lt;/code&gt;/&lt;code&gt;reboot&lt;/code&gt;/&lt;code&gt;init 6&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注意&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;远程服务器在重启前，要中止正在执行的服务。计算机的硬盘最怕在高速存储时断电或重启，非常容易造成硬盘损坏。所以，在重启前先中止服务，甚至可以考虑暂时断开对外提供服务的网络&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>3 系统目录结构</title>
      <link>https://xueqing.github.io/blog/linux/3_%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/3_%E7%B3%BB%E7%BB%9F%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-fhs-%e6%a0%87%e5%87%86&#34;&gt;3.1 FHS 标准&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-linux-%e6%a0%b9%e7%9b%ae%e5%bd%95&#34;&gt;3.2 Linux 根目录&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#321-%e7%b3%bb%e7%bb%9f%e5%90%af%e5%8a%a8%e7%9b%b8%e5%85%b3&#34;&gt;3.2.1 系统启动相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#322-%e5%91%bd%e4%bb%a4%e9%9b%86%e5%90%88&#34;&gt;3.2.2 命令集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3221-usr-%e7%9b%ae%e5%bd%95&#34;&gt;3.2.2.1 /usr 目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3222-linux-%e5%91%bd%e4%bb%a4&#34;&gt;3.2.2.2 Linux 命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#32221-%e5%91%bd%e4%bb%a4%e6%8f%90%e7%a4%ba%e7%ac%a6&#34;&gt;3.2.2.2.1 命令提示符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32222-%e5%91%bd%e4%bb%a4%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a0%bc%e5%bc%8f&#34;&gt;3.2.2.2.2 命令的基本格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32223-%e5%91%bd%e4%bb%a4%e5%88%86%e7%b1%bb&#34;&gt;3.2.2.2.3 命令分类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#323-%e5%a4%96%e9%83%a8%e6%96%87%e4%bb%b6%e5%92%8c%e8%ae%be%e5%a4%87%e7%ae%a1%e7%90%86&#34;&gt;3.2.3 外部文件和设备管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#324-%e4%b8%b4%e6%97%b6%e6%96%87%e4%bb%b6&#34;&gt;3.2.4 临时文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#325-%e8%b4%a6%e6%88%b7%e7%9b%b8%e5%85%b3&#34;&gt;3.2.5 账户相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#326-%e8%bf%90%e8%a1%8c%e8%bf%87%e7%a8%8b%e7%9b%b8%e5%85%b3&#34;&gt;3.2.6 运行过程相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3261-var-%e7%9b%ae%e5%bd%95&#34;&gt;3.2.6.1 /var 目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#327-%e6%89%a9%e5%b1%95%e6%89%80%e9%9c%80&#34;&gt;3.2.7 扩展所需&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%e6%b3%a8%e6%84%8f&#34;&gt;3.3 注意&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-fhs-标准&#34;&gt;3.1 FHS 标准&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;为了避免诸多使用者对 Linux 系统目录结构天马行空，Linux 基金会发布了 FHS 标准。多数 Linux 发行版系统都遵循这一标准&lt;/li&gt;
&lt;li&gt;FHS（Filesystem Hierarchy Standard），文件系统层次化标准，该标准规定了 Linux 系统中所有一级目录以及部分二级目录（/usr 和 /var）的用途。发布此标准的主要目的就是为了让用户清楚地了解每个目录应该存放什么类型的文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-linux-根目录&#34;&gt;3.2 Linux 根目录&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;FHS 认为，Linux 系统的根目录（/）最为重要（没有之一），其原因有以下 2 点

&lt;ul&gt;
&lt;li&gt;所有目录都是由根目录衍生出来的&lt;/li&gt;
&lt;li&gt;根目录与系统的开机、修复、还原密切相关&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在 Linux 或 Unix 操作系统中，所有的文件和目录都被组织成以一个根节点开始的倒置的树状结构

&lt;ul&gt;
&lt;li&gt;文件系统的最顶层由根目录开始的，系统使用&lt;code&gt;/&lt;/code&gt;表示根目录&lt;/li&gt;
&lt;li&gt;根目录之下的既可以是目录(一级目录)，也可以是文件，而每一个目录中又可以包含子目录(二级目录)和文件。如此反复就可以构成一个庞大的文件系统&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;两个特殊的目录

&lt;ul&gt;
&lt;li&gt;用户所在的工作目录，也叫当前目录，可使用一个点&lt;code&gt;.&lt;/code&gt;或&lt;code&gt;./&lt;/code&gt;表示&lt;/li&gt;
&lt;li&gt;当前目录的上一级目录，也叫父目录，可使用两个点&lt;code&gt;..&lt;/code&gt;或&lt;code&gt;../&lt;/code&gt;表示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果一个目录或文件名以一个点&lt;code&gt;.&lt;/code&gt;开始，表示这个目录或文件是一个隐藏目录或文件(&lt;code&gt;.bashrc&lt;/code&gt;)。即以默认方式查找时，不显示该目录或文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-2-1-系统启动相关&#34;&gt;3.2.1 系统启动相关&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/boot&lt;/td&gt;
&lt;td&gt;存放启动 Linux 时使用的一些核心文件，包括一些链接文件以及镜像文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/etc&lt;/td&gt;
&lt;td&gt;存放所有系统管理所需要的配置文件和子目录，&lt;strong&gt;更改目录下的文件可能导致系统不能启动&lt;/strong&gt;。系统内所有默认安装（rpm 安装）的服务配置文件全部保存在此目录，如用户信息、服务启动脚本、常用服务的配置文件等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/lib&lt;/td&gt;
&lt;td&gt;存放系统最基本的动态链接共享库，作用类似 Windows 的 DLL 文件。几乎所有的应用程序都需要用到这些共享库&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/sys&lt;/td&gt;
&lt;td&gt;虚拟文件系统。和 /proc/ 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息。这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs。sysfs文件系统集成了下面3种文件系统的信息：针对进程信息的proc文件系统、针对设备的devfs文件系统以及针对伪终端的devpts文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-2-2-命令集合&#34;&gt;3.2.2 命令集合&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/bin&lt;/td&gt;
&lt;td&gt;Binary 的缩写，存放最常使用的命令(如 ls 在 /bin/ls 目录)，普通用户和 root 都可执行。在单用户模式下也可以执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/sbin&lt;/td&gt;
&lt;td&gt;s(Super User)，保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/bin&lt;/td&gt;
&lt;td&gt;系统用户使用的应用程序，普通用户和超级用户都可执行。这些命令和系统启动无关，在单用户模式下不能执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/sbin&lt;/td&gt;
&lt;td&gt;超级用户使用的比较高级的管理程序和系统守护程序&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;/bin, /sbin, /usr/bin, /usr/sbin: 系统预设的执行文件的放置目录

&lt;ul&gt;
&lt;li&gt;/sbin, /usr/sbin 是给 root 使用的指令&lt;/li&gt;
&lt;li&gt;/bin, /usr/bin 是给系统用户使用的指令(除root外的通用户)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;3-2-2-1-usr-目录&#34;&gt;3.2.2.1 /usr 目录&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;usr（注意不是 user），全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 /usr 目录下的各子目录中，而不是为他们的产品创建单独的目录&lt;/li&gt;
&lt;li&gt;Linux 系统中，所有系统默认的软件都存储在 /usr 目录下，/usr 目录类似 Windows 系统中 C:\Windows\ + C:\Program files\ 两个目录的综合体&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/usr/include&lt;/td&gt;
&lt;td&gt;C/C++ 等编程语言头文件的放置目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/lib&lt;/td&gt;
&lt;td&gt;应用程序调用的函数库保存位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/local&lt;/td&gt;
&lt;td&gt;手工安装的软件保存位置。一般建议源码包软件安装在这个位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/src&lt;/td&gt;
&lt;td&gt;内核源代码默认的放置目录。手工下载的源码包和内核源码包都可以保存到这里&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/usr/XllR6&lt;/td&gt;
&lt;td&gt;图形界面系统保存位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;3-2-2-2-linux-命令&#34;&gt;3.2.2.2 Linux 命令&lt;/h4&gt;

&lt;h5 id=&#34;3-2-2-2-1-命令提示符&#34;&gt;3.2.2.2.1 命令提示符&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;登录系统后，第一眼看到的内容是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost ~]#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这就是 Linux 系统的命令提示符&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;[]：这是提示符的分隔符号，没有特殊含义&lt;/li&gt;
&lt;li&gt;root：显示的是当前的登录用户&lt;/li&gt;
&lt;li&gt;@：分隔符号，没有特殊含义&lt;/li&gt;
&lt;li&gt;localhost：当前系统的简写主机名（完整主机名是 localhost.localdomain）&lt;/li&gt;
&lt;li&gt;~：代表用户当前所在的目录，此例中用户当前所在的目录是家目录&lt;/li&gt;
&lt;li&gt;#：命令提示符，Linux 用这个符号标识登录的用户权限等级&lt;/li&gt;
&lt;li&gt;超级用户，提示符是 #&lt;/li&gt;
&lt;li&gt;普通用户，提示符是 $&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户在自己的家目录中拥有完整权限，所以建议操作实验可以放在家目录中进行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost ~]# cd /usr/local
# 切换用户所在目录，命令提示符中的 ~ 会变成用户当前所在目录的最后一个目录（不显示完整的所在目录 /usr/local，只显示最后一个目录 local)
[root@localhost local]#
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-2-2-2-2-命令的基本格式&#34;&gt;3.2.2.2.2 命令的基本格式&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;基本格式 &lt;code&gt;命令[选项][参数]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;[] 代表可选项，也就是有些命令可以不写选项或参数，也能执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用 Linux 中最常见的 ls 命令来解释一下命令的格式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果按照命令的分类，那么 ls 命令应该属于目录操作命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# ls 命令之后不加选项和参数也能执行，但只能执行最基本的功能，即显示当前目录下的文件名
[root@localhost ~]# ls
anaconda-ks.cfg install.log install.log.syslog
# 如果加&amp;quot;-l&amp;quot;选项，可以看到显示的内容明显增多了
# &amp;quot;-l&amp;quot;是长格式（long list）的意思，也就是显示文件的详细信息
[root@localhost ~]# Is -l
总用量44
-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg
-rw-r--r--.1 root root 24772 1 月 14 18:17 install.log
-rw-r--r--.1 root root 7690 1 月 14 18:17 install.log.syslog
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项的作用：调整命令功能。如果没有选项，命令只能执行最基本的功能；而选项可以显示更加丰富的数据&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;短格式选项（-l）：是英文的简写，用一个减号调用，如 &lt;code&gt;[root@localhost ~]# ls -l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;长格式选项（&amp;ndash;all）：是英文完整单词，一般用两个减号调用，如 &lt;code&gt;[root@localhost ~]# ls --all&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一般情况下，短格式选项是长格式选项的缩写，也就是一个短格式选项会有对应的长格式选项&lt;/li&gt;
&lt;li&gt;当然也有例外，比如 ls 命令的短格式选项 -l 就没有对应的长格式选项&lt;/li&gt;
&lt;li&gt;具体的命令选项可以通过帮助命令来进行査询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;参数的作用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;参数是命令的操作对象，一般文件、目录、用户和进程等可以作为参数被命令操作&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命令一般都需要加入参数，用于指定命令操作的对象是谁。如果可以省略参数，则一般都有默认参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@localhost ~]# ls -l anaconda-ks.cfg
-rw-------.1 root root 1207 1 月 14 18:18 anaconda-ks.cfg
# ls 默认参数是当前所在位置，显示当前目录下的文件名
[root@localhost ~]# ls
anaconda-ks.cfg install.log install.log.syslog
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;3-2-2-2-3-命令分类&#34;&gt;3.2.2.2.3 命令分类&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Linux 命令按照来源方式，可分为两种

&lt;ul&gt;
&lt;li&gt;Shell 内置命令：Shell 自带的命令，这些命令没有执行文件，也没有执行文件所在路径&lt;/li&gt;
&lt;li&gt;外部命令：外部命令是由程序员单独开发的，是命令，会有命令的执行文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux 中的绝大多数命令是外部命令&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;3-2-3-外部文件和设备管理&#34;&gt;3.2.3 外部文件和设备管理&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/dev&lt;/td&gt;
&lt;td&gt;Device(设备)的缩写, 存放 Linux 的外部设备，在 Linux 中访问设备和访问文件的方式相同&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/media&lt;/td&gt;
&lt;td&gt;Linux 系统会自动识别一些媒体设备(U 盘/光驱)，识别后把识别的设备挂载到这个目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/mnt&lt;/td&gt;
&lt;td&gt;为了让用户临时挂载别的文件系统。可以将光驱挂载在/mnt/上，然后进入该目录查看光驱里的内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/misc&lt;/td&gt;
&lt;td&gt;挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/，但是哪个目录挂载什么设备可由管理员自己决定&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-2-4-临时文件&#34;&gt;3.2.4 临时文件&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/lost+found&lt;/td&gt;
&lt;td&gt;一般情况下为空，当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，/lost+found 就是根分区的备份恢复目录，/boot/lost+found 就是 /boot 分区的备份恢复目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/run&lt;/td&gt;
&lt;td&gt;一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果系统上有 /var/run 目录，应该让它指向 run&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/tmp&lt;/td&gt;
&lt;td&gt;用来存放一些临时文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-2-5-账户相关&#34;&gt;3.2.5 账户相关&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/home&lt;/td&gt;
&lt;td&gt;用户主目录(也称家目录)。创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 /home/ 下建立一个和用户名相同的目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/root&lt;/td&gt;
&lt;td&gt;系统管理员，也称作超级权限者的用户主目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-2-6-运行过程相关&#34;&gt;3.2.6 运行过程相关&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/proc&lt;/td&gt;
&lt;td&gt;虚拟文件系统。是一个虚拟目录，是系统内存的映射，可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘而在内存，主要保存系统的内核、进程、外部设备状态和网络状态等。如 /proc/cpuinfo 是保存 CPU 信息的，/proc/devices 是保存设备驱动的列表的，/proc/filesystems 是保存文件系统列表的，/proc/net 是保存网络协议信息的。也可直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器&lt;code&gt;echo 1 &amp;gt; /proc/sys/net/ipv4/icmp_echo_ignore_all&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var&lt;/td&gt;
&lt;td&gt;存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;3-2-6-1-var-目录&#34;&gt;3.2.6.1  /var 目录&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;/var：这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/var/lib&lt;/td&gt;
&lt;td&gt;程序运行中需要调用或改变的数据保存位置。如 MySQL 数据库保存在 /var/lib/mysql/&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/log&lt;/td&gt;
&lt;td&gt;登陆文件放置的目录，其中包含比较重要的文件如 /var/log/messages, /var/log/wtmp 等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/nis和/var/yp&lt;/td&gt;
&lt;td&gt;NIS 服务机制使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 NIS 服务的日志文件存放的目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/run&lt;/td&gt;
&lt;td&gt;一些服务和程序运行后，它们的 PID（进程 ID）保存位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/spool&lt;/td&gt;
&lt;td&gt;主要是一些临时存放，随时会被用户调用的数据，例如 /var/spool/mail/ 存放新收到的邮件，/var/spool/cron/ 存放系统定时任务&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/tmp&lt;/td&gt;
&lt;td&gt;一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/var/www&lt;/td&gt;
&lt;td&gt;RPM 包安装的 Apache 的网页主目录&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;3-2-7-扩展所需&#34;&gt;3.2.7 扩展所需&lt;/h3&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;目录&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;/opt&lt;/td&gt;
&lt;td&gt;第三方安装的软件保存位置。是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录。如安装一个ORACLE数据库就可以放到这个目录下。默认是空。/usr/local/ 目录也可以用来安装软件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/selinux&lt;/td&gt;
&lt;td&gt;Redhat/CentOS所特有的目录，Selinux是一个安全机制，类似于windows的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;/srv&lt;/td&gt;
&lt;td&gt;服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;3-3-注意&#34;&gt;3.3 注意&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;/proc/fn/sys/ 保存在内存，如果在这里写入数据，那么内存会越来越小，直至死机&lt;/li&gt;
&lt;li&gt;/boot/ 不能保存额外数据，因为会单独分区作为启动分区，如果没有空闲空间，会导致系统不能正常启动&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>4 文件基本属性</title>
      <link>https://xueqing.github.io/blog/linux/4_%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/4_%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-linux-%e6%96%87%e4%bb%b6%e5%b1%9e%e6%80%a7&#34;&gt;4.1 Linux 文件属性&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#411-linux-%e4%b8%80%e5%88%87%e7%9a%86%e6%96%87%e4%bb%b6&#34;&gt;4.1.1 Linux 一切皆文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4111-%e6%8c%82%e8%bd%bd&#34;&gt;4.1.1.1 挂载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#412-linuxunix-%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b&#34;&gt;4.1.2 Linux/UNIX 文件类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-linux-%e6%96%87%e4%bb%b6%e5%b1%9e%e4%b8%bb%e5%92%8c%e5%b1%9e%e7%bb%84&#34;&gt;4.2 Linux 文件属主和属组&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#421-%e6%9b%b4%e6%94%b9%e6%96%87%e4%bb%b6%e5%b1%9e%e6%80%a7&#34;&gt;4.2.1 更改文件属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4211-chgrp-%e6%9b%b4%e6%94%b9%e6%96%87%e4%bb%b6%e5%b1%9e%e7%bb%84&#34;&gt;4.2.1.1 chgrp 更改文件属组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4212-chown-%e6%9b%b4%e6%94%b9%e6%96%87%e4%bb%b6%e5%b1%9e%e4%b8%bb%e4%b9%9f%e5%8f%af%e4%bb%a5%e5%90%8c%e6%97%b6%e6%9b%b4%e6%94%b9%e6%96%87%e4%bb%b6%e5%b1%9e%e7%bb%84&#34;&gt;4.2.1.2 chown 更改文件属主，也可以同时更改文件属组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4213-chmod-%e6%9b%b4%e6%94%b9%e6%96%87%e4%bb%b69%e4%b8%aa%e5%b1%9e%e6%80%a7&#34;&gt;4.2.1.3 chmod 更改文件9个属性&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#42131-chmod-%e7%94%a8%e6%95%b0%e5%ad%97%e6%9b%b4%e6%94%b9%e6%96%87%e4%bb%b69%e4%b8%aa%e5%b1%9e%e6%80%a7&#34;&gt;4.2.1.3.1 chmod 用数字更改文件9个属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42131-chmod-%e7%94%a8%e7%ac%a6%e5%8f%b7%e6%9b%b4%e6%94%b9%e6%96%87%e4%bb%b69%e4%b8%aa%e5%b1%9e%e6%80%a7&#34;&gt;4.2.1.3.1 chmod 用符号更改文件9个属性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-linux-%e6%96%87%e4%bb%b6%e6%97%b6%e9%97%b4%e5%b1%9e%e6%80%a7&#34;&gt;4.3 Linux 文件时间属性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-1-linux-文件属性&#34;&gt;4.1 Linux 文件属性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限&lt;/li&gt;
&lt;li&gt;为了保护系统的安全性，Linux系统对不同的用户访问同一文件(包括目录文件)的权限做了不同的规定&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Linux中我们可以使用&lt;code&gt;ll&lt;/code&gt;或者&lt;code&gt;ls –l&lt;/code&gt;命令来显示一个文件的属性以及文件所属的用户和组，如&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;实例中，bin文件的第一个属性用&amp;rdquo;d&amp;rdquo;表示，在Linux中代表该文件是一个目录文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www /]# ls -l
total 64
dr-xr-xr-x   2 root root 4096 Dec 14  2012 bin
dr-xr-xr-x   4 root root 4096 Apr 19  2012 boot
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在Linux中第一个字符代表这个文件是目录、文件或链接文件等等&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; 目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt; 链接文档(link file)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt; 可供储存的接口设备(可随机存取装置)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 串行端口设备，如键盘、鼠标(一次性读取装置)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接下来的字符中，以三个为一组，且均为&lt;code&gt;rwx&lt;/code&gt;的三个参数的组合&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt;代表可读(read)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt;代表可写(write)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;代表可执行(execute)&lt;/li&gt;
&lt;li&gt;要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号&lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每个文件的属性由左边第一部分的10个字符来确定，从左至右用0-9这些数字来表示&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0位：确定文件类型&lt;/li&gt;
&lt;li&gt;1-3位：确定属主(该文件的所有者 owner)拥有该文件的权限&lt;/li&gt;
&lt;li&gt;4-6位：确定属组(所有者的同组用户 group)拥有该文件的权限&lt;/li&gt;
&lt;li&gt;7-9位：确定其他用户(others)拥有该文件的权限&lt;/li&gt;
&lt;li&gt;1、4、7位：表示读权限，&amp;rdquo;r&amp;rdquo;字符表示有读权限；&amp;rdquo;-&amp;ldquo;字符表示没有读权限&lt;/li&gt;
&lt;li&gt;2、5、8位：表示写权限，&amp;rdquo;w&amp;rdquo;字符表示有写权限；&amp;rdquo;-&amp;ldquo;字符表示没有写权限&lt;/li&gt;
&lt;li&gt;3、6、9位：表示可执行权限，&amp;rdquo;x&amp;rdquo;字符表示有执行权限；&amp;rdquo;-&amp;ldquo;字符表示没有执行权限&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/blog/linux/images/file_attr.png&#34; alt=&#34;文件属性&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;4-1-1-linux-一切皆文件&#34;&gt;4.1.1 Linux 一切皆文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linux 中所有内容都是以文件的形式保存和管理的，即一切皆文件。包括普通文件、目录(Windows 下称为文件夹)、硬件设备(键盘、监视器、硬盘、打印机)、套接字(socket)、网络通信等资源&lt;/li&gt;
&lt;li&gt;好处

&lt;ul&gt;
&lt;li&gt;开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源&lt;/li&gt;
&lt;li&gt;比如，Linux 中几乎所有读（文件、系统状态、socket、pipe）的操作都可以用 read 函数；几乎所有更改（改文件、改系统参数、写 socket、写 pipe）的操作都可以用 write 函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;坏处

&lt;ul&gt;
&lt;li&gt;使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用&lt;/li&gt;
&lt;li&gt;如果想通过 Linux 上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义&lt;/li&gt;
&lt;li&gt;如果不挂载，通过Linux系统中的图形界面系统可以查看找到硬件设备，但命令行方式无法找到&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-1-1-1-挂载&#34;&gt;4.1.1.1 挂载&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;挂载：指将设备文件中的顶级目录连接到 Linux 根目录下的某一目录（最好是空目录），访问此目录就等同于访问设备文件&lt;/li&gt;
&lt;li&gt;误区：并不是根目录下任何一个目录都可以作为挂载点，由于挂载操作会使得原有目录中文件被隐藏，因此根目录以及系统原有目录都不要作为挂载点，会造成系统异常甚至崩溃，挂载点最好是新建的空目录&lt;/li&gt;
&lt;li&gt;根目录下的 /dev/ 目录文件负责所有的硬件设备文件，事实上，当 U 盘插入 Linux 后，系统会给 U 盘分配一个目录文件（比如 sdb1），就位于 /dev/ 目录下（/dev/sdb1），但无法通过 /dev/sdb1/ 直接访问 U 盘数据，访问此目录只会提供此设备的一些基本信息（比如容量）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-1-2-linux-unix-文件类型&#34;&gt;4.1.2 Linux/UNIX  文件类型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linux系统中，文件具体可分为以下几种类型&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件类型&lt;/th&gt;
&lt;th&gt;权限位表示&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;普通文件&lt;/td&gt;
&lt;td&gt;&amp;rsquo;-&amp;rsquo;&lt;/td&gt;
&lt;td&gt;类似 mp4、pdf、html 这样，可直接拿来使用的文件。Linux 用户根据访问权限不同可对这些文件进行查看、删除和更改操作&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;目录文件&lt;/td&gt;
&lt;td&gt;&amp;rsquo;d&amp;rsquo;&lt;/td&gt;
&lt;td&gt;包含了此目录中各个文件的文件名以及指向这些文件的指针。打开目录等同于打开目录文件，只要有权限，可以随意访问目录中的任何文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;特殊文件-块文件(block)&lt;/td&gt;
&lt;td&gt;&amp;lsquo;b&amp;rsquo;&lt;/td&gt;
&lt;td&gt;通常隐藏在 /dev/ 目录下，当进行设备读取或外设交互时才会被使用。如磁盘光驱&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;特殊文件-字符设备文件(character)&lt;/td&gt;
&lt;td&gt;&amp;lsquo;c&amp;rsquo;&lt;/td&gt;
&lt;td&gt;通常隐藏在 /dev/ 目录下，当进行设备读取或外设交互时才会被使用。如串口设备&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;特殊文件-符号链接文件(symbolic link)&lt;/td&gt;
&lt;td&gt;&amp;lsquo;l&amp;rsquo;&lt;/td&gt;
&lt;td&gt;类似与 Windows 中的快捷方式，是指向另一文件的简介指针(软链接)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;特殊文件-管道文件(pipe)&lt;/td&gt;
&lt;td&gt;&amp;lsquo;p&amp;rsquo;&lt;/td&gt;
&lt;td&gt;主要用于进程间通信。例如，使用 mkfifo 命令创建一个 FIFO 文件，与此同时，启用进程 A 从 FIFO 文件读数据，启用进程 B 从 FIFO 文件中写数据，随写随读&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;特殊文件-套接字文件(socket)&lt;/td&gt;
&lt;td&gt;&amp;rsquo;s&amp;rsquo;&lt;/td&gt;
&lt;td&gt;一般隐藏在 /var/run/ 目录下，用于进程间的网络通信&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;目录文件的访问权限，同普通文件的执行权限，是一个意思&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-linux-文件属主和属组&#34;&gt;4.2 Linux 文件属主和属组&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户&lt;/li&gt;
&lt;li&gt;在Linux系统中，用户是按组分类的，一个用户属于一个或多个组&lt;/li&gt;
&lt;li&gt;文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www /]# ls -l
total 64
drwxr-xr-x 2 root  root  4096 Feb 15 14:46 cron
drwxr-xr-x 3 mysql mysql 4096 Apr 21  2014 mysql
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在以上实例中，mysql 文件是一个目录文件，属主和属组都为 mysql，属主有可读、可写、可执行的权限；与属主同组的其他用户有可读和可执行的权限；其他用户也有可读和可执行的权限&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于 root 用户来说，一般情况下，文件的权限对其不起作用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;4-2-1-更改文件属性&#34;&gt;4.2.1 更改文件属性&lt;/h3&gt;

&lt;h4 id=&#34;4-2-1-1-chgrp-更改文件属组&#34;&gt;4.2.1.1 chgrp 更改文件属组&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;chgrp [-R] 属组名 文件名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;参数选项

&lt;ul&gt;
&lt;li&gt;-R：递归更改文件属组，即在更改某个目录文件的属组时加上 -R，则该目录下所有文件的属组都会更改&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-1-2-chown-更改文件属主-也可以同时更改文件属组&#34;&gt;4.2.1.2 chown 更改文件属主，也可以同时更改文件属组&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;语法：&lt;code&gt;chown [–R] 属主名 文件名&lt;/code&gt;或&lt;code&gt;chown [-R] 属主名:属组名 文件名&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入&lt;code&gt;/root&lt;/code&gt;目录(~)将&lt;code&gt;install.log&lt;/code&gt;的拥有者改为&lt;code&gt;bin&lt;/code&gt;这个账号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~] cd ~
[root@www ~]# chown bin install.log
[root@www ~]# ls -l
-rw-r--r--  1 bin  users 68495 Jun 25 08:53 install.log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将&lt;code&gt;install.log&lt;/code&gt;的拥有者与群组改回&lt;code&gt;root&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~]# chown root:root install.log
[root@www ~]# ls -l
-rw-r--r--  1 root root 68495 Jun 25 08:53 install.log
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;4-2-1-3-chmod-更改文件9个属性&#34;&gt;4.2.1.3 chmod 更改文件9个属性&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Linux文件属性有两种设置方法，一种是数字，一种是符号&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-2-1-3-1-chmod-用数字更改文件9个属性&#34;&gt;4.2.1.3.1 chmod 用数字更改文件9个属性&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux文件的基本权限有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文件的权限字符为：&lt;code&gt;-rwxrwxrwx&lt;/code&gt;， 这九个权限是三个三个一组的&lt;/li&gt;
&lt;li&gt;可以使用数字来代表各个权限，各权限的分数对照表如下&lt;/li&gt;
&lt;li&gt;r:4&lt;/li&gt;
&lt;li&gt;w:2&lt;/li&gt;
&lt;li&gt;x:1&lt;/li&gt;
&lt;li&gt;每种身份(owner/group/others)各自的三个权限(r/w/x)分数需要累加，如权限为&lt;code&gt;-rwxrwx---&lt;/code&gt;分数是&lt;/li&gt;
&lt;li&gt;owner： rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;group： rwx = 4+2+1 = 7&lt;/li&gt;
&lt;li&gt;others：&amp;mdash; = 0+0+0 = 0&lt;/li&gt;
&lt;li&gt;设定权限的变更时，该文件的权限数字就是 770&lt;/li&gt;
&lt;li&gt;变更权限的指令 chmod 的语法：&lt;code&gt;chmod [-R] xyz 文件或目录&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加&lt;/li&gt;
&lt;li&gt;-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;举例，如果要将&lt;code&gt;.bashrc&lt;/code&gt;这个文件所有的权限都设定启用，那么命令如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~]# ls -al .bashrc
-rw-r--r--  1 root root 395 Jul  4 11:45 .bashrc
[root@www ~]# chmod 777 .bashrc
[root@www ~]# ls -al .bashrc
-rwxrwxrwx  1 root root 395 Jul  4 11:45 .bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;如果要将权限变成&lt;code&gt;-rwxr-xr--&lt;/code&gt;，那么权限的分数就成为&lt;code&gt;[4+2+1][4+0+1][4+0+0]=754&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;4-2-1-3-1-chmod-用符号更改文件9个属性&#34;&gt;4.2.1.3.1 chmod 用符号更改文件9个属性&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;九个权限分别是

&lt;ul&gt;
&lt;li&gt;(1)user&lt;/li&gt;
&lt;li&gt;(2)group&lt;/li&gt;
&lt;li&gt;(3)others&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用 u, g, o 来代表三种身份的权限&lt;/li&gt;
&lt;li&gt;a 则代表 all，即全部的身份。读写的权限可以写成 r, w, x，也就是可以使用：&lt;code&gt;chmod u|g|o|a +(加入)|-(除去)|=(设定) r|w|x 文件或目录&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果需要将文件权限设置为&lt;code&gt;-rwxr-xr--&lt;/code&gt;，可以使用&lt;code&gt;chmod u=rwx,g=rx,o=r 文件名&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建 test1 文件
touch test1
# 查看 test1 默认权限
ls -al test1
# -rw-r--r-- 1 root root 0 Nov 15 10:32 test1
# 修改 test1 权限
chmod u=rwx,g=rx,o=r test1
ls -al test1
# -rwxr-xr-- 1 root root 0 Nov 15 10:32 test1
# 如果是要将权限去掉而不改变其他已存在的权限。如要拿掉全部人的可执行权限
chmod  a-x test1
ls -al test1
#-rw-r--r-- 1 root root 0 Nov 15 10:32 test1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-linux-文件时间属性&#34;&gt;4.3 Linux 文件时间属性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间

&lt;ul&gt;
&lt;li&gt;访问时间(Access Time, atime)：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变&lt;/li&gt;
&lt;li&gt;数据修改时间(Modify Time, mtime)：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变&lt;/li&gt;
&lt;li&gt;状态修改时间(Change Time, ctime)：当文件的状态发生变化，就会相应改变这个时间。比如，如果文件的权限或者属性发生改变，此时间就会相应改变&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>5 文件与目录管理</title>
      <link>https://xueqing.github.io/blog/linux/5_%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/5_%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%e5%a4%84%e7%90%86%e7%9b%ae%e5%bd%95%e7%9a%84%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4&#34;&gt;5.1 处理目录的常用命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#511-ls-%e5%88%97%e5%87%ba%e7%9b%ae%e5%bd%95&#34;&gt;5.1.1 ls 列出目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#512-cd-%e5%88%87%e6%8d%a2%e7%9b%ae%e5%bd%95&#34;&gt;5.1.2 cd 切换目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#513-pwd-%e6%98%be%e7%a4%ba%e5%bd%93%e5%89%8d%e7%9b%ae%e5%bd%95&#34;&gt;5.1.3 pwd 显示当前目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#514-mkdir-%e5%88%9b%e5%bb%ba%e6%96%b0%e7%9b%ae%e5%bd%95&#34;&gt;5.1.4 mkdir 创建新目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#515-rmdir-%e5%88%a0%e9%99%a4%e7%a9%ba%e7%9a%84%e7%9b%ae%e5%bd%95&#34;&gt;5.1.5 rmdir 删除空的目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#516-cp-%e5%a4%8d%e5%88%b6%e6%96%87%e4%bb%b6%e6%88%96%e7%9b%ae%e5%bd%95&#34;&gt;5.1.6 cp 复制文件或目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#517-rm-%e7%a7%bb%e9%99%a4%e6%96%87%e4%bb%b6%e6%88%96%e7%9b%ae%e5%bd%95&#34;&gt;5.1.7 rm 移除文件或目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#518-mv-%e7%a7%bb%e5%8a%a8%e6%96%87%e4%bb%b6%e4%b8%8e%e7%9b%ae%e5%bd%95%e6%88%96%e4%bf%ae%e6%94%b9%e5%90%8d%e7%a7%b0&#34;&gt;5.1.8 mv 移动文件与目录，或修改名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#519-touch-%e5%88%9b%e5%bb%ba%e6%96%87%e4%bb%b6%e5%8f%8a%e4%bf%ae%e6%94%b9%e6%96%87%e4%bb%b6%e6%97%b6%e9%97%b4%e6%88%b3&#34;&gt;5.1.9 touch 创建文件及修改文件时间戳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5110-ln-%e5%9c%a8%e6%96%87%e4%bb%b6%e4%b9%8b%e9%97%b4%e5%bb%ba%e7%ab%8b%e9%93%be%e6%8e%a5%e7%a1%ac%e9%93%be%e6%8e%a5%e5%92%8c%e8%bd%af%e9%93%be%e6%8e%a5&#34;&gt;5.1.10 ln 在文件之间建立链接(硬链接和软链接)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-linux-%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9%e6%9f%a5%e7%9c%8b&#34;&gt;5.2 Linux 文件内容查看&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#521-cat-%e7%94%b1%e7%ac%ac%e4%b8%80%e8%a1%8c%e5%bc%80%e5%a7%8b%e6%98%be%e7%a4%ba%e6%96%87%e4%bb%b6%e5%86%85%e5%ae%b9&#34;&gt;5.2.1 cat 由第一行开始显示文件内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#522-tac&#34;&gt;5.2.2 tac&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#523-nl-%e6%98%be%e7%a4%ba%e8%a1%8c%e5%8f%b7&#34;&gt;5.2.3 nl 显示行号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#524-more-%e4%b8%80%e9%a1%b5%e4%b8%80%e9%a1%b5%e7%bf%bb%e5%8a%a8&#34;&gt;5.2.4 more 一页一页翻动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#525-less-%e4%b8%80%e9%a1%b5%e4%b8%80%e9%a1%b5%e7%bf%bb%e5%8a%a8&#34;&gt;5.2.5 less 一页一页翻动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#526-head-%e5%8f%96%e5%87%ba%e6%96%87%e4%bb%b6%e5%89%8d%e9%9d%a2%e5%87%a0%e8%a1%8c&#34;&gt;5.2.6 head 取出文件前面几行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#527-tail-%e5%8f%96%e5%87%ba%e6%96%87%e4%bb%b6%e5%90%8e%e9%9d%a2%e5%87%a0%e8%a1%8c&#34;&gt;5.2.7 tail 取出文件后面几行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#53-linux-%e9%93%be%e6%8e%a5&#34;&gt;5.3 Linux 链接&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#531-%e7%a1%ac%e9%93%be%e6%8e%a5&#34;&gt;5.3.1 硬链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#532-%e8%bd%af%e9%93%be%e6%8e%a5&#34;&gt;5.3.2 软链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#533-inode-%e5%b1%9e%e6%80%a7&#34;&gt;5.3.3 inode 属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#534-ln-%e5%91%bd%e4%bb%a4&#34;&gt;5.3.4 ln 命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux的目录结构为树状结构，最顶级的目录为根目录&lt;code&gt;/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他目录可以通过挂载将添加到树中，通过解除挂载可以移除&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;绝对路径：由根目录&lt;code&gt;/&lt;/code&gt;写起，如&lt;code&gt;/usr/share/doc&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;相对路径：不是由&lt;code&gt;/&lt;/code&gt;写起，是相对于当前路径的写法，如由&lt;code&gt;/usr/share/doc&lt;/code&gt;要到&lt;code&gt;/usr/share/man&lt;/code&gt;底下时，可以写成&lt;code&gt;cd ../man&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-1-处理目录的常用命令&#34;&gt;5.1 处理目录的常用命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用&lt;code&gt;man 命令&lt;/code&gt;来查看各个命令的使用文档，如&lt;code&gt;man cp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ls&lt;/td&gt;
&lt;td&gt;列出目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cd&lt;/td&gt;
&lt;td&gt;切换目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;td&gt;显示目前的目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mkdir&lt;/td&gt;
&lt;td&gt;创建一个新的目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rmdir&lt;/td&gt;
&lt;td&gt;删除一个空的目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cp&lt;/td&gt;
&lt;td&gt;复制文件或目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;rm&lt;/td&gt;
&lt;td&gt;移除文件或目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;mv&lt;/td&gt;
&lt;td&gt;移动文件与目录，或修改文件与目录的名称&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;5-1-1-ls-列出目录&#34;&gt;5.1.1 ls 列出目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ls [-aAdfFhilnrRSt] 目录名称&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls [--color={never,auto,always}] 目录名称&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls [--full-time] 目录名称&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选项与参数&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;显示全部文件，包括隐藏文件（开头为 . 的文件），是最常用的选项之一&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-A&lt;/td&gt;
&lt;td&gt;显示全部文件，连同隐藏文件，但不包括 . 与 ..&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;仅列出目录本身，不列出目录内的文件数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;ls 默认会以文件名排序，使用 -f 会直接列出结果，不进行排序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-F&lt;/td&gt;
&lt;td&gt;在文件或目录名后加上文件类型的指示符号，例如，* 代表可运行文件，/ 代表目录，= 代表 socket 文件，&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-h&lt;/td&gt;
&lt;td&gt;以易读的方式显示文件或目录大小，如 1KB、234MB、2GB 等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;显示 inode 节点信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;使用长格式列出文件和目录信息，包含文件的属性与权限等数据&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;以 UID 和 GID 分别代替文件用户名和群组名显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;将排序结果反向输出，比如若原本文件名由小到大，反向则为由大到小&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-R&lt;/td&gt;
&lt;td&gt;连同子目录内容一起列出来，等于将该目录下的所有文件都显示出来&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-S&lt;/td&gt;
&lt;td&gt;以文件容量大小排序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;以时间排序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;color=never&lt;/td&gt;
&lt;td&gt;不依据文件特性给予颜色显示&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;color=always&lt;/td&gt;
&lt;td&gt;表示显示颜色，ls 默认采用这种方式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;color=auto&lt;/td&gt;
&lt;td&gt;表示让系统自行依据配置来判断是否给予颜色&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;full-time&lt;/td&gt;
&lt;td&gt;以完整时间模式（包含年、月、日、时、分）输出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&amp;ndash;time={atime,ctime}&lt;/td&gt;
&lt;td&gt;输出访问时间或改变权限属性时间（ctime），而不是内容变更时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将主目录下的所有文件列出来(含属性与隐藏文件)
ls -al ~
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;5-1-2-cd-切换目录&#34;&gt;5.1.2 cd 切换目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;cd(Change Directory)：用来变换工作目录&lt;/li&gt;

&lt;li&gt;&lt;p&gt;语法 &lt;code&gt;cd [相对路径或绝对路径]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 回到自己的主目录，对于 root 用户，其主目录为 /root
[root@localhost vbird]# cd ~
# 没有加上任何路径，代表回到当前登录用户的主目录
[root@localhost ~]# cd
# 切换到 vbird 这个用户的主目录，即 /home/vbird
[root@localhost ~]# cd ~vbird
# 切换到目前的上一级目录，即 /root 的上一级目录
# 需要注意，在 Linux 系统中，根目录存在 .（当前目录）以及 ..（当前目录的父目录）两个目录
# 但由于根目录是最顶级目录，因此根目录的 .. 和 . 属性和权限完全一致，即根目录的父目录是自身
[root@localhost ~]# cd ..
# 回到上次所在目录
[root@localhost /]# cd -
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-3-pwd-显示当前目录&#34;&gt;5.1.3 pwd 显示当前目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;pwd(Print Working Directory)：显示当前所在目录(链接路径)&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;pwd [-P]&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-P ：显示出实际路径，而非使用链接(link)路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 确定当前登陆的用户
[root@www ~]# whoami
root
# 显示出目录
[root@www ~]# pwd
/root
# /var/mail是一个链接文件
[root@www ~]# cd /var/mail
# 列出目前的工作目录
[root@www mail]# pwd
/var/mail
[root@www mail]# pwd -P
# /var/spool/mail
[root@www mail]# ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&amp;gt; spool/mail
# /var/mail 链接到 /var/spool/mail
# 加上 -P 选项后，会不以链接文件的数据显示，而是显示正确的完整路径
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-4-mkdir-创建新目录&#34;&gt;5.1.4 mkdir 创建新目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;mkdir [-mp] 目录名称&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-m：配置文件的权限，直接配置，不需要看默认权限(umask)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-p：直接递归创建目录(包含上一级目录)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SH&#34;&gt;[root@www ~]# cd /tmp
# 创建一名为 test 的新目录
[root@www tmp]# mkdir test
# 没办法直接创建此目录
[root@www tmp]# mkdir test1/test2/test3/test4
# mkdir: cannot create directory `test1/test2/test3/test4&#39;:
# No such file or directory
# 加 -p 选项可以自行创建多层目录
[root@www tmp]# mkdir -p test1/test2/test3/test4
# 如果没有加上 -m 来强制配置属性，系统会使用默认属性。
[root@www tmp]# mkdir -m 711 test2
[root@www tmp]# ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-5-rmdir-删除空的目录&#34;&gt;5.1.5 rmdir 删除空的目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;rmdir [-p] 目录名称&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-p：递归删除空目录&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;#删除 runoob 目录
[root@www tmp]# rmdir runoob/
# 将 mkdir 实例中创建的目录(/tmp 底下)删除掉
[root@www tmp]# ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
[root@www tmp]# rmdir test
# 因为尚有内容，所以无法删除
[root@www tmp]# rmdir test1
# rmdir: `test1&#39;: Directory not empty
# 利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除
[root@www tmp]# rmdir -p test1/test2/test3/test4
[root@www tmp]# ls -l        &amp;lt;==您看看，底下的输出中test与test1不见了！
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要注意 rmdir 仅能删除空的目录，可以使用 rm 命令来删除非空目录&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-6-cp-复制文件或目录&#34;&gt;5.1.6 cp 复制文件或目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cp [-adfilprsu] 源文件(source) 目标文件(destination)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp [options] source1 source2 source3 .... directory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-a：等同于 -pdr&lt;/li&gt;
&lt;li&gt;-d：若源文件为链接文件(link file)，则复制链接文件属性而非文件本身&lt;/li&gt;
&lt;li&gt;-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次&lt;/li&gt;
&lt;li&gt;-i：若目标文件(destination)已经存在，在覆盖时会先询问动作&lt;/li&gt;
&lt;li&gt;-l：进行硬式连结(hard link)的链接文件创建，而非复制文件本身&lt;/li&gt;
&lt;li&gt;-p：连同文件的属性(所有者、所属组和时间等)一起复制，而非使用默认属性(备份常用)&lt;/li&gt;
&lt;li&gt;-r：递归复制，用于复制目录&lt;/li&gt;
&lt;li&gt;-s：复制成为符号链接文件(symbolic link)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-u：destination 比 source 旧才更新(update) destination&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 用 root 身份，将 root 目录下的 .bashrc 复制到 /tmp 下，并命名为 bashrc
[root@www ~]# cp ~/.bashrc /tmp/bashrc
[root@www ~]# cp -i ~/.bashrc /tmp/bashrc
# cp: overwrite `/tmp/bashrc&#39;? n  &amp;lt;==n不覆盖，y为覆盖
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-7-rm-移除文件或目录&#34;&gt;5.1.7 rm 移除文件或目录&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;rm [-fir] 文件或目录&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-f：force，忽略不存在的文件，不会出现警告信息&lt;/li&gt;
&lt;li&gt;-i：互动模式，在删除前会询问使用者是否动作&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-r：递归删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 删除创建的 bashrc
[root@www tmp]# rm -i bashrc
# rm: remove regular file `bashrc&#39;? y
# 如果加上 -i 就会主动询问
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-8-mv-移动文件与目录-或修改名称&#34;&gt;5.1.8 mv 移动文件与目录，或修改名称&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mv [-finuv] source destination&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mv [options] source1 source2 source3 .... directory&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-f：force 强制，如果目标文件已经存在，不会询问而直接覆盖&lt;/li&gt;
&lt;li&gt;-i：若目标文件 (destination) 已经存在，就会询问是否覆盖，默认选项&lt;/li&gt;
&lt;li&gt;-n：若目标文件已经存在，则不会覆盖移动，且不会询问用户&lt;/li&gt;
&lt;li&gt;-u：若目标文件已经存在，且 source 比较新，才会更新(update)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-v：显示文件或目录的移动过程&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 复制一文件，创建一目录，将文件移动到目录中
[root@www ~]# cd /tmp
[root@www tmp]# cp ~/.bashrc bashrc
[root@www tmp]# mkdir mvtest
[root@www tmp]# mv bashrc mvtest
# 将刚刚的目录名称更名为 mvtest2
[root@www tmp]# mv mvtest mvtest2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-9-touch-创建文件及修改文件时间戳&#34;&gt;5.1.9 touch 创建文件及修改文件时间戳&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;touch [options] 文件名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-a：只修改文件的访问时间&lt;/li&gt;
&lt;li&gt;-c：仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件&lt;/li&gt;
&lt;li&gt;-d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间&lt;/li&gt;
&lt;li&gt;-m：只修改文件的数据修改时间&lt;/li&gt;
&lt;li&gt;-t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 &lt;code&gt;YYMMDDhhmm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;touch 命令可以只修改文件的 atime，也可以只修改文件的数据 mtime，但是不能只修改文件的 ctime。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即 ctime 会随之改变(更新为操作当前文件的真正时间)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 建立名为 bols 的空文件
[root@www ~]# touch bols
# 查看文件的访问时间
[root@www ~]# ll --time=atime bols
# 文件上次的访问时间为 9 月 25 号 21：23
-rw-r--r-- 1 root root 0 Sep 25 21:23 bols
[root@localhost ~]# touch bols
[root@localhost ~]# ll --time=atime bols
-rw-r--r-- 1 root root 0 May 15 16:36 bols
# 而如果文件已经存在，则也不会报错，只是会修改文件的访问时间
# 修改 bols 文件的 atime 和 mtime
[root@localhost ~]# touch -d &amp;quot;2017-05-04 15:44&amp;quot; bols
[root@localhost ~]# ll bols; ll --time=atime bols; ll --time=ctime bols
-rw-r--r-- 1 root root 0 May 4 2017 bols
-rw-r--r-- 1 root root 0 May 4 2017 bols
-rw-r--r-- 1 root root 0 Sep 25 21:40 bols
# ctime 不会变为设定时间，但更新为当前服务器的时间
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-1-10-ln-在文件之间建立链接-硬链接和软链接&#34;&gt;5.1.10 ln 在文件之间建立链接(硬链接和软链接)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linux 系统中，每个文件主要拥有 3 个时间参数(通过 stat 命令进行查看)，分别是文件的访问时间、数据修改时间以及状态修改时间

&lt;ul&gt;
&lt;li&gt;访问时间(Access Time, atime)：只要文件的内容被读取，访问时间就会更新。例如，使用 cat 命令可以查看文件的内容，此时文件的访问时间就会发生改变&lt;/li&gt;
&lt;li&gt;数据修改时间(Modify Time, mtime)：当文件的内容数据发生改变，此文件的数据修改时间就会跟着相应改变&lt;/li&gt;
&lt;li&gt;状态修改时间(Change Time, ctime)：当文件的状态发生变化，就会相应改变这个时间。比如，如果文件的权限或者属性发生改变，此时间就会相应改变&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;语法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;touch [options] 文件名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-a：只修改文件的访问时间&lt;/li&gt;
&lt;li&gt;-c：仅修改文件的时间参数(3 个时间参数都改变)，如果文件不存在，则不建立新文件&lt;/li&gt;
&lt;li&gt;-d：后面可以跟欲修订的日期，而不用当前的日期，即把文件的 atime 和 mtime 时间改为指定的时间&lt;/li&gt;
&lt;li&gt;-m：只修改文件的数据修改时间&lt;/li&gt;
&lt;li&gt;-t：命令后面可以跟欲修订的时间，而不用目前的时间，时间书写格式为 &lt;code&gt;YYMMDDhhmm&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;touch 命令可以只修改文件的 atime，也可以只修改文件的数据 mtime，但是不能只修改文件的 ctime。因为，不论是修改访问时间，还是修改文件的数据时间，对文件来讲，状态都会发生改变，即 ctime 会随之改变(更新为操作当前文件的真正时间)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 建立名为 bols 的空文件
[root@www ~]# touch bols
# 查看文件的访问时间
[root@www ~]# ll --time=atime bols
# 文件上次的访问时间为 9 月 25 号 21：23
-rw-r--r-- 1 root root 0 Sep 25 21:23 bols
[root@localhost ~]# touch bols
[root@localhost ~]# ll --time=atime bols
-rw-r--r-- 1 root root 0 May 15 16:36 bols
# 而如果文件已经存在，则也不会报错，只是会修改文件的访问时间
# 修改 bols 文件的 atime 和 mtime
[root@localhost ~]# touch -d &amp;quot;2017-05-04 15:44&amp;quot; bols
[root@localhost ~]# ll bols; ll --time=atime bols; ll --time=ctime bols
-rw-r--r-- 1 root root 0 May 4 2017 bols
-rw-r--r-- 1 root root 0 May 4 2017 bols
-rw-r--r-- 1 root root 0 Sep 25 21:40 bols
# ctime 不会变为设定时间，但更新为当前服务器的时间
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-2-linux-文件内容查看&#34;&gt;5.2 Linux 文件内容查看&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以使用&lt;code&gt;man 命令&lt;/code&gt;来查看各个命令的使用文档，如&lt;code&gt;man cp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;cat&lt;/td&gt;
&lt;td&gt;由第一行开始显示文件内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tac&lt;/td&gt;
&lt;td&gt;从最后一行开始显示，可以看出 tac 是倒著写 cat&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;nl&lt;/td&gt;
&lt;td&gt;显示的时候，输出行号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;more&lt;/td&gt;
&lt;td&gt;一页一页的显示文件内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;less&lt;/td&gt;
&lt;td&gt;与 more 类似，但是比 more 更好的是，可以往前翻页&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;head&lt;/td&gt;
&lt;td&gt;只看头几行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tail&lt;/td&gt;
&lt;td&gt;只看尾几行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;5-2-1-cat-由第一行开始显示文件内容&#34;&gt;5.2.1 cat 由第一行开始显示文件内容&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;cat [-AbEnTv]&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-A：等同于 -vET，可列出一些特殊字符而不是空白&lt;/li&gt;
&lt;li&gt;-b：列出行号，仅针对非空白行做行号显示，空白行不标行号&lt;/li&gt;
&lt;li&gt;-E：将结尾的断行字节 $ 显示出来&lt;/li&gt;
&lt;li&gt;-n：列印出行号，连同空白行也会有行号，与 -b 的选项不同&lt;/li&gt;
&lt;li&gt;-T：将 [tab] 按键以 ^I 显示出来&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-v：列出一些看不出来的特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看 /etc/issue 文件内容
[root@www ~]# cat /etc/issue
CentOS release 6.4 (Final)
Kernel \r on an \m
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-2-2-tac&#34;&gt;5.2.2 tac&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;tac 与 cat 命令相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 倒着写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~]# tac /etc/issue

Kernel \r on an \m
CentOS release 6.4 (Final)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-2-3-nl-显示行号&#34;&gt;5.2.3 nl 显示行号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;nl [-bnw] 文件&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-b：指定行号显示的方式，主要有两种&lt;/li&gt;
&lt;li&gt;-b a：不论是否为空行，也同样列出行号(类似 cat -n)&lt;/li&gt;
&lt;li&gt;-b t：如果有空行，空的那一行不要列出行号(默认值)&lt;/li&gt;
&lt;li&gt;-n：列出行号表示的方法，主要有三种&lt;/li&gt;
&lt;li&gt;-n ln：行号在荧幕的最左方显示&lt;/li&gt;
&lt;li&gt;-n rn：行号在自己栏位的最右方显示，且不加 0&lt;/li&gt;
&lt;li&gt;-n rz ：行号在自己栏位的最右方显示，且加 0&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-w ：行号栏位的占用的位数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 用 nl 列出 /etc/issue 的内容
[root@www ~]# nl /etc/issue
1  CentOS release 6.4 (Final)
2  Kernel \r on an \m
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-2-4-more-一页一页翻动&#34;&gt;5.2.4 more 一页一页翻动&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~]# more /etc/man_db.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
--More--(28%)
# 光标在这一行等待命令
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在 more 程序的运行过程中，有几个按键可以按

&lt;ul&gt;
&lt;li&gt;空白键(space)：代表向下翻一页&lt;/li&gt;
&lt;li&gt;Enter：代表向下翻一行&lt;/li&gt;
&lt;li&gt;/字串：代表在这个显示的内容当中，向下搜寻&amp;rdquo;字串&amp;rdquo;关键字&lt;/li&gt;
&lt;li&gt;:f：立刻显示出文件名以及目前显示的行数&lt;/li&gt;
&lt;li&gt;q：代表立刻离开 more，不再显示该文件内容&lt;/li&gt;
&lt;li&gt;b 或 [ctrl]-b：代表往回翻页，不过这动作只对文件有用，对管线无用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-2-5-less-一页一页翻动&#34;&gt;5.2.5 less 一页一页翻动&lt;/h3&gt;

&lt;p&gt;，以下实例输出/etc/man.config文件的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~]# less /etc/man.config
#
# Generated automatically from man.conf.in by the
# configure script.
#
# man.conf from man-1.6d
# :   这里可以等待输入命令
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;less 运行时可以输入的命令

&lt;ul&gt;
&lt;li&gt;空白键：向下翻动一页&lt;/li&gt;
&lt;li&gt;[pagedown]：向下翻动一页&lt;/li&gt;
&lt;li&gt;[pageup]：向上翻动一页&lt;/li&gt;
&lt;li&gt;/字串：向下搜寻&amp;rdquo;字串&amp;rdquo;的功能&lt;/li&gt;
&lt;li&gt;?字串：向上搜寻&amp;rdquo;字串&amp;rdquo;的功能&lt;/li&gt;
&lt;li&gt;n：重复前一个搜寻(与 / 或 ? 有关)&lt;/li&gt;
&lt;li&gt;N：反向的重复前一个搜寻(与 / 或 ? 有关)&lt;/li&gt;
&lt;li&gt;q：离开 less 程序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-2-6-head-取出文件前面几行&#34;&gt;5.2.6 head 取出文件前面几行&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;head [-n number] 文件&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-n：后面接数字，代表显示几行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~]# head /etc/man.config
# 默认的情况中，显示前面 10 行
# 若要显示前 20 行，就得
[root@www ~]# head -n 20 /etc/man.config
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-2-7-tail-取出文件后面几行&#34;&gt;5.2.7 tail 取出文件后面几行&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;tail [-n number] 文件&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-n：后面接数字，代表显示几行&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-f：表示持续侦测后面所接的文件名，要等到按下 [ctrl]-c 才会结束 tail&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;[root@www ~]# tail /etc/man.config
# 默认的情况中，显示最后 10 行
# 若要显示最后的 20 行，就得
[root@www ~]# tail -n 20 /etc/man.config
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-3-linux-链接&#34;&gt;5.3 Linux 链接&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 链接分两种：硬链接(Hard Link)和符号链接(Symbolic Link)&lt;/li&gt;
&lt;li&gt;默认情况下，ln 命令产生硬链接&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-3-1-硬链接&#34;&gt;5.3.1 硬链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;硬链接指通过索引节点进行链接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)&lt;/li&gt;
&lt;li&gt;在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接(A 和 B 都是文件名)，则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问&lt;/li&gt;
&lt;li&gt;硬链接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬链接到重要文件，以防止“误删”的功能&lt;/li&gt;
&lt;li&gt;其原因如上所述，因为对应该目录的索引节点有一个以上的链接。只删除一个链接并不影响索引节点本身和其它的链接，只有当最后一个链接被删除后，文件的数据块及目录链接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬链接文件均被删除&lt;/li&gt;
&lt;li&gt;修改源文件和硬链接文件都会改变另一个文件的数据。硬链接不会建立新的 inode 信息，也不会更改 inode 的总数&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-3-2-软链接&#34;&gt;5.3.2 软链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;符号链接(Symbolic Link)，也叫软链接。软链接文件类似于 Windows 的快捷方式。它实际上是一个特殊的文件，用于指向另一个文件。此链接方式也适用于目录&lt;/li&gt;
&lt;li&gt;在符号链接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接(A 和 B 都是文件名)，A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名(可以根据这个找到 B 的目录项)。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在(因为两个是不同的文件)，但指向的是一个无效的链接&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-3-3-inode-属性&#34;&gt;5.3.3 inode 属性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linux 目前使用 ext4 文件系统：分区分为两大部分(不考虑超级块)，小部分用于保存文件的 inode 信息；剩余大部分用于保存 block 信息

&lt;ul&gt;
&lt;li&gt;iNode 默认大小是 128 Byte，用于记录文件的权限、所有者和属组、大小、ctime、atime、mtime、文件数据的 block 编号，每个文件一个 inode&lt;/li&gt;
&lt;li&gt;block 默认大小是 4KB。用于实际的数据存储，一个 block 只属于一个文件，可能未占满。一个文件占用的 block 也可以是不连续的&lt;/li&gt;
&lt;li&gt;总之，每个文件一个 inode，文件内容由 inode 的记录指向。目录的 block 记录该目录下所有一级子文件和子目录的文件名及对应的 inode。需要根据文件名找到对应的 inode，再找到文件内容所在的 block 块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux 操作系统的文件数据除了文件实际内容外，通常含有非常多的属性，如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)&lt;/li&gt;
&lt;li&gt;文件系统通常会将这两部分的数据分别存放在不同的区块，权限与属性存放在 inode 中，至于实际数据则放置到 data block 区块中

&lt;ul&gt;
&lt;li&gt;inode：记录文件的属性，一个文件占用一个 inode，同时记录此文件的数据所在的 block&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;还有一个超级区块(superblock)会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 Linux 中，可以使用 stat 命令查看某个文件的 inode 信息，包括文件大小、占用的 block 数量、block 大小、文件类型(普通文件或其他)、inode 节点号、链接数、权限、所有者、所属组、访问时间、数据修改时间、状态修改时间&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;stat /etc/passwd
linux-peanut:~/Desktop # stat /etc/passwd
File: &#39;/etc/passwd&#39;
Size: 2269          Blocks: 8          IO Block: 4096   regular file
Device: 802h/2050d    Inode: 1149740     Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2018-04-09 17:16:42.000000000 +0800
Modify: 2018-04-09 17:16:36.000000000 +0800
Change: 2018-04-09 17:16:36.000000000 +0800
Birth: -
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;5-3-4-ln-命令&#34;&gt;5.3.4 ln 命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;ln [选项] 源文件 目标文件&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-s：建立软链接文件。如果不加 &amp;ldquo;-s&amp;rdquo; 选项，则建立硬链接文件&lt;/li&gt;
&lt;li&gt;-f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件&lt;/li&gt;
&lt;li&gt;目标文件可以只写路径没有写文件名，会和原名一致&lt;/li&gt;

&lt;li&gt;&lt;p&gt;软链接文件的源文件必须写成绝对路径，而不能写成相对路径(硬链接没有这样的要求)；否则软链接文件会报错 &lt;code&gt;No such file or directory&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建一个测试文件f1
[oracle@Linux]$ touch f1
# 创建f1的一个硬链接文件f2
[oracle@Linux]$ ln f1 f2
# 创建f1的一个符号链接文件f3
[oracle@Linux]$ ln -s f1 f3
# -i参数显示文件的inode节点信息
[oracle@Linux]$ ls -li
total 0
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f1
9797648 -rw-r--r--  2 oracle oinstall 0 Apr 21 08:11 f2
9797649 lrwxrwxrwx  1 oracle oinstall 2 Apr 21 08:11 f3 -&amp;gt; f1
# 硬链接文件 f2 与原文件 f1 的 inode 节点相同，均为 9797648，符号链接文件的 inode 节点不同
[oracle@Linux]$ echo &amp;quot;I am f1 file&amp;quot; &amp;gt;&amp;gt;f1
[oracle@Linux]$ cat f1
I am f1 file
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
I am f1 file
[oracle@Linux]$ rm -f f1
[oracle@Linux]$ cat f2
I am f1 file
[oracle@Linux]$ cat f3
cat: f3: No such file or directory
# 当删除原始文件 f1 后，硬链接 f2 不受影响，但是符号链接 f1 文件无效
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除符号链接 f3，对 f1 f2 无影响&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除硬链接 f2，对 f1 f3 也无影响&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;删除原文件 f1，对硬链接 f2 没有影响，导致符号链接 f3 失效&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同时删除原文件 f1 和 硬链接 f2，整个文件会真正的被删除&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>6 用户和用户组管理</title>
      <link>https://xueqing.github.io/blog/linux/6_%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/6_%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-%e7%ae%80%e4%bb%8b&#34;&gt;6.1 简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62-linux-%e7%b3%bb%e7%bb%9f%e7%94%a8%e6%88%b7%e8%b4%a6%e5%8f%b7%e7%9a%84%e7%ae%a1%e7%90%86&#34;&gt;6.2 Linux 系统用户账号的管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#621-useradd-%e6%b7%bb%e5%8a%a0%e6%96%b0%e7%9a%84%e7%94%a8%e6%88%b7%e8%b4%a6%e5%8f%b7&#34;&gt;6.2.1 useradd 添加新的用户账号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#622-userdel-%e5%b7%b2%e6%9c%89%e7%9a%84%e7%94%a8%e6%88%b7%e8%b4%a6%e5%8f%b7&#34;&gt;6.2.2 userdel 已有的用户账号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#623-usermod-%e4%bf%ae%e6%94%b9%e5%b7%b2%e6%9c%89%e7%94%a8%e6%88%b7%e5%b8%90%e5%8f%b7&#34;&gt;6.2.3 usermod 修改已有用户帐号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#624-passwd-%e6%8c%87%e5%ae%9a%e5%92%8c%e4%bf%ae%e6%94%b9%e7%94%a8%e6%88%b7%e5%8f%a3%e4%bb%a4&#34;&gt;6.2.4 passwd 指定和修改用户口令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63-linux%e7%b3%bb%e7%bb%9f%e7%94%a8%e6%88%b7%e7%bb%84%e7%9a%84%e7%ae%a1%e7%90%86&#34;&gt;6.3 Linux系统用户组的管理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#631-groupadd-%e5%a2%9e%e5%8a%a0%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84%e7%94%a8%e6%88%b7%e7%bb%84&#34;&gt;6.3.1 groupadd 增加一个新的用户组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#632-groupdel-%e5%88%a0%e9%99%a4%e4%b8%80%e4%b8%aa%e5%b7%b2%e6%9c%89%e7%9a%84%e7%94%a8%e6%88%b7%e7%bb%84&#34;&gt;6.3.2 groupdel 删除一个已有的用户组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#633-groupmod-%e4%bf%ae%e6%94%b9%e7%94%a8%e6%88%b7%e7%bb%84%e7%9a%84%e5%b1%9e%e6%80%a7&#34;&gt;6.3.3 groupmod 修改用户组的属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#634-newgrp-%e5%88%87%e6%8d%a2%e7%94%a8%e6%88%b7%e7%bb%84&#34;&gt;6.3.4 newgrp 切换用户组&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#64-%e4%b8%8e%e7%94%a8%e6%88%b7%e8%b4%a6%e5%8f%b7%e6%9c%89%e5%85%b3%e7%9a%84%e7%b3%bb%e7%bb%9f%e6%96%87%e4%bb%b6&#34;&gt;6.4 与用户账号有关的系统文件&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#641-etcpasswd-%e6%98%af%e7%94%a8%e6%88%b7%e7%ae%a1%e7%90%86%e5%b7%a5%e4%bd%9c%e6%b6%89%e5%8f%8a%e7%9a%84%e6%9c%80%e9%87%8d%e8%a6%81%e7%9a%84%e4%b8%80%e4%b8%aa%e6%96%87%e4%bb%b6&#34;&gt;6.4.1 /etc/passwd 是用户管理工作涉及的最重要的一个文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#642-%e6%8b%a5%e6%9c%89%e5%b8%90%e6%88%b7%e6%96%87%e4%bb%b6&#34;&gt;6.4.2 拥有帐户文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6421-etcshadow-%e6%96%87%e4%bb%b6&#34;&gt;6.4.2.1 /etc/shadow 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6422-etcshadow-vs-etcpasswd&#34;&gt;6.4.2.2 /etc/shadow vs /etc/passwd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6423-etcgroup-%e6%96%87%e4%bb%b6&#34;&gt;6.4.2.3 /etc/group 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#65-%e6%b7%bb%e5%8a%a0%e6%89%b9%e9%87%8f%e7%94%a8%e6%88%b7&#34;&gt;6.5 添加批量用户&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#651-%e7%bc%96%e8%be%91%e4%b8%80%e4%b8%aa%e6%96%87%e6%9c%ac%e7%94%a8%e6%88%b7%e6%96%87%e4%bb%b6&#34;&gt;6.5.1 编辑一个文本用户文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#652-%e4%bb%a5-root-%e8%ba%ab%e4%bb%bd%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4-usrsbinnewusers&#34;&gt;6.5.2 以 root 身份执行命令 /usr/sbin/newusers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#653-%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4-usrsbinpwunconv&#34;&gt;6.5.3 执行命令 /usr/sbin/pwunconv&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#654-%e7%bc%96%e8%be%91%e6%af%8f%e4%b8%aa%e7%94%a8%e6%88%b7%e7%9a%84%e5%af%86%e7%a0%81%e5%af%b9%e7%85%a7%e6%96%87%e4%bb%b6&#34;&gt;6.5.4 编辑每个用户的密码对照文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#655-%e4%bb%a5-root-%e8%ba%ab%e4%bb%bd%e6%89%a7%e8%a1%8c%e5%91%bd%e4%bb%a4-usrsbinchpasswd&#34;&gt;6.5.5 以 root 身份执行命令 /usr/sbin/chpasswd&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#656-%e7%a1%ae%e5%ae%9a%e5%af%86%e7%a0%81%e7%bb%8f%e7%bc%96%e7%a0%81%e5%86%99%e5%85%a5-etcpasswd-%e7%9a%84%e5%af%86%e7%a0%81%e6%a0%8f%e5%90%8e&#34;&gt;6.5.6 确定密码经编码写入 /etc/passwd 的密码栏后&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-1-简介&#34;&gt;6.1 简介&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统&lt;/li&gt;
&lt;li&gt;用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护&lt;/li&gt;
&lt;li&gt;每个用户账号都拥有一个唯一的用户名和各自的口令&lt;/li&gt;
&lt;li&gt;用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录&lt;/li&gt;
&lt;li&gt;实现用户账号的管理，要完成的工作主要有如下几个方面

&lt;ul&gt;
&lt;li&gt;用户账号的添加、删除与修改&lt;/li&gt;
&lt;li&gt;用户口令的管理&lt;/li&gt;
&lt;li&gt;用户组的管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-2-linux-系统用户账号的管理&#34;&gt;6.2 Linux 系统用户账号的管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用户账号的管理工作主要涉及到用户账号的添加、修改和删除

&lt;ul&gt;
&lt;li&gt;添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源&lt;/li&gt;
&lt;li&gt;刚添加的账号是被锁定的，无法使用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-2-1-useradd-添加新的用户账号&#34;&gt;6.2.1 useradd 添加新的用户账号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;useradd 选项 用户名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项

&lt;ul&gt;
&lt;li&gt;-c comment 指定一段注释性描述&lt;/li&gt;
&lt;li&gt;-d 目录 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录&lt;/li&gt;
&lt;li&gt;-g 用户组 指定用户所属的用户组&lt;/li&gt;
&lt;li&gt;-G 用户组，用户组 指定用户所属的附加组&lt;/li&gt;
&lt;li&gt;-s Shell文件 指定用户的登录Shell&lt;/li&gt;
&lt;li&gt;-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户名：指定新账号的登录名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam(/usr为默认的用户主目录所在的父目录)
useradd –d /usr/sam -m sam
# 新建了一个用户gem，该用户的登录Shell是 /bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组
useradd -s /bin/sh -g group –G adm,root gem
# 可能新建组
groupadd group
groupadd adm
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;增加用户账号就是在&lt;code&gt;/etc/passwd&lt;/code&gt;为新用户增加一条记录，同时更新其他系统文件如&lt;code&gt;/etc/shadow&lt;/code&gt;，&lt;code&gt;/etc/group&lt;/code&gt;等&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux提供了集成的系统管理工具&lt;code&gt;userconf&lt;/code&gt;，它可以用来对用户账号进行统一管理&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-2-2-userdel-已有的用户账号&#34;&gt;6.2.2 userdel 已有的用户账号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果一个用户的账号不再使用，可以从系统中删除&lt;/li&gt;
&lt;li&gt;删除用户账号就是要将&lt;code&gt;/etc/passwd&lt;/code&gt;等系统文件中的该用户记录删除，必要时还删除用户的主目录&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;userdel 选项 用户名&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-r 是把用户的主目录一起删除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 删除用户sam在系统文件中(主要是/etc/passwd, /etc/shadow, /etc/group等)的记录，同时删除用户的主目录
userdel -r sam
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-2-3-usermod-修改已有用户帐号&#34;&gt;6.2.3 usermod 修改已有用户帐号&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;usermod 选项 用户名&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-c, -d, -m, -g, -G, -s, -u及-o等，意义与useradd命令中的选项一样，可以为用户指定新的资源值&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有些系统可以使用选项：&lt;code&gt;-l 新用户名&lt;/code&gt;。这个选项指定一个新的账号，即将原来的用户名改为新的用户名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer
usermod -s /bin/ksh -d /home/z –g developer sam
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-2-4-passwd-指定和修改用户口令&#34;&gt;6.2.4 passwd 指定和修改用户口令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令&lt;/li&gt;
&lt;li&gt;超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;passwd 选项 用户名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项

&lt;ul&gt;
&lt;li&gt;-l 锁定口令，即禁用账号&lt;/li&gt;
&lt;li&gt;-u 口令解锁&lt;/li&gt;
&lt;li&gt;-d 使账号无口令&lt;/li&gt;
&lt;li&gt;-f 强迫用户下次登录时修改口令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认用户名，则修改当前用户的口令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 假设当前用户是sam，修改该用户自己的口令
$ passwd
Old password:******
New password:*******
Re-enter new password:*******
# 如果是超级用户，可以用下列形式指定任何用户的口令
# passwd sam
New password:*******
Re-enter new password:*******
# 将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令
passwd -d sam
# 锁定某一用户，使其不能登录
passwd -l sam
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;普通用户修改自己的口令时，passwd 命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用 8 位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-3-linux系统用户组的管理&#34;&gt;6.3 Linux系统用户组的管理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理&lt;/li&gt;
&lt;li&gt;不同 Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建&lt;/li&gt;
&lt;li&gt;用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&lt;code&gt;/etc/group&lt;/code&gt;文件的更新&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-3-1-groupadd-增加一个新的用户组&#34;&gt;6.3.1 groupadd 增加一个新的用户组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;格式 &lt;code&gt;groupadd 选项 用户组&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-g GID 指定新用户组的组标识号(GID)&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 系统中增加一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1
groupadd group1
# 系统中增加一个新组group2，同时指定新组的组标识号是101
groupadd -g 101 group2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-3-2-groupdel-删除一个已有的用户组&#34;&gt;6.3.2 groupdel 删除一个已有的用户组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;格式 &lt;code&gt;groupdel 用户组&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 从系统中删除组group1
groupdel group1
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-3-3-groupmod-修改用户组的属性&#34;&gt;6.3.3 groupmod 修改用户组的属性&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;格式 &lt;code&gt;groupmod 选项 用户组&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-g GID 为用户组指定新的组标识号。&lt;/li&gt;
&lt;li&gt;-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-n 新用户组 将用户组的名字改为新名字&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将组group2的组标识号修改为102
groupmod -g 102 group2
# 将组group2的标识号改为10000，组名修改为group3
groupmod –g 10000 -n group3 group2
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-3-4-newgrp-切换用户组&#34;&gt;6.3.4 newgrp 切换用户组&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限&lt;/li&gt;

&lt;li&gt;&lt;p&gt;用户可以在登录后，使用&lt;code&gt;newgrp 目的用户组&lt;/code&gt;切换到其他用户组&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成
newgrp root
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-4-与用户账号有关的系统文件&#34;&gt;6.4 与用户账号有关的系统文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改&lt;/li&gt;
&lt;li&gt;与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-4-1-etc-passwd-是用户管理工作涉及的最重要的一个文件&#34;&gt;6.4.1 /etc/passwd 是用户管理工作涉及的最重要的一个文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Linux 系统中每个用户在&lt;code&gt;/etc/passwd&lt;/code&gt;文件中有一个对应的记录行，它记录了这个用户的一些基本属性&lt;/li&gt;

&lt;li&gt;&lt;p&gt;这个文件对所有用户都是可读的。它的内容类似下面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat /etc/passwd

root❌0:0:Superuser:/:
daemon❌1:1:System daemons:/etc:
bin❌2:2:Owner of system commands:/bin:
sys❌3:3:Owner of system files:/usr/sys:
adm❌4:4:System accounting:/usr/adm:
uucp❌5:5:UUCP administrator:/usr/lib/uucp:
auth❌7:21:Authentication administrator:/tcb/files/auth:
cron❌9:16:Cron daemon:/usr/spool/cron:
listen❌37:4:Network daemon:/usr/net/nls:
lp❌71:18:Printer administrator:/usr/spool/lp:
sam❌200:50:Sam san:/usr/sam:/bin/sh
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;格式&lt;code&gt;用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户名&lt;/strong&gt;：代表用户账号的字符串&lt;/li&gt;
&lt;li&gt;通常长度不超过8个字符，且由大小写字母和/或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符&lt;/li&gt;
&lt;li&gt;为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;口令&lt;/strong&gt;：一些系统中，存放着加密后的用户口令字&lt;/li&gt;
&lt;li&gt;这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患&lt;/li&gt;
&lt;li&gt;现在许多 Linux 系统(如SVR4)都使用了 shadow 技术，把真正的加密后的用户口令字存放到&lt;code&gt;/etc/shadow&lt;/code&gt;文件中，而在&lt;code&gt;/etc/passwd&lt;/code&gt;文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户标识号&lt;/strong&gt;：一个整数，系统内部用它来标识用户&lt;/li&gt;
&lt;li&gt;一般情况下与用户名一一对应&lt;/li&gt;
&lt;li&gt;如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等&lt;/li&gt;
&lt;li&gt;通常用户标识号的取值范围是0～65535

&lt;ul&gt;
&lt;li&gt;0是超级用户root的标识号&lt;/li&gt;
&lt;li&gt;1～99由系统保留，作为管理账号&lt;/li&gt;
&lt;li&gt;普通用户的标识号从100开始。在Linux系统中，这个界限是500。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组标识号&lt;/strong&gt;：记录用户所属的用户组。对应着&lt;code&gt;/etc/group&lt;/code&gt;文件中的一条记录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注释性描述&lt;/strong&gt;：记录用户的一些个人情况&lt;/li&gt;
&lt;li&gt;例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途&lt;/li&gt;
&lt;li&gt;在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主目录&lt;/strong&gt;：用户的起始工作目录&lt;/li&gt;
&lt;li&gt;是用户在登录到系统之后所处的目录&lt;/li&gt;
&lt;li&gt;大多数系统中，各用户的主目录被组织在同一个特定目录下，而用户主目录的名称就是该用户的登录名&lt;/li&gt;
&lt;li&gt;各用户对自己的主目录有读、写、执行(搜索)权限，其他用户对此目录的访问权限则根据具体情况设置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;登录Shell&lt;/strong&gt;：用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序&lt;/li&gt;
&lt;li&gt;Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等&lt;/li&gt;
&lt;li&gt;系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh&lt;/li&gt;
&lt;li&gt;用户的登录Shell也可以指定为某个特定的程序(此程序不是一个命令解释器)&lt;/li&gt;
&lt;li&gt;利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中&lt;/li&gt;
&lt;li&gt;系统中有一类用户称为&lt;strong&gt;伪用户&lt;/strong&gt;(pseudo users)&lt;/li&gt;
&lt;li&gt;这些用户在&lt;code&gt;/etc/passwd&lt;/code&gt;文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求&lt;/li&gt;
&lt;li&gt;常见的伪用户如下所示&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;| 伪用户 | 含义 |
  | bin | 拥有可执行的用户命令文件 |
  | sys | 拥有系统文件 |
  | adm | 拥有帐户文件 |
  | uucp | UUCP使用 |
  | lp | lp或lpd子系统使用 |
  | nobody | NFS使用 |&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-4-2-拥有帐户文件&#34;&gt;6.4.2 拥有帐户文件&lt;/h3&gt;

&lt;h4 id=&#34;6-4-2-1-etc-shadow-文件&#34;&gt;6.4.2.1 /etc/shadow 文件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;除了上面列出的伪用户外，还有许多标准的伪用户，如audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要&lt;/li&gt;
&lt;li&gt;由于&lt;code&gt;/etc/passwd&lt;/code&gt;文件是所有用户都可读的，如果用户的密码太简单或规律比较明显，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件&lt;/li&gt;
&lt;li&gt;有超级用户才拥有该文件读权限，这就保证了用户密码的安全性&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;6-4-2-2-etc-shadow-vs-etc-passwd&#34;&gt;6.4.2.2 /etc/shadow vs /etc/passwd&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/etc/shadow&lt;/code&gt;中的记录行与&lt;code&gt;/etc/passwd&lt;/code&gt;一一对应，它由&lt;code&gt;pwconv&lt;/code&gt;命令根据&lt;code&gt;/etc/passwd&lt;/code&gt;中的数据自动产生&lt;/li&gt;
&lt;li&gt;文件格式与&lt;code&gt;/etc/passwd&lt;/code&gt;类似，由若干个字段组成，字段之间用&amp;rdquo;:&amp;ldquo;隔开&lt;/li&gt;
&lt;li&gt;字段有 &lt;code&gt;登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;登录名&lt;/strong&gt;：与&lt;code&gt;/etc/passwd&lt;/code&gt;文件中的登录名相一致的用户账号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;口令&lt;/strong&gt;：存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合{ ./0-9A-Za-z }中的字符，则对应的用户不能登录&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最后一次修改时间&lt;/strong&gt;：表示从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最小时间间隔&lt;/strong&gt;：指两次修改口令之间所需的最小天数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最大时间间隔&lt;/strong&gt;：指口令保持有效的最大天数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;警告时间&lt;/strong&gt;：表示从系统开始警告用户到用户密码正式失效之间的天数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不活动时间&lt;/strong&gt;：表示用户没有登录活动但账号仍能保持有效的最大天数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;失效时间&lt;/strong&gt;：是一个绝对天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面是&lt;code&gt;/etc/shadow&lt;/code&gt;的一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat /etc/shadow

root:Dnakfw28zf38w:8764:0:168:7:::
daemon:*::0:0::::
bin:*::0:0::::
sys:*::0:0::::
adm:*::0:0::::
uucp:*::0:0::::
nuucp:*::0:0::::
auth:*::0:0::::
cron:*::0:0::::
listen:*::0:0::::
lp:*::0:0::::
sam:EkdiSECLWPdSa:9740:0:0::::
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;6-4-2-3-etc-group-文件&#34;&gt;6.4.2.3 /etc/group 文件&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将用户分组是 Linux 系统中对用户进行管理及控制访问权限的一种手段

&lt;ul&gt;
&lt;li&gt;每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组&lt;/li&gt;
&lt;li&gt;当一个用户同时是多个组中的成员时，在&lt;code&gt;/etc/passwd&lt;/code&gt;文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组&lt;/li&gt;
&lt;li&gt;用户要访问属于附加组的文件时，必须首先使用&lt;code&gt;newgrp&lt;/code&gt;命令使自己成为所要访问的组中的成员&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户组的所有信息都存放在&lt;code&gt;/etc/group&lt;/code&gt;文件中。此文件的格式也类似于&lt;code&gt;/etc/passwd&lt;/code&gt;文件，由冒号(:)隔开若干个字段&lt;/li&gt;
&lt;li&gt;字段有 &lt;code&gt;组名:口令:组标识号:组内用户列表&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;组名&lt;/strong&gt;：用户组的名称，由字母或数字构成。与&lt;code&gt;/etc/passwd&lt;/code&gt;中的登录名一样，组名不应重复&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;口令&lt;/strong&gt;：字段存放的是用户组加密后的口令字。一般 Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组标识号&lt;/strong&gt;：与用户标识号类似，也是一个整数，被系统内部用来标识组&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组内用户列表&lt;/strong&gt;：属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;/etc/group&lt;/code&gt;文件的一个例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat /etc/group
root::0:root
bin::2:root,bin
sys::3:root,uucp
adm::4:root,adm
daemon::5:root,daemon
lp::7:root,lp
users::20:root,sam
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-5-添加批量用户&#34;&gt;6.5 添加批量用户&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 系统提供了创建大量用户的工具，可以立即创建大量用户，方法如下&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-5-1-编辑一个文本用户文件&#34;&gt;6.5.1 编辑一个文本用户文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每一列按照&lt;code&gt;/etc/passwd&lt;/code&gt;密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个范例文件&lt;code&gt;user.txt&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;user001::600:100:user:/home/user001:/bin/bash
user002::601:100:user:/home/user002:/bin/bash
user003::602:100:user:/home/user003:/bin/bash
user004::603:100:user:/home/user004:/bin/bash
user005::604:100:user:/home/user005:/bin/bash
user006::605:100:user:/home/user006:/bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-5-2-以-root-身份执行命令-usr-sbin-newusers&#34;&gt;6.5.2 以 root 身份执行命令 /usr/sbin/newusers&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 从刚创建的用户文件 user.txt 中导入数据，创建用户
newusers &amp;lt; user.txt
# 执行命令 vipw 或 vi /etc/passwd 检查 /etc/passwd 文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-5-3-执行命令-usr-sbin-pwunconv&#34;&gt;6.5.3 执行命令 /usr/sbin/pwunconv&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将 /etc/shadow 产生的 shadow 密码解码，然后回写到 /etc/passwd 中，并将 /etc/shadow 的 shadow 密码栏删掉
# 这是为了方便下一步的密码转换工作，即先取消 shadow password 功能
pwunconv
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-5-4-编辑每个用户的密码对照文件&#34;&gt;6.5.4 编辑每个用户的密码对照文件&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;范例文件&lt;code&gt;passwd.txt&lt;/code&gt;内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;user001:密码
user002:密码
user003:密码
user004:密码
user005:密码
user006:密码
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6-5-5-以-root-身份执行命令-usr-sbin-chpasswd&#34;&gt;6.5.5 以 root 身份执行命令 /usr/sbin/chpasswd&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 创建用户密码，chpasswd 会将经过 /usr/bin/passwd 命令编码过的密码写入 /etc/passwd 的密码栏
chpasswd &amp;lt; passwd.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;6-5-6-确定密码经编码写入-etc-passwd-的密码栏后&#34;&gt;6.5.6 确定密码经编码写入 /etc/passwd 的密码栏后&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 执行命令 /usr/sbin/pwconv 将密码编码为 shadow password，并将结果写入 /etc/shadow
pwconv
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;这样就完成了大量用户的创建了，之后可以到&lt;code&gt;/home&lt;/code&gt;下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>7 磁盘管理</title>
      <link>https://xueqing.github.io/blog/linux/7_%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/7_%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-%e7%a3%81%e7%9b%98%e7%ae%a1%e7%90%86%e5%91%bd%e4%bb%a4&#34;&gt;7.1 磁盘管理命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#711-df&#34;&gt;7.1.1 df&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#712-du&#34;&gt;7.1.2 du&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#713-fdisk&#34;&gt;7.1.3 fdisk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#714-mkfs&#34;&gt;7.1.4 mkfs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-%e7%a3%81%e7%9b%98%e6%a3%80%e9%aa%8c&#34;&gt;7.2 磁盘检验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-%e7%a3%81%e7%9b%98%e6%8c%82%e8%bd%bd%e4%b8%8e%e5%8d%b8%e9%99%a4&#34;&gt;7.3 磁盘挂载与卸除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74-%e4%bd%bf%e7%94%a8%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%bb%84%e7%bb%87%e7%a3%81%e7%9b%98%e5%ad%98%e5%82%a8%e5%92%8c%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86%e7%9a%84%e5%bf%85%e8%a6%81%e6%80%a7&#34;&gt;7.4 使用文件系统组织磁盘存储和数据管理的必要性&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-1-磁盘管理命令&#34;&gt;7.1 磁盘管理命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 磁盘管理好坏直接关系到整个系统的性能问题&lt;/li&gt;
&lt;li&gt;Linux 磁盘管理常用三个命令为df、du和fdisk

&lt;ul&gt;
&lt;li&gt;df：列出文件系统的整体磁盘使用量&lt;/li&gt;
&lt;li&gt;du：检查磁盘空间使用量&lt;/li&gt;
&lt;li&gt;fdisk：用于磁盘分区&lt;/li&gt;
&lt;li&gt;mkfs：磁盘格式化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-1-1-df&#34;&gt;7.1.1 df&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;df：检查文件系统的磁盘空间占用情况&lt;/li&gt;
&lt;li&gt;可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;df [-ahikHTm] [目录或文件名]&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-a：列出所有的文件系统，包括系统特有的 /proc 等文件系统&lt;/li&gt;
&lt;li&gt;-k：以 KBytes 的容量显示各文件系统&lt;/li&gt;
&lt;li&gt;-m：以 MBytes 的容量显示各文件系统&lt;/li&gt;
&lt;li&gt;-h：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示&lt;/li&gt;
&lt;li&gt;-H：以 M=1000K 取代 M=1024K 的进位方式&lt;/li&gt;
&lt;li&gt;-T：显示文件系统类型, 连同该 partition 的 filesystem 名称(如 ext3)也列出&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-i：不用硬盘容量，而以 inode 的数量来显示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 将系统内所有的文件系统列出来！
[root@www ~]# df
Filesystem      1K-blocks      Used Available Use% Mounted on
/dev/hdc2         9920624   3823112   5585444  41% /
/dev/hdc3         4956316    141376   4559108   4% /home
/dev/hdc1          101086     11126     84741  12% /boot
tmpfs              371332         0    371332   0% /dev/shm
# 没有加任何选项，默认将系统内所有(不含特殊内存内的文件系统与 swap)以 1 Kbytes 容量列出来
# 将容量结果以易读的容量格式显示出来
[root@www ~]# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /
/dev/hdc3             4.8G  139M  4.4G   4% /home
/dev/hdc1              99M   11M   83M  12% /boot
tmpfs                 363M     0  363M   0% /dev/shm
# 将系统内的所有特殊文件格式及名称都列出来
[root@www ~]# df -aT
Filesystem    Type 1K-blocks    Used Available Use% Mounted on
/dev/hdc2     ext3   9920624 3823112   5585444  41% /
proc          proc         0       0         0   -  /proc
sysfs        sysfs         0       0         0   -  /sys
devpts      devpts         0       0         0   -  /dev/pts
/dev/hdc3     ext3   4956316  141376   4559108   4% /home
/dev/hdc1     ext3    101086   11126     84741  12% /boot
tmpfs        tmpfs    371332       0    371332   0% /dev/shm
none   binfmt_misc         0       0         0   -  /proc/sys/fs/binfmt_misc
sunrpc  rpc_pipefs         0       0         0   -  /var/lib/nfs/rpc_pipefs
# 将 /etc 下的可用的磁盘容量以易读的容量格式显示
[root@www ~]# df -h /etc
Filesystem            Size  Used Avail Use% Mounted on
/dev/hdc2             9.5G  3.7G  5.4G  41% /
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-1-2-du&#34;&gt;7.1.2 du&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;du：查看使用空间&lt;/li&gt;
&lt;li&gt;与 df 命令不同：du 命令是对文件和目录磁盘使用的空间的查看，df 检查文件系统的磁盘空间占用情况&lt;/li&gt;
&lt;li&gt;与 df 不一样的是，du 会直接到文件系统内去搜寻所有的文件数据&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;du [-ahskm] 文件或目录名称&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-a：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已&lt;/li&gt;
&lt;li&gt;-h：以人们较易读的容量格式 (G/M) 显示&lt;/li&gt;
&lt;li&gt;-s：列出总量而已，而不列出每个各别的目录占用容量&lt;/li&gt;
&lt;li&gt;-S：不包括子目录下的总计，与 -s 有点差别&lt;/li&gt;
&lt;li&gt;-k：以 KBytes 列出容量显示&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-m：以 MBytes 列出容量显示&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 列出当前目录下的所有文件容量，包括隐藏文件的目录
# 当前目录(.)所占用的总量
[root@www ~]# du
8       ./test4
8       ./test2
12      ./.gconfd
220     .
# 没有加任何选项时，du 会分析当前所在目录的文件与目录所占用的硬盘空间
# 将文件的容量也列出来
[root@www ~]# du -a
12      ./install.log.syslog
8       ./.bash_logout
8       ./test4
8       ./test2
12      ./.gconfd
220     .
# 检查根目录下每个目录所占用的容量
# 通配符 * 代表每个目录
[root@www ~]# du -sm /*
7       /bin
6       /boot
0       /proc
1       /tmp
3859    /usr
77      /var
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-1-3-fdisk&#34;&gt;7.1.3 fdisk&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;fdisk：磁盘分区表操作工具&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;fdisk [-l] 装置名称&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-l：输出后面接的装置所有的分区内容&lt;/li&gt;

&lt;li&gt;&lt;p&gt;若仅有&lt;code&gt;fdisk -l&lt;/code&gt;时， 系统将会把整个系统内能够搜寻到的装置的分区均列出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 列出所有分区信息
[root@AY120919111755c246621 tmp]# fdisk -l

Disk /dev/xvda: 21.5 GB, 21474836480 bytes
255 heads, 63 sectors/track, 2610 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000

Device Boot      Start         End      Blocks   Id  System
/dev/xvda1   *           1        2550    20480000   83  Linux
/dev/xvda2            2550        2611      490496   82  Linux swap / Solaris

Disk /dev/xvdb: 21.5 GB, 21474836480 bytes
255 heads, 63 sectors/track, 2610 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x56f40944

Device Boot      Start         End      Blocks   Id  System
/dev/xvdb2               1        2610    20964793+  83  Linux

# 找出系统中的根目录所在磁盘，并查阅该硬盘内的相关信息。重点在找出磁盘文件名
[root@www ~]# df /
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/hdc2              9920624   3823168   5585388  41% /
# 不要加上数字
[root@www ~]# fdisk /dev/hdc
The number of cylinders for this disk is set to 5005.
There is nothing wrong with that, but this is larger than 1024,
and could in certain setups cause problems with:
1) software that runs at boot time (e.g., old versions of LILO)
2) booting and partitioning software from other OSs
(e.g., DOS FDISK, OS/2 FDISK)

# 输入 m 后，就会看到命令介绍
Command (m for help):
# 离开 fdisk 时按下 q，那么所有动作都不会生效。相反的， 按下 w 就是动作生效
# 使用 p 可以列出目前这颗磁盘的分割表信息，这个信息的上半部显示整体磁盘的状态
Command (m for help): p

# 这个磁盘的文件名与容量
Disk /dev/hdc: 41.1 GB, 41174138880 bytes
# 磁头、扇区与磁柱大小
255 heads, 63 sectors/track, 5005 cylinders
# 每个磁柱的大小
Units = cylinders of 16065 * 512 = 8225280 bytes

# 装置文件名 启动区否 开始磁柱    结束磁柱  1K大小容量 磁盘分区槽内的系统
Device Boot      Start         End      Blocks   Id  System
/dev/hdc1   *           1          13      104391   83  Linux
/dev/hdc2              14        1288    10241437+  83  Linux
/dev/hdc3            1289        1925     5116702+  83  Linux
/dev/hdc4            1926        5005    24740100    5  Extended
/dev/hdc5            1926        2052     1020096   82  Linux swap / Solaris

# 想要不储存离开按下 q
Command (m for help): q
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;7-1-4-mkfs&#34;&gt;7.1.4 mkfs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;磁盘分割完毕后自然就是要进行文件系统的格式化&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;mkfs [-t 文件系统格式] 装置文件名&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-t：可以接文件系统格式，如 ext3, ext2, vfat 等(系统有支持才会生效)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看 mkfs 支持的文件格式
# 按下两个[tab]，会发现 mkfs 支持的文件格式
[root@www ~]# mkfs[tab][tab]
mkfs         mkfs.cramfs  mkfs.ext2    mkfs.ext3    mkfs.msdos   mkfs.vfat
# 将分区 /dev/hdc6(可指定你自己的分区)格式化为 ext3 文件系统
[root@www ~]# mkfs -t ext3 /dev/hdc6
mke2fs 1.39 (29-May-2006)
# 指的是分割槽的名称(label)
Filesystem label=
OS type: Linux
# block 的大小配置为 4K
Block size=4096 (log=2)
Fragment size=4096 (log=2)
# 由此配置决定的inode/block数量
251392 inodes, 502023 blocks
25101 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=515899392
16 block groups
32768 blocks per group, 32768 fragments per group
15712 inodes per group
Superblock backups stored on blocks:
32768, 98304, 163840, 229376, 294912

Writing inode tables: done
# 有日志记录
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 34 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
# 这样就创建起来 Ext3 文件系统了
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-2-磁盘检验&#34;&gt;7.2 磁盘检验&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;fsck（file system check）用来检查和维护不一致的文件系统&lt;/li&gt;
&lt;li&gt;若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;fsck [-t 文件系统] [-ACay] 装置名称&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-t: 给定档案系统的型式，若在 /etc/fstab 中已有定义或 kernel 本身已支援的则不需加上此参数&lt;/li&gt;
&lt;li&gt;-s: 依序一个一个地执行 fsck 的指令来检查&lt;/li&gt;
&lt;li&gt;-A: 对/etc/fstab 中所有列出来的分区（partition）做检查&lt;/li&gt;
&lt;li&gt;-C: 显示完整的检查进度&lt;/li&gt;
&lt;li&gt;-d: 打印出 e2fsck 的 debug 结果&lt;/li&gt;
&lt;li&gt;-p: 同时有 -A 条件时，同时有多个 fsck 的检查一起执行&lt;/li&gt;
&lt;li&gt;-R: 同时有 -A 条件时，省略 / 不检查&lt;/li&gt;
&lt;li&gt;-V: 详细显示模式&lt;/li&gt;
&lt;li&gt;-a: 如果检查有错则自动修复&lt;/li&gt;
&lt;li&gt;-r: 如果检查有错则由使用者回答是否修复&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-y: 指定检测每个文件自动输入yes，在不确定哪些是不正常的时候，可以执行&lt;code&gt;fsck -y&lt;/code&gt;全部检查修复&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看系统有多少文件系统支持的 fsck 命令
[root@www ~]# fsck[tab][tab]
fsck         fsck.cramfs  fsck.ext2    fsck.ext3    fsck.msdos   fsck.vfat
# 强制检测 /dev/hdc6 分区
[root@www ~]# fsck -C -f -t ext3 /dev/hdc6
fsck 1.39 (29-May-2006)
e2fsck 1.39 (29-May-2006)
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Checking reference counts
Pass 5: Checking group summary information
vbird_logical: 11/251968 files (9.1% non-contiguous), 36926/1004046 blocks
# 如果没有 -f，则由于这个文件系统不曾出现问题，检查的经过非常快速
# 若加上 -f 强制检查，才会一项一项的显示过程
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-3-磁盘挂载与卸除&#34;&gt;7.3 磁盘挂载与卸除&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令&lt;/li&gt;

&lt;li&gt;&lt;p&gt;磁盘挂载语法 &lt;code&gt;mount [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 装置文件名 挂载点&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 用默认方式，将刚刚创建的 /dev/hdc6 挂载到 /mnt/hdc6 上面
[root@www ~]# mkdir /mnt/hdc6
[root@www ~]# mount /dev/hdc6 /mnt/hdc6
[root@www ~]# df
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/hdc6              1976312     42072   1833836   3% /mnt/hdc6
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;磁盘卸载命令 umount 语法 &lt;code&gt;umount [-fn] 装置文件名或挂载点&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-f：强制卸除。可用在类似网络文件系统(NFS)无法读取到的情况下&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-n：不升级 /etc/mtab 情况下卸除&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 卸载/dev/hdc6
[root@www ~]# umount /dev/hdc6
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-4-使用文件系统组织磁盘存储和数据管理的必要性&#34;&gt;7.4 使用文件系统组织磁盘存储和数据管理的必要性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用文件系统是和使用裸设备相对而言的。裸设备是一种没有格式化的磁盘或磁盘分区，也就是让操作系统或者程序直接操作磁盘设备&lt;/li&gt;
&lt;li&gt;文件系统是操作系统和磁盘之间的一个桥梁，因此对磁盘的任何写操作，都要经过文件系统，然后才到磁盘&lt;/li&gt;
&lt;li&gt;通过文件系统的方式来组织磁盘存储和数据管理。优点

&lt;ul&gt;
&lt;li&gt;数据的读取、管理操作变得简单：文件系统给用户提供了一个简单的操作界面，用户可以通过对文件系统的简单操作，实现对磁盘的管理。虽然 Linux 系统下也可以直接使用裸设备，但是在读取性能上，裸设备并不比文件系统能高出多少，同时还造成了管理与维护的麻烦，普通用户是无法接受的&lt;/li&gt;
&lt;li&gt;磁盘分区管理灵活：在文件系统下提供了很多的磁盘分区管理工具(如 LVM)，通过这些工具可以灵活地对磁盘分区进行大小的修改，而在裸设备下，必须预先规划好磁盘空间，可能造成空间的不足或者浪费&lt;/li&gt;
&lt;li&gt;支持数据容错机制，数据安全能得到保障：一个好的文件系统提供了对于数据读取和写入的各种容错和保护机制，很好地保障了数据的安全，而裸设备没有这种灵活的管理机制，对于数据安全只能通过手工的备份方式来实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点：在大量写操作下，文件系统本身也会产生开销，例如对元数据的维护、文件系统缓存等，这个桥梁就成了一个障碍。不过，现在很多类型的文件系统都在做写入性能的改进，因而相对于文件系统提供的这些优点，缺点基本可以忽略&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>8 打包(归档)和压缩</title>
      <link>https://xueqing.github.io/blog/linux/8_%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/linux/8_%E6%89%93%E5%8C%85%E5%92%8C%E5%8E%8B%E7%BC%A9/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e5%bf%b5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tar&#34;&gt;tar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tar-%e5%91%bd%e4%bb%a4%e5%81%9a%e6%89%93%e5%8c%85%e6%93%8d%e4%bd%9c&#34;&gt;tar 命令做打包操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tar-%e5%91%bd%e4%bb%a4%e5%81%9a%e8%a7%a3%e6%89%93%e5%8c%85%e6%93%8d%e4%bd%9c&#34;&gt;tar 命令做解打包操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tar-%e5%91%bd%e4%bb%a4%e5%81%9a%e6%89%93%e5%8c%85%e5%8e%8b%e7%bc%a9%e8%a7%a3%e5%8e%8b%e7%bc%a9%e8%a7%a3%e6%89%93%e5%8c%85%e6%93%8d%e4%bd%9c&#34;&gt;tar 命令做打包压缩(解压缩解打包)操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#zip&#34;&gt;zip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#unzip&#34;&gt;unzip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gzip&#34;&gt;gzip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gunzip&#34;&gt;gunzip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bzip2&#34;&gt;bzip2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bunzip2&#34;&gt;bunzip2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;打包：也称为归档，指的是一个文件或目录的集合，而这个集合被存储在一个文件中。归档文件没有经过压缩，因此，它占用的空间是其中所有文件和目录的总和&lt;/li&gt;
&lt;li&gt;压缩：指利用算法将文件进行处理，已达到保留最大文件信息，而让文件体积变小的目的。基本原理为，通过查找文件内的重复字节，建立一个相同字节的词典文件，并用一个代码表示

&lt;ul&gt;
&lt;li&gt;有损压缩：指即便丢失个别的数据，对文件也不会造成太大的影响。广泛应用于动画、声音和图像文件中，典型代表就是影碟文件格式 mpeg、音乐文件格式 mp3 以及图像文件格式 jpg&lt;/li&gt;
&lt;li&gt;无损压缩：指压缩数据必须准确无误&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;压缩包：采用压缩工具对文件进行压缩，生成的文件。该文件的体积通常只有原文件的一半甚至更小&lt;/li&gt;
&lt;li&gt;解压：压缩包中的数据无法直接使用，使用前需要利用压缩工具将文件数据还原的过程称为解压缩&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;常用的归档命令：tar 和 dd(相对而言，tar 的使用更为广泛)&lt;/li&gt;
&lt;li&gt;常用的压缩命令：如 tar、gzip、zip、bzip2 等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;tar&#34;&gt;tar&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;tar 可以将许多文件一起保存到一个单独的磁带或磁盘中进行归档。使用 tar 命令归档的包通常称为 tar 包(tar 包文件都是以 &lt;code&gt;.tar&lt;/code&gt; 结尾)&lt;/li&gt;
&lt;li&gt;tar 还可以从归档文件中还原所需文件，也就是打包的反过程，称为解打包&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tar-命令做打包操作&#34;&gt;tar 命令做打包操作&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;tar [选项] 源文件或目录&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-c：将多个文件或目录进行打包&lt;/li&gt;
&lt;li&gt;-A：追加 tar 文件到归档文件&lt;/li&gt;
&lt;li&gt;-f 包名：指定包的文件名。包的扩展名是用来给管理员识别格式的，所以一定要正确指定扩展名&lt;/li&gt;
&lt;li&gt;-v：显示打包文件过程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在使用 tar 命令指定选项时可以不在选项前面输入 &amp;ldquo;-&amp;rdquo;&lt;/li&gt;
&lt;li&gt;选项 &amp;ldquo;-cvf&amp;rdquo; 一般是习惯用法，记住打包时需要指定打包之后的文件名，而且要用 &amp;ldquo;.tar&amp;rdquo; 作为扩展名&lt;/li&gt;
&lt;li&gt;打包并压缩目录。&lt;strong&gt;压缩命令不能直接压缩目录&lt;/strong&gt;，必须先用 tar 命令将目录打包，然后才能用 gzip 命令或 bzip2 命令对打包文件进行压缩&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tar-命令做解打包操作&#34;&gt;tar 命令做解打包操作&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;tar [选项] 压缩包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-x：对 tar 包做解打包操作&lt;/li&gt;
&lt;li&gt;-f 包名：指定要解压的 tar 包的包名&lt;/li&gt;
&lt;li&gt;-t：只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作&lt;/li&gt;
&lt;li&gt;-C 目录：指定解打包位置&lt;/li&gt;
&lt;li&gt;-v：显示解打包的具体过程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;习惯使用 &amp;ldquo;-xvf&amp;rdquo; 选项，会把包中的文件解压到当前目录下。如果想要指定解压位置，则需要使用 &amp;ldquo;-C(大写)&amp;rdquo; 选项&lt;/li&gt;
&lt;li&gt;只想查看文件包中有哪些文件，则可以把解打包选项 &amp;ldquo;-x&amp;rdquo; 更换为测试选项 &amp;ldquo;-t&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;tar-命令做打包压缩-解压缩解打包-操作&#34;&gt;tar 命令做打包压缩(解压缩解打包)操作&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;语法 &lt;code&gt;tar [选项] 压缩包 源文件或目录&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-z：压缩和解压缩 &amp;ldquo;.tar.gz&amp;rdquo; 格式，习惯使用 &amp;ldquo;-zcvf&amp;rdquo; 和 &amp;ldquo;-zxvf&amp;rdquo;&lt;/li&gt;
&lt;li&gt;-j：压缩和解压缩 &amp;ldquo;.tar.bz2&amp;rdquo;格式，习惯使用 &amp;ldquo;-jcvf&amp;rdquo; 和 &amp;ldquo;-jxvf&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;zip&#34;&gt;zip&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&amp;rdquo;.zip&amp;rdquo; 格式文件是 Windows 和 Linux 系统都通用的压缩文件类型，属于几种主流的压缩格式(zip、rar等)之一，是一种相当简单的分别压缩每个文件的存储格式&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;zip [选项] 压缩包名 源文件或源目录列表&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-r：递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩&lt;/li&gt;
&lt;li&gt;-m：将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中&lt;/li&gt;
&lt;li&gt;-v：显示详细的压缩过程信息&lt;/li&gt;
&lt;li&gt;-q：在压缩的时候不显示命令的执行过程&lt;/li&gt;
&lt;li&gt;-压缩级别：压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好&lt;/li&gt;
&lt;li&gt;-u：更新压缩文件，即往压缩文件中添加新文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;unzip&#34;&gt;unzip&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;unzip 命令可以查看和解压缩 zip 文件&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;unzip [选项] 压缩包名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-d 目录名：将压缩文件解压到指定目录下&lt;/li&gt;
&lt;li&gt;-n：解压时并不覆盖已经存在的文件&lt;/li&gt;
&lt;li&gt;-o：解压时覆盖已经存在的文件，并且无需用户确认&lt;/li&gt;
&lt;li&gt;-v：查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作&lt;/li&gt;
&lt;li&gt;-t：测试压缩文件有无损坏，但并不解压&lt;/li&gt;
&lt;li&gt;-x 文件列表：解压文件，但不包含文件列表中指定的文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gzip&#34;&gt;gzip&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名通常标记为 “.gz”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gzip 命令只能用来压缩文件，不能压缩目录，即便指定了目录，也只能压缩目录内的所有文件，即对目录内每个文件执行 gzip 命令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;gzip [选项] 源文件&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;命令中的源文件，当进行压缩操作时，指的是普通文件；当进行解压缩操作时，指的是压缩文件&lt;/li&gt;
&lt;li&gt;不带参数时，默认将源文件压缩，生成压缩文件，不会保留源文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选项与参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-c：将压缩数据输出到标准输出中，并保留源文件&lt;/li&gt;
&lt;li&gt;-d：对压缩文件进行解压缩&lt;/li&gt;
&lt;li&gt;-r：递归压缩指定目录下以及子目录下的所有文件&lt;/li&gt;
&lt;li&gt;-v：对于每个压缩和解压缩的文件，显示相应的文件名和压缩比&lt;/li&gt;
&lt;li&gt;-l：对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 保留源文件压缩
[root@localhost ~]# gzip -c anaconda-ks.cfg &amp;gt;anaconda-ks.cfg.gz
# 使用-c，但是不让压缩数据输出到屏幕上，而是重定向到压缩文件，这样可以压缩文件的同时不删除源文件
[root@localhost ~]# ls
anaconda-ks.cfg anaconda-ks.cfg.gz install.log.gz install.log.syslog
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;gunzip&#34;&gt;gunzip&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用于解压被 gzip 压缩过的文件(扩展名为 “.gz”)&lt;/li&gt;
&lt;li&gt;对于解压被 gzip 压缩过的文件，还可以使用 gzip 命令，即 &lt;code&gt;gzip -d&lt;/code&gt; 压缩包&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;gunzip [选项] 文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-r 目录名：递归处理，解压缩指定目录下以及子目录下的所有文件&lt;/li&gt;
&lt;li&gt;-c：把解压缩后的文件输出到标准输出设备&lt;/li&gt;
&lt;li&gt;-f：强制解压缩文件，不理会文件是否已存在等情况&lt;/li&gt;
&lt;li&gt;-l：列出压缩文件内容&lt;/li&gt;
&lt;li&gt;-v：显示命令执行过程&lt;/li&gt;
&lt;li&gt;-t：测试压缩文件是否正常，但不对其做解压缩操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果压缩的是一个纯文本文件，则可以直接使用 &lt;code&gt;zcat&lt;/code&gt; 命令在不解压缩的情况下查看这个文本文件中的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bzip2&#34;&gt;bzip2&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;同 gzip 命令类似，只能对文件进行压缩(或解压缩)，对于目录只能压缩(或解压缩)该目录及子目录下的所有文件。当执行压缩任务完成后，会生成一个以 “.bz2” 为后缀的压缩包&lt;/li&gt;
&lt;li&gt;从理论上来讲，&amp;rdquo;.bz2&amp;rdquo;格式的算法更先进、压缩比更好；而 &amp;ldquo;.gz&amp;rdquo;格式相对来讲的时间更快&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;bzip2 [选项] 源文件&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;源文件指的要压缩或解压缩的文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-d：执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件&lt;/li&gt;
&lt;li&gt;-k：bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项&lt;/li&gt;
&lt;li&gt;-f：bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件&lt;/li&gt;
&lt;li&gt;-t：测试压缩包文件的完整性&lt;/li&gt;
&lt;li&gt;-v：压缩或解压缩文件时，显示详细信息&lt;/li&gt;
&lt;li&gt;-数字：这个参数和 gzip 命令的作用一样，用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gzip 只是不会打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；而 bzip2 命令则根本不支持压缩目录，也没有“-r”选项&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bunzip2&#34;&gt;bunzip2&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;要解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2&lt;/li&gt;
&lt;li&gt;bunzip2 命令只能用于解压文件，即便解压目录，也是解压该目录以及所含子目录下的所有文件&lt;/li&gt;
&lt;li&gt;语法 &lt;code&gt;bunzip2 [选项] 源文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选项与参数

&lt;ul&gt;
&lt;li&gt;-k：解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数&lt;/li&gt;
&lt;li&gt;-f：解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项&lt;/li&gt;
&lt;li&gt;-v：显示命令执行过程&lt;/li&gt;
&lt;li&gt;-L：列出压缩文件内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&amp;rdquo;.bz2&amp;rdquo; 格式压缩的纯文本文件也可以不解压缩直接查看，使用的命令是 &lt;code&gt;bzcat&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>awk 命令</title>
      <link>https://xueqing.github.io/blog/ubuntu/awk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/awk/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%84%9a%e6%9c%ac%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84&#34;&gt;脚本基本架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86&#34;&gt;工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b0%86%e5%a4%96%e9%83%a8%e5%8f%98%e9%87%8f%e4%bc%a0%e9%80%92%e7%bb%99-awk&#34;&gt;将外部变量传递给 awk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;脚本基本架构&#34;&gt;脚本基本架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;awk &#39;BEGIN{ print &amp;quot;start&amp;quot; } pattern{ commands } END{ print &amp;quot;end&amp;quot; }&#39; file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个 awk 脚本通常由：&lt;code&gt;BEGIN&lt;/code&gt;语句块、能够使用模式匹配的通用语句块、&lt;code&gt;END&lt;/code&gt;语句块 3 部分组成&lt;/li&gt;
&lt;li&gt;这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被单引号或双引号中&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;工作原理&#34;&gt;工作原理&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;awk &#39;BEGIN{ commands } pattern{ commands } END{ commands }&#39;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一步：执行&lt;code&gt;BEGIN{ commands }&lt;/code&gt;语句块中的语句

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BEGIN&lt;/code&gt;语句块在 awk 开始从输入流中读取行之前被执行&lt;/li&gt;
&lt;li&gt;这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在&lt;code&gt;BEGIN&lt;/code&gt;语句块中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二步：从文件或标准输入(stdin)读取一行，然后执行&lt;code&gt;pattern{ commands }&lt;/code&gt;语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pattern&lt;/code&gt;语句块中的通用命令是最重要的部分，它也是可选的&lt;/li&gt;
&lt;li&gt;如果没有提供&lt;code&gt;pattern&lt;/code&gt;语句块，则默认执行&lt;code&gt;{ print }&lt;/code&gt;，即打印每一个读取到的行，awk 读取的每一行都会执行该语句块&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;echo -e &amp;quot;A line 1\nA line 2&amp;quot; | awk &#39;BEGIN{ print &amp;quot;Start&amp;quot; } { print } END{ print &amp;quot;End&amp;quot; }&#39;&lt;/code&gt;输出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Start
A line 1
A line 2
End
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当使用不带参数的&lt;code&gt;print&lt;/code&gt;时，它就打印当前行，当&lt;code&gt;print&lt;/code&gt;的参数是以逗号进行分隔时，打印时则以空格作为定界符。在 awk 的&lt;code&gt;print&lt;/code&gt;语句块中双引号是被当作拼接符使用&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo | awk &#39;{ var1=&amp;quot;v1&amp;quot;; var2=&amp;quot;v2&amp;quot;; var3=&amp;quot;v3&amp;quot;; print var1,var2,var3; }&#39;&lt;/code&gt;输出&lt;code&gt;v1 v2 v3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo | awk &#39;{ var1=&amp;quot;v1&amp;quot;; var2=&amp;quot;v2&amp;quot;; var3=&amp;quot;v3&amp;quot;; print var1&amp;quot;=&amp;quot;var2&amp;quot;=&amp;quot;var3; }&#39;&lt;/code&gt;输出&lt;code&gt;v1=v2=v3&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三步：当读至输入流末尾时，执行&lt;code&gt;END{ commands }&lt;/code&gt;语句块&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;END&lt;/code&gt;语句块在 awk 从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成&lt;/li&gt;
&lt;li&gt;也是一个可选语句块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;将外部变量传递给-awk&#34;&gt;将外部变量传递给 awk&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;借助&lt;code&gt;-v&lt;/code&gt;选项，可以将外部值（并非来自 stdin）传递给 awk&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;VAR=10000
echo | awk -v VARIABLE=$VAR &#39;{ print VARIABLE }&#39; ## 输出&amp;quot;10000&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;另一种传递外部变量方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;var1=&amp;quot;aaa&amp;quot;
var2=&amp;quot;bbb&amp;quot;
echo | awk &#39;{ print v1,v2 }&#39; v1=$var1 v2=$var2 ## 输出&amp;quot;aaa bbb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当输入来自于文件时使用&lt;code&gt;awk &#39;{ print v1,v2 }&#39; v1=$var1 v2=$var2 filename&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;以上方法中，变量之间用空格分隔作为 awk 的命令行参数跟随在&lt;code&gt;BEGIN&lt;/code&gt;、&lt;code&gt;{}&lt;/code&gt;和&lt;code&gt;END&lt;/code&gt;语句块之后&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>dpkg 安装和卸载程序</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_dpkg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_dpkg/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo dpkg -i *.deb&lt;/code&gt;安装服务&lt;/li&gt;
&lt;li&gt;卸载服务

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dpkg -l | grep xxx&lt;/code&gt;查看包是否正确安装&lt;/li&gt;
&lt;li&gt;第一列的&lt;code&gt;ii&lt;/code&gt;指的是&lt;code&gt;installed ok installed&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpkg -r xxx&lt;/code&gt;移除安装包，但是保留配置文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dpkg -P/--purge xxx&lt;/code&gt;完全移除安装包，包括配置文件&lt;/li&gt;
&lt;li&gt;再用&lt;code&gt;dpkg -l | grep xxx&lt;/code&gt;查看安装状态&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;-r&lt;/code&gt;移除，可以看到第一列的的状态是&lt;code&gt;rc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;-P&lt;/code&gt;移除，输出为空，找不到对应条目&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>find 命令</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_find/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_find/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;递归删除文件夹下某个文件或文件夹&lt;/li&gt;
&lt;li&gt;find 指定&lt;code&gt;-name&lt;/code&gt;查找类型默认包括文件和文件夹

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;find ./ -name .git | xargs rm -rf&lt;/code&gt;递归删除当前路径下的&lt;code&gt;.git&lt;/code&gt;文件和文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find ./ -name .git -type f | xargs rm -rf&lt;/code&gt;递归删除当前路径下的&lt;code&gt;.git&lt;/code&gt;文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find ./ -name .git -type d | xargs rm -rf&lt;/code&gt;递归删除当前路径下的&lt;code&gt;.git&lt;/code&gt;文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find ./ -name .git -print -exec rm -rf {} \;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-print&lt;/code&gt;输出查找的文件或文件夹名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-exec&lt;/code&gt;后边跟着要执行的命令，表示将 find 查找的文件或目录执行该命令

&lt;ul&gt;
&lt;li&gt;选项后面跟着要执行的命令和脚本，然后是一对&lt;code&gt;{}&lt;/code&gt;，一个空格和一个&lt;code&gt;\&lt;/code&gt;，然后是一个分号&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xargs- build and execute command lines from standard input&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>fsck 命令</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_fsck/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_fsck/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Ubuntu16 在启动的时候出错 &lt;code&gt;fsck exited with status code 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;出错原因：磁盘检测不能通过&lt;/li&gt;
&lt;li&gt;解决方法：&lt;code&gt;fsck.ext4 -y /dev/sda1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GDB 学习</title>
      <link>https://xueqing.github.io/blog/ubuntu/gdb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/gdb/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#gdb-%E5%AD%A6%E4%B9%A0&#34;&gt;GDB 学习&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#g-%E7%BC%96%E8%AF%91&#34;&gt;g++ 编译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8-gdb-%E8%B0%83%E8%AF%95&#34;&gt;启动 GDB 调试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9&#34;&gt;设置断点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E5%90%84%E7%B1%BB%E4%BF%A1%E6%81%AF&#34;&gt;查看各类信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%90%E8%A1%8C%E8%A2%AB%E8%B0%83%E8%AF%95%E7%9A%84%E7%A8%8B%E5%BA%8F&#34;&gt;运行被调试的程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%BE%E7%BD%AE%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E5%90%8E%E6%AC%B2%E6%98%BE%E7%A4%BA%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8F%8A%E6%A0%BC%E5%BC%8F&#34;&gt;设置程序中断后欲显示的数据及格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%AE%E5%8A%A9%E5%91%BD%E4%BB%A4&#34;&gt;帮助命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;g-编译&#34;&gt;g++ 编译&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;添加编译参数&lt;code&gt;-std=c++11 -fpermissive&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定编译生成的可执行文件名字&lt;code&gt;-o gdb-sample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加调试编译，将源代码信息编译到可执行文件中&lt;code&gt;-g&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不用 -g，看不到程序的函数名、变量名，代替的是运行时的内存地址&lt;/li&gt;
&lt;li&gt;没有源代码，调试和跟踪时只能是汇编代码级别的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;启动-gdb-调试&#34;&gt;启动 GDB 调试&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;先启动 gdb，再加载被调试的可执行程序文件：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gdb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file gdb-sample&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;也可在启动调试时载入被调试程序名字&lt;code&gt;gdb gdb-sample&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同时调试一个运行程序和 core 文件，core 是程序非法执行后 core dump 后产生的文件&lt;code&gt;gdb gdb-sample core&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定程序运行的进程 ID：&lt;code&gt;gdb gdb-sample 2048&lt;/code&gt;，主要用于服务程序&lt;/li&gt;
&lt;li&gt;退出 GDB 调试环境&lt;code&gt;q(quit)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;设置断点&#34;&gt;设置断点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;b + 行号&lt;code&gt;b 8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;b + 函数名称&lt;code&gt;b main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;b + *函数名称，将断点设置在由编译器生成的 prolg 代码处&lt;code&gt;b *main&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;b + *代码地址&lt;code&gt;b *004835c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除断点，不指定编号则删除所有断点&lt;code&gt;d(delete breakpoints) N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;禁用某个断点&lt;code&gt;disable breakpoints N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许使用某个断点&lt;code&gt;enable breakpoints N&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;清除源文件某一行代码的所有断点&lt;code&gt;clean number&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;查看各类信息&#34;&gt;查看各类信息&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;查看当前的所有断点信息&lt;code&gt;i(info) breakpoints&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看程序是否在运行，进程号，被暂停的原因&lt;/li&gt;
&lt;li&gt;显示指定变量（临时变量或全局变量）的值&lt;code&gt;p(print)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看程序运行路径&lt;code&gt;show paths&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置环境变量&lt;code&gt;set env(environment) varname[=value]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看环境变量&lt;code&gt;show environment [varname]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示当前所在目录&lt;code&gt;pwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看函数堆栈&lt;code&gt;bt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定运行时参数&lt;code&gt;set args 参数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看设置好的参数&lt;code&gt;show args&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;运行被调试的程序&#34;&gt;运行被调试的程序&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;运行&lt;code&gt;r(run)&lt;/code&gt;，如果没有断点则执行完，否则暂停在第一个可用断点处&lt;/li&gt;
&lt;li&gt;继续执行被调试程序&lt;code&gt;c(continue)&lt;/code&gt;，直至下一个断点或程序结束&lt;/li&gt;
&lt;li&gt;执行一行源程序代码：

&lt;ul&gt;
&lt;li&gt;如果该行有程序调用，则进入该函数&lt;code&gt;s(step into)&lt;/code&gt;，单步跟踪进入&lt;/li&gt;
&lt;li&gt;一并执行该行代码中的函数调用&lt;code&gt;n(step over)&lt;/code&gt;，单步跟踪&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;执行一行汇编指令&lt;code&gt;si/ni&lt;/code&gt;，类似于 s/n 命令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;设置程序中断后欲显示的数据及格式&#34;&gt;设置程序中断后欲显示的数据及格式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;例如&lt;code&gt;display /i $pc&lt;/code&gt;，每次程序中断后可以看到即将被执行的下一条汇编指令，&lt;code&gt;$pc&lt;/code&gt;代表当前汇编指令，&lt;code&gt;/i&lt;/code&gt;表示以十六进制显示&lt;/li&gt;
&lt;li&gt;取消先前的 display 设置&lt;code&gt;undisplay N&lt;/code&gt;，编号从 1 递增&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;帮助命令&#34;&gt;帮助命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;help，提供对 GDB 各种命令的解释说明

&lt;ul&gt;
&lt;li&gt;指定了命令名称参数，则显示该命令的详细说明&lt;code&gt;help display&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有指定参数，则分类显示所有 GDB 命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;直接回车，表示重复上一次命令&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Google 开源项目风格指南</title>
      <link>https://xueqing.github.io/blog/ubuntu/google_style_guide/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/google_style_guide/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://zh-google-styleguide.readthedocs.io/en/latest/contents/&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97&#34;&gt;shell 风格指南&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%83%8c%e6%99%af&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#shell-%e6%96%87%e4%bb%b6%e5%92%8c%e8%a7%a3%e9%87%8a%e5%99%a8%e8%b0%83%e7%94%a8&#34;&gt;shell 文件和解释器调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%8e%af%e5%a2%83&#34;&gt;环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e9%87%8a&#34;&gt;注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%bc%e5%bc%8f&#34;&gt;格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%a9%e8%bf%9b&#34;&gt;缩进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%8c%e7%9a%84%e9%95%bf%e5%ba%a6%e5%92%8c%e9%95%bf%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;行的长度和长字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ae%a1%e9%81%93&#34;&gt;管道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%be%aa%e7%8e%af&#34;&gt;循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#case-%e8%af%ad%e5%8f%a5&#34;&gt;case 语句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%98%e9%87%8f%e6%89%a9%e5%b1%95&#34;&gt;变量扩展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%95%e7%94%a8&#34;&gt;引用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%89%b9%e6%80%a7%e5%8f%8a%e9%94%99%e8%af%af&#34;&gt;特性及错误&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4%e6%9b%bf%e6%8d%a2&#34;&gt;命令替换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[&lt;code&gt;test&lt;/code&gt;,&lt;code&gt;[&lt;/code&gt;和&lt;code&gt;[[&lt;/code&gt;](#test%e5%92%8c)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b5%8b%e8%af%95%e5%ad%97%e7%ac%a6%e4%b8%b2&#34;&gt;测试字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%87%e4%bb%b6%e5%90%8d%e7%9a%84%e9%80%9a%e9%85%8d%e7%ac%a6%e6%89%a9%e5%b1%95&#34;&gt;文件名的通配符扩展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eval&#34;&gt;eval&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ae%a1%e9%81%93%e5%af%bc%e5%90%91-while-%e5%be%aa%e7%8e%af&#34;&gt;管道导向 while 循环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e5%90%8d%e7%ba%a6%e5%ae%9a&#34;&gt;命名约定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e5%90%8d&#34;&gt;函数名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%98%e9%87%8f%e5%90%8d&#34;&gt;变量名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e9%87%8f%e5%92%8c%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f%e5%90%8d&#34;&gt;常量和环境变量名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%ba%90%e6%96%87%e4%bb%b6%e5%90%8d&#34;&gt;源文件名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%aa%e8%af%bb%e5%8f%98%e9%87%8f&#34;&gt;只读变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e6%9c%ac%e5%9c%b0%e5%8f%98%e9%87%8f&#34;&gt;使用本地变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e4%bd%8d%e7%bd%ae&#34;&gt;函数位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%bb%e5%87%bd%e6%95%b0-main&#34;&gt;主函数 main&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b0%83%e7%94%a8%e5%91%bd%e4%bb%a4&#34;&gt;调用命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#c-%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97&#34;&gt;C++ 风格指南&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#python-%e9%a3%8e%e6%a0%bc%e6%8c%87%e5%8d%97&#34;&gt;Python 风格指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./shell-风格指南&#34;&gt;shell 风格指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./C++-风格指南&#34;&gt;C++ 风格指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./Python-风格指南&#34;&gt;Python 风格指南&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;shell-风格指南-https-zh-google-styleguide-readthedocs-io-en-latest-google-shell-styleguide-contents&#34;&gt;&lt;a href=&#34;https://zh-google-styleguide.readthedocs.io/en/latest/google-shell-styleguide/contents/&#34; target=&#34;_blank&#34;&gt;shell 风格指南&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&#34;背景&#34;&gt;背景&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;使用哪一种 shell

&lt;ul&gt;
&lt;li&gt;bash 是唯一被允许执行的 shell 脚本语言&lt;/li&gt;
&lt;li&gt;可执行文件以&lt;code&gt;#!/bin/bash&lt;/code&gt;开始&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;set&lt;/code&gt;设置 shell 的选项&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;什么时候使用 shell

&lt;ul&gt;
&lt;li&gt;仅被用于小功能或简单的包装脚本&lt;/li&gt;
&lt;li&gt;如果在乎性能，不使用 shell&lt;/li&gt;
&lt;li&gt;需要使用数据而不是变量赋值，如&lt;code&gt;${PHPESTATUS}&lt;/code&gt;，使用 Python 脚本&lt;/li&gt;
&lt;li&gt;脚本超过 100 行，尽可能使用 Python，以免之后花更多时间重写脚本&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;shell-文件和解释器调用&#34;&gt;shell 文件和解释器调用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;文件扩展名

&lt;ul&gt;
&lt;li&gt;可执行文件应该没有扩展名（强烈建议）或使用&lt;code&gt;.sh&lt;/code&gt;扩展名&lt;/li&gt;
&lt;li&gt;库文件使用&lt;code&gt;.sh&lt;/code&gt;扩展名，且不可执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SUID/SGID

&lt;ul&gt;
&lt;li&gt;禁止在脚本中使用 SUID(Set User ID) 和 SGID(Set Group ID)&lt;/li&gt;
&lt;li&gt;如果需要较高权限使用&lt;code&gt;sudo&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;环境&#34;&gt;环境&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;STDOUT vs STDERR&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有错误信息应导向 STDERR&lt;/li&gt;
&lt;li&gt;便于从实际问题中分离出正常状态&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推荐使用如下函数，打印错误信息和其他状态信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;err() {
echo &amp;quot;[$(date +&#39;%Y-%m-%dT%H:%M:%S%z&#39;)]: $@&amp;quot; &amp;gt;&amp;amp;2
}

if ! do_sth; then
err &amp;quot;Unable to do_sth&amp;quot;
exit &amp;quot;${E_DID_NOTHING}&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;注释&#34;&gt;注释&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件头&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;文件必须包含一个顶层注释，简要概述内容。版权声明和作者信息可选&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
#
# Perform hot bakeups of Oracle databases.
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;功能注释&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;除了明显简短的函数必须被注释&lt;/li&gt;
&lt;li&gt;库函数都必须注释&lt;/li&gt;
&lt;li&gt;注释包括&lt;/li&gt;
&lt;li&gt;函数的描述&lt;/li&gt;
&lt;li&gt;全局变量的使用和修改&lt;/li&gt;
&lt;li&gt;使用的参数说明&lt;/li&gt;
&lt;li&gt;返回值，而不是上一条命令运行后默认的退出状态&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
#
# Perform hot bakeups of Oracle databases.

export PATH=&#39;/usr/xpg4/bin:/usr/bin:/opt/csw/bin:/opt/goog/bin&#39;

#######################################
# Cleanup files from the backup dir
# Globals:
#   BACKUP_DIR
#   ORACLE_SID
# Arguments:
#   None
# Returns:
#   None
#######################################
cleanup() {
#...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;实现部分的注释&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注释代码中有技巧、不明显、有趣或重要的部分&lt;/li&gt;
&lt;li&gt;不要注释所有代码，简单注释&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TODO 注释&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用 TODO 注释临时的、短期解决方案的、或足够好但不完美的代码&lt;/li&gt;
&lt;li&gt;应包含全部大写的字符串 TODO + 用户名，冒号可选，最好在后面加上 bug 或 ticket 的序号&lt;/li&gt;
&lt;li&gt;例如&lt;code&gt;# TODO(kiki): Handle the unlikely edge cases (bug ####)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;

&lt;h4 id=&#34;缩进&#34;&gt;缩进&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;缩进两个空格，没有制表符&lt;/li&gt;
&lt;li&gt;代码块直接使用空行提升可读性&lt;/li&gt;
&lt;li&gt;对于已有文件，保持已有的缩进风格&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;行的长度和长字符串&#34;&gt;行的长度和长字符串&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;行的最大长度为 80 个字符&lt;/li&gt;
&lt;li&gt;使用 here document 或嵌入的换行符&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# DO use &#39;here document&#39;s
cat &amp;lt;&amp;lt;END;
I am an exceptionally long
string.
END

# Embedded newlines are ok too
long_string=&amp;quot;I am an exceptionally
long string.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;管道&#34;&gt;管道&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;如果一行容不下一个管道，将正哥管道操作分割成梅钢一个管道&lt;/li&gt;
&lt;li&gt;管道操作的下一部分应放在新行且缩进两个空格&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# All fits on one line
command1 | command2

# Long commands
command1 \
| command2 \
| command3 \
| command4
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;循环&#34;&gt;循环&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;; do&lt;/code&gt;，&lt;code&gt;; then&lt;/code&gt;和&lt;code&gt;while&lt;/code&gt;，&lt;code&gt;for&lt;/code&gt;，&lt;code&gt;if&lt;/code&gt;放在同一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;else&lt;/code&gt;单独成一行&lt;/li&gt;
&lt;li&gt;结束语句单独一行并与开始语句垂直对齐&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for dir in ${dirs_to_cleanup}; do
if [[ -d &amp;quot;${dir}/${ORACLE_SID}&amp;quot; ]]; then
log_date &amp;quot;Cleaning up old files in ${dir}/${ORACLE_SID}&amp;quot;
rm &amp;quot;${dir}/${ORACLE_SID}/&amp;quot;*
if [[ &amp;quot;$?&amp;quot; -ne 0 ]]; then
error_message
fi
else
mkdir -p &amp;quot;${dir}/${ORACLE_SID}&amp;quot;
if [[ &amp;quot;$?&amp;quot; -ne 0 ]]; then
error_message
fi
fi
done
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;case-语句&#34;&gt;case 语句&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;通过 2 个空格缩进可选项&lt;/li&gt;
&lt;li&gt;同一行可选项的模式右圆括号知乎和结束符&lt;code&gt;;;&lt;/code&gt;之前各一个空格&lt;/li&gt;

&lt;li&gt;&lt;p&gt;长可选项或多命令可选项应被拆成多行，模式、操作和结束符&lt;code&gt;;;&lt;/code&gt;在不同的行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# multi-lines
case &amp;quot;${expression}&amp;quot; in
a)
variable=&amp;quot;...&amp;quot;
some_command &amp;quot;${variable}&amp;quot; &amp;quot;${other_expr}&amp;quot; ...
;;
absolute)
actions=&amp;quot;relative&amp;quot;
another_command &amp;quot;${actions}&amp;quot; &amp;quot;${other_expr}&amp;quot; ...
;;
*)
error &amp;quot;Unexpected expression &#39;${expression}&#39;&amp;quot;
;;
esac

# one-line
verbose=&#39;false&#39;
aflag=&#39;&#39;
bflag=&#39;&#39;
files=&#39;&#39;
while getopts &#39;abf:v&#39; flag; do
case &amp;quot;${flag}&amp;quot; in
a) aflag=&#39;true&#39; ;;
b) bflag=&#39;true&#39; ;;
f) files=&amp;quot;${OPTARG}&amp;quot; ;;
v) verbose=&#39;true&#39; ;;
*) error &amp;quot;Unexpected option ${flag}&amp;quot; ;;
esac
done
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;变量扩展&#34;&gt;变量扩展&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;按照优先级顺序

&lt;ul&gt;
&lt;li&gt;与现存代码发现的保持一致&lt;/li&gt;
&lt;li&gt;阅读&lt;a href=&#34;#引用&#34;&gt;引用变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;推荐使用&lt;code&gt;${var}&lt;/code&gt;而不是&lt;code&gt;$var&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Section of recommended cases.

# Preferred style for &#39;special&#39; variables:
echo &amp;quot;Positional: $1&amp;quot; &amp;quot;$5&amp;quot; &amp;quot;$3&amp;quot;
echo &amp;quot;Specials: !=$!, -=$-, _=$_. ?=$?, #=$# *=$* @=$@ \$=$$ ...&amp;quot;

# Braces necessary:
echo &amp;quot;many parameters: ${10}&amp;quot;

# Braces avoiding confusion:
# Output is &amp;quot;a0b0c0&amp;quot;
set -- a b c
echo &amp;quot;${1}0${2}0${3}0&amp;quot;

# Preferred style for other variables:
echo &amp;quot;PATH=${PATH}, PWD=${PWD}, mine=${some_var}&amp;quot;
while read f; do
echo &amp;quot;file=${f}&amp;quot;
done &amp;lt; &amp;lt;(ls -l /tmp)

# Section of discouraged cases

# Unquoted vars, unbraced vars, brace-quoted single letter
# shell specials.
echo a=$avar &amp;quot;b=$bvar&amp;quot; &amp;quot;PID=${$}&amp;quot; &amp;quot;${1}&amp;quot;

# Confusing use: this is expanded as &amp;quot;${1}0${2}0${3}0&amp;quot;,
# not &amp;quot;${10}${20}${30}
set -- a b c
echo &amp;quot;$10$20$30&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;引用&#34;&gt;引用&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;除非需要小心不带引用的扩展，否则总是引用包含变量、命令替换符、空格或 shell 元字符的字符串&lt;/li&gt;
&lt;li&gt;推荐引用是单词的字符串(而不是命令选项或者路径名)&lt;/li&gt;
&lt;li&gt;不要引用整数&lt;/li&gt;
&lt;li&gt;注意&lt;code&gt;[[&lt;/code&gt;中模式匹配的引用规则&lt;/li&gt;

&lt;li&gt;&lt;p&gt;请使用&lt;code&gt;$@&lt;/code&gt;除非有特殊原因需要使用&lt;code&gt;S*&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &#39;Single&#39; quotes indicate that no substitution is desired.
# &amp;quot;Double&amp;quot; quotes indicate that substitution is required/tolerated.

# Simple examples
# &amp;quot;quote command substitutions&amp;quot;
flag=&amp;quot;$(some_command and its args &amp;quot;$@&amp;quot; &#39;quoted separately&#39;)&amp;quot;

# &amp;quot;quote variables&amp;quot;
echo &amp;quot;${flag}&amp;quot;

# &amp;quot;never quote literal integers&amp;quot;
value=32
# &amp;quot;quote command substitutions&amp;quot;, even when you expect integers
number=&amp;quot;$(generate_number)&amp;quot;

# &amp;quot;prefer quoting words&amp;quot;, not compulsory
readonly USE_INTEGER=&#39;true&#39;

# &amp;quot;quote shell meta characters&amp;quot;
echo &#39;Hello stranger, and well met. Earn lots of $$$&#39;
echo &amp;quot;Process $$: Done making \$\$\$.&amp;quot;

# &amp;quot;command options or path names&amp;quot;
# ($1 is assumed to contain a value here)
grep -li Hugo /dev/null &amp;quot;$1&amp;quot;

# Less simple examples
# &amp;quot;quote variables, unless proven false&amp;quot;: ccs might be empty
git send-email --to &amp;quot;${reviewers}&amp;quot; ${ccs:+&amp;quot;--cc&amp;quot; &amp;quot;${ccs}&amp;quot;}

# Positional parameter precautions: $1 might be unset
# Single quotes leave regex as-is.
grep -cP &#39;([Ss]pecial|\|?characters*)$&#39; ${1:+&amp;quot;$1&amp;quot;}

# For passing on arguments,
# &amp;quot;$@&amp;quot; is right almost everytime, and
# $* is wrong almost everytime:
#
# * $* and $@ will split on spaces, clobbering up arguments
#   that contain spaces and dropping empty strings;
# * &amp;quot;$@&amp;quot; will retain arguments as-is, so no args
#   provided will result in no args being passed on;
#   This is in most cases what you want to use for passing
#   on arguments.
# * &amp;quot;$*&amp;quot; expands to one argument, with all args joined
#   by (usually) spaces,
#   so no args provided will result in one empty string
#   being passed on.
# (Consult &#39;man bash&#39; for the nit-grits ;-)

set -- 1 &amp;quot;2 two&amp;quot; &amp;quot;3 three tres&amp;quot;; echo $# ; set -- &amp;quot;$*&amp;quot;; echo &amp;quot;$#, $@&amp;quot;)
set -- 1 &amp;quot;2 two&amp;quot; &amp;quot;3 three tres&amp;quot;; echo $# ; set -- &amp;quot;$@&amp;quot;; echo &amp;quot;$#, $@&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;特性及错误&#34;&gt;特性及错误&lt;/h3&gt;

&lt;h4 id=&#34;命令替换&#34;&gt;命令替换&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;${command}&lt;/code&gt;而不是反引号&lt;/li&gt;
&lt;li&gt;嵌套的反引号要求用反斜杠转义内部的反引号，而&lt;code&gt;${command}&lt;/code&gt;形式嵌套时不需要改变，易于阅读&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# This is preferred:
var=&amp;quot;$(command &amp;quot;$(command1)&amp;quot;)&amp;quot;

# This is not:
var=&amp;quot;`command \`command1\``&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;test-和&#34;&gt;&lt;code&gt;test&lt;/code&gt;,&lt;code&gt;[&lt;/code&gt;和&lt;code&gt;[[&lt;/code&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;推荐使用&lt;code&gt;[[ ... ]]&lt;/code&gt;，而不是&lt;code&gt;[&lt;/code&gt;，&lt;code&gt;test&lt;/code&gt;和&lt;code&gt;/usr/bin [&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;[[ ... ]]&lt;/code&gt;之间不会有路径名称扩展或单词分割发生，且允许正则表达式匹配&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# This ensures the string on the left is made up of characters in the
# alnum character class followed by the string name.
# Note that the RHS should not be quoted here.
# For the gory details, see
# E14 at http://tiswww.case.edu/php/chet/bash/FAQ
if [[ &amp;quot;filename&amp;quot; =~ ^[[:alnum:]]+name ]]; then
echo &amp;quot;Match&amp;quot;
fi

# This matches the exact pattern &amp;quot;f*&amp;quot; (Does not match in this case)
if [[ &amp;quot;filename&amp;quot; == &amp;quot;f*&amp;quot; ]]; then
echo &amp;quot;Match&amp;quot;
fi

# This gives a &amp;quot;too many arguments&amp;quot; error as f* is expanded to the
# contents of the current directory
if [ &amp;quot;filename&amp;quot; == f* ]; then
echo &amp;quot;Match&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;测试字符串&#34;&gt;测试字符串&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;尽可能使用引用，而不是过滤字符串&lt;/li&gt;
&lt;li&gt;使用空&lt;code&gt;-z&lt;/code&gt;或非空&lt;code&gt;-n&lt;/code&gt;字符串测试，而不是过滤字符串&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Do this:
if [[ &amp;quot;${my_var}&amp;quot; = &amp;quot;some_string&amp;quot; ]]; then
do_something
fi

# -z (string length is zero) and -n (string length is not zero) are
# preferred over testing for an empty string
if [[ -z &amp;quot;${my_var}&amp;quot; ]]; then
do_something
fi

# This is OK (ensure quotes on the empty side), but not preferred:
if [[ &amp;quot;${my_var}&amp;quot; = &amp;quot;&amp;quot; ]]; then
do_something
fi

# Not this:
if [[ &amp;quot;${my_var}X&amp;quot; = &amp;quot;some_stringX&amp;quot; ]]; then
do_something
fi

# Use this
if [[ -n &amp;quot;${my_var}&amp;quot; ]]; then
do_something
fi

# Instead of this as errors can occur if ${my_var} expands to a test
# flag
if [[ &amp;quot;${my_var}&amp;quot; ]]; then
do_something
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;文件名的通配符扩展&#34;&gt;文件名的通配符扩展&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用明确的路径&lt;/li&gt;
&lt;li&gt;文件名可能以&lt;code&gt;-&lt;/code&gt;开头，使用扩展通配符&lt;code&gt;./*&lt;/code&gt;比&lt;code&gt;*&lt;/code&gt;更安全&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Here&#39;s the contents of the directory:
# -f  -r  somedir  somefile

# This deletes almost everything in the directory by force
rm -v *
#removed directory: `somedir&#39;
#removed `somefile&#39;

# As opposed to:
rm -v ./*
#removed `./-f&#39;
#removed `./-r&#39;
#rm: cannot remove `./somedir&#39;: Is a directory
#removed `./somefile&#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;eval&#34;&gt;eval&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;避免使用 eval&lt;/li&gt;
&lt;li&gt;当用于给变量赋值时，eval 解析输入，并能够设置变量，但无法检查变量是什么&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# What does this set?
# Did it succeed? In part or whole?
eval $(set_my_variables)

# What happens if one of the returned values has a space in it?
variable=&amp;quot;$(eval some_function)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;管道导向-while-循环&#34;&gt;管道导向 while 循环&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用过程替换或 for 虚幻，而不是管道导向 while 循环&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在 while 循环中被修改的变量不能传递给父 shell，因为循环命令是在一个子 shell 中运行的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;last_line=&#39;NULL&#39;
your_command | while read line; do
last_line=&amp;quot;${line}&amp;quot;
done

# This will output &#39;NULL&#39;
echo &amp;quot;${last_line}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果确定输入中不包含空格或特殊符号，可使用一个 for 循环&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;total=0
# Only do this if there are no spaces in return values.
for value in $(command); do
total+=&amp;quot;${value}&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用过程替换允许重定向输出，但是请将命令放入一个显式的子 shell 中，而不是 bash 为 while 循环创建的隐式子 shell&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;total=0
last_file=
while read count filename; do
total+=&amp;quot;${count}&amp;quot;
last_file=&amp;quot;${filename}&amp;quot;
done &amp;lt; &amp;lt;(your_command | uniq -c)

# This will output the second field of the last line of output from
# the command.
echo &amp;quot;Total = ${total}&amp;quot;
echo &amp;quot;Last one = ${last_file}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当不需要传递复杂的结果给父 shell 时可使用 while 循环，当不希望改变父 shell 的范围变量时也是有用的&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Trivial implementation of awk expression:
#   awk &#39;$3 == &amp;quot;nfs&amp;quot; { print $2 &amp;quot; maps to &amp;quot; $1 }&#39; /proc/mounts
cat /proc/mounts | while read src dest type opts rest; do
if [[ ${type} == &amp;quot;nfs&amp;quot; ]]; then
echo &amp;quot;NFS ${dest} maps to ${src}&amp;quot;
fi
done
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命名约定&#34;&gt;命名约定&lt;/h3&gt;

&lt;h4 id=&#34;函数名&#34;&gt;函数名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用小写字符，用下划线分割单词，使用双冒号&lt;code&gt;::&lt;/code&gt;分割库&lt;/li&gt;
&lt;li&gt;函数名之后必须有圆括号。关键词&lt;code&gt;function&lt;/code&gt;可选，但必须在一个项目中保持一致

&lt;ul&gt;
&lt;li&gt;函数名之后有括号时，关键词&lt;code&gt;function&lt;/code&gt;是多余的，但是促进了函数的快速辨识&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大括号和函数名位于同一行，且函数名和圆括号之间没有空格&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Single function
my_func() {
#...
}

# Part of a package
mypackage::my_func() {
#...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;变量名&#34;&gt;变量名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;如&lt;a href=&#34;#函数名&#34;&gt;函数名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;循环的变量名应该和循环的任何变量同样命名&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for zone in ${zones}; do
something_with &amp;quot;${zone}&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;常量和环境变量名&#34;&gt;常量和环境变量名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;全部大写，用下划线分割，声明在文件的顶部&lt;/li&gt;
&lt;li&gt;有的第一次设置就变成了常量(如通过 getopts)，所以可以在 getopts 或基于条件来设定常量，但之后应立即设置为只读&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在函数中&lt;code&gt;declare&lt;/code&gt;不会对全局变量进行操作，所以推荐使用&lt;code&gt;readonly&lt;/code&gt;和&lt;code&gt;export&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Constant
readonly PATH_TO_FILES=&#39;/some/path&#39;

# Both constant and environment
declare -xr ORACLE_SID=&#39;PROD&#39;

VERBOSE=&#39;false&#39;
while getopts &#39;v&#39; flag; do
case &amp;quot;${flag}&amp;quot; in
v) VERBOSE=&#39;true&#39; ;;
esac
done
readonly VERBOSE
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;源文件名&#34;&gt;源文件名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;小写，可使用下划线分割单词&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;只读变量&#34;&gt;只读变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;readonly&lt;/code&gt;或&lt;code&gt;declare -r&lt;/code&gt;确保变量只读&lt;/li&gt;

&lt;li&gt;&lt;p&gt;因为全局变量在 shell 中广泛使用，所以在使用过程中捕获错误很重要。明确只读变量&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zip_version=&amp;quot;$(dpkg --status zip | grep Version: | cut -d &#39; &#39; -f 2)&amp;quot;
if [[ -z &amp;quot;${zip_version}&amp;quot; ]]; then
error_message
else
readonly zip_version
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;使用本地变量&#34;&gt;使用本地变量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;local&lt;/code&gt;声明特定功能的变量，可以确保只在函数内部和子函数中可见，避免了污染全局命名空间&lt;/li&gt;
&lt;li&gt;当赋值的值由命令替换提供时，声明和赋值需分开。因为内建的&lt;code&gt;local&lt;/code&gt;命令不会从命令替换中传递退出码&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;my_func2() {
local name=&amp;quot;$1&amp;quot;

# Separate lines for declaration and assignment:
local my_var
my_var=&amp;quot;$(my_func)&amp;quot; || return

# DO NOT do this: $? contains the exit code of &#39;local&#39;, not my_func
local my_var=&amp;quot;$(my_func)&amp;quot;
[[ $? -eq 0 ]] || return
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;函数位置&#34;&gt;函数位置&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;将文件中所有函数一起放在常量下面，不要在函数直接隐藏可执行代码&lt;/li&gt;
&lt;li&gt;只有&lt;code&gt;includes&lt;/code&gt;，&lt;code&gt;set&lt;/code&gt;声明和常量设置可能在函数声明之前完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;主函数-main&#34;&gt;主函数 main&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;对于包含至少一个其他函数的足够长的脚本，需要称为&lt;code&gt;main&lt;/code&gt;的函数&lt;/li&gt;
&lt;li&gt;便于查找程序的开始，同时允许定义更多变量为局部变量&lt;/li&gt;
&lt;li&gt;文件中最后的非注释行应该是对&lt;code&gt;main&lt;/code&gt;函数的调用&lt;code&gt;main &amp;quot;$@&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;调用命令&#34;&gt;调用命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;检查返回值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;总是检查返回值，并给出信息返回值&lt;/li&gt;
&lt;li&gt;对于非管道命令，使用&lt;code&gt;$?&lt;/code&gt;或直接通过一个&lt;code&gt;if&lt;/code&gt;语句来检查以保持简洁&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;if ! mv &amp;quot;${file_list}&amp;quot; &amp;quot;${dest_dir}/&amp;quot; ; then
echo &amp;quot;Unable to move ${file_list} to ${dest_dir}&amp;quot; &amp;gt;&amp;amp;2
exit &amp;quot;${E_BAD_MOVE}&amp;quot;
fi
  
# Or
mv &amp;quot;${file_list}&amp;quot; &amp;quot;${dest_dir}/&amp;quot;
if [[ &amp;quot;$?&amp;quot; -ne 0 ]]; then
echo &amp;quot;Unable to move ${file_list} to ${dest_dir}&amp;quot; &amp;gt;&amp;amp;2
exit &amp;quot;${E_BAD_MOVE}&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;bash 也有&lt;code&gt;PIPESTATUS&lt;/code&gt;变量，允许检查从管道所有部分返回的代码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果仅仅检查整个管道成功还是失败，可用下面的方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar -cf - ./* | ( cd &amp;quot;${dir}&amp;quot; &amp;amp;&amp;amp; tar -xf - )
if [[ &amp;quot;${PIPESTATUS[0]}&amp;quot; -ne 0 || &amp;quot;${PIPESTATUS[1]}&amp;quot; -ne 0 ]]; then
echo &amp;quot;Unable to tar files to ${dir}&amp;quot; &amp;gt;&amp;amp;2
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;只要运用任何其他命令，&lt;code&gt;PIPESTATUS&lt;/code&gt;会被覆盖。如果需要机遇管道中发生的错误执行不同的操作，需要在运行命令后立即将&lt;code&gt;PIPESTATUS&lt;/code&gt;赋值给另一个变量，&lt;code&gt;[&lt;/code&gt;是一个会将&lt;code&gt;PIPESTATUS&lt;/code&gt;擦出的命令&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar -cf - ./* | ( cd &amp;quot;${DIR}&amp;quot; &amp;amp;&amp;amp; tar -xf - )
return_codes=(${PIPESTATUS[*]})
if [[ &amp;quot;${return_codes[0]}&amp;quot; -ne 0 ]]; then
do_something
fi
if [[ &amp;quot;${return_codes[1]}&amp;quot; -ne 0 ]]; then
do_something_else
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内建命令和外部命令&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在调用 shell 内建命令和调用另外的程序之间选择，选择内建命令&lt;/li&gt;
&lt;li&gt;例如在&lt;code&gt;bash(1)&lt;/code&gt;中参数扩展函数，内建函数更强健和便携，尤其是跟&lt;code&gt;sed&lt;/code&gt;这样的命令比较&lt;/li&gt;

&lt;li&gt;&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Prefer this:
addition=$((${X} + ${Y}))
substitution=&amp;quot;${string/#foo/bar}&amp;quot;
  
# Instead of this:
addition=&amp;quot;$(expr ${X} + ${Y})&amp;quot;
substitution=&amp;quot;$(echo &amp;quot;${string}&amp;quot; | sed -e &#39;s/^foo/bar/&#39;)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;c-风格指南-https-zh-google-styleguide-readthedocs-io-en-latest-google-cpp-styleguide-contents&#34;&gt;&lt;a href=&#34;https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/&#34; target=&#34;_blank&#34;&gt;C++ 风格指南&lt;/a&gt;&lt;/h2&gt;

&lt;h2 id=&#34;python-风格指南-https-zh-google-styleguide-readthedocs-io-en-latest-google-python-styleguide-contents&#34;&gt;&lt;a href=&#34;https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/contents/&#34; target=&#34;_blank&#34;&gt;Python 风格指南&lt;/a&gt;&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>ldconfig</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_ldconfig/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_ldconfig/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ldconfig&#34;&gt;ldconfig&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ldconfig-%E4%B8%8E-etcldsoconf&#34;&gt;ldconfig 与 /etc/ld.so.conf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B7%BB%E5%8A%A0%E5%8A%A8%E6%80%81%E5%BA%93%E8%B7%AF%E5%BE%84&#34;&gt;添加动态库路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldd&#34;&gt;ldd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ldconfig-与-etc-ld-so-conf&#34;&gt;ldconfig 与 /etc/ld.so.conf&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ldconfig&lt;/code&gt; 默认查找的路径包括 &lt;code&gt;lib&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt;, &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; 列举的目录和 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如何将动态函数库加载到高速缓存

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; 写入想要读入告诉缓存中的动态函数库所在的目录&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;ldconfig&lt;/code&gt; 可执行文件将 &lt;code&gt;/etc/ld.so.conf&lt;/code&gt; 的数据读入缓存&lt;/li&gt;
&lt;li&gt;同时将数据记录一份在 &lt;code&gt;/etc/ld.so.cache&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;添加动态库路径&#34;&gt;添加动态库路径&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;查找库路径 &lt;code&gt;sudo find / -iname *library_name*.so*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法 1

&lt;ul&gt;
&lt;li&gt;追加路径到 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当前终端生效: 在终端执行 &lt;code&gt;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/library&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;~/.bashrc&lt;/code&gt; 或 &lt;code&gt;~/.bash_profile&lt;/code&gt; 中追加 &lt;code&gt;export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/path/to/library&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;source ~/.bashrc&lt;/code&gt; 或 &lt;code&gt;source ~/.bash_profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;sudo ldconfig&lt;/code&gt; 更新缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法 2

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;/etc/ld.so.conf.d/&lt;/code&gt; 中创建一个新文件 &lt;code&gt;your_lib.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;/etc/ld.so.conf.d/your_lib.conf&lt;/code&gt; 中写入想要添加的路径&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;sudo ldconfig&lt;/code&gt; 更新缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;方法 3

&lt;ul&gt;
&lt;li&gt;将库移动到 &lt;code&gt;/usr/lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;sudo ldconfig&lt;/code&gt; 更新缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ldd&#34;&gt;ldd&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ldd filename&lt;/code&gt; 可以显示可执行文件 filename 所依赖的动态函数库&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>linux 下其他命令</title>
      <link>https://xueqing.github.io/blog/ubuntu/linux_other_cmd/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/linux_other_cmd/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#linux-%E4%B8%8B%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4&#34;&gt;linux 下其他命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F&#34;&gt;文件格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ftp&#34;&gt;ftp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4-tar&#34;&gt;压缩命令 tar&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;添加可执行权限&lt;code&gt;chmod a+x filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改本机 IP 地址&lt;code&gt;ifconfig eth0 192.168.1.110&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列举目录&lt;code&gt;ls -lt&lt;/code&gt;按时间顺序显示&lt;/li&gt;
&lt;li&gt;查看所有用户&lt;code&gt;cat /etc/passwd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看所有用户组&lt;code&gt;cat /etc/group&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加用户到已存在的组：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo adduser user-name user-group&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo gpasswd -a user-name group-name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从用户组删除删除&lt;code&gt;：&lt;/code&gt;sudo gpasswd -d user-name user-group`&lt;/li&gt;
&lt;li&gt;安装 deb 文件缺少依赖库时继续执行&lt;code&gt;sudo apt-get install -f&lt;/code&gt;即可自动安装依赖库并安装 deb 包&lt;/li&gt;
&lt;li&gt;查看指定监听端口的服务&lt;code&gt;lsof -i :3000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;文件格式&#34;&gt;文件格式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/bin/sh^M: bad interpreter: No such file or directory&lt;/code&gt;脚本异常，转换为 UNIX 格式

&lt;ul&gt;
&lt;li&gt;windows：UE 或 EditPlus 转换编码为UNIX&lt;/li&gt;
&lt;li&gt;Linux：&lt;/li&gt;
&lt;li&gt;可执行权限&lt;code&gt;chmod a+x filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;改文件格式&lt;code&gt;vi filename&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;查看文件格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set ff&lt;/code&gt;或&lt;code&gt;:set fileformat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Fileformat=dos&lt;/code&gt;或&lt;code&gt;fileformat=unix&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改文件格式&lt;code&gt;:set ff=unix或:set fieformat=unix&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;保存退出&lt;code&gt;:wq&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;执行文件&lt;code&gt;./filename&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ftp&#34;&gt;ftp&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;连接&lt;code&gt;ftp ServerIP&lt;/code&gt;，输入用户名和密码&lt;/li&gt;
&lt;li&gt;切换 ftp 所在目录&lt;code&gt;cd DestDir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;切换本地目录&lt;code&gt;lcd DestDir&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;上传文件&lt;code&gt;put FileName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下载文件&lt;code&gt;mget FileName&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;退出&lt;code&gt;exit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;压缩命令-tar&#34;&gt;压缩命令 tar&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;查看压缩文件&lt;code&gt;tar -tvf filename&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mongodb 环境搭建</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_mongodb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_mongodb/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA&#34;&gt;mongodb 环境搭建&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-apt-%E5%AE%89%E8%A3%85&#34;&gt;1 apt 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%91%BD%E4%BB%A4&#34;&gt;2 命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E5%90%AF%E5%8A%A8-mongodb&#34;&gt;2.1 启动 MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81-mongodb&#34;&gt;2.2 查看状态 MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8-mongodb&#34;&gt;2.3 重新启动 MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%E5%81%9C%E6%AD%A2-mongodb&#34;&gt;2.4 停止 MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%8D%B8%E8%BD%BD-mongodb&#34;&gt;3 卸载 MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8&#34;&gt;4 设置开机自启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE&#34;&gt;5 开启远程访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E6%95%85%E9%9A%9C%E9%97%AE%E9%A2%98&#34;&gt;6 故障问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-apt-安装&#34;&gt;1 apt 安装&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4
echo &amp;quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/4.0 multiverse&amp;quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list
sudo apt-get update
sudo apt-get install -y mongodb-org
echo &amp;quot;mongodb-org hold&amp;quot; | sudo dpkg --set-selections
echo &amp;quot;mongodb-org-server hold&amp;quot; | sudo dpkg --set-selections
echo &amp;quot;mongodb-org-shell hold&amp;quot; | sudo dpkg --set-selections
echo &amp;quot;mongodb-org-mongos hold&amp;quot; | sudo dpkg --set-selections
echo &amp;quot;mongodb-org-tools hold&amp;quot; | sudo dpkg --set-selections

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-命令&#34;&gt;2 命令&lt;/h2&gt;

&lt;h3 id=&#34;2-1-启动-mongodb&#34;&gt;2.1 启动 MongoDB&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo service mongod start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-2-查看状态-mongodb&#34;&gt;2.2 查看状态 MongoDB&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo service mongod status
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-重新启动-mongodb&#34;&gt;2.3 重新启动 MongoDB&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo service mongod restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-4-停止-mongodb&#34;&gt;2.4 停止 MongoDB&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo service mongod stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-卸载-mongodb&#34;&gt;3 卸载 MongoDB&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo service mongod stop
sudo apt-get purge mongodb-org*
sudo rm -r /var/log/mongodb
sudo rm -r /var/lib/mongodb
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-设置开机自启动&#34;&gt;4 设置开机自启动&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo systemctl enable mongod
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-开启远程访问&#34;&gt;5 开启远程访问&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vim /etc/mongod.conf
# 把 bindIp:127.0.0.1 修改为 bindIp:0.0.0.0

# 之后重启服务
sudo service mongod restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-故障问题&#34;&gt;6 故障问题&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;遇到连接拒绝问题 &lt;code&gt;Failed to connect to 127.0.0.1:27017, in(checking socket for error after poll), reason: Connection refused&lt;/code&gt;，执行下面命令可解决&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo rm /var/lib/mongodb/mongod.lock
sudo service mongod restart
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>mysql</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_mysql/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_mysql/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ubuntu-%e5%ae%89%e8%a3%85%e5%92%8c%e9%85%8d%e7%bd%ae-mysql&#34;&gt;1 ubuntu 安装和配置 mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-mysql%e5%91%bd%e4%bb%a4&#34;&gt;2 mysql命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-ubuntu-安装和配置-mysql&#34;&gt;1 ubuntu 安装和配置 mysql&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;执行&lt;code&gt;sudo apt-get insall mysql-server mysql-client&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改配置运行远程连接

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注释或删除&lt;code&gt;bind-address           = 127.0.0.1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改数据库的授权&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mysql -uroot -p&lt;/code&gt;输入密码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;use mysql&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flush privileges;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启数据库服务&lt;code&gt;sudo service mysql restart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-mysql命令&#34;&gt;2 mysql命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;导出数据库&lt;code&gt;mysqldump -uroot -p bmi_nvr &amp;gt; bmi_nvr.sql&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导出数据库表&lt;code&gt;mysqldump -uroot -p bmi_nvr sip_info&amp;gt; bmi_nvr_sipinfo.sql&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导入数据表:进入 mysql 命令行后&lt;code&gt;use bmi_nvr;source /home/kiki/bmi_nvr.sql&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;mysql source 防止乱码

&lt;ul&gt;
&lt;li&gt;备份&lt;code&gt;mysqldump -uroot -p --default-character-set=utf8 bmi_nvr &amp;gt; bmi_nvr.sql&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导入&lt;code&gt;mysqldump -uroot -p --default-character-set=utf8 bmi_nvr sip_info&amp;gt; bmi_nvr_sipinfo.sql&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进入 mysql 命令行&lt;code&gt;use bmi_nvr;source /home/kiki/bmi_nvr.sql&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Node.js 环境搭建</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_nodejs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_nodejs/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e7%89%88%e6%9c%ac%e8%a6%81%e6%b1%82&#34;&gt;1 版本要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e6%8f%90%e4%be%9b%e4%bb%a5%e4%b8%8b%e5%9b%9b%e7%a7%8d%e6%96%b9%e5%bc%8f%e5%ae%89%e8%a3%85ps-%e5%bb%ba%e8%ae%ae%e7%ac%ac%e5%9b%9b%e7%a7%8d%e6%96%b9%e5%bc%8f%e5%ae%89%e8%a3%85&#34;&gt;2 提供以下四种方式安装(PS: 建议第四种方式安装)&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e8%b0%83%e7%94%a8%e5%ae%98%e7%bd%91%e8%84%9a%e6%9c%ac%e8%87%aa%e5%8a%a8%e5%ae%89%e8%a3%85&#34;&gt;2.1 调用官网脚本自动安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%e4%bd%bf%e7%94%a8%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%8c%85%e6%96%87%e4%bb%b6&#34;&gt;2.2 使用二进制包文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#221-%e8%ae%be%e7%bd%ae%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84&#34;&gt;2.2.1 设置文件路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#222-%e5%bb%ba%e7%ab%8b%e8%bd%af%e8%bf%9e%e6%8e%a5&#34;&gt;2.2.2 建立软连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-apt-%e5%ae%89%e8%a3%85&#34;&gt;2.3 apt 安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e6%9f%a5%e7%9c%8bnodejs%e7%9a%84%e7%89%88%e6%9c%ac&#34;&gt;3 查看nodejs的版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e6%9f%a5%e7%9c%8bnpm%e7%9a%84%e7%89%88%e6%9c%ac&#34;&gt;4 查看npm的版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-版本要求&#34;&gt;1 版本要求&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;node &amp;gt;= 8.x 目前稳定版本为 10.x&lt;/li&gt;
&lt;li&gt;npm &amp;gt;= 5.x&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-提供以下四种方式安装-ps-建议第四种方式安装&#34;&gt;2 提供以下四种方式安装(PS: 建议第四种方式安装)&lt;/h2&gt;

&lt;h3 id=&#34;2-1-调用官网脚本自动安装&#34;&gt;2.1 调用官网脚本自动安装&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/nodesource/distributions/blob/master/README.md#debinstall&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -
sudo apt-get install -y nodejs
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2-2-使用二进制包文件&#34;&gt;2.2 使用二进制包文件&lt;/h3&gt;

&lt;h4 id=&#34;2-2-1-设置文件路径&#34;&gt;2.2.1 设置文件路径&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 按下载版本修改 VERSION
VERSION=v10.15.1
DISTRO=linux-x64
sudo mkdir -p /usr/local/lib/nodejs
sudo tar -xJvf node-$VERSION-$DISTRO.tar.xz -C /usr/local/lib/nodejs
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-2-2-建立软连接&#34;&gt;2.2.2 建立软连接&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;VERSION=v10.15.1
DISTRO=linux-x64
sudo ln -s /usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin/node /usr/bin/node
sudo ln -s /usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin/npm /usr/bin/npm
sudo ln -s /usr/local/lib/nodejs/node-$VERSION-$DISTRO/bin/npx /usr/bin/npx
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-3-apt-安装&#34;&gt;2.3 apt 安装&lt;/h3&gt;

&lt;p&gt;安装版本较低，需手动更新&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 安装 nodejs
sudo apt install node
# 安装 nodejs 的依赖库管理工具 npm
sudo apt install npm
# 安装 nodejs 版本管理工具 n
sudo npm install n -g
# 升级 nodejs 的版本
sudo n stable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt install node
sudo apt install npm
# 升级 npm
sudo npm install npm@latest -g
# 升级 node
sudo npm install -g n
sudo n stable
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-查看nodejs的版本&#34;&gt;3 查看nodejs的版本&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;node
# 或
node -v
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-查看npm的版本&#34;&gt;4 查看npm的版本&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;npm -v
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>OpenSSL 版本不兼容</title>
      <link>https://xueqing.github.io/blog/ubuntu/openssl_version_mismatch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/openssl_version_mismatch/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# git 命令失败
ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by ssh)
ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by ssh)
OpenSSL version mismatch. Built against 1000207f, you have 1000103f
# ssh 可执行文件链接库
ldd /usr/bin/ssh
/usr/bin/ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by /usr/bin/ssh)
/usr/bin/ssh: /usr/local/lib/libcrypto.so.1.0.0: no version information available (required by /usr/bin/ssh)
        linux-vdso.so.1 =&amp;gt;  (0x00007fff3fdc1000)
        libselinux.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f30e3f81000)
        libcrypto.so.1.0.0 =&amp;gt; /usr/local/lib/libcrypto.so.1.0.0 (0x00007f30e3b96000)# this line is differeent
        libdl.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f30e3992000)
        libz.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f30e3778000)
        libresolv.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f30e355d000)
        libgssapi_krb5.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2 (0x00007f30e3313000)
        libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f30e2f49000)
        libpcre.so.3 =&amp;gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f30e2cd9000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f30e4453000)
        libkrb5.so.3 =&amp;gt; /usr/lib/x86_64-linux-gnu/libkrb5.so.3 (0x00007f30e2a07000)
        libk5crypto.so.3 =&amp;gt; /usr/lib/x86_64-linux-gnu/libk5crypto.so.3 (0x00007f30e27d8000)
        libcom_err.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libcom_err.so.2 (0x00007f30e25d4000)
        libkrb5support.so.0 =&amp;gt; /usr/lib/x86_64-linux-gnu/libkrb5support.so.0 (0x00007f30e23c9000)
        libpthread.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f30e21ac000)
        libkeyutils.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libkeyutils.so.1 (0x00007f30e1fa8000)
# 正常情况下查看 ssh 可执行文件链接库
ldd /usr/bin/ssh
        linux-vdso.so.1 =&amp;gt;  (0x00007fff59ca9000)
        libselinux.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f324fa4d000)
        libcrypto.so.1.0.0 =&amp;gt; /lib/x86_64-linux-gnu/libcrypto.so.1.0.0 (0x00007f324f608000)# this line is differeent
        libdl.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f324f404000)
        libz.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libz.so.1 (0x00007f324f1ea000)
        libresolv.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libresolv.so.2 (0x00007f324efcf000)
        libgssapi_krb5.so.2 =&amp;gt; /usr/lib/x86_64-linux-gnu/libgssapi_krb5.so.2 (0x00007f324ed85000)
        libc.so.6 =&amp;gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f324e9bb000)
        libpcre.so.3 =&amp;gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f324e74b000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f324ff1f000)
        libkrb5.so.3 =&amp;gt; /usr/lib/x86_64-linux-gnu/libkrb5.so.3 (0x00007f324e479000)
        libk5crypto.so.3 =&amp;gt; /usr/lib/x86_64-linux-gnu/libk5crypto.so.3 (0x00007f324e24a000)
        libcom_err.so.2 =&amp;gt; /lib/x86_64-linux-gnu/libcom_err.so.2 (0x00007f324e046000)
        libkrb5support.so.0 =&amp;gt; /usr/lib/x86_64-linux-gnu/libkrb5support.so.0 (0x00007f324de3b000)
        libpthread.so.0 =&amp;gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f324dc1e000)
        libkeyutils.so.1 =&amp;gt; /lib/x86_64-linux-gnu/libkeyutils.so.1 (0x00007f324da1a000)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;原因

&lt;ul&gt;
&lt;li&gt;在 ubuntu 编译了一个 OpenSSL 的源码，并执行了&lt;code&gt;sudo make install&lt;/code&gt;。 Ubuntu 自带的 OpenSSL 版本带有额外的补丁，包含版本信息等，但是标准的 OpenSSL 库(1.1.0 之前)是没有版本信息的。OpenSSH 在运行时链接到源码编译的 OpenSSL 库，没有这些版本信息符号&lt;/li&gt;
&lt;li&gt;OpenSSH 和 OpenSSL 的安装顺序是有一定限制的，可单独升级 OpenSSH，但升级了 OpenSSL 之后，需要重新编译 OpenSSH 或升级，否则不能使用 OpenSSH&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解决方法

&lt;ul&gt;
&lt;li&gt;删除&lt;code&gt;/usr/local/include/openssl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;/usr/local/lib/libcrypto.*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;/usr/local/lib/libssl.*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>RabbitMQ 环境搭建</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_mq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_mq/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%ae%89%e8%a3%85%e4%be%9d%e8%b5%96&#34;&gt;1 安装依赖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e5%ae%89%e8%a3%85-rabbitmq&#34;&gt;2 安装 RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e5%90%af%e7%94%a8-rabbitmq-%e7%ae%a1%e7%90%86%e6%8e%a7%e5%88%b6%e5%8f%b0&#34;&gt;3 启用 RabbitMQ 管理控制台&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%e5%88%9b%e5%bb%ba%e7%94%a8%e6%88%b7%e5%b9%b6%e8%ae%be%e7%bd%ae%e8%a7%92%e8%89%b2&#34;&gt;3.1 创建用户并设置角色&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-rabbitmq-%e6%9c%8d%e5%8a%a1%e5%91%bd%e4%bb%a4&#34;&gt;4 RabbitMQ 服务命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%e4%bf%ae%e6%94%b9%e6%9c%8d%e5%8a%a1%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6&#34;&gt;5 修改服务配置文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-安装依赖&#34;&gt;1 安装依赖&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 添加 erlang 源到 apt 仓库
wget https://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb
sudo dpkg -i erlang-solutions_1.0_all.deb
# 更新安装
sudo apt-get update
sudo apt-get install erlang
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-安装-rabbitmq&#34;&gt;2 安装 RabbitMQ&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 调用官方安装脚本
curl -s https://packagecloud.io/install/repositories/rabbitmq/rabbitmq-server/script.deb.sh | sudo bash
# 添加 RabbitMQ 签名 (会出现 403 错误，可忽略不运行)
wget -O- https://www.rabbitmq.com/rabbitmq-release-signing-key.asc | sudo apt-key add -
# 更新并安装
sudo apt-get update  #（可忽略不运行）
sudo apt-get install rabbitmq-server
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-启用-rabbitmq-管理控制台&#34;&gt;3 启用 RabbitMQ 管理控制台&lt;/h2&gt;

&lt;p&gt;启用管理插件和 STOMP 插件:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo rabbitmq-plugins enable rabbitmq_management rabbitmq_stomp
# 重启服务器
sudo systemctl restart rabbitmq-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;登录 &lt;a href=&#34;http://localhost:15672&#34; target=&#34;_blank&#34;&gt;http://localhost:15672&lt;/a&gt; web管理页面 默认提供 guest 账号(密码：guest)，但是该账号只提供 localhost 登录，所以需要单独创建用户，使用 rabbitmqctl。
用户相关命令如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo rabbitmqctl help | grep user
    add_user &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;  # 创建用户
    delete_user &amp;lt;username&amp;gt;          # 删除用户
    change_password &amp;lt;username&amp;gt; &amp;lt;newpassword&amp;gt;  # 修改密码
    clear_password &amp;lt;username&amp;gt;                 # 清楚密码，直接登录
    authenticate_user &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;   # 测试用户认证（我也不知道2333）
    set_user_tags &amp;lt;username&amp;gt; &amp;lt;tag&amp;gt; ...        # 设置用户权限 []
    list_users
    set_permissions [-p &amp;lt;vhost&amp;gt;] &amp;lt;user&amp;gt; &amp;lt;conf&amp;gt; &amp;lt;write&amp;gt; &amp;lt;read&amp;gt;
    clear_permissions [-p &amp;lt;vhost&amp;gt;] &amp;lt;username&amp;gt;
    list_user_permissions &amp;lt;username&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;3-1-创建用户并设置角色&#34;&gt;3.1 创建用户并设置角色&lt;/h3&gt;

&lt;p&gt;创建管理员用户，负责整个 MQ 的运维：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 添加用户
sudo rabbitmqctl add_user  admin  admin
# 赋予其 administrator 角色
sudo rabbitmqctl set_user_tags admin administrator
# 为用户赋权
sudo rabbitmqctl  set_permissions -p / admin &#39;.*&#39; &#39;.*&#39; &#39;.*&#39;
# 查看权限
sudo rabbitmqctl list_user_permissions admin
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-rabbitmq-服务命令&#34;&gt;4 RabbitMQ 服务命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 启动服务
# sudo service rabbitmq-server start
sudo systemctl start rabbitmq-server
# 停止服务
sudo systemctl stop rabbitmq-server
# 重启服务
sudo systemctl restart rabbitmq-server
# 检查服务状态
sudo systemctl status rabbitmq-server
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-修改服务配置文件&#34;&gt;5 修改服务配置文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 如果需要管理最大连接数，修改配置文件
sudo vim /etc/default/rabbitmq-server
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>redis 环境搭建</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_redis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_redis/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e5%ae%89%e8%a3%85-redis-server&#34;&gt;1 安装 redis-server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e5%91%bd%e4%bb%a4&#34;&gt;2 命令&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#211-%e5%85%b3%e4%ba%8e-key-%e7%9a%84%e5%91%bd%e4%bb%a4&#34;&gt;2.1.1 关于 key 的命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#212-%e5%85%b3%e4%ba%8e-hash-%e7%9a%84%e5%91%bd%e4%bb%a4&#34;&gt;2.1.2 关于 hash 的命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e5%bc%80%e5%90%af%e8%bf%9c%e7%a8%8b%e8%ae%bf%e9%97%ae%e5%b9%b6%e5%8a%a0%e5%af%86%e8%ae%bf%e9%97%ae&#34;&gt;3 开启远程访问并加密访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e5%8f%82%e8%80%83&#34;&gt;4 参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-安装-redis-server&#34;&gt;1 安装 redis-server&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install redis-server
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-命令&#34;&gt;2 命令&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查看 redis 的版本
redis-server -v
# 重启 redis 服务
sudo service redis-server restart
# 进入 redis
redis-cli
auth admin
# 查看 redis 内存，即获取 redis 中所有的 key
keys *
# 退出 redis
exit
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-1-关于-key-的命令&#34;&gt;2.1.1 关于 key 的命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 查找所有符合给定模式 pattern 的 key
keys pattern
# del 命令用于删除已存在的键。不存在的 key 会被忽略
del key_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-1-2-关于-hash-的命令&#34;&gt;2.1.2 关于 hash 的命令&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# hgetall 命令用于返回哈希表中，所有的字段和值
# 在返回值里，紧跟每个字段名(field name)之后是字段的值(value)，所以返回值的长度是哈希表大小的两倍
# 若 key 不存在，返回空列表
hgetall key_name
# hget 命令用于返回哈希表中指定字段的值
# 如果给定的字段或 key 不存在时，返回 nil
hget key_name field_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-开启远程访问并加密访问&#34;&gt;3 开启远程访问并加密访问&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo vim /etc/redis/redis.conf
# 开启远程访问
# 注释掉 bind 127.0.0.1
# 如果有其他 bind 语句也注释

## 配置外网访问需要修改 Linux 防火墙(iptables)，开启 redis 端口
# -A INPUT -m state -state NEW -m tcp -p tcp -dport 6379 -j ACCEPT
# ...
# -A INPUT -j REJECT -reject-with icmp-host-prohibited
# 执行 service iptables restart

# 加密访问
# 打开注释 requirepass xxxxx，并且把密码 xxxx 改为 admin
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;不建议在公网访问 redis，因为 redis 处理速度非常快。所以如果密码简单，外部用户可通过暴力破解密码&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-参考&#34;&gt;4 参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/redis/redis-tutorial.html&#34; target=&#34;_blank&#34;&gt;Redis 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>sed</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_sed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_sed/</guid>
      <description>

&lt;h2 id=&#34;批量替换&#34;&gt;批量替换&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在一个文件中替换字符串

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sed -i &amp;quot;s/original_str/replace_str/g&amp;quot; filename&lt;/code&gt;可查找&lt;code&gt;filename&lt;/code&gt;中的&lt;code&gt;original_str&lt;/code&gt;替换成&lt;code&gt;replace_str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filename&lt;/code&gt;可用通配符&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在一个文件夹中替换字符串

&lt;ul&gt;
&lt;li&gt;批量查找文件夹中的文件&lt;code&gt;grep &amp;quot;original_str&amp;quot; -rl dirname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;批量替换文件&lt;code&gt;sed -i s/original_str/replace_str/g `grep &amp;quot;original_str&amp;quot; -rl dirname`&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遍历当前文件夹所有文件&lt;code&gt;find ./ -type f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;批量替换当前文件夹下所有文件的字符串&lt;code&gt;sed -i s/original_str/replace_str/g `find ./ type f`&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;批量替换文件、文件夹名字

&lt;ul&gt;
&lt;li&gt;查找文件名&lt;code&gt;find ./ -name original_str*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;替换输出&lt;code&gt;find ./ -name original_str* | sed &#39;s/\(.*\)\(original_str\)\(.*\)/mv \1\2\3 \replace_str\3/&#39; | sh&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;文件夹查找文件，将文件名转换为&lt;code&gt;mv orifile newfile&lt;/code&gt;模式，最后应用管道命令&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;查找文件夹&lt;code&gt;find ./ -name original_str* -type d&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;替换输出&lt;code&gt;find ./ -name original_str* -type d | sed &#39;s/\(.*\)\(original_str\)\(.*\)/mv \1\2\3 \replace_str\3/&#39; | sh&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;文件夹查找文件，将文件夹名转换为&lt;code&gt;mv orifile newfile&lt;/code&gt;模式，最后应用管道命令
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;按行删除&#34;&gt;按行删除&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;不加&lt;code&gt;-i&lt;/code&gt;打印删除之后的文本内容，并没有真正删除文件文本内容；加&lt;code&gt;-i&lt;/code&gt;不打印，但是会真正删除对应内容

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sed nd filename&lt;/code&gt;删除第&lt;code&gt;n&lt;/code&gt;行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed n~md filename&lt;/code&gt;从第&lt;code&gt;n&lt;/code&gt;行开始，每隔&lt;code&gt;m-1&lt;/code&gt;行删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed m,nd filename&lt;/code&gt;删除第&lt;code&gt;m&lt;/code&gt;行到第&lt;code&gt;n&lt;/code&gt;行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;m,n&#39;d filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;m,nd&#39; filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;$&#39;d filename&lt;/code&gt;删除最后一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;$d&#39; filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed /pattern/d filename&lt;/code&gt;删除匹配&lt;code&gt;pattern&lt;/code&gt;所在行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;/pattern/d&#39; filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;/pattern/&#39;d filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;/pattern/,+2d&#39; filename&lt;/code&gt;删除匹配&lt;code&gt;pattern&lt;/code&gt;所在行和之后&lt;code&gt;m&lt;/code&gt;行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;/pattern/,+2&#39;d filename&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sed &#39;/^$/d&#39; filename&lt;/code&gt;删除空行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ubuntu 下安装包失败</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_apt_get_install_failure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_apt_get_install_failure/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;错误 1：Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)

&lt;ul&gt;
&lt;li&gt;可能原因：有另外一个程序正在运行，导致资源锁不可用。导致资源被锁的原因，可能是上次安装没正常完成。&lt;/li&gt;
&lt;li&gt;解决方法：执行下面两个命令行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo rm /var/cache/apt/archives/lock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo rm /var/lib/dpkg/lock&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;错误 2：Unable to fetch some archives, maybe run apt-get update or try with &amp;ndash;fix-missing?

&lt;ul&gt;
&lt;li&gt;可能原因：未更新源&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;System Settings&lt;/code&gt; -&amp;gt; &lt;code&gt;Software &amp;amp; Updates&lt;/code&gt; -&amp;gt; &lt;code&gt;Download from&lt;/code&gt;: 选择 China 中，比如 &lt;code&gt;mirrors.aliyun.com&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 下的实用工具</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_tool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_tool/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tree&lt;/code&gt; 以树状图逐级列出目录的内容命令

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 只列举目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-L level&lt;/code&gt; 设置目录树最大的显示深度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o filename&lt;/code&gt; 将结果输出到 filename&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ubuntu 安装 phpmyadmin</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_phpmyadmin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_phpmyadmin/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;执行&lt;code&gt;sudo apt-get install phpmyadmin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;建立软链接&lt;code&gt;sudo ln -s /usr/share/phpmyadmin /var/www/html/phpmyadmin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在浏览器打开网址&lt;code&gt;localhost/phpmyadmin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;一些错误&#34;&gt;一些错误&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;打开网页错误&lt;code&gt;the mbstring extension is missing. please check your php configuration&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;安装包&lt;code&gt;sudo apt-get install php-mbstring php-gettext&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重启 Apache 服务&lt;code&gt;sudo service apache2 restart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 安装 wireshark</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_wireshark/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_wireshark/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;命令行安装 &lt;code&gt;sudo apt-get install wireshark&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置非 root 访问

&lt;ul&gt;
&lt;li&gt;添加 wireshark 用户组 &lt;code&gt;sudo groupadd wireshark&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将 dumpcap 更改为 wireshark 用户组 &lt;code&gt;sudo chgrp wireshark /usr/bin/dumpcap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;让 wireshark 用户组有 root 权限使用 dumpcap &lt;code&gt;sudo chmod 4755 /usr/bin/dumpcap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将普通用户加入 wireshark 用户组 &lt;code&gt;sudo gpasswd -a kiki wireshark&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 新手配置</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_rookie/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_rookie/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%e7%8e%af%e5%a2%83&#34;&gt;1 环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%e9%85%8d%e7%bd%ae%e9%9d%99%e6%80%81-ip&#34;&gt;2 配置静态 ip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%e9%85%8d%e7%bd%ae%e8%be%93%e5%85%a5%e6%b3%95%e5%92%8c%e5%ad%97%e4%bd%93&#34;&gt;3 配置输入法和字体&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ad%e6%96%87%e7%95%8c%e9%9d%a2&#34;&gt;中文界面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%85%8d%e7%bd%ae%e6%90%9c%e7%8b%97%e8%be%93%e5%85%a5%e6%b3%95&#34;&gt;配置搜狗输入法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%85%8d%e7%bd%ae-consolas-%e9%9b%85%e9%bb%91%e5%ad%97%e4%bd%93&#34;&gt;配置 Consolas 雅黑字体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%e5%ae%89%e8%a3%85%e4%b8%8e%e9%85%8d%e7%bd%ae-git&#34;&gt;4 安装与配置 Git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%e5%ae%89%e8%a3%85-qt&#34;&gt;5 安装 Qt&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#qt571&#34;&gt;Qt5.7.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#qt541&#34;&gt;Qt5.4.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%e5%91%bd%e4%bb%a4%e8%a1%8c%e5%ae%89%e8%a3%85%e5%b7%a5%e5%85%b7%e5%8c%85&#34;&gt;6 命令行安装工具包&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#supervisor&#34;&gt;supervisor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vscode&#34;&gt;VSCode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chrome-%e6%b5%8f%e8%a7%88%e5%99%a8&#34;&gt;Chrome 浏览器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#teamviewer&#34;&gt;TeamViewer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%89%e9%81%93%e8%af%8d%e5%85%b8&#34;&gt;有道词典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%88%aa%e5%9b%be%e5%b7%a5%e5%85%b7-shutter&#34;&gt;截图工具 Shutter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-环境&#34;&gt;1 环境&lt;/h2&gt;

&lt;p&gt;默认 Ubuntu 16.04&lt;/p&gt;

&lt;h2 id=&#34;2-配置静态-ip&#34;&gt;2 配置静态 ip&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;IP地址      192.168.1.81&lt;/li&gt;
&lt;li&gt;子网掩码    255.255.0.0&lt;/li&gt;
&lt;li&gt;DNS 与网关  192.168.1.1&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-配置输入法和字体&#34;&gt;3 配置输入法和字体&lt;/h2&gt;

&lt;h3 id=&#34;中文界面&#34;&gt;中文界面&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;系统输入-语言支持-添加删除语言-选择 Chinese&lt;/li&gt;
&lt;li&gt;将汉语中国拖动到第一栏&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置搜狗输入法&#34;&gt;配置搜狗输入法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 从 Sogou 官网下载 deb 安装包
sudo dpkg -i sougou-packet.deb
sudo apt-get install -f
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;系统输入-语言支持-键盘输入法系统选择 fctix&lt;/li&gt;
&lt;li&gt;系统输入-文本输入-添加输入源-选择 sougo 输入法。&lt;/li&gt;
&lt;li&gt;系统输入-文本输入-切换到下一个源改为 Super+空格（Ctrl+空格 与 Qt 提示冲突）&lt;/li&gt;
&lt;li&gt;重启&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;配置-consolas-雅黑字体&#34;&gt;配置 Consolas 雅黑字体&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd temp
wget http://www.mycode.net.cn/wp-content/uploads/2015/07/YaHeiConsolas.tar.gz
tar -zxvf YaHeiConsolas.tar.gz
sudo mkdir -p /usr/share/fonts/vista
sudo cp YaHeiConsolas.ttf /usr/share/fonts/vista/
sudo chmod 644 /usr/share/fonts/vista/*.ttf
cd /usr/share/fonts/vista/
sudo mkfontscale &amp;amp;&amp;amp; sudo mkfontdir &amp;amp;&amp;amp; sudo fc-cache -fv
sudo apt-get install unity-tweak-tool
reboot
# 终端中输入配置字体
unity-tweak-tool
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-安装与配置-git&#34;&gt;4 安装与配置 Git&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install git
sudo apt-get install gitk
# 创建私钥与公钥，并把公钥放到gitlab上
cd ~/.ssh
ssh-keygen 或者 ssh-keygen -t rsa -C &amp;quot;kiki@ubuntu.com&amp;quot;
# 配置全局姓名与邮箱
git config --global user.name kiki
git config --global user.email kiki@ubuntu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-安装-qt&#34;&gt;5 安装 Qt&lt;/h2&gt;

&lt;h3 id=&#34;qt5-7-1&#34;&gt;Qt5.7.1&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要解决 Qt 中不能输入中文的 BUG&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install fcitx-frontend-qt5
cd usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/
cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.7.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts
cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.7.1/5.7/gcc_64/plugins/platforminputcontexts
# 重启 Qt_Creator
# 双版本需要添加快捷方式
cd ~/.local/share/applications
touch DigiaQt-qtcreator-community-5.7.1.desktop
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输入以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;[Desktop Entry]
Type=Application
Exec=/local_path/Qt5.4.1/Tools/QtCreator/bin/qtcreator
Name=QtCreator5.4.1 (Community)
GenericName=The IDE of choice for Qt development.
Icon=QtProject-qtcreator
Terminal=false
Categories=Development;IDE;Qt;
MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.qt.qmakeprofile;application/vnd.qt.xml.resource;text/x-qml;text/x-qt.qml;text/x-qt.qbs;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;qt5-4-1&#34;&gt;Qt5.4.1&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要解决 Qt 中不能输入中文的 BUG&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install fcitx-frontend-qt5
cd usr/lib/x86_64-linux-gnu/qt5/plugins/platforminputcontexts/
cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.4.1/Tools/QtCreator/lib/Qt/plugins/platforminputcontexts
cp -rp libfcitxplatforminputcontextplugin.so ~/Software/Qt5.4.1/5.7/gcc_64/plugins/platforminputcontexts
# 重启Qt_Creator
# 双版本需要添加快捷方式
cd ~/.local/share/applications
touch DigiaQt-qtcreator-community-5.4.1.desktop
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;输入以下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;[Desktop Entry]
Type=Application
Exec=/local_path/Qt5.4.1/Tools/QtCreator/bin/qtcreator
Name=QtCreator5.4.1 (Community)
GenericName=The IDE of choice for Qt development.
Icon=QtProject-qtcreator
Terminal=false
Categories=Development;IDE;Qt;
MimeType=text/x-c++src;text/x-c++hdr;text/x-xsrc;application/x-designer;application/vnd.qt.qmakeprofile;application/vnd.qt.xml.resource;text/x-qml;text/x-qt.qml;text/x-qt.qbs;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-命令行安装工具包&#34;&gt;6 命令行安装工具包&lt;/h2&gt;

&lt;h3 id=&#34;supervisor&#34;&gt;supervisor&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd ~/temp/
git clone git@192.168.1.36:ylrc/Supervisor.git
cd Supervisor
sudo dpkg -i python-meld3_1.0.2-2_all.deb supervisor_3.2.0-2_all.deb
supervisorctl -v
sudo service supervisor start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;vscode&#34;&gt;VSCode&lt;/h3&gt;

&lt;p&gt;到&lt;code&gt;https://code.visualstudio.com/docs/?dv=linux64_deb&lt;/code&gt;下载
使用 &lt;code&gt;sudo dpkg -i target.deb&lt;/code&gt; 安装
有错误的话使用 &lt;code&gt;sudo apt-get install -f&lt;/code&gt; 修复
修改首选项中 VSCode 的配置文件,配置字体 Consolas&lt;/p&gt;

&lt;h3 id=&#34;chrome-浏览器&#34;&gt;Chrome 浏览器&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
sudo dpkg -i google-chrome-stable_current_amd64.deb
sudo apt-get install -f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;teamviewer&#34;&gt;TeamViewer&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# https://www.teamviewer.com/zhcn/download/linux/ 下载
sudo dpkg -i teamviewerTarget.deb
sudo apt-get install -f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;有道词典&#34;&gt;有道词典&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 有道官方下载ubuntu安装包
sudo apt update
sudo apt upgrade
sudo dpkg -i youdao.deb
sudo apt install -f
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;截图工具-shutter&#34;&gt;截图工具 Shutter&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install shutter
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;设置快捷键：系统设置-&amp;gt;键盘-&amp;gt;窗口-&amp;gt;自定义快捷键: commond 输入 &lt;code&gt;shutter -s&lt;/code&gt;, 然后在右侧点击输入想要设置的快捷键&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>ubuntu 查看磁盘空间</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_disk/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_disk/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;code&gt;df -hl&lt;/code&gt;显示目前所有文件系统的可用空间及使用情形

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-h&lt;/code&gt;表示使用&lt;code&gt;human readable&lt;/code&gt;的输出，即使用 GB，MB 等易读的格式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Filesystem&lt;/code&gt;表示文件系统&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mounted on&lt;/code&gt;表示挂载点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Size&lt;/code&gt;&lt;code&gt;Used&lt;/code&gt;&lt;code&gt;Avail&lt;/code&gt;&lt;code&gt;Use&lt;/code&gt;分别表示分割区的容量、已使用的大小、剩下的大小及使用的百分比&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;du -sh *&lt;/code&gt;显示当前目录下各个文件及目录占用空间大小

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;du&lt;/code&gt;查询文件或文件夹的磁盘使用空间，可以添加&lt;code&gt;--max-depth=&lt;/code&gt;限制目录深度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ubuntu 的日志文件</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_syslog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_syslog/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;日志文件存在&lt;code&gt;/var/log&lt;/code&gt;即其子目录

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;message&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auth.log&lt;/code&gt;: 鉴权日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kern.log&lt;/code&gt;: 内核日志&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mysql/&lt;/code&gt;: mysql 数据库服务日志文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utmp&lt;/code&gt;或&lt;code&gt;wtmp&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;查看日志文件的命令

&lt;ul&gt;
&lt;li&gt;less:&lt;code&gt;less /var/log/messages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;more:&lt;code&gt;more -f /var/log/messages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cat:&lt;code&gt;cat /var/log/messages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;grep:&lt;code&gt;grep -i error /var/log/message&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tail:&lt;code&gt;tail -f /var/log/messages&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;zcat&lt;/li&gt;
&lt;li&gt;zgrep&lt;/li&gt;
&lt;li&gt;zmore&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;上面的日志都有使用 rsyslogd 服务生成的。这是一个系统工具。

&lt;ul&gt;
&lt;li&gt;配置文件在&lt;code&gt;vim /etc/rsyslog.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;日志目录&lt;code&gt;ls /etc/rsyslog.d/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>update-alternatives</title>
      <link>https://xueqing.github.io/blog/ubuntu/update_alternatives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/update_alternatives/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;update-alternatives&lt;/code&gt;命令用于增加、删除、维护和显示&lt;code&gt;/etc/alternatives&lt;/code&gt;下的软链接，用于切换相同或相似功能的应用程序（如浏览器、编辑器等）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;generic name&lt;/code&gt;一系列功能相似的程序的公用名字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alternative&lt;/code&gt;一个可选的程序所在的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;link&lt;/code&gt;一个&lt;code&gt;alternative&lt;/code&gt;在&lt;code&gt;/etc/alternatives&lt;/code&gt;中的名字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;priority&lt;/code&gt;一个&lt;code&gt;alternative&lt;/code&gt;的优先级，优先级越高，数字越大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ls -l /etc/alternatives&lt;/code&gt;可以看到所有的软链接&lt;/li&gt;
&lt;li&gt;显示所有可选命令：&lt;code&gt;update-alternatives --display editor&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选择配置命令程序：&lt;code&gt;update-alternatives --config editor&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;不使用交互模式：&lt;code&gt;update-alternatives --set editor path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安装命令程序：&lt;code&gt;update-alternatives --install link generic_name path priority&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;删除命令程序：&lt;code&gt;update-alternatives --remove name path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;以-ubuntu14-04-配置-java1-8-为例&#34;&gt;以 Ubuntu14.04 配置 java1.8 为例&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;安装 java1.6 和 java1.7 可以直接用&lt;code&gt;sudo apt-get install openjdk-6-gre(openjdk-7-gre)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;访问 oracle 官网下载 jdk&lt;/li&gt;
&lt;li&gt;解压下载的 tar.gz 压缩包&lt;/li&gt;
&lt;li&gt;执行命令安装：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir -p /usr/lib/jvm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo cp -a jdk1.8.0_162/ /usr/lib/jvm/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo ln -s /usr/lib/jvm/jdk1.8.0_162/ /usr/lib/jvm/java-8&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设置环境变量：

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vi ~/.bashrc&lt;/code&gt;在文件最后加入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export JAVA_HOME=/usr/lib/jvm/java-8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export JRE_HOME=${JAVA_HOME}/jre&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export PATH=${JAVA_HOME}/bin:$PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;配置默认 jdk 版本

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8/bin/java 300&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8/bin/javac 300&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo update-alternatives --config java&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo update-alternatives --config javac&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;测试验证&lt;code&gt;java -version&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-gcc-4-8-g-4-8-gcc-5-4-g-5-以及多版本切换&#34;&gt;安装 gcc-4.8、g++-4.8、gcc-5.4、g++-5 以及多版本切换&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install gcc-4.8 gcc-4.8-multilib g++-4.8 g++-4.8-multilib
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 50
sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5.4 40
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 50
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 40
#切换版本
sudo update-alternatives --config gcc
#删除切换版本的选项
sudo update-alternatives --remove gcc /usr/bin/gcc-4.5
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>wget 命令</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_wget/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_wget/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://man.linuxde.net/wget&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;wget 用来从指定的 URL 下载文件&lt;/li&gt;
&lt;li&gt;wget 非常稳定，在网络原因下载失败时会不断重试知道下载完毕；如果是服务器影响下载，会再次连到服务器从断掉的地方继续下载&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wget URL&lt;/code&gt;下载单个文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wget -O filename URL&lt;/code&gt;下载并保存成不同的文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wget -c URL&lt;/code&gt;使用断点续传&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>修改 hosts 文件</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_hosts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_hosts/</guid>
      <description>

&lt;h2 id=&#34;ubuntu&#34;&gt;ubuntu&lt;/h2&gt;

&lt;p&gt;公司内部添加了域名服务器，每次将域名改成 IP 地址很麻烦，所以修改本地 hosts 可以直接重定向
&lt;code&gt;sudo vim /etc/hosts&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;windows&#34;&gt;windows&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;搜索程序“记事本”，用管理员身份打开&lt;/li&gt;
&lt;li&gt;在记事本中打开文件，路径是&lt;code&gt;C:\Windows\System32\drivers\etc&lt;/code&gt;，选择&lt;code&gt;所有文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可以看到&lt;code&gt;hosts&lt;/code&gt;文件，选中打开进行修改，保存就可以了&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>命令行创建文件</title>
      <link>https://xueqing.github.io/blog/ubuntu/shell_new_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/shell_new_file/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#cat&#34;&gt;cat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#touch&#34;&gt;touch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e5%87%86%e9%87%8d%e5%ae%9a%e5%90%91%e7%ac%a6%e5%8f%b7&#34;&gt;标准重定向符号 &amp;gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#echoprintf&#34;&gt;echo/printf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nano&#34;&gt;nano&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vivim&#34;&gt;vi/vim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;cat&#34;&gt;cat&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 可用于创建文件。输入回车后，光标移到到下一行，可以开始输入文本。完成之后使用 Ctrl+D 退出，并返回到提示符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat &amp;gt; file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;cat&lt;/code&gt; 也可以查看文件内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cat file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;touch&#34;&gt;touch&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;touch&lt;/code&gt; 支持一条命令创建多个文件，且不支持立刻输入文本。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;touch file1 file2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;标准重定向符号&#34;&gt;标准重定向符号 &amp;gt;&lt;/h2&gt;

&lt;p&gt;标准重定向符号通常用于重定向一个命令的输出到一个新文件。如果没有前置的命令，命令只创建一个新文件。类似于 &lt;code&gt;touch&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;与 &lt;code&gt;touch&lt;/code&gt; 不同，&lt;code&gt;&amp;gt;&lt;/code&gt; 只能一次创建一个文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;&amp;gt; file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;echo-printf&#34;&gt;echo/printf&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;echo/printf&lt;/code&gt; 命令输入文本到指定文件，文件不存在则会被创建。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;echo &#39;hello&#39; &amp;gt; file1
printf &amp;quot;world\nI&#39;m kiki&amp;quot; &amp;gt; file2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;nano&#34;&gt;nano&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;nano&lt;/code&gt; 是 GNU 项目的文本编辑器。输入回车之后可以开始输入文本。按照命令提示退出编辑界面。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;nano file_name
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vi-vim&#34;&gt;vi/vim&lt;/h2&gt;

&lt;p&gt;使用 &lt;code&gt;vi/vim&lt;/code&gt; 文本编辑器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;vi file_name
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>安装 Linuxbrew</title>
      <link>https://xueqing.github.io/blog/ubuntu/ubuntu_brew/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/ubuntu_brew/</guid>
      <description>&lt;p&gt;参考 &lt;a href=&#34;https://docs.brew.sh/Homebrew-on-Linux#install&#34; target=&#34;_blank&#34;&gt;Linuxbrew&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sh -c &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Linuxbrew/install/master/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装脚本将 Homebrew 安装到 &lt;code&gt;/home/linuxbrew/.linuxbrew&lt;/code&gt;(sudo) 或者 &lt;code&gt;~/.linuxbrew&lt;/code&gt;。安装之后不需要 &lt;code&gt;sudo&lt;/code&gt; 使用 Homebrew。使用 &lt;code&gt;/home/linuxbrew/.linuxbrew&lt;/code&gt; 弄马壮加密和搭配和人的主目录支持使用更多二进制包。&lt;/p&gt;

&lt;p&gt;遵循下面的步骤指导增加 Homebrew 到 &lt;code&gt;PATH&lt;/code&gt; 和 bash shell 配置脚本，即 Debian/Ubuntu 下是 &lt;code&gt;~/.profile&lt;/code&gt;， CentOS/Fedora/RedHat 下是 &lt;code&gt;~/bash_profile&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;test -d ~/.linuxbrew &amp;amp;&amp;amp; eval $(~/.linuxbrew/bin/brew shellenv)
test -d /home/linuxbrew/.linuxbrew &amp;amp;&amp;amp; eval $(/home/linuxbrew/.linuxbrew/bin/brew shellenv)
test -r ~/.bash_profile &amp;amp;&amp;amp; echo &amp;quot;eval \$($(brew --prefix)/bin/brew shellenv)&amp;quot; &amp;gt;&amp;gt;~/.bash_profile
echo &amp;quot;eval \$($(brew --prefix)/bin/brew shellenv)&amp;quot; &amp;gt;&amp;gt;~/.profile
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面尝试安装一个包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;brew install hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>安装和配置 Apache 服务</title>
      <link>https://xueqing.github.io/blog/ubuntu/apache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/apache/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85-apache&#34;&gt;安装 Apache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9b%e5%bb%ba%e8%87%aa%e5%b7%b1%e7%9a%84%e7%bd%91%e7%ab%99&#34;&gt;创建自己的网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%ae%be%e7%bd%ae-virtualhost-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6&#34;&gt;设置 VirtualHost 配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%bf%80%e6%b4%bb-virtualhost-%e6%96%87%e4%bb%b6&#34;&gt;激活 VirtualHost 文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96-virtualhost-%e4%be%8b%e5%ad%90&#34;&gt;其他 VirtualHost 例子&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8%e4%b8%80%e4%b8%aa-ip-%e5%9c%b0%e5%9d%80%e4%b8%8a%e8%bf%90%e8%a1%8c%e5%a4%9a%e4%b8%aa%e4%b8%8d%e5%90%8c%e4%b8%bb%e6%9c%ba%e5%90%8d%e7%9a%84%e7%bd%91%e7%ab%99&#34;&gt;在一个 IP 地址上运行多个不同主机名的网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9c%a8%e4%b8%8d%e5%90%8c%e7%ab%af%e5%8f%a3%e4%b8%8a%e8%bf%90%e8%a1%8c%e4%b8%8d%e5%90%8c%e7%bd%91%e7%ab%99&#34;&gt;在不同端口上运行不同网站&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装-apache&#34;&gt;安装 Apache&lt;/h2&gt;

&lt;p&gt;环境：ubuntu 16.04&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo apt-get install update
# 安装
sudo apt-get install apache2
# 可在浏览器输入本机 ip，看到 Apache2 的欢迎页面说明服务正常
# 修改显示内容：修改 `/var/www/html` 文件夹
# 或修改配置文件，修改 /var/www/html 为 html 文件所在目录
vim /etc/apache2/sites-enabled/000-default.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建自己的网站&#34;&gt;创建自己的网站&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 新建文件夹
sudo mkdir /var/www/mysite &amp;amp;&amp;amp; cd /var/www/mysite
# 创建 html 文件
vim index.html
# 在浏览器输入本机 ip，看到新的内容
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;设置-virtualhost-配置文件&#34;&gt;设置 VirtualHost 配置文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;# 切换到配置文件目录，创建配置文件
cd /etc/apache2/sites-available &amp;amp;&amp;amp; sudo cp 000-default.conf mysite.conf
# 修改配置文件，修改 ServerAdmin 为自己的邮箱
# 修改 DocumentRoot 为 /var/www/mysite，
# 修改 ServerName 为 mysite.example.com
sudo vim mysite.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;激活-virtualhost-文件&#34;&gt;激活 VirtualHost 文件&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /etc/apache2/sites-available &amp;amp;&amp;amp; sudo a2ensite mysite.conf
# 重新加载网页
sudo service apache2 reload
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其他-virtualhost-例子&#34;&gt;其他 VirtualHost 例子&lt;/h2&gt;

&lt;h3 id=&#34;在一个-ip-地址上运行多个不同主机名的网站&#34;&gt;在一个 IP 地址上运行多个不同主机名的网站&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;# Ensure that Apache listens on port 80
Listen 80
&amp;lt;VirtualHost *:80&amp;gt;
    DocumentRoot &amp;quot;/www/example1&amp;quot;
    ServerName www.example.com

    # Other directives here
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost *:80&amp;gt;
    DocumentRoot &amp;quot;/www/example2&amp;quot;
    ServerName www.example.org

    # Other directives here
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;在不同端口上运行不同网站&#34;&gt;在不同端口上运行不同网站&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-conf&#34;&gt;Listen 80
Listen 8080

&amp;lt;VirtualHost 172.20.30.40:80&amp;gt;
    ServerName www.example.com
    DocumentRoot &amp;quot;/www/domain-80&amp;quot;
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost 172.20.30.40:8080&amp;gt;
    ServerName www.example.com
    DocumentRoot &amp;quot;/www/domain-8080&amp;quot;
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost 172.20.30.40:80&amp;gt;
    ServerName www.example.org
    DocumentRoot &amp;quot;/www/otherdomain-80&amp;quot;
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost 172.20.30.40:8080&amp;gt;
    ServerName www.example.org
    DocumentRoot &amp;quot;/www/otherdomain-8080&amp;quot;
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tutorials.ubuntu.com/tutorial/install-and-configure-apache#0&#34; target=&#34;_blank&#34;&gt;Install and Configure Apache&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://httpd.apache.org/docs/2.4/vhosts/examples.html&#34; target=&#34;_blank&#34;&gt;VirtualHost Examples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>正则表达式</title>
      <link>https://xueqing.github.io/blog/ubuntu/regular_expression/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/ubuntu/regular_expression/</guid>
      <description>

&lt;h2 id=&#34;分组&#34;&gt;分组&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;加&lt;code&gt;()&lt;/code&gt;，即小括号，表示分组：例如&lt;code&gt;m_([a|b|c])&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个分组有一个组号：从左向右，以分组的左括号为标识，第一个出现的分组的组号是 1，第二个是 2，以此类推&lt;/li&gt;
&lt;li&gt;后向引用：用于重复搜索前面某个分组匹配的文本：例如，&lt;code&gt;\1&lt;/code&gt;代表分组 1 匹配的文本&lt;/li&gt;
&lt;li&gt;可以自己指定子表达式的组名：&lt;code&gt;m_(?&amp;lt;Word&amp;gt;[a|b|c])&lt;/code&gt;，或者&lt;code&gt;m_(?&#39;Word&#39;[a|b|c])&lt;/code&gt;，可以把&lt;code&gt;[a|b|c]&lt;/code&gt;的组名指定为&lt;code&gt;Word&lt;/code&gt;，后面可以使用&lt;code&gt;\k&amp;lt;Word&amp;gt;&lt;/code&gt;来反向引用该分组捕获的内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;匹配符&#34;&gt;匹配符&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;匹配开始符&lt;code&gt;^&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配结束符&lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
