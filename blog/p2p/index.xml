<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>P2P | kiki</title>
    <link>https://xueqing.github.io/blog/p2p/</link>
      <atom:link href="https://xueqing.github.io/blog/p2p/index.xml" rel="self" type="application/rss+xml" />
    <description>P2P</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language>
    <image>
      <url>https://xueqing.github.io/img/icon-192.png</url>
      <title>P2P</title>
      <link>https://xueqing.github.io/blog/p2p/</link>
    </image>
    
    <item>
      <title>BitTorrent 协议</title>
      <link>https://xueqing.github.io/blog/p2p/bittorrent%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/p2p/bittorrent%E5%8D%8F%E8%AE%AE/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.bittorrent.org/beps/bep_0005.html&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ba%a6%e5%ae%9a&#34;&gt;约定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%87%8d%e8%a6%81%e6%a6%82%e5%bf%b5&#34;&gt;重要概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bittorrent-dht-%e5%8d%8f%e8%ae%ae&#34;&gt;BitTorrent DHT 协议&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b7%af%e7%94%b1%e8%a1%a8&#34;&gt;路由表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bittorrent-%e5%8d%8f%e8%ae%ae%e6%89%a9%e5%b1%95&#34;&gt;BitTorrent 协议扩展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a7%8d%e5%ad%90%e6%96%87%e4%bb%b6%e6%89%a9%e5%b1%95&#34;&gt;种子文件扩展&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#krpc-%e5%8d%8f%e8%ae%ae&#34;&gt;KRPC 协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dht-%e6%9f%a5%e8%af%a2&#34;&gt;DHT 查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bittorrent-dht-%e5%87%a0%e4%b8%aa%e9%87%8d%e8%a6%81%e8%bf%87%e7%a8%8b&#34;&gt;Bittorrent DHT 几个重要过程&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a7%8d%e5%ad%90%e5%88%b6%e4%bd%9c&#34;&gt;种子制作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b&#34;&gt;启动过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%b7%e6%96%b0%e8%b7%af%e7%94%b1%e8%a1%a8&#34;&gt;刷新路由表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;约定&#34;&gt;约定&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;peers vs 客户端（client）：

&lt;ul&gt;
&lt;li&gt;一个 peer 可以是任何参与下载的 BitTorrent 客户端&lt;/li&gt;
&lt;li&gt;客户端也是一个 peer&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;片（piece） vs 块（block）：

&lt;ul&gt;
&lt;li&gt;片指在元信息文件中描述的一部分已下载的数据，可通过 sha-1 hash 验证&lt;/li&gt;
&lt;li&gt;块是客户端向 peer 请求的一部分数据。两块或更多块可以组成一个完整的可被验证的片&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;B 编码（Bencoding）：B 编码是一种以简洁的格式描述和组织数据的方法，支持字节串、整数、lists 和 dictionaries

&lt;ul&gt;
&lt;li&gt;字节串：&lt;/li&gt;
&lt;li&gt;字节串没有开始和结束分隔符&lt;/li&gt;
&lt;li&gt;编码方式&lt;code&gt;&amp;lt;以十进制 ASCII 编码的串长度&amp;gt;:&amp;lt;串数据&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如：&lt;code&gt;4:spam&lt;/code&gt;表示字节串&amp;rdquo;spam&amp;rdquo;&lt;/li&gt;
&lt;li&gt;整数：&lt;/li&gt;
&lt;li&gt;编码方式&lt;code&gt;i&amp;lt;以十进制 ASCII 编码的整数&amp;gt;e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt;和&lt;code&gt;e&lt;/code&gt;分别是开始和结束分隔符&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;i0e&lt;/code&gt;，&lt;code&gt;i-1e&lt;/code&gt;；&lt;code&gt;i01e&lt;/code&gt;是无效的&lt;/li&gt;
&lt;li&gt;lists：&lt;/li&gt;
&lt;li&gt;编码方式&lt;code&gt;l&amp;lt;B 编码值&amp;gt;e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l&lt;/code&gt;是小写的&lt;code&gt;L&lt;/code&gt;，是开始分隔符；&lt;code&gt;e&lt;/code&gt;是结束分隔符&lt;/li&gt;
&lt;li&gt;lists 可以包含任何 B 编码的类型，包括整数、串、dictionaries 和其他的 lists&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;l4:spam4:eggse&lt;/code&gt;表示含义两个串的 lists：[&amp;ldquo;spam&amp;rdquo;, &amp;ldquo;eggs&amp;rdquo;]&lt;/li&gt;
&lt;li&gt;dictionaries：&lt;/li&gt;
&lt;li&gt;编码方式&lt;code&gt;d&amp;lt;B 编码串&amp;gt;&amp;lt;B 编码元素&amp;gt;e&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt;和&lt;code&gt;e&lt;/code&gt;分别是开始和结束分隔符&lt;/li&gt;
&lt;li&gt;键 key 必须被 B 编码为串

&lt;ul&gt;
&lt;li&gt;串必须以排序的方式出现（以原始串排序，而不是字母数字顺序）&lt;/li&gt;
&lt;li&gt;串采用二进制比较方式，而不是特定于某种文化的自然比较（不是中文或英文的排序方式）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;值 value 可以是任何 B 编码的类型，包括整数、串、lists 和其他的 dictionaries&lt;/li&gt;
&lt;li&gt;如 &lt;code&gt;d3:cow3:moo4:spam4:eggse&lt;/code&gt;表示 dictionaries {&amp;ldquo;cow&amp;rdquo;=&amp;gt;&amp;ldquo;moo&amp;rdquo;, &amp;ldquo;spam&amp;rdquo;=&amp;gt;&amp;ldquo;eggs&amp;rdquo;}&lt;/li&gt;
&lt;li&gt;如 &lt;code&gt;d4:spaml1:a1:bee&lt;/code&gt;表示 dictionaries {&amp;ldquo;spam&amp;rdquo;=&amp;gt;[&amp;ldquo;a&amp;rdquo;, &amp;ldquo;b&amp;rdquo;]}&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;重要概念&#34;&gt;重要概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;元信息文件结构（Metainfo file structure）：所有数据以 B 编码方式编码&lt;/li&gt;
&lt;li&gt;元信息文件：一个 B 编码的 dictionary

&lt;ul&gt;
&lt;li&gt;元信息文件包含的键 key 如下，其中字符串类型的值均以 UTF-8 编码&lt;/li&gt;
&lt;li&gt;info：dictionary 类型，，值描述了种子文件。该 dictionary 可能是

&lt;ul&gt;
&lt;li&gt;没有目录结构的单文件，即种子文件只包含一个文件&lt;/li&gt;
&lt;li&gt;有目录文件的多文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;announce：string 类型，值是 tracker 的 announce URL&lt;/li&gt;
&lt;li&gt;announce-list： [lists/string] 类型，可选，对正式规范的一个扩展，提供向后兼容性&lt;/li&gt;
&lt;li&gt;creation date：整数类型，是 unix 时间戳，可选，值是种子文件的创建时间&lt;/li&gt;
&lt;li&gt;comment：string 类型，可选，值是种子文件制作者的评论&lt;/li&gt;
&lt;li&gt;create by：string 类型，可选，值是只做种子文件的程序的名称和版本&lt;/li&gt;
&lt;li&gt;encoding：string 类型，可选，用于生成分片（当info dictionary 过大时，需要对其分片）&lt;/li&gt;
&lt;li&gt;元信息文件包含的值 value&lt;/li&gt;
&lt;li&gt;info dictionary，即 info 对应的值，其单文件和多文件模式公共的键 可以 如下：

&lt;ul&gt;
&lt;li&gt;piece length：整数类型，值是每个 piece 的字节数&lt;/li&gt;
&lt;li&gt;一般是 2 的整数次方，根据种子文件数据的总大小来选择 piece 的大小&lt;/li&gt;
&lt;li&gt;piece 过小使得种子文件过大，piece 过大则降低下载效率&lt;/li&gt;
&lt;li&gt;以前的 piece 大小是种子文件不超过 50-75KB，目前保持为 256KB，512KB 或 1MB&lt;/li&gt;
&lt;li&gt;除了最后一块，其他块大小相同，piece 的数量取决于  total_length/piece_size&lt;/li&gt;
&lt;li&gt;多文件模式的 piece 可能跨越文件边界&lt;/li&gt;
&lt;li&gt;pieces：string 类型，值由每个 piece的 20 字节 sha1 散列值连接而成，每个 piece 包含一个唯一的 sha1 散列值&lt;/li&gt;
&lt;li&gt;private：整数类型，可选，值 为 0 或者 1，可不设置，表示是否有外部的 peer 源&lt;/li&gt;
&lt;li&gt;值为 1：客户端必须广播自己的存在，通过元信息文件中显式描述的 trackers 得到其他的 peers&lt;/li&gt;
&lt;li&gt;不设置或值为 0：客户端可以通过其他方式得到其他的 peers&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;单文件模式（Single file mode）的 info dictionary 包含的键：

&lt;ul&gt;
&lt;li&gt;name：string 类型，文件名，建议使用&lt;/li&gt;
&lt;li&gt;length：整数类型，文件所占字节数&lt;/li&gt;
&lt;li&gt;md5sum：string 类型，可选，相当于文件 MD5 和的 32 个字符的 16 进制字符串， BT 不使用这个键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多文件模式（Multiple file mode）的 info dictionary 包含的键：

&lt;ul&gt;
&lt;li&gt;name：string 类型，存储文件的目录名，建议使用，utf-8&lt;/li&gt;
&lt;li&gt;name.files：[dictionaries] 每个文件对应一个 dictionary，list 中每个 dictionary 包含的键包括：&lt;/li&gt;
&lt;li&gt;length：整数类型，文件所占字节数&lt;/li&gt;
&lt;li&gt;md5sum：string 类型，可选，相当于文件 MD5 和的 32 个字符的 16 进制字符串， BT 不使用这个键&lt;/li&gt;
&lt;li&gt;path：包含单个或多个元素的 list，元素合成在一起表示文件路径或文件名，utf-8

&lt;ul&gt;
&lt;li&gt;list 中每个元素对应一个目录名或文件名（最后一个元素对应文件名）&lt;/li&gt;
&lt;li&gt;如&lt;code&gt;dir1/dir2/file.txt&lt;/code&gt;会被编码成 B 编码的字符串 list &lt;code&gt;l4:dir14:dir28:file.txte&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;tracker：响应 HTTP GET 请求的 HTTP/HTTPS 服务

&lt;ul&gt;
&lt;li&gt;请求包含来自客户端的度量信息，这些信息能够帮助 tracker 全面统计种子文件&lt;/li&gt;
&lt;li&gt;响应包含一个 peers 列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bittorrent-dht-协议&#34;&gt;BitTorrent DHT 协议&lt;/h2&gt;

&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;peer：在一个 TCP 端口上监听的客户端/服务端，实现了 BitTorrent 协议&lt;/li&gt;
&lt;li&gt;节点：一个在 UDP 端口上监听的客户端/服务端，实现了 DHT 协议

&lt;ul&gt;
&lt;li&gt;DHT 由节点组成，存储了 peer 的位置&lt;/li&gt;
&lt;li&gt;BitTorrent 客户端包含一个 DHT 节点，该节点用来联系 DHT 中其他节点，从而得到 peer 的位置，进而通过 BitTorrent 协议下载&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;节点为种子文件寻找 peer 时，返回值包含一个不透明的值，称之为令牌 token。如果一个节点 announce 它控制的 peer 正在下载一个种子，必须在回复中加上被请求方之前在 get_peers 回复中发送的 token

&lt;ul&gt;
&lt;li&gt;当节点试图 announce 一个种子时，被请求的节点会核对 token 和请求节点的 IP 地址。这可以防止恶意的主机登记其他主机的种子&lt;/li&gt;
&lt;li&gt;token 只能由请求查询的节点返回给之前发送此 token 给它的节点&lt;/li&gt;
&lt;li&gt;token 必须在发布的一段时间内被接收，即有时效性。BitTorrent 使用 SHA1 哈希 IP 地址，后面跟上一个 secret（5 分钟改变一次），token 在 10 分钟之内是可接受的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;路由表&#34;&gt;路由表&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个节点维护一个路由表保存已知的好节点，用来作为在 DHT 请求的起始点。路由表中的节点是在向其他节点请求过程中，被请求的节点回复的&lt;/li&gt;
&lt;li&gt;一个好的节点是在过去 15 分钟回复过某个请求的节点，或者增加回复过请求而且在过去 15 分钟发送过请求的节点

&lt;ul&gt;
&lt;li&gt;当节点 15 分钟没有活跃，则成为可疑的节点&lt;/li&gt;
&lt;li&gt;当节点连续不能回复时，节点变为坏的&lt;/li&gt;
&lt;li&gt;和状态未知的节点相比，已知的好节点有更高的优先级&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;目前每个 k-bucket 中可疑保存 8 个节点，即 k=8&lt;/li&gt;
&lt;li&gt;k-bucket 节点的更新

&lt;ul&gt;
&lt;li&gt;当得到一个新的好节点时&lt;/li&gt;
&lt;li&gt;如果已有节点都是好的，则丢弃新的节点&lt;/li&gt;
&lt;li&gt;如果已知有坏节点，则用新节点替换坏节点&lt;/li&gt;
&lt;li&gt;如果有可疑的节点，则试图 ping 该节点

&lt;ul&gt;
&lt;li&gt;收到回复，则 ping 下一个可疑节点，直到遇到未回复的节点或者所有节点都是好的&lt;/li&gt;
&lt;li&gt;可疑节点没有回复建议再发一次，仍然没有回复则丢弃，用新节点替换&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每个 bucket 持有一个 last changed 属性，标记内容的新鲜度

&lt;ul&gt;
&lt;li&gt;ping 一个节点并且收到回复，插入一个新节点，替换一个节点都会更新 bucket 的属性&lt;/li&gt;
&lt;li&gt;15 分支没有更新的 bucket 应当被刷新&lt;/li&gt;
&lt;li&gt;在 bucket 中随机选取一个 ID，执行一个 find_node 操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当在路由表中插入第一个节点并启动时，节点应该尝试一个 find_node 操作，参数是它本身，以更新 DHT 中此节点临近的节点&lt;/li&gt;
&lt;li&gt;路由表应保存在客户端软件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bittorrent-协议扩展&#34;&gt;BitTorrent 协议扩展&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;BitTorrent 协议扩展用于交换 peer 之间的 UDP 端口数&lt;/li&gt;
&lt;li&gt;客户端可以通过正常的下载种子文件自动更新路由表

&lt;ul&gt;
&lt;li&gt;新安装的客户端下载一个没有 tracker 的种子，一开始路由表也没有节点，需要从种子文件获得联系信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;支持 DHT 的 peers 在 BitTorrent 的握手协议中设置预留的 8-byte 的最后一位为 1，收到握手的 peer 表明远端的 peer 支持 DHT 协议，应该发送 PORT 消息

&lt;ul&gt;
&lt;li&gt;消息一 0x09 字节开头，有两个字节的 payload，包含了该 DHT peer 使用的网络字节序的 UDP 端口&lt;/li&gt;
&lt;li&gt;收到 PORT 消息的 peer 应该尝试用收到的端口和 IP 地址 ping 这个节点。如果收到回复，该节点应该插入这个新的联系方式到它的路由表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;种子文件扩展&#34;&gt;种子文件扩展&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;一个没有 tracker 的种子 dictionary 没有 announce 键

&lt;ul&gt;
&lt;li&gt;取而代之的是 nodes 键，这个键设为客户端路由表中 k 个最近的节点&lt;/li&gt;
&lt;li&gt;也可以设置为已知的好的节点，比如种子文件的创建者&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不要自动加入&lt;code&gt;router.bittorrent.com&lt;/code&gt;到种子文件或者自动加入此节点到客户端路由表

&lt;ul&gt;
&lt;li&gt;一开始节点不在 DHT 网络中，可以向&lt;code&gt;router.bittorrent.com:6881&lt;/code&gt;或&lt;code&gt;dht.transmissionbt.com:6881&lt;/code&gt;等发送 find_node 请求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;krpc-协议&#34;&gt;KRPC 协议&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;KRPC 协议是一个简单的 RPC 结构，由 bencode 编码的 dictionaries 组成，通过 UDP 发送&lt;/li&gt;
&lt;li&gt;发出去一个单独的查询包然后回复一个单独的包，消息不会重试&lt;/li&gt;
&lt;li&gt;有三种消息类型

&lt;ul&gt;
&lt;li&gt;查询 query，有四种查询：ping，find_node，get_peers，announce_peer&lt;/li&gt;
&lt;li&gt;回复 response，&lt;/li&gt;
&lt;li&gt;错误 error，&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一个 KRPC 消息是一个单独的 dictionary，有三个共同的键以及和消息类型相关的附加键

&lt;ul&gt;
&lt;li&gt;t：string 类型，表示会话 transaction ID，由查询节点生成，回复的时候携带，因此回复可能和同一节点的多个查询相关&lt;/li&gt;
&lt;li&gt;会话 ID 应当被编码成二进制的段字符串，比如 2 个字节可以覆盖 2^16 个请求&lt;/li&gt;
&lt;li&gt;y：单字符类型，描述消息类型，q-query，r-response，e-error&lt;/li&gt;
&lt;li&gt;v：字符串类型，表示客户端版本，2 个字符表示客户端注册标识符，2 个字符表示版本标记&lt;/li&gt;
&lt;li&gt;不是所有实现有包含 v 键&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;联系信息编码 contact encoding

&lt;ul&gt;
&lt;li&gt;peers 的联系信息被编码为 6 字节的字符串，又被称为“Compact IP-address/port info”&lt;/li&gt;
&lt;li&gt;4 字节的 IP 地址，网络字节序&lt;/li&gt;
&lt;li&gt;2 字节的端口，网络字节序&lt;/li&gt;
&lt;li&gt;节点的联系信息被编码为 26 字节的字符串，又被称为“Compact node info”&lt;/li&gt;
&lt;li&gt;20 字节的 Node ID，网络字节序&lt;/li&gt;
&lt;li&gt;6 字节的 “Compact IP-address/port info”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;查询 query 消息字典

&lt;ul&gt;
&lt;li&gt;y：q&lt;/li&gt;
&lt;li&gt;q：string 类型，包含 query 的 method 名称&lt;/li&gt;
&lt;li&gt;a：dictionary 类型，包含参数名字和值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;回复 response 消息字典

&lt;ul&gt;
&lt;li&gt;y：r&lt;/li&gt;
&lt;li&gt;r：dictionary 类型，包含返回值名字和值&lt;/li&gt;
&lt;li&gt;当查询正确执行完成之后才会发送回复消息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;错误 error 消息字典

&lt;ul&gt;
&lt;li&gt;y：e&lt;/li&gt;
&lt;li&gt;e：list 类型&lt;/li&gt;
&lt;li&gt;第一个元素是一个整数代表错误码

&lt;ul&gt;
&lt;li&gt;201：generic 错误&lt;/li&gt;
&lt;li&gt;202：server 错误&lt;/li&gt;
&lt;li&gt;203：protocol 错误，比如 malformed packet，无效参数，bad token&lt;/li&gt;
&lt;li&gt;204：未知的 method&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二个元素是一个 string 包含错误消息&lt;/li&gt;
&lt;li&gt;当一个查询不能完成的时候发送错误消息&lt;/li&gt;
&lt;li&gt;比如&lt;code&gt;generic error={&amp;quot;t&amp;quot;:&amp;quot;aa&amp;quot;, &amp;quot;y&amp;quot;:&amp;quot;e&amp;quot;, &amp;quot;e&amp;quot;:[201, &amp;quot;A Generic Error Occured&amp;quot;]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;bencode 编码是&lt;code&gt;d1:eli201e23:A Generic Error Occurred1:t2:aa1:y1:ee&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dht-查询&#34;&gt;DHT 查询&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;所有的查询都有一个 id 的键，表示查询节点的 Node ID，所有的回复有一个 id 的键，表示回复节点的 Node ID&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ping：&lt;code&gt;&amp;quot;q&amp;quot;=&amp;quot;ping&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;id：string 类型，20 字节，指的发送者的节点 ID，网络字节序&lt;/li&gt;

&lt;li&gt;&lt;p&gt;回复的键只有 id 表示回复者的节点 ID&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;ping query:{&amp;quot;t&amp;quot;:&amp;quot;aa&amp;quot;, &amp;quot;y&amp;quot;:&amp;quot;q&amp;quot;, &amp;quot;q&amp;quot;:&amp;quot;ping&amp;quot;, &amp;quot;a&amp;quot;:{&amp;quot;id&amp;quot;:&amp;quot;querying_node_id&amp;quot;}}
{&amp;quot;bencoded&amp;quot;: &amp;quot;d1:ad2:id14:querying_node_ide1:q4:ping1:t2:aa1:y1:qe&amp;quot;}
response:{&amp;quot;t&amp;quot;:&amp;quot;aa&amp;quot;, &amp;quot;y&amp;quot;:&amp;quot;r&amp;quot;, &amp;quot;r&amp;quot;:{&amp;quot;id&amp;quot;:&amp;quot;queried_nodes_id&amp;quot;}
{&amp;quot;bencoded&amp;quot;: &amp;quot;d1:rd2:id16:queried_node_ide1:t2:aa1:y1:re&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;find_node：&lt;code&gt;&amp;quot;q&amp;quot;=&amp;quot;find_node&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;指定节点 ID，查询节点的联系信息&lt;/li&gt;
&lt;li&gt;id：查询节点的 ID&lt;/li&gt;
&lt;li&gt;target：查询者要查询的节点 ID&lt;/li&gt;
&lt;li&gt;回复的键&lt;/li&gt;
&lt;li&gt;id：接收者的节点 ID&lt;/li&gt;
&lt;li&gt;nodes：string 类型，包含目的节点的紧密（compact）信息或者接收者路由表中 k 个最近最好的节点信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get_peers：&lt;code&gt;&amp;quot;q&amp;quot;=&amp;quot;get_peers&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;请求与种子文件的 info_hash 相关&lt;/li&gt;
&lt;li&gt;id：查询节点的 ID&lt;/li&gt;
&lt;li&gt;info_hash：种子文件的 info_hash 值&lt;/li&gt;
&lt;li&gt;回复的键：接收者有 info_hash 的 peers 则返回 values，否则返回 nodes&lt;/li&gt;
&lt;li&gt;id：接收者的节点 ID&lt;/li&gt;
&lt;li&gt;token：用于后续的 announce_peer 查询，是一个短的二进制字符串&lt;/li&gt;
&lt;li&gt;values：list of string 类型，每个字符串包含一个紧密（compact）格式的 peer 信息&lt;/li&gt;
&lt;li&gt;nodes：接收节点路由表最接近 info_hash 的 k 个节点信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;announce_peer：&lt;code&gt;&amp;quot;q&amp;quot;=&amp;quot;announce_peer&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;宣布一个控制请求节点的 peer 正在某个端口下载一个种子文件&lt;/li&gt;
&lt;li&gt;id：查询请求节点的 ID&lt;/li&gt;
&lt;li&gt;info_hash：种子文件的 info_hash&lt;/li&gt;
&lt;li&gt;port：整数类型，表示在哪个端口下载&lt;/li&gt;
&lt;li&gt;token：之前的一个“get_peers”回复中的 token&lt;/li&gt;
&lt;li&gt;被请求的节点必须验证 token 之前发送的节点 IP 地址与请求节点相同，然后被请求的节点保存这个请求节点的 IP 地址和提供的端口到它自己的 peer 联系信息&lt;/li&gt;
&lt;li&gt;implied_port：可选，0 或者 1，如果存在且不为 0，port 参数值应该忽略，而且 UDP 包的源端口应作为 peer 的端口&lt;/li&gt;
&lt;li&gt;这对于 NAT 之后的 peer 有用，因为 peer 不知道自己外部端口，但是支持 uTP，接收同一 DHT 端口的连接&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;总结：DHT 是一个 hash 表，发送 KRPC 的 find_node 或 get_peers 消息，就是对表执行 get(key) 操作，发送 announce_peer 消息，就是对表执行 set(key,val) 操作&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bittorrent-dht-几个重要过程&#34;&gt;Bittorrent DHT 几个重要过程&lt;/h2&gt;

&lt;h3 id=&#34;种子制作&#34;&gt;种子制作&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;use_tracker 设置为 false，则不会产生 announce tracker 字段&lt;/li&gt;
&lt;li&gt;读取本地路由表文件，从中找到 k 个离 info_hash 最近的节点，作为 nodes 字段&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;启动过程&#34;&gt;启动过程&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从路由表文件装载之前保存的路由表 k-bucket 信息，初始化内存路由表信息&lt;/li&gt;
&lt;li&gt;强制刷新路由表的每一个 k-bucket，刷新过世是随机产生一个 id 进行 find_node 操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;刷新路由表&#34;&gt;刷新路由表&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;启动的时候强制刷新&lt;/li&gt;
&lt;li&gt;每 15 分钟如果 k-bucket 中信息没有更新，则刷新一次，即 refreshTable&lt;/li&gt;
&lt;li&gt;每 5 分钟进行一次 checkPoint 操作，把当前的路由表保存到 routing_table 文件

&lt;ul&gt;
&lt;li&gt;routing_table 文件格式&lt;code&gt;{&#39;id&#39;:node_id, &#39;host&#39;:node_host, &#39;port&#39;:node_port, &#39;age&#39;:int(node_age)}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每个路由表的 k-bucket 有一个 last changed 属性，具体描述参考上面的&lt;code&gt;BitTorrent DHT 协议&lt;/code&gt;-&amp;gt;&lt;code&gt;路由表&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>IPFS 入门</title>
      <link>https://xueqing.github.io/blog/p2p/ipfs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/p2p/ipfs/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ipfs-%e7%9a%84%e4%bc%98%e7%82%b9&#34;&gt;IPFS 的优点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipns%e5%8e%bb%e4%b8%ad%e5%bf%83%e5%8c%96%e5%91%bd%e5%90%8d%e7%b3%bb%e7%bb%9f&#34;&gt;IPNS（去中心化命名系统）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipfs-http-%e7%bd%91%e5%85%b3&#34;&gt;IPFS HTTP 网关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipfs-vs-scsia-coin&#34;&gt;IPFS vs SC（Sia coin）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8d%e5%8f%af%e9%9d%a0unreliable-vs-%e5%8f%af%e9%9d%a0reliable&#34;&gt;不可靠（Unreliable） VS 可靠（Reliable）&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#%e6%80%bb%e7%bb%93&#34;&gt;总结&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IPFS(InterPlanetary File Syatem，星际文件系统)是一个面向全球的、点对点的分布式版本文件系统，目标是为了补充甚至取代目前通知互联网的 HTTP（超文本传输协议），将所有具有相同文件系统的计算机设备连接在一起&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;永久的、去中心化保存、共享文件&lt;/li&gt;
&lt;li&gt;内容可寻址：通过文件内容生成唯一哈希值来标识文件。相同内容的文件在系统中只存在一份，节约存储空间&lt;/li&gt;
&lt;li&gt;版本化：可追溯文件修改历史&lt;/li&gt;
&lt;li&gt;点对点超媒体分布式： P2P 保存各种类型的数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原理用基于内容的地址替代基于域名的地址，也就是用户寻找的不是某个地址而是存储在某个地方的内容，不需要验证发送者的身份，而只需要验证内容的哈希，这样可以让网页的速度更快、更安全、更健壮、更持久。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP 的问题：互联网的数据交互模式使用的是 B/S 和 C/S 模式，即客户-服务器、浏览器-服务器模式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;鼓励高度集中化：PFS 将 web 去中心化，可以降低极少数强大组织的延展性，提高所有站点的自由度和独立性，同时降低了由于服务器中断造成数据丢失的风险&lt;/li&gt;
&lt;li&gt;低效：HTTP 协议从一台服务器一次只能下载一个文件，IPFS 可代替总是从数据中心获取内容的 HTTP，减少数据传输的费用&lt;/li&gt;
&lt;li&gt;过度依赖于 Internet 主干网：Internet 主干网并不健全，易被攻击，同时一些重要的光纤线路被切断时服务容易遭受影响&lt;/li&gt;
&lt;li&gt;服务器成本昂贵： HTTP 需要大量的重心服务器保存数据&lt;/li&gt;
&lt;li&gt;历史文件被删除：网页平均使用寿命为 100 天，大量网站文件不能长期保存。重要的文件也会因操作不当而在互联网消失&lt;/li&gt;
&lt;li&gt;中心化的网络限制了发展：中心化的网络易被控制，限制了互联网的良性发展&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ipfs-的优点&#34;&gt;IPFS 的优点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;IPFS 用户搜索的是内容。通过浏览器搜索文件时，先找到服务器的位置（IP 地址），然后使用路径名称在服务器查找文件

&lt;ul&gt;
&lt;li&gt;只有文件所有者可以判断是否是用户要找的文件&lt;/li&gt;
&lt;li&gt;必须保证托管这不会通过移除文件或者关闭服务器而对文件做任何更改&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当文件被添加到 IPFS 节点，得到一个加密哈希名字，是从文件内容计算得到，通过加密保证哈希只表示文件内容，文件内容修改，哈希都会不一样&lt;/li&gt;
&lt;li&gt;向 IPFS 分布式网络询问哈希时，通过使用一个分布式哈希表，可以快速找到拥有数据的节点，从而检索该数据，并使用哈希验证是否正确&lt;/li&gt;
&lt;li&gt;IPFS 是通用的，存储限制少。服务的文件可大可小。大的文件会自动切割为小块，是节点可以从数百台服务器同步下载&lt;/li&gt;
&lt;li&gt;IPFS 网络是细粒度、&lt;a href=&#34;https://www.inetdaemon.com/tutorials/basic_concepts/communication/reliable_vs_unreliable.shtml&#34; target=&#34;_blank&#34;&gt;不可靠&lt;/a&gt;、分布式、易联合的内容分发网络（CDN，Content Delivery Network）

&lt;ul&gt;
&lt;li&gt;IPFS 是静态 web 网站&lt;/li&gt;
&lt;li&gt;(不可靠和可靠的区别)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IPFS 文件可以是特殊的目录对象，允许用户使用人类可读的文件名，透明地链接到其他哈希

&lt;ul&gt;
&lt;li&gt;用户可以通过默认方式加载目录中的 index.html，这也是标准的 HTTP 服务器采用的方式&lt;/li&gt;
&lt;li&gt;使用目录对象，IPFS 可允许用户采用完全相同的方式生成静态网站&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IPFS 通过网络删除具有相同哈希值的文件，通过计算可以判断哪些文件是冗余重复的&lt;/li&gt;
&lt;li&gt;每个网络节点只存储感兴趣的内容，以及一些索引信息，记录节点存储的内容&lt;/li&gt;
&lt;li&gt;提供文件的历史版本控制器，且让多节点使用保存不同版本的文件&lt;/li&gt;
&lt;li&gt;通过使用代币（FileCoin）的激励作用，让各节点有动力去存储数据。代币一个由加密货币驱动的存储网络。矿工通过为网络提供开放的硬盘空间获得代币，用户则用代币来支付在去中心化网卡中存储加密文件的费用&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ipns-去中心化命名系统&#34;&gt;IPNS（去中心化命名系统）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用 IPNS，每个文件可以被协作命名为易读的名字&lt;/li&gt;
&lt;li&gt;IPNS 允许用户使用一个私钥来对 IPFS 哈希附加一个引用，使用一个公钥哈希（pubkeyhash）表示用户网站的最新版本&lt;/li&gt;
&lt;li&gt;如果链接不起作用，可以通过更改 pubkeyhash 指向的内容更新网站&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ipfs-http-网关&#34;&gt;IPFS HTTP 网关&lt;/h2&gt;

&lt;p&gt;通过一个 HTTP 网关，IPFS 可以实现从 HTTP 到 IPFS 的过渡。浏览器可以在完全实现 IPFS 之前，允许当前的浏览器访问 IPFS&lt;/p&gt;

&lt;h2 id=&#34;ipfs-vs-sc-sia-coin&#34;&gt;IPFS vs SC（Sia coin）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;SC 是一条去中心化存储的公链，通过代币购买存储空间，将文件备份在互联网的多个节点上，提高文件的安全性&lt;/li&gt;
&lt;li&gt;IPFS 是一个底层的互联网协议，跟 HTTP 一样是交换信息。IPFS 实现的是互联网各个节点的文件读取、分享、交换&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;不可靠-unreliable-vs-可靠-reliable&#34;&gt;不可靠（Unreliable） VS 可靠（Reliable）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可靠的：运行在可靠的协议的终端会一起工作检查传输的数据，以确保正确性和数据完整性

&lt;ul&gt;
&lt;li&gt;一个可靠的系统会建立一个连接并且验证所有传输的数据被控制是有序的，按照正确的顺序被接收并且是完好无损的&lt;/li&gt;
&lt;li&gt;可靠的协议对于丢失数据，易出错的物理介质工作比较好&lt;/li&gt;
&lt;li&gt;差错校验，排序和验证机制需要数据包的多余负载，增加了传输数据的总带宽&lt;/li&gt;
&lt;li&gt;TCP（Transmision Control Protocol）是典型的可靠协议，数据包平均增加 42-63 字节&lt;/li&gt;
&lt;li&gt;对于一个 Telnet 连接，单独传送每个击键，这样是非常低效的，因为传输一个有用的字节信息需要传输 64 个字节的数据包&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不可靠的

&lt;ul&gt;
&lt;li&gt;不可靠的协议不会建立连接，不检查数据是否被接收，也不会提供数据来恢复错误或丢失的数据&lt;/li&gt;
&lt;li&gt;不可靠的协议对于较少丢失数据和不易出错的物理介质工作较好&lt;/li&gt;
&lt;li&gt;UDP（User Datagram Protocol）是不可靠的协议，不会检查数据到达终端或者是完好无损的&lt;/li&gt;
&lt;li&gt;相比 TCP，UDP 增加了很小的数据负载，因此在高质量的物理介质上传输更快&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;总结-https-github-com-ipfs-ipfs-quick-summary&#34;&gt;&lt;a href=&#34;https://github.com/ipfs/ipfs#quick-summary&#34; target=&#34;_blank&#34;&gt;总结&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;IPFS 协议：定义了基于内容寻址的文件系统；协调内容分发；合并了 Kademlia + BitTorrent + Git&lt;/li&gt;
&lt;li&gt;IPFS 文件系统：有目录和文件；可挂载的文件系统（通过 FUSE）&lt;/li&gt;
&lt;li&gt;IPFS 网络：像网络一样查看文件&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>P2P 中 DHT 网络介绍</title>
      <link>https://xueqing.github.io/blog/p2p/p2p%E5%8F%8Adht/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/p2p/p2p%E5%8F%8Adht/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e5%93%88%e5%b8%8c%e8%a1%a8-dht&#34;&gt;分布式哈希表 DHT&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#kademlia&#34;&gt;Kademlia&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#kademlia-a-peer-to-peer-information-system-based-on-the-xor-metric-%e8%ae%ba%e6%96%87%e9%98%85%e8%af%bb&#34;&gt;Kademlia: A Peer-to-Peer Information System Based on the XOR Metric 论文阅读&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%bc%82%e6%88%96%e5%ba%a6%e9%87%8f&#34;&gt;异或度量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%8a%82%e7%82%b9%e7%8a%b6%e6%80%81&#34;&gt;节点状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kad-%e5%8d%8f%e8%ae%ae&#34;&gt;KAD 协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b7%af%e7%94%b1%e8%a1%a8&#34;&gt;路由表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9c%89%e6%95%88%e7%9a%84-key-re-publishing&#34;&gt;有效的 key re-publishing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bc%98%e5%8c%96&#34;&gt;优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dht-%e4%b8%ad-kad-%e7%9a%84%e5%ba%94%e7%94%a8&#34;&gt;DHT 中 KAD 的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;P2P(peer-to-peer) 技术的应用：文件分享、即时通信、协同处理、流媒体通信等&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;P2P 文件分享网络的发展阶段：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;包含 tracker 服务器的网络&lt;/li&gt;
&lt;li&gt;无任何服务器的纯 DHT 网络&lt;/li&gt;
&lt;li&gt;混合型 P2P 网络&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分布式哈希表-dht&#34;&gt;分布式哈希表 DHT&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;分布式哈希表(DHT， Distributed Hash Table)，一种分布式存储方法，一类可由键值来唯一标识的信息按照某种约定/协议被分散地存储在多个节点上&lt;/li&gt;
&lt;li&gt;不需要服务器，每个客户端负责一个小范围的路由，并负责存储一小部分数据，从而实现正哥 DHT 网络的寻址和存储&lt;/li&gt;
&lt;li&gt;可以有效地避免“中央集权式”的服务器(如 tracker)的单一故障而带来整个网络瘫痪&lt;/li&gt;
&lt;li&gt;实现 DHT 的算法常用的有 Chord，Pastry，Kademlia

&lt;ul&gt;
&lt;li&gt;最直接的目标是以最快的速度定位到期望的节点&lt;/li&gt;
&lt;li&gt;计算的是某种逻辑上的距离，因为地理距离的计算很复杂&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;kademlia&#34;&gt;Kademlia&lt;/h2&gt;

&lt;h3 id=&#34;kademlia-a-peer-to-peer-information-system-based-on-the-xor-metric-论文阅读&#34;&gt;Kademlia: A Peer-to-Peer Information System Based on the XOR Metric 论文阅读&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;特点

&lt;ul&gt;
&lt;li&gt;最小化节点发送的配置消息：可以通过 key lookup 流程展开配置信息&lt;/li&gt;
&lt;li&gt;节点通过低延迟的路径来路由查询&lt;/li&gt;
&lt;li&gt;KAD 使用并行、异步查询来避免离线节点的超时&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;异或度量&#34;&gt;异或度量&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;每个 KAD 节点有一个 160 比特长的 ID，节点 ID 是随机值

&lt;ul&gt;
&lt;li&gt;节点发送的每个消息包含自身的节点 ID，允许接收者记录发送者的存在性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;键(Key)也是 160 比特的标识符&lt;/li&gt;
&lt;li&gt;Kademlia 采用简单的异或计算衡量两节点之间的距离，与地理距离无关：&lt;code&gt;d(x,y)=xor(x,y)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;具备几何公式的多数特征

&lt;ul&gt;
&lt;li&gt;节点和本身的异或距离是 0：&lt;code&gt;d(x,x)=0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;异或距离是对称的：&lt;code&gt;d(x,y)=d(y,x)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;异或距离符合三角不等式：给定三个顶点 A B C，若 AC 之间的异或距离最大，则 AC 之间的异或必小于等于 AB 异或距离和 BC 异或距离之和&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d(x,y)+d(y,z)&amp;gt;=d(x,z)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;证明：&lt;code&gt;xor(d(x,y), d(y,z))=d(x,z),且 a+b&amp;gt;=xor(a,b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于给定的一个距离，距离 A 只存在唯一的一个节点 B，也即单向性，在查找路径上也是单向的，这个和地理距离不同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;已知 x 和 dis, 求 y 使得 dis=xor(x,y)：xor(dis,x)=xor(xor(x,y),x)=y&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;节点状态&#34;&gt;节点状态&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;KAD 节点存储其他节点的信息来路由请求消息&lt;/li&gt;
&lt;li&gt;每个节点保存一张三元组&lt;code&gt;&amp;lt;IP_addr, UDP_port, Node_ID&amp;gt;&lt;/code&gt;链表，记录距离自身&lt;code&gt;2^i&lt;/code&gt;到&lt;code&gt;2^(i+1)&lt;/code&gt;的节点，称之为&lt;code&gt;k-bucket&lt;/code&gt;(k 桶)

&lt;ul&gt;
&lt;li&gt;k-bucket 存储策略是&lt;code&gt;least-recently seen eviction&lt;/code&gt;：最少最近访问的节点放在链表头，最多最近访问的节点放在链表尾&lt;/li&gt;
&lt;li&gt;关于 k 值

&lt;ul&gt;
&lt;li&gt;对于较小的 i，k-bucket 可能为空，即不存在合适的距离较近的节点&lt;/li&gt;
&lt;li&gt;对于较大的 i，链表的长度可以增加到 k&lt;/li&gt;
&lt;li&gt;k 是一个系统范围的参数，是指任意 k 个节点在一个小时内不会全部掉线&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于 k-bucket 的更新

&lt;ul&gt;
&lt;li&gt;当一个 KAD 节点收到其他节点的消息（请求或者回复）时，节点会更新发送者节点 ID 对应的 k-bucket 信息&lt;/li&gt;
&lt;li&gt;如果发送节点已经存在 k-bucket，接收者将其移到链表尾部&lt;/li&gt;
&lt;li&gt;如果发送节点不在 k-bucket&lt;/li&gt;
&lt;li&gt;k-bucket 的元素数目小于 k，接收者将发送节点插入链表尾部&lt;/li&gt;
&lt;li&gt;k-bucket 已满，接收者将会 ping 最近最少访问的节点决定如何做

&lt;ul&gt;
&lt;li&gt;如果最近最少访问的节点没有回复，接收者将该节点从 k-bucket 移除，并将之前的发送者节点插入链表尾部&lt;/li&gt;
&lt;li&gt;如果收到最近最少访问的节点的回复，接收者将该节点移到链表尾部，并丢弃之前的发送者节点的信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;k-bucket 不会将 live 的节点从链表移除

&lt;ul&gt;
&lt;li&gt;在线时间长的节点更值得信任，即下一段时间保持在线的可能性比新访问的节点更大&lt;/li&gt;
&lt;li&gt;k-bucket 在某种程度上可以抵制 DOS 攻击，因为节点的路由状态不会被新访问的节点刷新，当旧的节点没有离开系统时，k-bucket 不会插入新的节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;kad-协议&#34;&gt;KAD 协议&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;KAD 协议包括四个 RPC

&lt;ul&gt;
&lt;li&gt;ping：探测一个节点是否在线&lt;/li&gt;
&lt;li&gt;store：指导节点存储一个&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对便于之后的检索&lt;/li&gt;
&lt;li&gt;find_node：取一个 160 比特的 ID 作为参数，发送给 k-bucket 的节点，接收者返回已知的距离目标 ID 最近的节点的三元组&lt;code&gt;&amp;lt;IP_addr, UDP_port, Node_ID&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;三元组可以来自一个 k-bucket&lt;/li&gt;
&lt;li&gt;当最近的 k-bucket 不满时，三元组来自多个 k-bucket&lt;/li&gt;
&lt;li&gt;RPC 接收者必须返回 k 个元素，当接收者所有的 k-bucket 加起来不到 k 个 节点，则返回它知道的所有节点&lt;/li&gt;
&lt;li&gt;find_value：类似于 find_node，当 RPC 接收者收到一个关于 key 的 store RPC，则返回存储的 value&lt;/li&gt;
&lt;li&gt;接收者若存储了 key 对应的 value，则返回 value&lt;/li&gt;
&lt;li&gt;否则返回距离 key 最近的 k 个节点的信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;node lookup：每个 KAD 的参与者执行的一个最重要的操作就是对于给定的节点 ID，定位 k 个最近的节点

&lt;ul&gt;
&lt;li&gt;KAD 使用递归的算法查找节点&lt;/li&gt;
&lt;li&gt;查找的发起者从它最近的非空 k-bucket 中选择 α 个节点(当 bucket 中节点少于 α，则选择已知的最近的 α 个节点)

&lt;ul&gt;
&lt;li&gt;α 是系统范围的并发参数&lt;/li&gt;
&lt;li&gt;假设发起者是节点 x，x 先计算距离 d=xor(x, ID)&lt;/li&gt;
&lt;li&gt;x 从第 log2(d)个 k-bucket 中选择 α 个节点，不足 α 个节点时，从附近多个 bucket 中选择距离最接近 d 的一共 α 个节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;查找的发起者发送并行、异步的 find_node RPC 到这 α 个节点&lt;/li&gt;
&lt;li&gt;接收者如果发现自己就是 ID，则回答自己是最接近的，否则计算自己和 ID 的距离，从中自己的 k-bucket 中选择 α 个节点返回&lt;/li&gt;
&lt;li&gt;发起者收到接收者回复的 k 个节点，再选择未发送过请求的 α 个节点，再次发送 find_node 请求到这 α 个节点

&lt;ul&gt;
&lt;li&gt;没有回复的节点直接被移除&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当所有的 find_node 不再返回比已知的节点更近的节点，查找的发起者发送重新发送 find_node 给所有最近且未查询过的 k 个节点&lt;/li&gt;
&lt;li&gt;当发起者查询并且收到 k 个最近的节点的回复，查询终止&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;存储&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对

&lt;ul&gt;
&lt;li&gt;参与者定位距离 key 最近的 k 个节点，并发送 store RPC&lt;/li&gt;
&lt;li&gt;每个节点间隔一段时间(如 24h)重新发布&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对来保持 alive&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;查找一个&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对

&lt;ul&gt;
&lt;li&gt;一个节点先执行 lookup 找到 k 个距离 key 最近的节点 ID&lt;/li&gt;
&lt;li&gt;查找 value 使用 find_value RPC&lt;/li&gt;
&lt;li&gt;当任意节点返回此 value 时，此流程终止&lt;/li&gt;
&lt;li&gt;当查询成功时，发送请求的节点会存储&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对到已知的距离最近且未返回 value 的节点&lt;/li&gt;
&lt;li&gt;由于拓扑的无方向性，查询相同的 key 可能会在找到最近的节点之前找到缓存的条目&lt;/li&gt;
&lt;li&gt;为了避免对常查找的 key 的&amp;rdquo;over-caching&amp;rdquo;，对于所有节点数据库的&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对设置过期时间，过期时间与当前节点和距离 key 最近的节点之间的节点数成指数反比关系，即越远的节点过期时间越短&lt;/li&gt;
&lt;li&gt;数字可以通过当前节点的 bucket  结构推算出来&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;通常通过请求在节点之间的转发更新 bucket。为了避免某些节点范围不被查询，每个在一小时之内未执行查询节点的节点会更新其所有的 bucket。

&lt;ul&gt;
&lt;li&gt;刷新意味着从 bucket 中随机选择一个 ID，并且对该 ID 执行一次节点查询&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新加入的节点 u 更新自己的 k-bucket

&lt;ul&gt;
&lt;li&gt;u 选择一个已经加入网络的节点 w 到自己的对应 k-bucket&lt;/li&gt;
&lt;li&gt;u 对自己的节点 ID 执行一次节点查询&lt;/li&gt;
&lt;li&gt;最终，u 更新自己所有的 k-bucket，同时插入自身到其他的一些节点的 k-bucket&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;路由表&#34;&gt;路由表&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;KAD 的路由表是一个二叉树，叶子节点是 k-bucket

&lt;ul&gt;
&lt;li&gt;每个 k-bucket 包含和 ID 有一些共同前缀的节点，前缀是 k-bucket 在二叉树中的位置&lt;/li&gt;
&lt;li&gt;每个 k-bucket 覆盖了 ID 空间的某个范围，所有的 k-bucket 刚好覆盖了整个 160 比特的 ID 空间&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;路由树的节点根据需要动态分布

&lt;ul&gt;
&lt;li&gt;一开始，一个节点 u 的路由表有一个节点，一个 k-bucket 覆盖整个 ID 空间&lt;/li&gt;
&lt;li&gt;当 u 得到新的联系信息，尝试插入到适合的 k-bucket&lt;/li&gt;
&lt;li&gt;当该 bucket 不满，则插入新的联系信息&lt;/li&gt;
&lt;li&gt;否则，如果 k-bucket 范围包含节点自身，则将 bucket 分为两个 bucket，再尝试插入适合的 bucket&lt;/li&gt;
&lt;li&gt;如果不同范围的 k-bucket 已满，则丢弃新的联系信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;有效的-key-re-publishing&#34;&gt;有效的 key re-publishing&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;之前缓存了&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对的节点可能会掉线，新加入的节点可能比缓存了&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;的节点距离 key 更近，因此持有&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;的节点需要重复发布&lt;/li&gt;
&lt;li&gt;KAD 每隔一个小时会重复发布所有的&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对，以避免缓存过的节点掉线

&lt;ul&gt;
&lt;li&gt;re-publishing 过程的优化：&lt;/li&gt;
&lt;li&gt;每个收到 store RPC 的节点会假定消息已经发送到另外 k-1 个最近的节点，所以接收者不会发布这个消息。因此，当 re-publication 的间隔没有完全同步，每个小时，只有一个节点会 republish 指定的&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;对&lt;/li&gt;
&lt;li&gt;在 republish 之前避免查找节点。这样，一个节点对所有 k-bucket 的刷新可以分摊到许多的节点的重复发布过程中&lt;/li&gt;
&lt;li&gt;每个节点只会在自己的 ID 比其他节点距离 key 更近的情况下发布 store RPC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;优化&#34;&gt;优化&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;采用 LRU  策略维持 k-bucket 的联系信息时，为了避免发送过多的 ping 请求阻塞网络， KAD 增加一个替换缓存(Replacement cache)保存新得到的联系信息，当持有有用的信息才会发送 ping 信息给链表中的节点，如果节点没有回复，则从链表中删除该节点，并从替换缓存中找一个最近最多访问的节点插入链表头&lt;/li&gt;
&lt;li&gt;因为 KAD 使用 UDP，当网络阻塞的时候，网卡会丢掉一些包。 KAD 会锁住没有回复的联系信息，并不会再给这些联系节点发送 RPC&lt;/li&gt;
&lt;li&gt;当一个联系节点连续 5 次没有回复 RPC，其他节点会认为此联系节点是 stale（过时，失去时效），当节点的 k-bucket 不满或者替换缓存为空的时候， KAD 不会从 k-bucket 移除这个联系节点，而是将其置为 stale。这样保证了一个节点自身的网络连接暂时断掉的时候，不会将自身所有的 k-bucket 置为无效。（什么时候再置为有效呢？？？）&lt;/li&gt;
&lt;li&gt;减少查找节点的跳跃数：增加路由表的 size，即每次根据 b 个比特位来查找临近节点发送请求。但是这样会增加维护难度&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dht-中-kad-的应用&#34;&gt;DHT 中 KAD 的应用&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;每个节点的 ID 和种子文件的 info_hash 采用 sha-1 算法，节点和种子(&lt;code&gt;&amp;lt;key,value&amp;gt;&lt;/code&gt;)的距离就是节点 ID 和 info_hash 的异或距离&lt;/li&gt;
&lt;li&gt;每个节点按照距离自己的异或远近将所有的节点划分成 160 棵子树，表示其他节点 ID 和自身 ID 的共同前缀的比特数的范围 0-159

&lt;ul&gt;
&lt;li&gt;每个节点的各个 k-bucket 记录了每个子树中的 k 个节点信息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每个新加入 DHT 网络的节点更新路由表的步骤

&lt;ul&gt;
&lt;li&gt;如本节点曾经启动过，则从保存的“路由表”文件中直接读取然后刷新“路由表”&lt;/li&gt;
&lt;li&gt;如果节点第一次启动，且节点有“超级节点”，则通过这些“超级节点”来间接地生成自己的“路由表”&lt;/li&gt;
&lt;li&gt;如果节点第一次启动且没有“超级节点”，则路由表生成过程需要推迟到 download 文件过程。节点从获取到的种子文件提取 nodes 字段，通过这些 nodes 字段中的节点来间接生成自己的路由表&lt;/li&gt;
&lt;li&gt;该 nodes 字段是做种子（支持 DHt 网络的种子）的时候生成的&lt;/li&gt;
&lt;li&gt;一般 nodes 字段设置为原始种子的 ip 和 port，或者是做种子的节点离该种子的 info-hash 最近的 k 个节点&lt;/li&gt;
&lt;li&gt;动态建立过程：节点经过初始化后，在下载、上传或无任务过程中收到任何节点发送的消息，都会检查当前的“路由表”并尝试按照一定的规则去建立/刷新路由表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;tracker：对每一个分享文件（种子）维护一个 peers 列表，告诉需要下载的询问者 client&lt;/li&gt;
&lt;li&gt;DHT 查找类型包括

&lt;ul&gt;
&lt;li&gt;find_nodes：是为了建立路由表。节点 x 查找节点 y 的过程&lt;/li&gt;
&lt;li&gt;x 从 xor(x,y) 对应的本地 k-bucket 中得到 k 个比较近的节点&lt;/li&gt;
&lt;li&gt;x 向上面找到的 k 个节点发送消息查找节点 y&lt;/li&gt;
&lt;li&gt;收到请求的节点从自己的 k-bucket 中找到更近的 k 个节点返回给 x&lt;/li&gt;
&lt;li&gt;x 从收到的回复中选择 k 个最近的节点再次发送请求&lt;/li&gt;
&lt;li&gt;当 x 收到的回复的节点中没有更近的节点停止查找

&lt;ul&gt;
&lt;li&gt;x 最后得到 k 个距离 y 最近的节点&lt;/li&gt;
&lt;li&gt;在此过程中，x 会尝试将得到的节点插到自己的路由表中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;get_peers：与 find_nodes 类似，但是查找的参数不是节点 ID，而是 info_hash&lt;/li&gt;
&lt;li&gt;在查找过程中，收到任意&lt;code&gt;&amp;lt;info_hash, peers_list&amp;gt;&lt;/code&gt;回复就停止查找&lt;/li&gt;
&lt;li&gt;得到 peers_list之后，节点会试图给每个 peer 主动发起 TCP 的连接，之后开始下载，同时会把自己的 peer 信息发送给 k 个距离自己最近的节点存储 &lt;code&gt;&amp;lt;info_hash, peers_list&amp;gt;&lt;/code&gt;信息

&lt;ul&gt;
&lt;li&gt;k 个节点保存该信息 24 小时，期间没有收到 x 的更新消息则信息失效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>torrent 文件</title>
      <link>https://xueqing.github.io/blog/p2p/torrent/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/p2p/torrent/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bt&#34;&gt;BT&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bt-%e4%b8%8b%e8%bd%bd&#34;&gt;BT 下载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#%e7%a7%8d%e5%ad%90%e5%b8%82%e5%9c%ba&#34;&gt;种子市场&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;torrent 文件（种子文件）是被下载文件的“索引”。本质上是文本文件，主要包含 Tracker 信息和文件信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Tracker 信息：BT 下载中需要用到的 Tracker 服务器的地址和针对 Tracker 服务器的设置&lt;/li&gt;
&lt;li&gt;文件信息：根据对目标文件的计算生成，计算结果根据 BitTorrent 协议内的 B 编码规则进行编码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原理：把提供下载的文件虚拟分成大小相等的块，块大小必须为 2k 的整数次方，并把每个块的索引信息和 Hash 验证码写入 .torrent 文件&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;虚拟分块是不在硬盘上产生各个块文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;torrent 文件包含的信息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;资源的名称&lt;/li&gt;
&lt;li&gt;如果资源是以目录形式，还有目录树中每个文件的路径信息和文件名&lt;/li&gt;
&lt;li&gt;如果是单个文件呢，包含文件的大小信息；如果是目录形式，目录树中每个文件大小&lt;/li&gt;
&lt;li&gt;对资源实际文件按照固定大小进行分块后每块进行 SHA1 hash 运算得到的若干特征值的集合&lt;/li&gt;
&lt;li&gt;torrent 文件的创建时间、制作者填写的注释、以及制作者的信息等&lt;/li&gt;
&lt;li&gt;至少一个 announce 地址，对应 Internet 上部署的一个 Tracker 服务器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bt&#34;&gt;BT&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;BT（BitTorrent，比特流），一种 P2P 传输协议。

&lt;ul&gt;
&lt;li&gt;克服了传统下载方式的局限性，下载的人越多，文件下载速度越快&lt;/li&gt;
&lt;li&gt;传统下载方式：一般是文件由服务器传送到客户端，例如 FTP，HTPP，PUB等。服务器的带宽一定，所以下载人越多速度越慢&lt;/li&gt;
&lt;li&gt;普通的 HTPP/FTP 下载使用 TCp/IP 协议，BitTorrent 协议是在 TCP/IP 协议之上的一个 P2P 文件传输协议，处于 TCP/IP 结构的应用层&lt;/li&gt;
&lt;li&gt;根据 BitTorrent 协议，文件发布者发布的文件生成提供一个 .torrent 文件，即种子文件，简称为“种子”&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;bt-下载&#34;&gt;BT 下载&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;下载者要下载文件内容，需要先得到相应的 .torrent 文件，然后使用 BT 客户端下载&lt;/li&gt;
&lt;li&gt;BT 客户端先解析文件得到 Tracker 地址，连接 Tracker 服务器&lt;/li&gt;
&lt;li&gt;Tracker 服务器回应下载者的请求，提供下载者和其他下载者（包括发布者）的 IP&lt;/li&gt;
&lt;li&gt;下载者连接其他下载者，根据 .torrent 文件，下载者分别告知对方自己已有的块，然后交换对方没有的数据

&lt;ul&gt;
&lt;li&gt;不需要服务器参与，分散了单个线路的数据流量，减轻了服务器负担&lt;/li&gt;
&lt;li&gt;下载者每得到一个块，需计算出下载块的 Hash 验证码与 .torrent 文件对比，一样说明块正确，否则需要重新下载&lt;/li&gt;
&lt;li&gt;此规定解决下载内容准确性的问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;种子市场&#34;&gt;种子市场&lt;/h2&gt;

&lt;p&gt;用户在种子市场共享种子文件；用户可以共享任务列表，也可以浏览下载其他人共享的任务&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>分布式原理</title>
      <link>https://xueqing.github.io/blog/p2p/dht/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/p2p/dht/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bittorrent%e5%8d%8f%e8%ae%ae&#34;&gt;Bittorrent协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ad%e5%bf%83%e5%8c%96%e5%8e%9f%e7%90%86&#34;&gt;中心化原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8e%bb%e4%b8%ad%e5%bf%83%e5%8c%96%e5%8e%9f%e7%90%86&#34;&gt;去中心化原理&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dhtkademlia&#34;&gt;DHT/kademlia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nat&#34;&gt;NAT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipfslibp2p&#34;&gt;IPFS/libp2p&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8e%bb%e4%b8%ad%e5%bf%83%e5%8c%96%e6%b5%81%e5%aa%92%e4%bd%93%e5%ba%94%e7%94%a8livepeer&#34;&gt;去中心化流媒体应用livepeer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;bittorrent协议&#34;&gt;Bittorrent协议&lt;/h2&gt;

&lt;p&gt;比特流（BitTorrent）是一种内容分发协议，由布拉姆·科恩自主开发。它采用高效的软件分发系统和点对点技术共享大体积文件（如一部电影或电视节目），并使每个用户像网络重新分配结点那样提供上传服务。一般的下载服务器为每一个发出下载请求的用户提供下载服务，而BitTorrent的工作方式与之不同。分配器或文件的持有者将文件发送给其中一名用户，再由这名用户转发给其它用户，用户之间相互转发自己所拥有的文件部分，直到每个用户的下载都全部完成。这种方法可以使下载服务器同时处理多个大体积文件的下载请求，而无须占用大量带宽。&lt;/p&gt;

&lt;p&gt;Bittorrent 中文协议1,2,3,4是有中心化的
  &lt;a href=&#34;https://blog.csdn.net/xxxxxx91116/article/details/8544365?locationnum=14&#34; target=&#34;_blank&#34;&gt;Bittorrent协议中文版一&lt;/a&gt;
  &lt;a href=&#34;https://blog.csdn.net/xxxxxx91116/article/details/8544366&#34; target=&#34;_blank&#34;&gt;Bittorrent协议中文版二&lt;/a&gt;
  &lt;a href=&#34;https://blog.csdn.net/xxxxxx91116/article/details/8544367&#34; target=&#34;_blank&#34;&gt;Bittorrent协议中文版三&lt;/a&gt;
  &lt;a href=&#34;https://blog.csdn.net/xxxxxx91116/article/details/8544370&#34; target=&#34;_blank&#34;&gt;Bittorrent协议中文版四&lt;/a&gt;
  BitTorrent DHT 协议是扩充协议没有中心化的
  &lt;a href=&#34;https://www.jianshu.com/p/ffeed4801b0e&#34; target=&#34;_blank&#34;&gt;Bittorrent DHT 去中心化协议&lt;/a&gt;
  关键名词&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;peers: 在本文档中，一个 peer 可以是任何参与下载的 BitTorrent 客户端&lt;/li&gt;
&lt;li&gt;tracker 是一个响应HTTP GET请求的HTTP/HTTPS服务&lt;/li&gt;
&lt;li&gt;node 是一个dht节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;中心化原理&#34;&gt;中心化原理&lt;/h2&gt;

&lt;p&gt;参考 Bittorrent协议中文1,2,3,4原理tracker
    &lt;a href=&#34;https://blog.csdn.net/xxxxxx91116/article/details/8544367&#34; target=&#34;_blank&#34;&gt;Bittorrent协议中文版三&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;去中心化原理&#34;&gt;去中心化原理&lt;/h2&gt;

&lt;p&gt;去中心化，即，不存在数据中心，每个节点的信息存储能力都是对等的，存储的内容都是一致的，账目是公开的（这个公开我也不是很理解，我认为应该是有一定的加密机制）。进行支付时，用户只需要向任意一个节点发送支付信息，网络中的各节点是对等的，它们最终会对如何记录这笔支付达成共识，将这笔支付记入一个公开账本。从这个角度说，去中心化可以提升安全性、提升效率、提升资源利用率，降低系统运行成本&lt;/p&gt;

&lt;h3 id=&#34;dht-kademlia&#34;&gt;DHT/kademlia&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/mergerly/article/details/7989281&#34; target=&#34;_blank&#34;&gt;P2P中DHT网络介绍&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;nat&#34;&gt;NAT&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/my_life/articles/1908552.html&#34; target=&#34;_blank&#34;&gt;NAT 的四种类型&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Full Cone NAT&lt;/li&gt;
&lt;li&gt;Restricted Cone NAT&lt;/li&gt;
&lt;li&gt;Port Restricted Cone NAT&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Symmetric NAT&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;ipfs-libp2p&#34;&gt;IPFS/libp2p&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/libp2p/specs&#34; target=&#34;_blank&#34;&gt;IPFS/libp2p结构文档&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;去中心化流媒体应用livepeer&#34;&gt;去中心化流媒体应用livepeer&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/livepeer/go-livepeer&#34; target=&#34;_blank&#34;&gt;livepeer源码&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>学习 libp2p</title>
      <link>https://xueqing.github.io/blog/p2p/libp2p/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/blog/p2p/libp2p/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%84%bf%e6%99%af&#34;&gt;愿景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%ae%e6%a0%87&#34;&gt;目标&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bd%91%e7%bb%9c%e5%a0%86%e6%a0%88%e6%8a%80%e6%9c%af%e7%8e%b0%e7%8a%b6%e5%88%86%e6%9e%90&#34;&gt;网络堆栈技术现状分析&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%a2%e6%88%b7%e7%ab%af-%e6%9c%8d%e5%8a%a1%e7%ab%afcs%e6%a8%a1%e5%9e%8b&#34;&gt;客户端-服务端（C/S）模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8c%89%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88%e5%af%b9%e7%bd%91%e7%bb%9c%e5%88%86%e7%b1%bb&#34;&gt;按解决方案对网络分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%ae%e5%89%8d%e7%9a%84%e7%bc%ba%e7%82%b9&#34;&gt;目前的缺点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a6%81%e6%b1%82&#34;&gt;要求&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%bf%e5%90%8d%e4%bc%a0%e8%be%93&#34;&gt;匿名传输&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%9a%e7%a7%8d%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8multi-multiplexing&#34;&gt;多种多路复用（multi-multiplexing）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8a%a0%e5%af%86&#34;&gt;加密&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nat-%e9%81%8d%e5%8e%86traversal&#34;&gt;NAT 遍历（traversal）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ad%e7%bb%a7relay&#34;&gt;中继（relay）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%90%af%e7%94%a8%e5%a4%9a%e4%b8%aa%e7%bd%91%e7%bb%9c%e6%8b%93%e6%89%91&#34;&gt;启用多个网络拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b5%84%e6%ba%90%e5%8f%91%e7%8e%b0&#34;&gt;资源发现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b6%88%e6%81%af&#34;&gt;消息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e5%90%8d&#34;&gt;命名&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%b6%e6%9e%84&#34;&gt;架构&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%8a%82%e7%82%b9%e8%b7%af%e7%94%b1&#34;&gt;节点路由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9b%86%e7%be%a4&#34;&gt;集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%86%e5%b8%83%e5%bc%8f%e8%ae%b0%e5%bd%95%e5%ad%98%e5%82%a8&#34;&gt;分布式记录存储&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%91%e7%8e%b0&#34;&gt;发现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mdns-discovery&#34;&gt;mDNS-discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#random-walk&#34;&gt;random-walk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bootstrap-list&#34;&gt;bootstrap-list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b6%88%e6%81%af-%e6%9e%b6%e6%9e%84&#34;&gt;消息-架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85&#34;&gt;发布订阅&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e5%90%8d-%e6%9e%b6%e6%9e%84&#34;&gt;命名-架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#iprs&#34;&gt;IPRS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipns&#34;&gt;IPNS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84&#34;&gt;数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3&#34;&gt;接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%89%b9%e6%80%a7&#34;&gt;特性&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%80%9a%e4%bf%a1%e6%a8%a1%e5%9e%8b-%e6%b5%81&#34;&gt;通信模型-流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ab%af%e5%8f%a3-%e5%8f%97%e9%99%90%e5%85%a5%e5%8f%a3&#34;&gt;端口-受限入口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bc%a0%e8%be%93%e5%8d%8f%e8%ae%ae&#34;&gt;传输协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9d%9e-ip-%e7%bd%91%e7%bb%9c&#34;&gt;非 IP 网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bd%91%e7%ba%bf&#34;&gt;网线&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%9e%e7%8e%b0&#34;&gt;实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;解决兼容性问题：分布式文件系统运行的网络配置、网络性能、设备不同&lt;/p&gt;

&lt;h3 id=&#34;愿景&#34;&gt;愿景&lt;/h3&gt;

&lt;p&gt;建立分布式系统，由开发者决定在网络中的交互，以及支持的配置和扩展性&lt;/p&gt;

&lt;h3 id=&#34;目标&#34;&gt;目标&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;支持多种协议：

&lt;ul&gt;
&lt;li&gt;传输：TCP，UDP，STCP，UDT，uTP，QUIC，SSH 等&lt;/li&gt;
&lt;li&gt;认证的传输：TLS，DTLS，CurveCPU，SSH&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有效使用套接字（连接复用 connection reuse）&lt;/li&gt;
&lt;li&gt;支持 peer 之间的通讯可以通过一个套接字复用（multiplex）（避免握手的负载）&lt;/li&gt;
&lt;li&gt;支持 peer 之间通过协商过程，使用不同的协议或者不同的版本&lt;/li&gt;
&lt;li&gt;向后兼容&lt;/li&gt;
&lt;li&gt;在现有系统上运行&lt;/li&gt;
&lt;li&gt;使用现有网络技术的所有能力&lt;/li&gt;
&lt;li&gt;有 NAT 穿墙（raversal）&lt;/li&gt;
&lt;li&gt;支持连接中继（relay）&lt;/li&gt;
&lt;li&gt;支持加密的通道（channel）&lt;/li&gt;
&lt;li&gt;有效使用底层传输（如 native stream muxing，native auth）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;网络堆栈技术现状分析&#34;&gt;网络堆栈技术现状分析&lt;/h2&gt;

&lt;p&gt;分析网络栈可用的协议和架构&lt;/p&gt;

&lt;h3 id=&#34;客户端-服务端-c-s-模型&#34;&gt;客户端-服务端（C/S）模型&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;C/S 模型表明通道两端承担不同的角色，支持不同的服务，或者具有不同的能力&lt;/li&gt;
&lt;li&gt;C/S 应用成为趋势的原因

&lt;ul&gt;
&lt;li&gt;数据中心的带宽比相互连接的客户端之间的带宽高很多&lt;/li&gt;
&lt;li&gt;数据中心的资源更便宜，因为利用充分以及存储量大（bulk stocking）&lt;/li&gt;
&lt;li&gt;开发者和系统管理更容易拥有对应用的较好的细粒度控制&lt;/li&gt;
&lt;li&gt;减少了要处理的异构系统的数目（数字仍然很大）&lt;/li&gt;
&lt;li&gt;像 NAT 的系统使得客户端机器很难找到彼此并且互相通信，迫使开发者解决这些问题&lt;/li&gt;
&lt;li&gt;协议开始设计的前提是开发者会开发一个C/S应用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;libp2p 在拨号者-监听者（dialer-listener）交互上前进了一步

&lt;ul&gt;
&lt;li&gt;不明确 dialer 和 listener 各自的功能以及可以执行的操作&lt;/li&gt;
&lt;li&gt;dialer 和 listener 可以独立地执行请求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;按解决方案对网络分类&#34;&gt;按解决方案对网络分类&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;传统的 7 层 OSI 模型不适用于 libp2p，OSI 模型按照通讯功能划分

&lt;ul&gt;
&lt;li&gt;物理层 Physical Layer：通过物理介质传输比特流&lt;/li&gt;
&lt;li&gt;数据链路层 Data Link Layer：将比特组合成字节，再将字节组合成帧，使用链路层地址访问介质，并进行差错检测&lt;/li&gt;
&lt;li&gt;逻辑链路控制子层 LLC：定义一些字段使上层协议可以共享数据链路层，不是必须的&lt;/li&gt;
&lt;li&gt;媒体访问控制子层 MAC：处理 CSMA/CD 算法、数据出错校验、成帧等&lt;/li&gt;
&lt;li&gt;网络层 Network Layer：通过 IP 寻址建立两个节点之间的连接&lt;/li&gt;
&lt;li&gt;传输层 Transport Layer：建立主机端到端的链接，为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等&lt;/li&gt;
&lt;li&gt;会话层 Session Layer：负责建立、管理和终止表示层实体之间的通话会。由不同设备中的应用程序之间的服务请求和响应组成&lt;/li&gt;
&lt;li&gt;表示层 Presentation Layer：提供各种用于应用层数据的编码和转换功能，确保一个系统的应用层发送的数据能被另一个系统的应用层识别&lt;/li&gt;
&lt;li&gt;应用层 Application Layer：为计算机用户提供应用接口，也为用户直接提供各种网络服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;libp2p 根据角色将协议分类

&lt;ul&gt;
&lt;li&gt;建立物理链路：Ethernet，Wi-Fi，Bluetooth，USB&lt;/li&gt;
&lt;li&gt;寻址一个机器或程序：IPv4，IPv6，隐藏的寻址（无 SDP）&lt;/li&gt;
&lt;li&gt;发现其他 peer 或服务：ARP，DHCP，DNS，Onion&lt;/li&gt;
&lt;li&gt;通过网络路由消息：RIP(1,2)，OSPF，BGP，PPP，Tor，I2P，cjdns&lt;/li&gt;
&lt;li&gt;传输：TCP，UDP，UDT，QUIC，WebRTC 数据通道&lt;/li&gt;
&lt;li&gt;商定应用通讯的语义：RMI，Remoting，RPC，HTTP&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;目前的缺点&#34;&gt;目前的缺点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;大量的协议和解决方案使得让一个应用支持多种传输或通过多种传输并可用比较困难

&lt;ul&gt;
&lt;li&gt;如浏览器应用缺少 TCP/UDP 栈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一个 peer 不能在不同传输 announce 自己，使得其他的 peer 确信是同一个 peer&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;要求&#34;&gt;要求&lt;/h2&gt;

&lt;h3 id=&#34;匿名传输&#34;&gt;匿名传输&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;为了推理可能的传输，libp2p 使用多地址（multiaddr），一种自描述的地址格式

&lt;ul&gt;
&lt;li&gt;libp2p 可以在系统的任何地方将地址视为不透明的，支持网络层的不同传输协议&lt;/li&gt;
&lt;li&gt;libp2p 的地址格式是 ipfs-addr，以 IPFS 的节点 ID 结尾的多地址&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;目前，没有不可靠的实现存在。即定义和使用不可靠的传输协议接口未被定义&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;多种多路复用-multi-multiplexing&#34;&gt;多种多路复用（multi-multiplexing）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;libp2p 收集了多种协议，为了保留资源，是的建立连接更容易，libp2p 可以在一个端口（TCP 或 UDP，取决于使用的传输）上执行所有的操作&lt;/li&gt;
&lt;li&gt;libp2p 可以通过一个端到端的连接复用多种协议。这个复用包括可靠的流和不可靠的数据包&lt;/li&gt;
&lt;li&gt;libp2p 网络层提供的多路复用包括

&lt;ul&gt;
&lt;li&gt;可以复用多个监听网络接口&lt;/li&gt;
&lt;li&gt;可以复用多个传输协议&lt;/li&gt;
&lt;li&gt;每个 peer 可以复用多个连接&lt;/li&gt;
&lt;li&gt;可以复用多个客户端协议&lt;/li&gt;
&lt;li&gt;每个协议，每个连接可以复用多个流&lt;/li&gt;
&lt;li&gt;具有流控制（backpressure，fairness）&lt;/li&gt;
&lt;li&gt;用不同的短暂的 key 为每个连接加密&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;加密&#34;&gt;加密&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;libp2p 中的通讯是三种状态

&lt;ul&gt;
&lt;li&gt;加密的&lt;/li&gt;
&lt;li&gt;签名的（未加密）&lt;/li&gt;
&lt;li&gt;清楚的（未加密，未签名）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于一些性能要求高的数据中心，加密是不可行的。建议

&lt;ul&gt;
&lt;li&gt;实现默认为所有的通讯加密&lt;/li&gt;
&lt;li&gt;实现是审核的（audited）&lt;/li&gt;
&lt;li&gt;除非绝对必须，用户通常只操作加密的通讯&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;nat-遍历-traversal&#34;&gt;NAT 遍历（traversal）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;NAT（Network Address Translation，网络地址转换）在互联网普遍存在

&lt;ul&gt;
&lt;li&gt;大部分消费者设备在很多层的 NAT 后面&lt;/li&gt;
&lt;li&gt;大多数数据中心节点尝尝处于安全或虚拟化原因也在 NAT 后面&lt;/li&gt;
&lt;li&gt;在基于容器的部署阶段，这个现象更加普遍&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IPFS 的实现应该提高一种方式来遍历 NAT，否则操作会受影响，即使是在真实 IP 地址运行的节点也要实现 NAT 遍历，因为节点可能需要和 NAT 之后的节点建立连接&lt;/li&gt;
&lt;li&gt;libp2p 使用 ICE-like 的协议实现完全的 NAT 遍历

&lt;ul&gt;
&lt;li&gt;不是真的 ICE，因为 IPFS 网络可能为了 hole-punching 或者中继通讯通过 IPFS 协议中继通讯&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;建议使用一些现有的 NAT 遍历库来实现：libnice，libwebrtc，natty&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;中继-relay&#34;&gt;中继（relay）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;由于对称的 NAT，容器和 VM NAT，以及其他的 impossible-to-bypass 的 NAT，libp2p 必须中继通讯以建立完整的连接图&lt;/li&gt;
&lt;li&gt;因此，实现必须支持中继，虽然可能是可选的，而且可能被终端用户拒绝&lt;/li&gt;
&lt;li&gt;连接中继应该作为传输实现，以便于传给上层&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;启用多个网络拓扑&#34;&gt;启用多个网络拓扑&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;P2P 的拓扑分为：

&lt;ul&gt;
&lt;li&gt;unstructed 无结构的：网络是完全随机的，或者不确定的&lt;/li&gt;
&lt;li&gt;structed 结构化的：有一种隐式的方式来识别网络节点&lt;/li&gt;
&lt;li&gt;hybrid 混合的：无结构和结构化的拓扑混合&lt;/li&gt;
&lt;li&gt;centralized 中心化的：中心化的拓扑是 web 应用框架中最常见的，它要求一个或一些指定的服务在已知的静态位置一直存在&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;libp2p 必须执行不同的路由机制和 peer 的发现，以便建立路由表&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;资源发现&#34;&gt;资源发现&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;libp2p 通过记录（records）解决王路内部的资源发现问题

&lt;ul&gt;
&lt;li&gt;一个 record 是一个数据单元，可以按位签名，加时间戳或/和使用其他方法给它一个时效性&lt;/li&gt;
&lt;li&gt;这些 records 持有信息包括网络中的位置、资源的有效性等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;资源可以是数字，存储，CPU 周期和其他类型的服务&lt;/li&gt;
&lt;li&gt;libp2p 不能限制资源的位置，但是提供方式简单的发现网络中的资源或者使用一个 side channel&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;消息&#34;&gt;消息&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;有效的消息协议提供方法来发送消息，使得延迟最小，且/或支持庞大复杂的拓扑以便于分布式&lt;/li&gt;
&lt;li&gt;libp2p 结合 Multicast 和 PubSub 来实现这些需求&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命名&#34;&gt;命名&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;网络变化和应用可以使用网络以使得对于拓扑是匿名的，命名用于解决这个问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;libp2p 包括多个子系统。这些子系统可以遵循统一的接口建立在其他子系统之上

&lt;ul&gt;
&lt;li&gt;Peer Routing：节点路由。这个机制决定使用哪些节点来路由指定的消息。路由可以是递归的、迭代的，甚至是广播或多播的模式&lt;/li&gt;
&lt;li&gt;Swarm：集群。处理 libp2p2 中和打开流相关的部分，包括多传输过程中的协议复用，流复用，NAT 遍历，连接中继&lt;/li&gt;
&lt;li&gt;Distributed Record Store：分布式记录存储。存储和分发记录的系统。记录是指被其他吸烟使用的小的条目，用于发送信号，建立链路，announce 节点或内容等。和网络中的 DNS 类似&lt;/li&gt;
&lt;li&gt;Discovery：发现。发现和识别网络中的其他节点&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;节点路由&#34;&gt;节点路由&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;子系统暴露了一个接口来识别一个消息应该被路由到 DHT 中的哪些节点：接收一个 key，返回一个或多个 PeerInfo 对象

&lt;ul&gt;
&lt;li&gt;kad-routing：基于 Kademlia DHT，实现了 Kademlia 路由表，每个节点持有一个 k-bucket 的集合。每个k-bucket 包含几个 PeerInfo 对象&lt;/li&gt;
&lt;li&gt;mDNS-routing：使用 mDNS 探测和识别，当局域网内的节点有一个指定的 key 或者节点容易出现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;集群&#34;&gt;集群&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Stream Muxer：必须实现 &lt;a href=&#34;https://github.com/libp2p/interface-stream-muxer&#34; target=&#34;_blank&#34;&gt;interface-stream-muxer&lt;/a&gt; 中的接口&lt;/li&gt;
&lt;li&gt;Protocol Muxer：在应用层被处理而不是传统的端口层（不同的服务或协议监听不同的端口）。使得我们支持多种协议在一个套接字被复用，节约了多端口 NAT 遍历的花费

&lt;ul&gt;
&lt;li&gt;协议复用通过 &lt;a href=&#34;https://github.com/multiformats/multistream-select&#34; target=&#34;_blank&#34;&gt;multistream&lt;/a&gt; 完成，一个协议和不同的流协商使用 &lt;a href=&#34;https://github.com/multiformats/multicodec&#34; target=&#34;_blank&#34;&gt;multicodec&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Transport：传输&lt;/li&gt;
&lt;li&gt;Crypto：加密&lt;/li&gt;
&lt;li&gt;Identify：鉴别是 Swarm 之上的一些协议，是 Connection Handler。使得节点之间可以互换监听者地址(listenAddrs)和观察者(observeAddrs)地址。因为每个开放的套接字会实现 REUSEPORT，另一个节点的 ObserveAddr 可以使得第三个节点连接进来，因为端口已经是开放的，可以在 NAT 上重定向到开放的端口&lt;/li&gt;
&lt;li&gt;Relay：中继，参考 &lt;a href=&#34;https://github.com/libp2p/specs/tree/master/relay&#34; target=&#34;_blank&#34;&gt;Circuit Relay&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;分布式记录存储&#34;&gt;分布式记录存储&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Record&lt;/li&gt;
&lt;li&gt;abstract-record-store&lt;/li&gt;
&lt;li&gt;kad-record-store&lt;/li&gt;
&lt;li&gt;mDNS-record-store&lt;/li&gt;
&lt;li&gt;s3-record-store&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;发现&#34;&gt;发现&lt;/h3&gt;

&lt;p&gt;发现和识别网络中的其他节点&lt;/p&gt;

&lt;h4 id=&#34;mdns-discovery&#34;&gt;mDNS-discovery&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;mDNS-discovery 是局域网内使用 mDNS 的一个发现协议。它发射一个 mDNS 信号来发现是否有更多可用的节点。局域网内的节点对于 peer-to-peer 是非常有用的，因为链路延迟更低&lt;/li&gt;
&lt;li&gt;mDNS-discovery 是一个独立的协议，不依靠 libp2p2 中的其他协议。可以不依赖其他底层架构在局域网内生成可用的节点&lt;/li&gt;
&lt;li&gt;mDNS-discovery 可为每个服务配置，也可以在私有网络配置&lt;/li&gt;
&lt;li&gt;原始的 mDNS 会暴露本地 IP 地址，正在设法加密 mDNS-discovery 信号，使得局域网内其他节点不能识别正在使用的服务

&lt;ul&gt;
&lt;li&gt;不建议将 mDNS-discovery 应用到隐私敏感的应用或者未知到路由协议&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;random-walk&#34;&gt;random-walk&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;random-walk 是应用于 DHT （或其他有路由表的协议）的发现协议。它生成随机的 DHt 请求以快速了解大量的节点&lt;/li&gt;
&lt;li&gt;这个会在一开始的时候花费一些负载，但是可以使得 DHT （或其他协议）更快聚合&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;bootstrap-list&#34;&gt;bootstrap-list&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;bootstrap-list 是用本地存储来缓存网络中的高稳定（或信任的）节点的发现协议

&lt;ul&gt;
&lt;li&gt;列表应当被存储在对于本地节点来说是长期的本地存储&lt;/li&gt;
&lt;li&gt;在大部分情况下应该是可以用户配置的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;消息-架构&#34;&gt;消息-架构&lt;/h3&gt;

&lt;h4 id=&#34;发布订阅&#34;&gt;发布订阅&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;PubSub 参考 &lt;a href=&#34;https://github.com/libp2p/specs/tree/master/pubsub&#34; target=&#34;_blank&#34;&gt;pubsub&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/libp2p/specs/tree/master/pubsub/gossipsub&#34; target=&#34;_blank&#34;&gt;pubsub/gossippub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命名-架构&#34;&gt;命名-架构&lt;/h3&gt;

&lt;h4 id=&#34;iprs&#34;&gt;IPRS&lt;/h4&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://github.com/libp2p/specs/blob/master/IPRS.md&#34; target=&#34;_blank&#34;&gt;IPRS spec&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;ipns&#34;&gt;IPNS&lt;/h4&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;p&gt;网络协议处理的数据结构包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;PrivateKey：节点的私钥&lt;/li&gt;
&lt;li&gt;PublicKey：节点的公钥&lt;/li&gt;
&lt;li&gt;PeerId：节点公钥的一个哈希&lt;/li&gt;
&lt;li&gt;PeerInfo：一个对象，包含节点的 PeerId 和已知的多地址&lt;/li&gt;
&lt;li&gt;Transport：用于和其他 peer 建立连接的传输，必须实现 &lt;a href=&#34;https://github.com/libp2p/interface-transport&#34; target=&#34;_blank&#34;&gt;interface-transport&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Connection：两个 node 之间的一个 point-to-point 链路，必须实现 &lt;a href=&#34;https://github.com/libp2p/interface-connection&#34; target=&#34;_blank&#34;&gt;interface-connection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Muxed-Stream：一个双向（duplex）的消息通道&lt;/li&gt;
&lt;li&gt;Stream-Muxer：流复用器，必须实现 &lt;a href=&#34;https://github.com/libp2p/interface-stream-muxer&#34; target=&#34;_blank&#34;&gt;interface-stream-muxer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Record：LPLD（IPFS Linked Data）描述的对象，实现 &lt;a href=&#34;https://github.com/libp2p/specs/blob/master/IPRS.md&#34; target=&#34;_blank&#34;&gt;IPRS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;multiaddr：自描述的网络地址，参考 &lt;a href=&#34;https://github.com/multiformats/multiaddr&#34; target=&#34;_blank&#34;&gt;multiaddr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;multicodec：自描述的编码类型，参考 &lt;a href=&#34;https://github.com/multiformats/multicodec&#34; target=&#34;_blank&#34;&gt;multicodec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;multihash：自描述的哈希，参考 &lt;a href=&#34;https://github.com/multiformats/multihash&#34; target=&#34;_blank&#34;&gt;multihash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;接口&#34;&gt;接口&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;libp2p&lt;/li&gt;
&lt;li&gt;传输&lt;/li&gt;
&lt;li&gt;链接&lt;/li&gt;
&lt;li&gt;流多路复用器&lt;/li&gt;
&lt;li&gt;集群&lt;/li&gt;
&lt;li&gt;节点发现&lt;/li&gt;
&lt;li&gt;节点路由&lt;/li&gt;
&lt;li&gt;内容路由

&lt;ul&gt;
&lt;li&gt;接口-分布式记录存储&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;libp2p 接口和 UX&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;特性&#34;&gt;特性&lt;/h2&gt;

&lt;h3 id=&#34;通信模型-流&#34;&gt;通信模型-流&lt;/h3&gt;

&lt;h3 id=&#34;端口-受限入口&#34;&gt;端口-受限入口&lt;/h3&gt;

&lt;h3 id=&#34;传输协议&#34;&gt;传输协议&lt;/h3&gt;

&lt;h3 id=&#34;非-ip-网络&#34;&gt;非 IP 网络&lt;/h3&gt;

&lt;h3 id=&#34;网线&#34;&gt;网线&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;协议复用-同一个流上运行多个协议

&lt;ul&gt;
&lt;li&gt;多流-自描述协议流，为协议定义一个协议头&lt;/li&gt;
&lt;li&gt;多流选择器-自描述协议流选择器&lt;/li&gt;
&lt;li&gt;允许列举和选择其他协议。协议复用有一个注册协议的列表，监听一个协议，然后包装或升级连接来描述注册的协议&lt;/li&gt;
&lt;li&gt;直接利用了多流，可以交替多个协议，检查远端可能使用的协议&lt;/li&gt;
&lt;li&gt;流复用-通过一个网线运行多个独立流&lt;/li&gt;
&lt;li&gt;将多个流复用或合并成一个单独的流&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;便携式编码-使用便携的序列格式

&lt;ul&gt;
&lt;li&gt;目前使用 protobuf，候选的还有 capnp，bson，ubjson&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;安全通信-使用加密算法建立安全和隐私（像 TLS）&lt;/li&gt;
&lt;li&gt;协议多解码（multicodecs）&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
</description>
    </item>
    
  </channel>
</rss>
