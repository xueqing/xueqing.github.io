<!DOCTYPE html>
<html lang="zh-Hans">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.5.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="kiki">

  
  
  
    
  
  <meta name="description" content="1.让自己习惯 C&#43;&#43; 01.视 C&#43;&#43; 为一个语言联邦 02.常量，枚举和内联优于宏定义 03.尽可能使用常量 04.确定对象被使用前已先被初始化 2.构造/析构">

  
  <link rel="alternate" hreflang="zh-Hans" href="https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/">

  


  
  
  
  <meta name="theme-color" content="#ff3860">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    

    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  




  


  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon-32.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/">

  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="kiki">
  <meta property="og:url" content="https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/">
  <meta property="og:title" content="Effective C&#43;&#43;, 3rd | kiki">
  <meta property="og:description" content="1.让自己习惯 C&#43;&#43; 01.视 C&#43;&#43; 为一个语言联邦 02.常量，枚举和内联优于宏定义 03.尽可能使用常量 04.确定对象被使用前已先被初始化 2.构造/析构"><meta property="og:image" content="https://xueqing.github.io/img/icon-192.png">
  <meta property="twitter:image" content="https://xueqing.github.io/img/icon-192.png"><meta property="og:locale" content="zh-Hans">
  
    
    
  

  



  


  


  





  <title>Effective C&#43;&#43;, 3rd | kiki</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>搜索</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="搜索..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0 compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">kiki</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="切换导航">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>主页</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link  active" href="/blog/"><span>博客</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/translation/"><span>翻译</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        

        <li class="nav-item">
          <a class="nav-link " href="/reading/"><span>阅读</span></a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>Effective C&#43;&#43;, 3rd</h1>

  

  
    


<div class="article-metadata">

  
  
  
  
  <div>
    



  
  <span><a href="/authors/kiki/">kiki</a></span>

  </div>
  
  

  
  <span class="article-date">
    
    
      
    
    Jan 1, 0001
  </span>
  

  

  

  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/categories/blog/">blog</a></span>
  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      

<ul>
<li><a href="#1%e8%ae%a9%e8%87%aa%e5%b7%b1%e4%b9%a0%e6%83%af-c">1.让自己习惯 C++</a>

<ul>
<li><a href="#01%e8%a7%86-c-%e4%b8%ba%e4%b8%80%e4%b8%aa%e8%af%ad%e8%a8%80%e8%81%94%e9%82%a6">01.视 C++ 为一个语言联邦</a></li>
<li><a href="#02%e5%b8%b8%e9%87%8f%e6%9e%9a%e4%b8%be%e5%92%8c%e5%86%85%e8%81%94%e4%bc%98%e4%ba%8e%e5%ae%8f%e5%ae%9a%e4%b9%89">02.常量，枚举和内联优于宏定义</a></li>
<li><a href="#03%e5%b0%bd%e5%8f%af%e8%83%bd%e4%bd%bf%e7%94%a8%e5%b8%b8%e9%87%8f">03.尽可能使用常量</a></li>
<li><a href="#04%e7%a1%ae%e5%ae%9a%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%bd%bf%e7%94%a8%e5%89%8d%e5%b7%b2%e5%85%88%e8%a2%ab%e5%88%9d%e5%a7%8b%e5%8c%96">04.确定对象被使用前已先被初始化</a></li>
</ul></li>
<li><a href="#2%e6%9e%84%e9%80%a0%e6%9e%90%e6%9e%84%e8%b5%8b%e5%80%bc%e8%bf%90%e7%ae%97">2.构造/析构/赋值运算</a>

<ul>
<li><a href="#05%e4%ba%86%e8%a7%a3-c-%e9%bb%98%e9%bb%98%e7%bc%96%e5%86%99%e5%b9%b6%e8%b0%83%e7%94%a8%e5%93%aa%e4%ba%9b%e5%87%bd%e6%95%b0">05.了解 C++ 默默编写并调用哪些函数</a></li>
<li><a href="#06%e6%98%8e%e7%a1%ae%e6%8b%92%e7%bb%9d%e4%b8%8d%e6%83%b3%e7%94%a8%e7%9a%84%e7%bc%96%e8%af%91%e5%99%a8%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e7%9a%84%e5%87%bd%e6%95%b0">06.明确拒绝不想用的编译器自动生成的函数</a></li>
<li><a href="#07%e5%a3%b0%e6%98%8e%e5%a4%9a%e6%80%81%e5%9f%ba%e7%b1%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0%e4%b8%ba%e8%99%9a%e5%87%bd%e6%95%b0">07.声明多态基类析构函数为虚函数</a></li>
<li><a href="#08%e5%88%ab%e8%ae%a9%e5%bc%82%e5%b8%b8%e9%80%83%e7%a6%bb%e6%9e%90%e6%9e%84%e5%87%bd%e6%95%b0">08.别让异常逃离析构函数</a></li>
<li><a href="#09%e7%bb%9d%e4%b8%8d%e5%9c%a8%e6%9e%84%e9%80%a0%e5%92%8c%e6%9e%90%e6%9e%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e8%b0%83%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0">09.绝不在构造和析构过程中调用虚函数</a></li>
<li><a href="#10%e4%bd%bf-operator-%e8%bf%94%e5%9b%9e%e4%b8%80%e4%b8%aa-this-%e7%9a%84%e5%bc%95%e7%94%a8">10.使 operator= 返回一个 *this 的引用</a></li>
<li><a href="#11%e5%9c%a8-operator-%e4%b8%ad%e5%a4%84%e7%90%86%e8%87%aa%e6%88%91%e8%b5%8b%e5%80%bc">11.在 operator= 中处理“自我赋值”</a></li>
<li><a href="#12%e5%a4%8d%e5%88%b6%e5%af%b9%e8%b1%a1%e7%9a%84%e6%89%80%e6%9c%89%e9%83%a8%e5%88%86">12.复制对象的所有部分</a></li>
</ul></li>
<li><a href="#3%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86">3.资源管理</a>

<ul>
<li><a href="#13%e4%bb%a5%e5%af%b9%e8%b1%a1%e7%ae%a1%e7%90%86%e8%b5%84%e6%ba%90">13.以对象管理资源</a></li>
<li><a href="#14%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e5%b0%8f%e5%bf%83%e5%a4%8d%e5%88%b6%e8%a1%8c%e4%b8%ba">14.在资源管理类中小心复制行为</a></li>
<li><a href="#15%e5%9c%a8%e8%b5%84%e6%ba%90%e7%ae%a1%e7%90%86%e7%b1%bb%e4%b8%ad%e6%8f%90%e4%be%9b%e5%af%b9%e5%8e%9f%e5%a7%8b%e8%b5%84%e6%ba%90%e7%9a%84%e8%ae%bf%e9%97%ae">15.在资源管理类中提供对原始资源的访问</a></li>
<li><a href="#16%e5%9c%a8%e5%af%b9%e5%ba%94%e7%9a%84-new-%e5%92%8c-delete-%e9%87%87%e7%94%a8%e7%9b%b8%e5%90%8c%e5%bd%a2%e5%bc%8f">16.在对应的 new 和 delete 采用相同形式</a></li>
<li><a href="#17-%e4%bb%a5%e7%8b%ac%e7%ab%8b%e8%af%ad%e5%8f%a5%e5%b0%86-newed-%e5%af%b9%e8%b1%a1%e4%bf%9d%e5%ad%98%e5%88%b0%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88">17. 以独立语句将 newed 对象保存到智能指针</a></li>
</ul></li>
<li><a href="#4%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%a3%b0%e6%98%8e">4.设计与声明</a>

<ul>
<li><a href="#18%e8%ae%a9%e6%8e%a5%e5%8f%a3%e6%98%93%e8%a2%ab%e6%ad%a3%e5%b8%b8%e4%bd%bf%e7%94%a8%e4%b8%8d%e6%98%93%e8%a2%ab%e8%af%af%e7%94%a8">18.让接口易被正常使用，不易被误用</a></li>
<li><a href="#19%e6%8a%8a%e7%b1%bb%e8%ae%be%e8%ae%a1%e7%9c%8b%e4%bd%9c%e7%b1%bb%e5%9e%8b%e8%ae%be%e8%ae%a1">19.把类设计看作类型设计</a></li>
<li><a href="#20%e5%b8%b8%e9%87%8f%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92%e4%bc%98%e4%ba%8e%e5%80%bc%e4%bc%a0%e9%80%92">20.常量引用传递优于值传递</a></li>
<li><a href="#21%e5%bf%85%e9%a1%bb%e8%bf%94%e5%9b%9e%e5%af%b9%e8%b1%a1%e6%97%b6%e4%b8%8d%e8%a6%81%e8%bf%94%e5%9b%9e%e5%bc%95%e7%94%a8">21.必须返回对象时，不要返回引用</a></li>
<li><a href="#22%e5%a3%b0%e6%98%8e%e6%95%b0%e6%8d%ae%e6%88%90%e5%91%98%e4%b8%ba%e7%a7%81%e6%9c%89%e7%9a%84">22.声明数据成员为私有的</a></li>
<li><a href="#23%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e4%bc%98%e4%ba%8e%e9%9d%9e%e6%88%90%e5%91%98%e9%9d%9e%e5%8f%8b%e5%85%83%e5%87%bd%e6%95%b0">23.成员函数优于非成员、非友元函数</a></li>
<li><a href="#24%e5%bd%93%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e9%9c%80%e5%ba%94%e7%94%a8%e5%88%b0%e6%89%80%e6%9c%89%e5%8f%82%e6%95%b0%e5%a3%b0%e6%98%8e%e4%b8%ba%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0">24.当类型转换需应用到所有参数，声明为非成员函数</a></li>
<li><a href="#25%e8%80%83%e8%99%91%e6%94%af%e6%8c%81%e4%b8%8d%e6%8a%9b%e5%bc%82%e5%b8%b8%e7%9a%84-swap-%e5%87%bd%e6%95%b0">25.考虑支持不抛异常的 swap 函数</a></li>
</ul></li>
<li><a href="#5%e5%ae%9e%e7%8e%b0">5.实现</a>

<ul>
<li><a href="#26%e5%b0%bd%e5%8f%af%e8%83%bd%e6%8e%a8%e8%bf%9f%e5%8f%98%e9%87%8f%e5%ae%9a%e4%b9%89">26.尽可能推迟变量定义</a></li>
<li><a href="#27%e6%9c%80%e5%b0%8f%e5%8c%96-cast-%e6%93%8d%e4%bd%9c">27.最小化 cast 操作</a></li>
<li><a href="#28%e9%81%bf%e5%85%8d%e8%bf%94%e5%9b%9e%e6%8c%87%e5%90%91%e5%af%b9%e8%b1%a1%e5%86%85%e9%83%a8%e7%9a%84%e5%8f%a5%e6%9f%84">28.避免返回指向对象内部的句柄</a></li>
<li><a href="#29%e5%8a%aa%e5%8a%9b%e5%86%99%e5%bc%82%e5%b8%b8%e5%ae%89%e5%85%a8%e7%9a%84%e4%bb%a3%e7%a0%81">29.努力写异常安全的代码</a></li>
<li><a href="#30%e4%ba%86%e8%a7%a3%e5%86%85%e8%81%94%e7%9a%84%e7%bb%86%e8%8a%82">30.了解内联的细节</a></li>
<li><a href="#31%e6%9c%80%e5%b0%8f%e5%8c%96%e6%96%87%e4%bb%b6%e7%bc%96%e8%af%91%e4%be%9d%e8%b5%96">31.最小化文件编译依赖</a></li>
</ul></li>
<li><a href="#6%e7%bb%a7%e6%89%bf%e4%b8%8e%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1%e8%ae%be%e8%ae%a1">6.继承与面向对象设计</a>

<ul>
<li><a href="#32%e7%a1%ae%e4%bf%9d%e5%85%ac%e6%9c%89%e7%bb%a7%e6%89%bf%e6%98%af%22is-a%22%e5%85%b3%e7%b3%bb">32.确保公有继承是&rdquo;is-a&rdquo;关系</a></li>
<li><a href="#33%e9%81%bf%e5%85%8d%e9%9a%90%e8%97%8f%e7%bb%a7%e6%89%bf%e7%9a%84%e5%90%8d%e5%ad%97">33.避免隐藏继承的名字</a></li>
<li><a href="#34%e5%8c%ba%e5%88%86%e6%8e%a5%e5%8f%a3%e7%bb%a7%e6%89%bf%e5%92%8c%e5%ae%9e%e7%8e%b0%e7%bb%a7%e6%89%bf">34.区分接口继承和实现继承</a></li>
<li><a href="#35%e8%80%83%e8%99%91%e8%99%9a%e5%87%bd%e6%95%b0%e7%9a%84%e6%9b%bf%e4%bb%a3">35.考虑虚函数的替代</a></li>
<li><a href="#36%e7%bb%9d%e4%b8%8d%e9%87%8d%e5%ae%9a%e4%b9%89%e7%bb%a7%e6%89%bf%e7%9a%84%e9%9d%9e%e8%99%9a%e5%87%bd%e6%95%b0">36.绝不重定义继承的非虚函数</a></li>
<li><a href="#37%e7%bb%9d%e4%b8%8d%e9%87%8d%e5%ae%9a%e4%b9%89%e5%87%bd%e6%95%b0%e7%bb%a7%e6%89%bf%e7%9a%84%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0%e5%80%bc">37.绝不重定义函数继承的默认参数值</a></li>
<li><a href="#38%e9%80%9a%e8%bf%87%e7%bb%84%e5%90%88%e5%af%b9%22has-a%22%e6%88%96%22is-implemented-in-terms-of%22%e5%bb%ba%e6%a8%a1">38.通过组合对&rdquo;has-a&rdquo;或&rdquo;is-implemented-in-terms-of&rdquo;建模</a></li>
<li><a href="#39%e6%85%8e%e9%87%8d%e4%bd%bf%e7%94%a8%e7%a7%81%e6%9c%89%e7%bb%a7%e6%89%bf">39.慎重使用私有继承</a></li>
<li><a href="#40%e6%85%8e%e9%87%8d%e4%bd%bf%e7%94%a8%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf">40.慎重使用多重继承</a></li>
</ul></li>
<li><a href="#7%e6%a8%a1%e6%9d%bf%e4%b8%8e%e6%b3%9b%e5%9e%8b%e7%bc%96%e7%a8%8b">7.模板与泛型编程</a>

<ul>
<li><a href="#41%e7%90%86%e8%a7%a3%e9%9a%90%e5%bc%8f%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%bc%96%e8%af%91%e6%9c%9f%e5%a4%9a%e6%80%81">41.理解隐式接口和编译期多态</a></li>
<li><a href="#42%e7%90%86%e8%a7%a3-typename-%e7%9a%84%e5%8f%8c%e9%87%8d%e5%ae%9a%e4%b9%89">42.理解 typename 的双重定义</a></li>
<li><a href="#43%e4%ba%86%e8%a7%a3%e5%a6%82%e4%bd%95%e8%ae%bf%e9%97%ae%e6%a8%a1%e6%9d%bf%e5%8c%96%e5%9f%ba%e7%b1%bb%e5%86%85%e7%9a%84%e5%90%8d%e7%a7%b0">43.了解如何访问模板化基类内的名称</a></li>
<li><a href="#44%e6%8a%8a%e5%8f%82%e6%95%b0%e6%97%a0%e5%85%b3%e7%9a%84%e4%bb%a3%e7%a0%81%e5%88%86%e7%a6%bb%e5%87%ba%e6%a8%a1%e6%9d%bf">44.把参数无关的代码分离出模板</a></li>
<li><a href="#45%e4%bd%bf%e7%94%a8%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0%e6%a8%a1%e6%9d%bf%e6%9d%a5%e6%8e%a5%e5%8f%97%e6%89%80%e6%9c%89%e5%85%bc%e5%ae%b9%e7%b1%bb%e5%9e%8b">45.使用成员函数模板来接受“所有兼容类型”</a></li>
<li><a href="#46%e9%9c%80%e8%a6%81%e7%b1%bb%e5%9e%8b%e8%bd%ac%e5%8c%96%e6%97%b6%e5%9c%a8%e6%a8%a1%e6%9d%bf%e5%86%85%e5%ae%9a%e4%b9%89%e9%9d%9e%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0">46.需要类型转化时在模板内定义非成员函数</a></li>
<li><a href="#47%e4%bd%bf%e7%94%a8-traits-class-%e8%a1%a8%e7%8e%b0%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af">47.使用 traits class 表现类型信息</a></li>
<li><a href="#48-%e8%ae%a4%e8%af%86%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b">48. 认识模板元编程</a></li>
</ul></li>
<li><a href="#8%e5%ae%9a%e5%88%b6-new-%e5%92%8c-delete">8.定制 new 和 delete</a>

<ul>
<li><a href="#49%e7%90%86%e8%a7%a3-new-handler-%e7%9a%84%e8%a1%8c%e4%b8%ba">49.理解 new-handler 的行为</a></li>
<li><a href="#50%e7%90%86%e8%a7%a3%e4%bd%95%e6%97%b6%e6%9b%bf%e6%8d%a2-new-%e5%92%8c-delete-%e6%9c%89%e6%84%8f%e4%b9%89">50.理解何时替换 new 和 delete 有意义</a></li>
<li><a href="#51%e5%86%99-new-%e5%92%8c-delete-%e6%97%b6%e9%81%b5%e5%be%aa%e6%83%af%e4%be%8b">51.写 new 和 delete 时遵循惯例</a></li>
<li><a href="#52%e5%86%99%e4%ba%86-placement-new-%e4%b9%9f%e8%a6%81%e5%86%99-placement-delete">52.写了 placement new 也要写 placement delete</a></li>
</ul></li>
<li><a href="#9%e6%9d%82%e9%a1%b9%e8%ae%a8%e8%ae%ba">9.杂项讨论</a>

<ul>
<li><a href="#53%e6%b3%a8%e6%84%8f%e7%bc%96%e8%af%91%e5%99%a8%e8%ad%a6%e5%91%8a">53.注意编译器警告</a></li>
<li><a href="#54%e7%86%9f%e6%82%89%e5%8c%85%e6%8b%ac-tr1-%e5%9c%a8%e5%86%85%e7%9a%84%e6%a0%87%e5%87%86%e5%ba%93">54.熟悉包括 TR1 在内的标准库</a></li>
<li><a href="#55%e7%86%9f%e6%82%89-boost">55.熟悉 Boost</a></li>
</ul></li>
</ul>

<h2 id="1-让自己习惯-c">1.让自己习惯 C++</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Accustoming yourself to C++</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="01-视-c-为一个语言联邦">01.视 C++ 为一个语言联邦</h3>

<blockquote>
<blockquote>
<blockquote>
<p>View C++ as a federation of languages</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>C</li>
<li>面向对象的 C++：类、封装、继承、多态</li>
<li>模板 C++：泛型编程</li>
<li>STL：模板库</li>
</ul>

<h3 id="02-常量-枚举和内联优于宏定义">02.常量，枚举和内联优于宏定义</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Prefer consts, enums, inlines to #defines</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>对于单纯常量，以 const 对象或枚举</li>
<li>对于形似函数的宏，用内联函数替换

<ul>
<li>常量、枚举和内联更具封装性，可以限定作用域</li>
<li>枚举比常量约束更多，不能为该常量创建指针或引用</li>
</ul></li>
</ul>

<h3 id="03-尽可能使用常量">03.尽可能使用常量</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Use const whenever possible</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>指定语义约束，即“不该被改动”的对象

<ul>
<li>可帮助编译器侦测错误用法</li>
</ul></li>
<li>const 在 * 左边，表示被指物是常量

<ul>
<li>也可将 const 放在类型之前</li>
<li>例如<code>const widget *pw</code>等同于<code>widget const *pw</code></li>
<li>指针所指东西不可被改动</li>
</ul></li>
<li>const 在 * 右边，表示指针自身是常量

<ul>
<li>指针不得指向不同的东西，但所指东西的值可以改动</li>
</ul></li>
<li>const 在 * 两侧，表示被指物和指针自身都是常量</li>
<li>const 成员函数

<ul>
<li>可作用于 const 对象，不可更改对象内任何非静态成员变量</li>
<li>成员变量前加<code>mutable</code>，也可在 const 成员函数内部修改该成员变量</li>
<li>当 const 和 non-const 成员函数有着实质等价的实现时，另 non-const 版本调用 const 版本避免代码重复</li>
</ul></li>
</ul>

<h3 id="04-确定对象被使用前已先被初始化">04.确定对象被使用前已先被初始化</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Make sure that objects are initialized before they&rsquo;re used</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>对于内置类型手动初始化</li>
<li>对于类，在构造函数中初始化成员变量

<ul>
<li>赋值不等于初始化</li>
<li>使用成员初始化列表列替换赋值动作，前者效率更高，后者先设初值再赋值</li>
<li>可使用无参数构造函数来初始化</li>
<li>对于多个构造函数，可添加私有成员函数，接收初始化参数，在函数内部使用赋值操作给成员变量“初始化”</li>
<li>初始化顺序</li>
<li>先基类再衍生类</li>
<li>类内部，按照声明的顺序初始化，与成员初始化列表列操作顺序无关</li>
<li>最好按照声明顺序初始化</li>
<li>不同编译单元内的 non-local static 对象的初始化顺序未定义

<ul>
<li>static 对象包括全局对象、定义于命名空间作用域内的对象、类内、函数内，以及在文件作用域内被声明为 static 的对象</li>
<li>函数内的 static 对象称为 local-static 对象，其他的则是 non-local static 对象</li>
<li>程序结束时 static 对象会被自动销毁，即在 main 函数结束时调用他们的析构函数</li>
<li>编译单元是产出单一目标文件的源码</li>
<li>将每个 non-local static 对象移到自己的专属函数内，改函数返回对该对象的引用，保证该函数被调用期间，首次遇到该对象的定义时被初始化，即以函数调用替换直接访问 non-local static 对象</li>
</ul></li>
</ul></li>
</ul>

<h2 id="2-构造-析构-赋值运算">2.构造/析构/赋值运算</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Contructors, destructors, and assignments operators</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="05-了解-c-默默编写并调用哪些函数">05.了解 C++ 默默编写并调用哪些函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Know what functions C++ silently writes and calls</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>编译器自动为类创建默认构造函数、拷贝构造函数、拷贝赋值操作和析构函数</li>
</ul>

<h3 id="06-明确拒绝不想用的编译器自动生成的函数">06.明确拒绝不想用的编译器自动生成的函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Explicitly disallow the use of complier-generated functions you do not want</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>如果不想用编译器自动生成的函数，可将相应的成员函数声明为 private 并且不予实现</li>

<li><p>可以继承 Uncopyable 这样的基类，但是可能会多重继承</p>

<pre><code class="language-c++">class Uncopyable {
protected: // allow constructor and destructor for derived object
Uncopyable() {}
~Uncopyable() {}
private:
Uncopyable(const Uncopyable&amp;); //avoid copying
Uncopyable&amp; operator=(const Uncopyable&amp;);
};
</code></pre></li>
</ul>

<h3 id="07-声明多态基类析构函数为虚函数">07.声明多态基类析构函数为虚函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Declare destructors virtual in polymorphic base classes</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>包含虚函数的类需要额外的信息来实现虚函数：vptr(virtual table pointer)指向一个由函数指针构成的数组，称为 vtbl(virtual table)，每个有虚函数的类都有一个相应的 vtbl</li>
<li>析构顺序：先父类再子类，构造函数的调用顺序相反</li>
<li>带有多态性质的基类应声明一个虚析构函数</li>
<li>如果一个类带有任何虚函数，就声明一个虚析构函数</li>
<li>类的设计目的不是作为基类使用，或者不是为了多态性，不应该声明虚析构函数</li>
</ul>

<h3 id="08-别让异常逃离析构函数">08.别让异常逃离析构函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Prevent exceptions from leaving destructors</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>如果析构函数内可能抛出异常，应该在析构函数内捕获异常，然后不传播或结束程序</li>
<li>如果需要客户自定义异常的反应，类应该提供接口执行该操作</li>
</ul>

<h3 id="09-绝不在构造和析构过程中调用虚函数">09.绝不在构造和析构过程中调用虚函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Never call virtual functions during construction or destruction</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>在构造和析构中不要调用虚函数没因为这类调用不会下降到衍生类，即调用的仍然是基类的实现</li>
</ul>

<h3 id="10-使-operator-返回一个-this-的引用">10.使 operator= 返回一个 *this 的引用</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Having assignment operators return a reference to *this</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>赋值相关运算(包括 operator=/+=、-=、*=)操作符返回一个 *this 的引用</li>
</ul>

<h3 id="11-在-operator-中处理-自我赋值">11.在 operator= 中处理“自我赋值”</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Handle assignment to self in operator=</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>确保对象自我赋值时，operator= 行为良好，包括比较源对象和目标对象的地址、精心周到的语句顺序(先复制源对象，再执行删除)，以及icopy-and-swap</li>
<li>确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，行为仍然正确</li>
</ul>

<h3 id="12-复制对象的所有部分">12.复制对象的所有部分</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Copy all parts of an object</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>拷贝构造函数和拷贝赋值操作符都是 copying 函数</li>
<li>copying 函数应该确保复制“对象内的所有成员变量”和“所有基类成分”</li>
<li>不要尝试以某个 copying 函数实现另一个 copying 函数，应该将相同的东西抽象成一个函数，二者都调用这个函数</li>
</ul>

<h2 id="3-资源管理">3.资源管理</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Resource management</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="13-以对象管理资源">13.以对象管理资源</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Use objects to manage resources</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>为防止内存泄漏，建议使用 RAII(Resource Acquisition Is Initialization，资源取得时机就是初始化时机) 对象，它们在构造函数中获得资源并在析构函数中释放资源</li>
<li>常用的 RAII 类是 shared_ptr 和 auto_ptr。前者的拷贝行为比较直观，后者的复制动作会转移资源的所有权：shared_ptr 有引用计数，但是无法打破环装引用</li>
<li>参考<a href="./smart_ptr.md">智能指针</a>一文</li>
</ul>

<h3 id="14-在资源管理类中小心复制行为">14.在资源管理类中小心复制行为</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Think carefully about copying behavior in resource-managing classes</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>复制 RAII 对象必须一并复制它锁管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为</li>
<li>一般情况下，RAII 类的 copying 行为是：阻止 copying、实行引用计数法</li>
</ul>

<h3 id="15-在资源管理类中提供对原始资源的访问">15.在资源管理类中提供对原始资源的访问</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Provide access to raw resources in resource-managing classes</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>APIs 往往要求访问原始资源，所以每一个 RAII 类应该提供一个接口可以获得其管理的资源</li>
<li>对原始资源的访问可以是显示转换或隐式转换：一般显示转换比较安全，隐式转换对客户比较方便</li>
</ul>

<h3 id="16-在对应的-new-和-delete-采用相同形式">16.在对应的 new 和 delete 采用相同形式</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Use the same form in corresponding uses of new and delete</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>调用 new 时使用<code>[]</code>，那么对应调用 delete 时也调用<code>[]</code></li>
<li>调用 new 时没有使用<code>[]</code>，那么也不该在调用 delete 时使用<code>[]</code></li>
</ul>

<h3 id="17-以独立语句将-newed-对象保存到智能指针">17. 以独立语句将 newed 对象保存到智能指针</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Store newed onjects in smart pointers in standalone statements</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>以独立语句将 newed 对象保存在智能指针内。否则，抛出异常的时候，可能会导致内存泄漏</li>
</ul>

<h2 id="4-设计与声明">4.设计与声明</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Designs and declarations</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="18-让接口易被正常使用-不易被误用">18.让接口易被正常使用，不易被误用</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Make interfaces easy to use correctly and hard to use incorrectly</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任</li>
<li>shared_ptr 支持自定义删除器，可以防止 DLL 问题，可被用来自动解除互斥锁</li>
</ul>

<h3 id="19-把类设计看作类型设计">19.把类设计看作类型设计</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Treat class design as type design</p>
</blockquote>
</blockquote>
</blockquote>

<p>在设计一个类之前，考虑以下问题</p>

<ul>
<li>新类型的对象如何被创建和销毁</li>
<li>对象的初始化和对象的赋值该有什么样的差别：区分构造函数和赋值操作符的行为</li>
<li>新类型的对象如果以值传递，意味着什么：取决于拷贝构造函数</li>
<li>什么是新类型的“合法值”：确定需要做的错误检查工作</li>
<li>新类型需要配合某个继承图系吗：受继承类的约束，如果允许被继承，析构函数是否为虚函数</li>
<li>新类型需要什么样的转换：显示类型转换和隐式类型转换</li>
<li>什么样的操作符和函数对此新类型是合理的：确定需要声明的函数，哪些是成员函数，哪些不是成员函数</li>
<li>谁该调用新类型的成员：确定成员的属性(public/protected/private)，也确定类之间的关系(所属，友元)</li>
<li>什么是新类型的未声明接口</li>
<li>新类型有多一般化：是否需要定义一个模板类</li>
<li>真的需要一个新类型吗：是否可以为已有类添加非成员函数或模板来实现</li>
</ul>

<h3 id="20-常量引用传递优于值传递">20.常量引用传递优于值传递</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Prefer pass-by-reference-to-const to pass-by-value</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>值传递效率低，而且可能造成对象切割(slicing)：值传递一个衍生类对象时，如果函数声明的是基类，那么调用的是基类的拷贝构造函数</li>
<li>C++ 编译器底层使用指针实现，不同情形使用不同的方式

<ul>
<li>内置类型(如 int)采用值传递</li>
<li>STL 的迭代器和函数对象使用值传递</li>
<li>其他的采用常量引用传递</li>
</ul></li>
</ul>

<h3 id="21-必须返回对象时-不要返回引用">21.必须返回对象时，不要返回引用</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Don&rsquo;t try to return a reference when you must return an object</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>绝不要返回指针或引用指向一个 local stack 对象</li>
<li>绝不要返回引用指向一个 heap-allocated 对象</li>
<li>绝不要返回指针或引用指向一个 local static 对象而有可能同时需要多个这样的对象</li>
</ul>

<h3 id="22-声明数据成员为私有的">22.声明数据成员为私有的</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Declare data memebers private</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>语法一致性：public 接口内的所有东西都是函数</li>
<li>可细微划分访问控制、允诺约束条件获得保证</li>
<li>protected 并不比 public 更具封装性</li>
</ul>

<h3 id="23-成员函数优于非成员-非友元函数">23.成员函数优于非成员、非友元函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Prefer non-member non-friend functions to member function</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>将所有功能函数放在多个头文件内但隶属同一命名空间，使用者可以轻松扩展这一组功能函数

<ul>
<li>在命名空间添加非成员非友元函数，以便为使用者提供方便的接口</li>
</ul></li>
<li>优先考虑非成员、非友元函数替换成员函数，可以增加封装性、包裹弹性和机能扩充性</li>
</ul>

<h3 id="24-当类型转换需应用到所有参数-声明为非成员函数">24.当类型转换需应用到所有参数，声明为非成员函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Declare non-member functions when type conversions should apply to all parameters</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>如果需要为某个函数的所有参数(包括被 this 指针所指的隐喻参数)进行类型转换，那么这个函数必须是非成员函数

<ul>
<li>编译器可对每一个实参执行隐式类型转换</li>
</ul></li>
</ul>

<h3 id="25-考虑支持不抛异常的-swap-函数">25.考虑支持不抛异常的 swap 函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Consider support for a non-throwing swap</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>如果 std::swap 缺省实现对自定义的类或类模板的效率不足，试着做

<ul>
<li>提供一个 public swap 成员函数，在函数内高效地置换两个对象值</li>
<li>在类或模板所在的命名空间提供一个非成员的 swap 函数，在函数内调用上述 swap 函数</li>
<li>如果正在编写一个类或类模板，让该类特化 std::swap，另其调用上述的 swap 函数</li>
</ul></li>
<li>如果调用 swap，确定包含<code>using std::swap</code>，然后不加任何 namespace 修饰符，直接调用 swap，编译器就会查找适当的 swap 函数并调用</li>
<li>警告：成员函数 swap 不可抛出异常</li>
</ul>

<h2 id="5-实现">5.实现</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Implementations</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="26-尽可能推迟变量定义">26.尽可能推迟变量定义</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Postpone variable definitions as long as possible</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>尽可能延后变量定义式的出现，最好是延后到可以用有意义的参数进行始化</li>
<li>对于循环，如果构造和析构的代码大于赋值操作，则将定义放在循环外</li>
</ul>

<h3 id="27-最小化-cast-操作">27.最小化 cast 操作</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Minimize casting</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>C 风格的转换操作，将 expression 转换为 T：<code>(T)expression</code>和<code>T(expression)</code></li>
<li>C++ 另外提供 4 种转换操作

<ul>
<li><code>const_cast&lt;T&gt;( expression )</code>用来移除对象的常量性，唯一可以实现这个目的的 C++ 风格的转换操作符</li>
<li><code>dynamic_cast&lt;T&gt;( expression )</code>用于执行“安全向下转换”，用于确定某对象是否归属继承体系中的某个类型，可能耗费重大运行成本，唯一一个 C 风格无法实现的转换操作</li>
<li><code>reinterpret_cast&lt;T&gt;( expression )</code>意图执行低级转换，实际动作和结果可能取决于编译器，即不可移植</li>
<li><code>static_cast&lt;T&gt;( expression )</code>用于强迫隐式转换，例如 non-const 转换为 const，或者 int 转 double 等</li>
</ul></li>
<li>倾向使用 C++ 风格的转换操作，不要使用 C 风格的转换

<ul>
<li>易被辨识，因而得以简化查找类型被破坏的过程</li>
<li>各转换工作有各自的局限，便于编译器诊断错误的运用</li>
</ul></li>
<li>如果可以，尽量避免转换操作，特别是在注重效率的代码中避免 dynamic_cast，如果有需要，尝试改成无需转换的设计

<ul>
<li>使用类型安全容器，确定是哪种衍生类或基类</li>
<li>将虚函数放在父类，然后添加空实现</li>
</ul></li>
<li>如果必须转换，试着用函数封装，可以调用函数，而无需将转换操作引入代码</li>
</ul>

<h3 id="28-避免返回指向对象内部的句柄">28.避免返回指向对象内部的句柄</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Avoid returning &ldquo;handles&rdquo; to object internals</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>避免返回 handles(包括引用、指针、迭代器)指向对象内部。一遍增加封装性，帮助 const 成员函数的行为像个 const，并将发生 dangling handles 的可能性降至最低</li>
</ul>

<h3 id="29-努力写异常安全的代码">29.努力写异常安全的代码</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Strive for exception-safe code</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>异常安全函数即使发生议程也不会内存泄漏或破坏任何数据结构。这样的函数分为三种可能的保证：基本型、强烈型、不抛异常型</li>
<li>“强烈保证”往往以 copy-and-swap 实现，但“强烈保证”并非对所有函数都可实现或具备现实意义</li>
<li>函数提供的“异常安全保证”通常最高只等于其调用的各个函数的“异常安全保证”中的最弱者</li>
</ul>

<h3 id="30-了解内联的细节">30.了解内联的细节</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Understand the ins and outs of inlining</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>将大多数内联限制在小型、被频繁调用的函数。可使日后的调试过程和二进制升级更容易，也可最小化潜在的代码膨胀问题，最大化提升程序的速度

<ul>
<li>内联函数无法随着程序库的升级而升级：内联函数修改，用到该函数的程序必须重新编译</li>
<li>大部分调试器不支持内联函数调试</li>
</ul></li>
<li>隐式内联：函数定义在类定义内</li>
<li>显式内联：添加关键字 inline

<ul>
<li>没有要求每个函数都是内联，就避免声明一个模板是内联</li>
</ul></li>
<li>大多数编译拒绝复杂的函数内联：比如虚函数，带有循环或递归的函数。此时会有警告信息</li>
<li>编译器通常不对“通过函数指针进行的调用”执行内联</li>
<li>不要只因为函数模板出现在头文件，就将其声明为内联</li>
</ul>

<h3 id="31-最小化文件编译依赖">31.最小化文件编译依赖</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Minimize compilation dependencies between files</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>pimply idiom(pointer to implementation)：将一个类分为两个，一个提供接口，一个负责实现接口，前者在类内包含一个后者的 shared_ptr，做到“接口与实现分离”</li>
<li>使用接口类、衍生类和工厂模式进行实现</li>
<li>分离的关键在于“声明的依存性”替换“定义的依存性”：让头文件尽可能自我满足，万一做不到，则使用前置声明</li>
<li>设计策略

<ul>
<li>尽量使用对象引用或对象指针，而不是对象：可以在头文件中使用前置声明</li>
<li>尽量使用 class 声明式而不是 class 定义式</li>
<li>为声明式和定义式提供不同的头文件</li>
</ul></li>
<li>程序头文件应该以“完全且仅有声明式”的形式存在</li>
</ul>

<h2 id="6-继承与面向对象设计">6.继承与面向对象设计</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Inheritance and object-oriented design</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="32-确保公有继承是-is-a-关系">32.确保公有继承是&rdquo;is-a&rdquo;关系</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Make sure public inheritance models &ldquo;is-a&rdquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>public 继承意味着 is-a。适用于基类的每一件事情一定适用于衍生类，每一个衍生类对象也都是一个基类对象</li>
</ul>

<h3 id="33-避免隐藏继承的名字">33.避免隐藏继承的名字</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Avoid hiding inherited names</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>衍生类内的名称会隐藏基类内的名称

<ul>
<li>如果继承基类并加上重载函数，又希望重新定义或覆盖其中一部分，必须为那些原本会被隐藏的名称引入一个 using 声明式，否则继承的名称会被隐藏</li>
</ul></li>
<li>为了让隐藏的名称仍然可见，可使用 using 声明式或 forwarding 函数

<ul>
<li>内置的 forwarding 函数的另一个用途是为那些不支持 using 声明式的编译器而用</li>
</ul></li>
</ul>

<h3 id="34-区分接口继承和实现继承">34.区分接口继承和实现继承</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Differentiate between inheritance of interface and inhertance of implementation</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>接口继承和实现继承不同。在 public 继承时，衍生类会继承基类的接口，即成员函数</li>
<li>声明纯虚函数的目的是让衍生类只继承函数接口</li>
<li>声明非纯虚函数的目的是让衍生类继承该函数的接口和缺省实现</li>
<li>声明非虚函数的目的是让衍生类继承函数的接口和一份强制性实现</li>
</ul>

<h3 id="35-考虑虚函数的替代">35.考虑虚函数的替代</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Condider alternatives to virtual functions</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>虚函数的替代方案包括 NVI 手法及 Strategy 设计模式的多种形式

<ul>
<li>使用 non-virtual interface(NVI)手法，是 Template Method 设计模式的一种特殊形式。以 public non-virtual 成员函数包裹较低访问性的虚函数</li>
<li>将虚函数替换为“函数指针成员变量”。是 Strategy 设计模式的一种分解表现形式</li>
<li>以 function 成员变量替换虚函数，因而允许使用任何可调用实体(callable entities)搭配一个兼容与需求的签名式。这也是 Strategy 设计模式的某种形式</li>
<li>将继承体系内的虚函数替换为另一继承体系的虚函数。这是 Strategy 设计模式的传统实现手法</li>
</ul></li>
<li>将功能从成员函数移到类外部，缺点是非成员函数无法访问类的 non-public 成员</li>
<li>function 对象的行为就像一般函数指针。这样的对象可接纳“与给定的目标签名式兼容”的所有可调用实体</li>
</ul>

<h3 id="36-绝不重定义继承的非虚函数">36.绝不重定义继承的非虚函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Never redefine an inherited non-virtual function</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>非虚函数是静态绑定的，虚函数是动态绑定的</li>
<li>任何情况下都不该重新定义一个继承而来的非虚函数，否则调用的函数取决于对象最开始的声明类型，跟实际所指类型无关</li>
</ul>

<h3 id="37-绝不重定义函数继承的默认参数值">37.绝不重定义函数继承的默认参数值</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Never redefine a function&rsquo;s inherited default parameter value</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>虚函数是动态绑定，但是缺省参数是静态绑定

<ul>
<li>调用虚函数时，默认参数可能是基类的默认参数，而不是实际指向的父类的默认参数</li>
</ul></li>
<li>静态类型是声明的类型，动态类型是“目前所指对象的类型”

<ul>
<li>动态类型可以表现出一个对象将会有什么行为</li>
<li>动态类型可在程序执行过程中改变</li>
</ul></li>
<li>可以使用 NVI 手法：另基类内的一个 public 非虚函数调用 private 虚函数，后者可被衍生类重新定义。让非虚函数知道缺省参数，虚函数负责真正的工作</li>
</ul>

<h3 id="38-通过组合对-has-a-或-is-implemented-in-terms-of-建模">38.通过组合对&rdquo;has-a&rdquo;或&rdquo;is-implemented-in-terms-of&rdquo;建模</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Model &ldquo;has-a&rdquo; or &ldquo;is-implemented-in-terms-of&rdquo; through composition</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>复合是类型间的一种关系，当某种类型的对象内包含其他类型的对象，就是复合关系</li>
<li>在应用域，复合意味着 has-a(有一个)。在实现域，复合以为着 is-implemented-in-terms-of(根据某物实现出)</li>
</ul>

<h3 id="39-慎重使用私有继承">39.慎重使用私有继承</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Use private inheritance judiciously</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>private 继承意味着 is-implemented-in-terms-of。通常比复合的级别低，但是当衍生类需要访问基类的 protected 成员，或需要重新定义继承而来的虚函数时，private 继承是合理的

<ul>
<li>private 继承时，编译器不会自动将一个衍生类对象转换为一个基类对象</li>
<li>由 private 继承而来的所有成员，在衍生类中都是 private 属性</li>
<li>private 继承是一种实现技术，意味着只有实现部分被继承，接口部分应忽略</li>
</ul></li>
<li>与复合相比，private 继承可以使得空白基类最优化(EBO, empty base optimization)。对致力于“对象尺寸最小化”的程序库开发者比较重要</li>
<li>尽可能使用复合，必要时采用 private 继承

<ul>
<li>当想要访问一个类的 protected 成员，或需要重新定义该类的一个或多个虚函数</li>
<li>当空间更加重要，衍生类的基类可以不包含任何 non-static 成员变量</li>
<li>“独立(非附属)”对象的大小一定不为零，不适用于单一继承(多重继承不可以)衍生类对象的基类</li>
</ul></li>
</ul>

<h3 id="40-慎重使用多重继承">40.慎重使用多重继承</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Use multiple inheritance judiciously</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>多重继承是继承一个以上的基类，但这些基类并不常在继承体系中又有基类

<ul>
<li>虚继承：防止多重继承时，基类之间又有基类，从而上层的基类的成员变量被父类复制</li>
<li>虚继承的类产生的对象体积更大，访问虚基类的成员变量速度慢，增加初始化(及赋值)的复杂度</li>
<li>如果虚基类不带任何数据，是具有使用价值的情况</li>
</ul></li>
<li>多重继承比单一继承复杂，可能导致新的歧义性，以及对虚继承的需要</li>
<li>多重继承的用途：涉及“public 继承某个接口类”和“private 继承某个协助实现的类”</li>
</ul>

<h2 id="7-模板与泛型编程">7.模板与泛型编程</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Templates and generic programming</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="41-理解隐式接口和编译期多态">41.理解隐式接口和编译期多态</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Understand implicit interfaces and compile-time polymorphism</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>类和模板都支持接口和多态</li>
<li>对类而言接口是显式的，以函数签名为中心。多态则是通过虚函数发生于运行期</li>
<li>对模板参数而言，接口是隐式的，基于有效表达式。多态则是通过模板具体化和函数重载解析，发生于编译期</li>
</ul>

<h3 id="42-理解-typename-的双重定义">42.理解 typename 的双重定义</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Understand the two meanings of typename</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>声明模板类型参数的两种方式：

<ul>
<li><code>template&lt;class T&gt; class widget;</code></li>
<li><code>template&lt;typename T&gt; class widget;</code></li>
</ul></li>
<li>从属名称：模板内的名称依赖于某个模板参数

<ul>
<li>非从属名称：模板内不依赖模板参数的名称</li>
</ul></li>
<li>嵌套从属名称：从属名称在类内呈嵌套状</li>
<li>嵌套从属类型名称：嵌套从属名称且指向某类型

<ul>
<li>想在模板中指定一个嵌套从属类型名称，就必须在紧邻它的前一个位置加上关键字 typename</li>
<li>typename 不可出现在基类列表类的嵌套从属类型名称前，也不可在成员初始化列表中作为基类的修饰符</li>
</ul></li>
</ul>

<h3 id="43-了解如何访问模板化基类内的名称">43.了解如何访问模板化基类内的名称</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Know how to access names in templatized base classes</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>当基类从模板中被具体化时，它假设对基类的内容一无所知，即衍生类基类继承一个基类模板，不能再衍生类的实现中直接调用基类的成员(变量和函数)

<ul>
<li>可在衍生类模板内添加<code>this-&gt;</code>指向基类模板的成员(变量和函数)</li>
<li>使用 using 声明式，假设已经存在这个成员(变量和函数)</li>
<li>明确指出被调用的函数位于基类内，使用<code>基类::</code>，如果是一个虚函数，会关闭虚函数的动态绑定行为</li>
</ul></li>
</ul>

<h3 id="44-把参数无关的代码分离出模板">44.把参数无关的代码分离出模板</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Factor parameter-independent code out of templates</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>模板生成多个类和多个函数，所以任何模板代码都不该与某个造成膨胀的模板参数产生依赖关系</li>
<li>因非类型模板参数造成的代码膨胀，往往可以消除，做法是以函数参数或类成员变量替换模板参数</li>
<li>因类型参数造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表示的具体类型实现共享代码</li>
</ul>

<h3 id="45-使用成员函数模板来接受-所有兼容类型">45.使用成员函数模板来接受“所有兼容类型”</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Use member function templates to accept &ldquo;all compatible types&rdquo;</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>具有基类-衍生类关系的两个类型分别具体化某个模板，生成的两个结构并不带有基类-衍生类关系</li>
<li>使用成员函数模板生成“可接受所有兼容类型”的函数</li>
<li>如果声明成员模板用于“泛化拷贝构造”或“泛化赋值操作”，必须声明正常的拷贝构造函数和拷贝赋值操作符

<ul>
<li>声明泛化拷贝构造函数和拷贝赋值操作符，不会阻止编译器生成默认的拷贝构造函数和拷贝赋值操作符</li>
</ul></li>
</ul>

<h3 id="46-需要类型转化时在模板内定义非成员函数">46.需要类型转化时在模板内定义非成员函数</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Define non-member functions inside templates when type conversions are desired</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>模板实参推导过程中不会考虑隐式类型转换函数</li>
<li>写类模板时，当它提供的“与此模板相关的”函数支持“所有参数的隐式类型转换”时，将那些函数定义为类模板内部的友元函数

<ul>
<li>在类内部声明非成员函数作为友元函数，成为内联函数</li>
<li>为了将内联声明的影响最小化，在类外定义一个辅助函数模板，在友元函数内只调用辅助函数</li>
</ul></li>
</ul>

<h3 id="47-使用-traits-class-表现类型信息">47.使用 traits class 表现类型信息</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Use traits classes for information about types</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>STL 有 5 种迭代器

<ul>
<li>input 迭代器：只能向前移动，一次异步，只可读取(不能修改)所指的东西，且只能读取一次。模仿了指向输入文件的读指针。如 C++ 的 istream_iterator</li>
<li>output 迭代器：只能向前移动，一次一步，只可修改所指的东西，且只能修改一次。模仿了指向输出文件的写指针。如 C++ 的 ostream_iterator</li>
<li>input 和 output 迭代器都只适合“单步操作算法(one-pass algorithms)”</li>
<li>forward 迭代器：既能完成上述两种迭代器的工作，且可以读或写所指对象一次以上。使得可以实施“多步操作算法(multi-pass algorithms)”。如单向链表的迭代器</li>
<li>bidirectional 迭代器：既能完成 forward 迭代器的工作，还支持向后移动。STL 的 list/set/multiset/map/multimap 迭代器就属于这一分类</li>
<li>random access 迭代器：可以执行“迭代器运算”，即可以在常量时间内向前或向后跳跃任意距离。如 array/vector/deque/string 提供的都是随机访问迭代器</li>
</ul></li>
<li>如何设计一个 traits 类

<ul>
<li>确认若干希望将来可取得的类型相关信息。例如迭代器希望取得分类(category)</li>
<li>为该信息选择一个名词。如迭代器是 iterator_category</li>
<li>提供一个模板和一组特化版本，其中包含希望支持的类型相关信息</li>
<li>traits 类的名称常以&rdquo;traits&rdquo;结束</li>
</ul></li>
<li>如何使用一个 traits 类

<ul>
<li>建立一组重载函数(类似劳工)或函数模板，彼此间的差异只在于各自的 traits 参数。令每个函数实现与其接受的 traits 信息相对应</li>
<li>建立一个控制函数(类似工头)或函数模板，调用上述的函数并传递 traits 类所提供的信息</li>
</ul></li>
<li>traits 类使得“类型相关信息”在编译期可用。它们以模板和一组“模板特化”完成实现</li>
<li>整合重载技术后，traits 类可在编译期对类型执行 if&hellip;else 测试</li>
</ul>

<h3 id="48-认识模板元编程">48. 认识模板元编程</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Be aware of template metaprogramming</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>模板元编程(TMP, template metaprogramming)是编写基于模板的 C++ 程序并在编译期执行的过程

<ul>
<li>即以 C++ 写成、在 C++ 编译期内执行的程序</li>
<li>TMP 程序结束执行，输出的 C++ 源码可以像往常一样编译</li>
<li>优点：</li>
<li>让某些事情更容易</li>
<li>可将工作从运行期转移到编译期。使得原本在运行期才可以侦测的错误在编译期被找到</li>
<li>TMP 的 C++ 程序在每一方面可能更加高效：较小的可执行文件、较短的运行期、较少的内存需求</li>
<li>缺点：导致编译时间变长</li>
</ul></li>
<li>TMP 主要是函数式语言，可以达到的目的

<ul>
<li>确保度量单位正确：在编译期确保程序所有度量单位的组合是正确的</li>
<li>优化矩阵运算：使用 expression template，可能会消除中间计算生成的临时对象并合并循环</li>
<li>可生成用户自定义设计模式的实现品。设计模式如 Strategy/Observer/Visitor 等都可以多种方式实现</li>
</ul></li>
<li>问题：

<ul>
<li>语法不直观</li>
<li>支持工具不充分，如没有调试器</li>
</ul></li>
</ul>

<h2 id="8-定制-new-和-delete">8.定制 new 和 delete</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Customizing new and delete</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li><code>new</code>和<code>delete</code>只适合分配单一对象；<code>new []</code>和<code>delete []</code>用来分配数组</li>
<li>STL 容器所使用的 heap 内存是由容器所拥有的分配器对象(allocator objects)管理，而不是 new 和 delete 管理</li>
</ul>

<h3 id="49-理解-new-handler-的行为">49.理解 new-handler 的行为</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Understand the behavior of the new-handler</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>当 new 操作抛出异常以反映一个未获满足的内存需求之前，会先调研一个客户指定的错误处理函数，即 new-handler

<ul>
<li>可以用是<code>set_new_handler</code>设置该函数</li>
<li>参数是个指针，指向 new 无法分配足够内存时该调用的函数</li>
<li>返回值是个指针，指向<code>set_new_handler</code>被调用之前正在执行的 new_handler 函数</li>
<li>new_handler 是个 typedef，定义一个指针指向函数，函数没有参数也没有返回值</li>
</ul></li>
<li>设计良好的 new-handler 函数

<ul>
<li>让更多内存可被使用：程序一开始执行就分配一大块内存，而后第一次调用 new-handler，将该内存释放给程序使用</li>
<li>设置另一个 new-handler：如果已知哪个 new-handler 可以获得更多可用内存，调用时设置该 new-handler 替换自己。比如令 new-handler 修改“会影响 new-handler 行为”的静态数据、命名空间数据或全局数据</li>
<li>取消设置 new-handler：即将 null 指针传给<code>set_new_handler</code>，内存分配不成功时就会抛异常</li>
<li>抛出 bad_alloc 或派生自 bad_alloc 的异常：该异常不会被 new 操作捕获，但会传播给请求内存的代码</li>
<li>不返回：通常调用 abort 或 exit</li>
</ul></li>
<li><code>nothrow new</code>是一个有局限性的工具，因为它只适用于内存分配；后续的构造函数调用还是可能抛出异常</li>
</ul>

<h3 id="50-理解何时替换-new-和-delete-有意义">50.理解何时替换 new 和 delete 有意义</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Understand when it makes sense to replace new and delete</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>三个替换编译器提供的 new 和 delete 理由：

<ul>
<li>检测运用上的错误：自定义 new 操作，可超额分配内存，以额外空间放置特定的 byte patterns(即签名，signature)。对应的 delete 操作可以检查上述签名是否原封不动，若否表示在分配区的某个声生命时间点发生了 overrun(写入点在分配区块尾端之后) 或 underrun(写入点在分配区块起点之前)。此时 delete 可以日志记录该时间和发生错误的指针</li>
<li>强化效能：编译器的 new 和 delete 无法解决碎片问题，导致程序可能无法申请大区块内存。通常来说这种自定制的性能更好</li>
<li>收集使用上的统计数据：先收集软件如何使用动态内存，包括分配区块的大小分布、寿命分布、分配和释放的次序(FIFO/LIFO/随机)、任何时刻内存分配上限</li>
<li>增加分配和释放的速度：当定制型分配器专门针对某特定类型的对象设计时，往往比泛用型分配器更快</li>
<li>降低缺省内存管理器带来的空间额外开销：泛用型内存管理器往往使用更多内存</li>
<li>弥补缺省分配器中的非最佳对齐：缺省的分配器一般是 4 字节对齐，但是对于 x86 最好是 8 字节对齐</li>
<li>将相关对象成簇集中：将往往被一起使用某个数据结构放在一起创建，可以减少 page fault 的错误</li>
<li>获得非传统的行为：比如添加数据初始化工作</li>
</ul></li>
</ul>

<h3 id="51-写-new-和-delete-时遵循惯例">51.写 new 和 delete 时遵循惯例</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Adhere to convention when writing new and delete</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>new 操作

<ul>
<li>应该包含一个无穷循环，并在其中尝试分配内存</li>
<li>如果无法满足需求，调用 new-handler</li>
<li>也应该可以处理 0 字节申请</li>
<li>类的自定义版本还应该处理“比正确大小更大的(错误)申请”</li>
</ul></li>
<li>delete 操作

<ul>
<li>收到 null 指针不做任何事</li>
<li>类的自定义版本还应该处理“比正确大小更大的(错误)申请”</li>
</ul></li>
</ul>

<h3 id="52-写了-placement-new-也要写-placement-delete">52.写了 placement new 也要写 placement delete</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Write placement delete if you write placement new</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>如果自己实现一个 placement operator new，也要写出对应的 placement operator delete。否则会发生隐蔽时断时续的内存泄漏</li>
<li>当声明 placement new 和 placement delete，确定不要无意识地遮掩它们的正常版本</li>
</ul>

<h2 id="9-杂项讨论">9.杂项讨论</h2>

<blockquote>
<blockquote>
<blockquote>
<p>Miscellany</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="53-注意编译器警告">53.注意编译器警告</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Pay attention to compiler warnings</p>
</blockquote>
</blockquote>
</blockquote>

<ul>
<li>严肃对待编译器发出的警告信息。努力在编译器的最高(最严苛)警告级别下争取“无任何警告”</li>
<li>不要过度依赖编译器的报警能力，因为不同的编译器对待事情的态度不相同。一旦移植到另一个编译器上，原本依赖的警告信息有可能消失</li>
</ul>

<h3 id="54-熟悉包括-tr1-在内的标准库">54.熟悉包括 TR1 在内的标准库</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Familiarize yourself with the standard library, including TR1</p>
</blockquote>
</blockquote>
</blockquote>

<h3 id="55-熟悉-boost">55.熟悉 Boost</h3>

<blockquote>
<blockquote>
<blockquote>
<p>Familiarize yourself with Boost</p>
</blockquote>
</blockquote>
</blockquote>

    </div>

    





<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
  
</div>



<div class="share-box" aria-hidden="true">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/&amp;text=Effective%20C&#43;&#43;,%203rd" target="_blank" rel="noopener" class="share-btn-twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/&amp;t=Effective%20C&#43;&#43;,%203rd" target="_blank" rel="noopener" class="share-btn-facebook">
          <i class="fab fa-facebook-f"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=Effective%20C&#43;&#43;,%203rd&amp;body=https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/" target="_blank" rel="noopener" class="share-btn-email">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/&amp;title=Effective%20C&#43;&#43;,%203rd" target="_blank" rel="noopener" class="share-btn-linkedin">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://web.whatsapp.com/send?text=Effective%20C&#43;&#43;,%203rd%20https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/" target="_blank" rel="noopener" class="share-btn-whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=https://xueqing.github.io/blog/cplusplus/effectivec&#43;&#43;_3/&amp;title=Effective%20C&#43;&#43;,%203rd" target="_blank" rel="noopener" class="share-btn-weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>












  
  
    
  
  






  
  
  
  
  <div class="media author-card content-widget-hr">
    

    <div class="media-body">
      <h5 class="card-title"><a href="/authors/kiki/"></a></h5>
      
      
      <ul class="network-icon" aria-hidden="true">
  
</ul>

    </div>
  </div>









  
  
  <div class="article-widget content-widget-hr">
    <h3>相关</h3>
    <ul>
      
      <li><a href="/blog/cplusplus/cplusplus_new/">C&#43;&#43; new</a></li>
      
      <li><a href="/blog/cplusplus/cplusplus_string_case_convert/">C&#43;&#43; string 转换大小写</a></li>
      
      <li><a href="/blog/cplusplus/undefined_behavior/">C&#43;&#43; 未定义的行为</a></li>
      
      <li><a href="/blog/cplusplus/raii/">RAII 资源获取即初始化</a></li>
      
      <li><a href="/blog/cplusplus/stl/">STL</a></li>
      
    </ul>
  </div>
  



  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.3.1/mermaid.min.js" integrity="sha256-vOIuDSYDirTfyr+S2MjFnhOz6Rgiz4ODFAHATG0rFxw=" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js" integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js"></script>
        
      

      
      
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    

    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    
    
    
    
    <script>
      const search_config = {"indexURI":"/index.json","minLength":1,"threshold":0.3};
      const i18n = {"no_results":"没有找到结果","placeholder":"搜索...","results":"搜索结果"};
      const content_type = {
        'post': "文章",
        'project': "项目",
        'publication' : "出版物",
        'talk' : "演讲"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    

    
    
    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.d6bd04fdad2ad213aa8111c5a3b72fc5.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">引用</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> 复制
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> 下载
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
