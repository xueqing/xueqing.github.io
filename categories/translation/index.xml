<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>translation | kiki</title>
    <link>https://xueqing.github.io/categories/translation/</link>
      <atom:link href="https://xueqing.github.io/categories/translation/index.xml" rel="self" type="application/rss+xml" />
    <description>translation</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>zh-Hans</language>
    <image>
      <url>https://xueqing.github.io/img/icon-192.png</url>
      <title>translation</title>
      <link>https://xueqing.github.io/categories/translation/</link>
    </image>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;敏捷：一种用于增量创建软件的软件开发方法，使用 1-4 周的短期迭代以保证开发和一直改变的业务需求一致&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./1-primer.md&#34;&gt;1 入门&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.1-敏捷中的角色&#34;&gt;1.1 敏捷中的角色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.2-跨职能团队&#34;&gt;1.2 跨职能团队&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.3-敏捷团队如何计划工作&#34;&gt;1.3 敏捷团队如何计划工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.4-用户故事-user-story&#34;&gt;1.4 用户故事 user story&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./1-primer.md#1.5-故事何时完成&#34;&gt;1.5 故事何时完成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./2-manifesto.md&#34;&gt;2 宣言&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./2-manifesto.md#2.1-软件开发价值观&#34;&gt;2.1 软件开发价值观&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./2-manifesto.md#2.2-敏捷宣言的-12-个原则&#34;&gt;2.2 敏捷宣言的 12 个原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./3-characteristics.md&#34;&gt;3 特点&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./3-characteristics.md#3.1-迭代/增量和准备进化&#34;&gt;3.1 迭代/增量和准备进化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./3-characteristics.md#3.2-面对面沟通&#34;&gt;3.2 面对面沟通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./3-characteristics.md#3.3-反馈回路&#34;&gt;3.3 反馈回路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./4-daily-standup.md&#34;&gt;4 每日站会&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.1-每日站会的概念&#34;&gt;4.1 每日站会的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.2-每日站会的重要性&#34;&gt;4.2 每日站会的重要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.3-每日站会的参与人&#34;&gt;4.3 每日站会的参与人&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./4-daily-standup.md#4.4-物理分散的团队&#34;&gt;4.4 物理分散的团队&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./5-definition-of-done.md&#34;&gt;5 完成标准&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./5-definition-of-done.md#5.1-用户故事&#34;&gt;5.1 用户故事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./5-definition-of-done.md#5.2-迭代&#34;&gt;5.2 迭代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./5-definition-of-done.md#5.3-发布&#34;&gt;5.3 发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./6-release-planning.md&#34;&gt;6 发布计划&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.1-参与者&#34;&gt;6.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.2-计划的先决条件&#34;&gt;6.2 计划的先决条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.3-需要的材料&#34;&gt;6.3 需要的材料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.4-计划数据&#34;&gt;6.4 计划数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.5-输出&#34;&gt;6.5 输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./6-release-planning.md#6.6-日程&#34;&gt;6.6 日程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./7-iteration-planning.md&#34;&gt;7 迭代计划&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.1-参与者&#34;&gt;7.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.2-计划的先决条件&#34;&gt;7.2 计划的先决条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.3-计划流程&#34;&gt;7.3 计划流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.4-速度计算&#34;&gt;7.4 速度计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.5-任务容量&#34;&gt;7.5 任务容量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./7-iteration-planning.md#7.6-计划步骤&#34;&gt;7.6 计划步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./8-product-backlog.md&#34;&gt;8 产品需求列表&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;./8-product-backlog.md#8.1-产品需求列表的重要性&#34;&gt;8.1 产品需求列表的重要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;./8-product-backlog.md#8.2-产品需求列表的特点&#34;&gt;8.2 产品需求列表的特点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;./9-useful-terms.md&#34;&gt;9 有用的术语&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;有用的书&#34;&gt;有用的书&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Scrum-Breathtakingly-Brief-Agile-Introduction/dp/193796504X/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Scrum: a Breathtakingly Brief and Agile Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Learning-Agile-Understanding-Scrum-Kanban/dp/1449331920/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Learning Agile: Understanding Scrum, XP, Lean, and Kanban&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Agile-Project-Management-Dummies-Layton/dp/1118026241/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Agile Project Management For Dummies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Agile-Project-Management-QuickStart-Guide/dp/1502393468/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Agile Project Management QuickStart Guide: A Simplified Beginners Guide To Agile Project Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Agile-Half-Assed-Creating-Anything-Scratch-ebook/dp/B00R0QHV3G/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Agile!: The Half-Assed Guide To Creating Anything You Want From Scratch. No Experts Required!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Understanding-Agile-Manifesto-Brief-Guide-ebook/dp/B00GR31ZDU/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Understanding the Agile Manifesto: A Brief &amp;amp; Bold Guide to Agile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/command/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/readme/</guid>
      <description>

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/cmd/go/&#34; target=&#34;_blank&#34;&gt;Go 命令官网&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;p&gt;Go 是一个用于管理 Go 源码的工具。&lt;/p&gt;

&lt;p&gt;用法：&lt;code&gt;go &amp;lt;command&amp;gt; [arguments]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令有:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;bug.md&#34; target=&#34;_blank&#34;&gt;bug&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;开启一个缺陷报告&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;build.md&#34; target=&#34;_blank&#34;&gt;build&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;编译包及其依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;clean.md&#34; target=&#34;_blank&#34;&gt;clean&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;删除目标文件和缓存文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;doc.md&#34; target=&#34;_blank&#34;&gt;doc&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;查看包或者符号的文档&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;env.md&#34; target=&#34;_blank&#34;&gt;env&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;打印 Go 环境变量信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;fix.md&#34; target=&#34;_blank&#34;&gt;fix&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;更新包以使用新的 API&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;fmt.md&#34; target=&#34;_blank&#34;&gt;fmt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;gofmt(reformat) 包的源文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;generate.md&#34; target=&#34;_blank&#34;&gt;generate&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;通过处理源生成 Go 文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;get.md&#34; target=&#34;_blank&#34;&gt;get&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;为当前模块添加依赖并且安装依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;install.md&#34; target=&#34;_blank&#34;&gt;install&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;编译和安装包及其依赖&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;list.md&#34; target=&#34;_blank&#34;&gt;list&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;列举包或模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;mod.md&#34; target=&#34;_blank&#34;&gt;mod&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;模块维护&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;run.md&#34; target=&#34;_blank&#34;&gt;run&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;编译和运行 Go 程序&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;test_package.md&#34; target=&#34;_blank&#34;&gt;test&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;测试包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tool&lt;/td&gt;
&lt;td&gt;运行指定的 go 工具&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;version&lt;/td&gt;
&lt;td&gt;打印 Go 版本&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vet&lt;/td&gt;
&lt;td&gt;打印包中可能的错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;go help &amp;lt;command&amp;gt;&lt;/code&gt; 查看命令的更多信息。&lt;/p&gt;

&lt;p&gt;其他的帮助话题：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;帮助&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;buildmode&lt;/td&gt;
&lt;td&gt;编译模式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;在 Go 和 C 直接调用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cache&lt;/td&gt;
&lt;td&gt;编译和测试缓存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;environment&lt;/td&gt;
&lt;td&gt;环境变量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;filetype&lt;/td&gt;
&lt;td&gt;文件类型&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;go.mod&lt;/td&gt;
&lt;td&gt;go.mod 文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gopath&lt;/td&gt;
&lt;td&gt;GOPATH 环境变量&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;gopath-get&lt;/td&gt;
&lt;td&gt;传统 GOPATH 的 go get&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;goproxy&lt;/td&gt;
&lt;td&gt;模块 proxy 协议&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;importpath&lt;/td&gt;
&lt;td&gt;模块路径语法&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;modules&lt;/td&gt;
&lt;td&gt;模块，模块版本等&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;module-get&lt;/td&gt;
&lt;td&gt;明白模块的 go get&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;module-auth&lt;/td&gt;
&lt;td&gt;使用 go.sum 的模块认证&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;module-private&lt;/td&gt;
&lt;td&gt;对于非公共模块的模块配置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;packages&lt;/td&gt;
&lt;td&gt;包列表和模式&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;testflag&lt;/td&gt;
&lt;td&gt;测试标识&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;testfunc&lt;/td&gt;
&lt;td&gt;测试函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;使用 &lt;code&gt;go help &amp;lt;topic&amp;gt;&lt;/code&gt; 查看话题的更多信息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85-go&#34;&gt;安装 Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%a6%e4%b9%a0-go&#34;&gt;学习 Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%96%87%e7%ab%a0&#34;&gt;文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%9d%9e%e8%8b%b1%e6%96%87%e6%96%87%e7%ab%a0&#34;&gt;非英文文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;安装-go&#34;&gt;安装 Go&lt;/h2&gt;

&lt;h2 id=&#34;学习-go&#34;&gt;学习 Go&lt;/h2&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;h2 id=&#34;文章&#34;&gt;文章&lt;/h2&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;代码漫步：Go 程序的指导之旅。

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/codewalk/functions&#34; target=&#34;_blank&#34;&gt;Go 的一级函数&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/codewalk/markov&#34; target=&#34;_blank&#34;&gt;生成任意文本：一个 Markov 链算法&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/codewalk/sharemem&#34; target=&#34;_blank&#34;&gt;通过共享内存&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;articles/wiki.md&#34; target=&#34;_blank&#34;&gt;编写 Web 应用&lt;/a&gt;——构建一个简单的 web 应用。&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;工具

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;articles/go_command.md&#34; target=&#34;_blank&#34;&gt;关于 Go 命令&lt;/a&gt;——为什么我们编写它？它是什么？它不是什么？如何使用它？&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;gdb.md&#34; target=&#34;_blank&#34;&gt;使用 GDB 调试 Go 代码&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;articles/race_detector.md&#34; target=&#34;_blank&#34;&gt;数据竞争检测器&lt;/a&gt;——关于数据竞争检测器的手册&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;asm.md&#34; target=&#34;_blank&#34;&gt;快速入门 Go 的汇编器&lt;/a&gt;——介绍了 Go 使用的汇编器&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;更多

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 查看&lt;a href=&#34;../README.md&#34;&gt;维基&lt;/a&gt;的&lt;a href=&#34;../wiki/articles.md&#34;&gt;文章&lt;/a&gt;页面获取更多 Go 的文章&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;非英文文章&#34;&gt;非英文文章&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%87%e5%87%86%e5%ba%93&#34;&gt;标准库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96%e5%8c%85&#34;&gt;其他包&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%90%e4%bb%93%e5%ba%93&#34;&gt;子仓库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%be%e5%8c%ba&#34;&gt;社区&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;标准库&#34;&gt;标准库&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;概述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;testing.md&#34; target=&#34;_blank&#34;&gt;testing&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;支持对 Go 包的自动测试&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;——&lt;a href=&#34;iotest.md&#34; target=&#34;_blank&#34;&gt;iotest&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了主要用于 testing 的 Reader 和 Writer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;——&lt;a href=&#34;quick.md&#34; target=&#34;_blank&#34;&gt;quick&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了帮助黑盒测试的工具函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;其他包&#34;&gt;其他包&lt;/h2&gt;

&lt;h3 id=&#34;子仓库&#34;&gt;子仓库&lt;/h3&gt;

&lt;h3 id=&#34;社区&#34;&gt;社区&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/readme/</guid>
      <description>&lt;p&gt;关于 &lt;a href=&#34;http://tour.golang.org/&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt; 的练习题&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/readme/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e4%b9%8b%e5%ae%b6&#34;&gt;Go 之家&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b4%a1%e7%8c%ae&#34;&gt;贡献&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e5%ae%b9%e5%88%97%e8%a1%a8&#34;&gt;内容列表&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e5%85%a5%e9%97%a8&#34;&gt;Go 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8-go-%e5%b7%a5%e4%bd%9c&#34;&gt;用 Go 工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%b4%e5%a4%9a%e5%85%b3%e4%ba%8e-go-%e7%9a%84%e5%ad%a6%e4%b9%a0&#34;&gt;更多关于 Go 的学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e7%a4%be%e5%8c%ba&#34;&gt;Go 社区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-go-%e5%b7%a5%e5%85%b7%e9%93%be&#34;&gt;使用 go 工具链&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%85%b6%e4%bb%96%e7%9a%84-go-%e7%bc%96%e7%a8%8b%e7%bb%b4%e5%9f%ba&#34;&gt;其他的 Go 编程维基&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bd%91%e4%b8%8a%e7%94%a8-go-%e7%9a%84%e6%9c%8d%e5%8a%a1&#34;&gt;网上用 Go 的服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83%e7%9a%84-go-%e7%a8%8b%e5%ba%8f%e7%96%91%e9%9a%be%e8%a7%a3%e7%ad%94&#34;&gt;生产环境的 Go 程序疑难解答&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ba-go-%e9%a1%b9%e7%9b%ae%e5%81%9a%e8%b4%a1%e7%8c%ae&#34;&gt;为 Go 项目做贡献&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b3%e5%8f%b0%e7%89%b9%e5%ae%9a%e7%9a%84%e4%bf%a1%e6%81%af&#34;&gt;平台特定的信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%91%e5%b8%83%e7%89%b9%e5%ae%9a%e7%9a%84%e4%bf%a1%e6%81%af&#34;&gt;发布特定的信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%97%ae%e9%a2%98&#34;&gt;问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki&#34; target=&#34;_blank&#34;&gt;Go 维基官网&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;原网页由 HunterQ 在 2019/4/12 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/Home/_history&#34; target=&#34;_blank&#34;&gt;第 99 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;go-之家&#34;&gt;Go 之家&lt;/h2&gt;

&lt;p&gt;欢迎来到 Go 维基，集中了关于 &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;Go 编程语言&lt;/a&gt;的信息。&lt;a href=&#34;http://awesome-go.com/&#34; target=&#34;_blank&#34;&gt;Awesome Go&lt;/a&gt; 是另外一个给 Go 编程人员的丰富的资源，由 Go 社区管理。&lt;/p&gt;

&lt;h2 id=&#34;贡献&#34;&gt;贡献&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;这个维基可被拥有 Github 账号的 Go 社区的任意成员编辑。&lt;/li&gt;
&lt;li&gt;如果你想要新增一个页面，请首先在 &lt;a href=&#34;https://github.com/golang/go/issues&#34; target=&#34;_blank&#34;&gt;Go issue 跟踪页面&lt;/a&gt; 打开一个 issue，以前缀 “wiki” 开头来提议新增的内容。清楚地说明为什么这个内容不适用任何现有的页面。&lt;/li&gt;
&lt;li&gt;因为维基页面的重命名会破坏外部链接，请在重命名或删除任何维基页面之前打开一个 issue。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;内容列表&#34;&gt;内容列表&lt;/h2&gt;

&lt;h3 id=&#34;go-入门&#34;&gt;Go 入门&lt;/h3&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;gotour/README.md&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt;是入门最好的地方。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/doc/effective_go.html&#34; target=&#34;_blank&#34;&gt;实效 Go 编程&lt;/a&gt;将会帮助学习如何编写惯用的 Go 代码。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://golang.org/pkg/&#34; target=&#34;_blank&#34;&gt;Go 标准库文档&lt;/a&gt;使你熟悉标准库。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 使用 &lt;a href=&#34;http://play.golang.org/&#34; target=&#34;_blank&#34;&gt;Go Playground&lt;/a&gt; 用于在你的浏览器测试 Go 程序。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 仍然不确信？查看这份 &lt;a href=&#34;https://github.com/golang/go/wiki/GoUsers&#34; target=&#34;_blank&#34;&gt;Go 使用者&lt;/a&gt;清单以及他们的一些&lt;a href=&#34;https://github.com/golang/go/wiki/SuccessStories&#34; target=&#34;_blank&#34;&gt;成功案例&lt;/a&gt;。我们也收集了一份长长的原因清单，关于&lt;a href=&#34;https://github.com/golang/go/wiki/whygo&#34; target=&#34;_blank&#34;&gt;你为什么应该尝试 Go&lt;/a&gt;。&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 了解更多已经&lt;a href=&#34;https://github.com/golang/go/wiki/FromXToGo&#34; target=&#34;_blank&#34;&gt;从其他语言转到 Go&lt;/a&gt; 的公司。
这里是一些帮助你入门的链接。&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;用-go-工作&#34;&gt;用 Go 工作&lt;/h3&gt;

&lt;p&gt;准备好自己写一些 Go 代码了吗？这里是一些帮助你入门的链接。&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 安装和设置你的环境

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 由此开始：&lt;a href=&#34;https://golang.org/doc/install&#34; target=&#34;_blank&#34;&gt;官方安装文档&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 如果你更喜欢源码安装，&lt;a href=&#34;https://golang.org/doc/install/source&#34; target=&#34;_blank&#34;&gt;先阅读此文档&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/InstallFromSource&#34; target=&#34;_blank&#34;&gt;从源码安装&lt;/a&gt;——其他关于源码安装的建议&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Windows 用户？&lt;a href=&#34;https://github.com/abourget/getting-started-with-golang&#34; target=&#34;_blank&#34;&gt;为 Windows 安装和配置 Go、Git和 Atom&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; Mac 用户？&lt;a href=&#34;https://howistart.org/posts/go/1&#34; target=&#34;_blank&#34;&gt;如何开始-Go&lt;/a&gt;——安装 Go 和编译你的以第一个 web 服务的分步指南&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 安装遇到问题？&lt;a href=&#34;https://github.com/golang/go/wiki/InstallTroubleShooting&#34; target=&#34;_blank&#34;&gt;安装疑难解答&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 确保你已经&lt;a href=&#34;https://golang.org/doc/install/source#gopath&#34; target=&#34;_blank&#34;&gt;正确设置了 $GOPATH 环境变量&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 如果需要其他关于&lt;a href=&#34;https://github.com/golang/go/wiki/GOPATH&#34; target=&#34;_blank&#34;&gt;使用 $GOPATH 的建议，浏览这里&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/MultipleGoRoots&#34; target=&#34;_blank&#34;&gt;多个 GOROOT&lt;/a&gt;——更多高级信息关于在安装多个 go 以及 &lt;code&gt;$GOROOT&lt;/code&gt; 变量的环境工作&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/IDEsAndTextEditorPlugins&#34; target=&#34;_blank&#34;&gt;Go 集成开发环境和编辑器&lt;/a&gt;——一些关于如何使用你最喜欢的编辑器开发 Go 的信息&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/CodeTools&#34; target=&#34;_blank&#34;&gt;为开发 Go 代码的工具&lt;/a&gt;——格式化、语言分析、代码检查、代码重构、代码导航和可视化&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 查找 Go 库和包

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 由此开始：&lt;a href=&#34;https://github.com/golang/go/wiki/Projects&#34; target=&#34;_blank&#34;&gt;Go 开源工程&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 查找 Go 包：&lt;a href=&#34;http://godoc.org/&#34; target=&#34;_blank&#34;&gt;go 文档官网&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://anvaka.github.io/pm/#/galaxy/gosearch?l=1&#34; target=&#34;_blank&#34;&gt;Go 开源包图&lt;/a&gt;的可视化&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/PackageManagementTools&#34; target=&#34;_blank&#34;&gt;管理你的依赖&lt;/a&gt;——一个你可以用来管理第三方包 (vendoring) 的工具纵览&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 发布开源的 Go 包

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 准备好发布你的包了？&lt;a href=&#34;https://github.com/golang/go/wiki/PackagePublishing&#34; target=&#34;_blank&#34;&gt;由此开始&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/matttproud/gochecklist&#34; target=&#34;_blank&#34;&gt;Go 检查清单&lt;/a&gt;——发布一个项目的完全指南&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/GitHubCodeLayout&#34; target=&#34;_blank&#34;&gt;如何设计你的 Github 仓库&lt;/a&gt; 以便其他 Go 编程人员更容易使用 &lt;code&gt;go get&lt;/code&gt; 命令&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://johnsto.co.uk/blog/go-package-go&#34; target=&#34;_blank&#34;&gt;Go 包&lt;/a&gt;——一些使得 Go 包更易用的建议&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;更多关于-go-的学习&#34;&gt;更多关于 Go 的学习&lt;/h3&gt;

&lt;p&gt;当你对这门语言有一个概览之后，这里有一些资源供你使用学习更多关于 Go：&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Learn&#34; target=&#34;_blank&#34;&gt;学习 Go&lt;/a&gt;—— Go 入门到高级的资料集合

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://medium.com/@IndianGuru/best-practices-for-a-new-go-developer-8660384302fc&#34; target=&#34;_blank&#34;&gt;Go 新手开发人员的最佳实践&lt;/a&gt;——来自 Go 社区成员的见解&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/LearnServerProgramming&#34; target=&#34;_blank&#34;&gt;服务器编程&lt;/a&gt;——构建 web、移动端和 API 服务器&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/LearnConcurrency&#34; target=&#34;_blank&#34;&gt;并发&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/LearnErrorHandling&#34; target=&#34;_blank&#34;&gt;错误处理&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;learn_testing.md&#34; target=&#34;_blank&#34;&gt;测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Mobile&#34; target=&#34;_blank&#34;&gt;移动端&lt;/a&gt;——安卓和 iOS&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Books&#34; target=&#34;_blank&#34;&gt;书籍&lt;/a&gt;——一份已经出版的(电子书，论文)关于 Go 的的书籍清单&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Blogs&#34; target=&#34;_blank&#34;&gt;博客&lt;/a&gt;——关于 Go 的博客

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; [播客]——描写 Go 特色的播客和故事&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; 视频、谈话和演示

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;http://gophervids.appspot.com/&#34; target=&#34;_blank&#34;&gt;GopherVids&lt;/a&gt; 是一个关于 Go 的视频的搜索目录&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/GoTalks&#34; target=&#34;_blank&#34;&gt;GoTalks&lt;/a&gt;——来自 Go 会议和聚会的谈话集合&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Screencasts&#34; target=&#34;_blank&#34;&gt;Screencasts&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Articles&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;——帮助你学习 Go 的文章集合&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Training&#34; target=&#34;_blank&#34;&gt;培训&lt;/a&gt;——免费的、商业的、在线的 Go 课堂培训&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/Courses&#34; target=&#34;_blank&#34;&gt;大学课程&lt;/a&gt;——一个使用 Go 的 CS 编程和课程列表&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; disabled class=&#34;task-list-item&#34;&gt; &lt;a href=&#34;https://github.com/golang/go/wiki/NonEnglish&#34; target=&#34;_blank&#34;&gt;非英语人士的资源&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-社区&#34;&gt;Go 社区&lt;/h3&gt;

&lt;p&gt;有一些地方，你可以找到在线的 Gophers。要了解成为 Go 社区一名成员意味着什么，阅读 &lt;a href=&#34;https://medium.com/@dgryski/the-go-community-f0d00e3a19e&#34; target=&#34;_blank&#34;&gt;Damian Gryski 在 2015 年 GolankUK 会议上的主题演讲&lt;/a&gt;或者观看 &lt;a href=&#34;https://www.youtube.com/watch?v=0ht89TxZZnk&#34; target=&#34;_blank&#34;&gt;Andrew Gerrand 在 2015 年 GopherCon 上的闭幕演讲&lt;/a&gt;。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gophers 在线聚会场所：

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://forum.golangbridge.org/&#34; target=&#34;_blank&#34;&gt;Go 论坛&lt;/a&gt;——Go 社区的万能讨论论坛&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://gophers.slack.com/&#34; target=&#34;_blank&#34;&gt;Gophers Slack Channel&lt;/a&gt;——针对实时聊天(&lt;a href=&#34;http://blog.gopheracademy.com/gophers-slack-community/&#34; target=&#34;_blank&#34;&gt;要求成员&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://golangnews.com/&#34; target=&#34;_blank&#34;&gt;Golang 新闻&lt;/a&gt;——关于 Go 编程的链接&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://reddit.com/r/golang&#34; target=&#34;_blank&#34;&gt;r/golang&lt;/a&gt;——sub-reddit&lt;/li&gt;
&lt;li&gt;在 Twitter 上，follow @golang 账户，并且&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;使用-go-工具链&#34;&gt;使用 go 工具链&lt;/h3&gt;

&lt;h3 id=&#34;其他的-go-编程维基&#34;&gt;其他的 Go 编程维基&lt;/h3&gt;

&lt;h3 id=&#34;网上用-go-的服务&#34;&gt;网上用 Go 的服务&lt;/h3&gt;

&lt;h3 id=&#34;生产环境的-go-程序疑难解答&#34;&gt;生产环境的 Go 程序疑难解答&lt;/h3&gt;

&lt;h3 id=&#34;为-go-项目做贡献&#34;&gt;为 Go 项目做贡献&lt;/h3&gt;

&lt;h3 id=&#34;平台特定的信息&#34;&gt;平台特定的信息&lt;/h3&gt;

&lt;h3 id=&#34;发布特定的信息&#34;&gt;发布特定的信息&lt;/h3&gt;

&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>软件架构和设计教程</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/readme/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://www.tutorialspoint.com/software_architecture_design/index.htm&#34; target=&#34;_blank&#34;&gt;原网站&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;软件架构：指软件系统较大的结构，处理的是多个软件进程合作执行任务&lt;/li&gt;
&lt;li&gt;软件设计：指较小的结构，处理的是一个软件进程内部的设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;有用的书&#34;&gt;有用的书&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Software-Architecture-Practice-3rd-Engineering/dp/0321815734/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Software Architecture in Practice (3rd Edition) (SEI Series in Software Engineering)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Beyond-Software-Architecture-Sustaining-Solutions/dp/0201775948/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Beyond Software Architecture: Creating and Sustaining Winning Solutions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Software-Systems-Architecture-Stakeholders-Perspectives/dp/032171833X/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Software Systems Architecture: Working With Stakeholders Using Viewpoints and Perspectives (2nd Edition)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Software-Architecture-Foundations-Theory-Practice/dp/0470167742/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Software Architecture: Foundations, Theory, and Practice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.amazon.com/Software-Architecture-Practice-2nd-Bass/dp/0321154959/httpwwwtuto0a-20&#34; target=&#34;_blank&#34;&gt;Software Architecture in Practice (2nd Edition)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1 介绍</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/1-introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/1-introduction/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84&#34;&gt;1.1 软件架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1&#34;&gt;1.2 软件设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%e6%9e%b6%e6%9e%84%e7%9b%ae%e6%a0%87&#34;&gt;1.3 架构目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%e8%bd%af%e4%bb%b6%e6%9e%b6%e6%9e%84%e7%9a%84%e8%a7%92%e8%89%b2&#34;&gt;1.4 软件架构的角色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-%e8%b4%a8%e9%87%8f%e5%8f%82%e6%95%b0&#34;&gt;1.5 质量参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#16-%e8%b4%a8%e9%87%8f%e6%83%85%e6%99%af&#34;&gt;1.6 质量情景&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;软件架构和设计有关的元素如下图
&lt;img src=&#34;ref/software_architecture_types.jpg&#34; alt=&#34;软件架构类型&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-1-软件架构&#34;&gt;1.1 软件架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;软件架构描述了一个系统的蓝图&lt;/li&gt;
&lt;li&gt;定义了一个结构化的解决方案来满足所有的技术和操作需求，同时优化一些常见的质量参数(比如性能、安全性)&lt;/li&gt;
&lt;li&gt;包含一系列和软件开发组织有关的重要决策，而且每个决定对于最终产品的质量、可维护性、性能有重要的影响。决策包括

&lt;ul&gt;
&lt;li&gt;组成系统的结构化元素和元素接口的选取&lt;/li&gt;
&lt;li&gt;上述元素之间合作的行为&lt;/li&gt;
&lt;li&gt;将上述结构化、指定行为的元素组成一个大的子系统&lt;/li&gt;
&lt;li&gt;和商业目标一致的架构决策&lt;/li&gt;
&lt;li&gt;指导组织的架构风格&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-软件设计&#34;&gt;1.2 软件设计&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;软件设计提供了一个设计计划，此计划描述了一个系统的元素，以及元素之间如何组合并一起工作来满足系统的需求&lt;/li&gt;
&lt;li&gt;设计计划的目标包括

&lt;ul&gt;
&lt;li&gt;商定系统需求，设置对客户、市场和管理人事的期望&lt;/li&gt;
&lt;li&gt;作为开发过程中的一个蓝图&lt;/li&gt;
&lt;li&gt;指导执行任务，包括详细设计、编码、集成、测试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;软件设计在详细设计、编码、继承和测试之前，在领域分析、需求分析和风险分析之后
&lt;img src=&#34;ref/software_design.jpg&#34; alt=&#34;软件设计&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-3-架构目标&#34;&gt;1.3 架构目标&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;架构目标

&lt;ul&gt;
&lt;li&gt;主要目标是识别影响应用结构的需求&lt;/li&gt;
&lt;li&gt;降低和创建技术解决方案有关的商业风险，并且连接商业和技术需求&lt;/li&gt;
&lt;li&gt;展示系统结构，但是隐藏实现细节&lt;/li&gt;
&lt;li&gt;实现所有的用例(use-case)和情景&lt;/li&gt;
&lt;li&gt;设法满足不同利益共享者的需求&lt;/li&gt;
&lt;li&gt;简化所有者的目标，改善组织的市场定位&lt;/li&gt;
&lt;li&gt;改善系统提供的质量和功能&lt;/li&gt;
&lt;li&gt;改善外部对于组织或系统的信心&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;软件架构仍然是软件工程领域刚出现的准则。因此有一些限制

&lt;ul&gt;
&lt;li&gt;缺少工具和标准化的方式呈现架构&lt;/li&gt;
&lt;li&gt;缺少分析方法来预测架构是否会落实实现需求&lt;/li&gt;
&lt;li&gt;缺少对从架构设计到软件设计重要性的认知&lt;/li&gt;
&lt;li&gt;缺少对软件架角色和利益共享者之间缺乏沟通的理解&lt;/li&gt;
&lt;li&gt;缺少对设计流程、设计经验和设计评估的理解&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-4-软件架构的角色&#34;&gt;1.4 软件架构的角色&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;软件架构提供了解决方案，技术团队可以用来创建和设计整个应用&lt;/li&gt;
&lt;li&gt;相关的专业知识包括

&lt;ul&gt;
&lt;li&gt;设计：软件设计的知识、方法和途径；领导开发团队；审查和权衡设计建议&lt;/li&gt;
&lt;li&gt;领域：帮助确认需求，确保完整性和一致性&lt;/li&gt;
&lt;li&gt;技术：熟悉已有技术，整合选择编程语言、框架、平台和数据库等&lt;/li&gt;
&lt;li&gt;方法论：在软件开发生命周期可采用的软件开发方法，选择合适的方法帮助整个团队&lt;/li&gt;
&lt;li&gt;隐藏的角色：促进团队成员间的技术工作，强化团队的信任关系；分享知识，有很多经验的信息专家；保护团队免受外界干预和分心&lt;/li&gt;
&lt;li&gt;交付的产品：&lt;/li&gt;
&lt;li&gt;一个清楚、完整、一致且可达到的功能目标&lt;/li&gt;
&lt;li&gt;对于系统的一个功能性描述，至少有两个层面的分解&lt;/li&gt;
&lt;li&gt;对于该系统的一些概念&lt;/li&gt;
&lt;li&gt;系统的设计层面，至少有两层分解&lt;/li&gt;
&lt;li&gt;对于时间、操作人员属性、实现和操作计划的标注&lt;/li&gt;
&lt;li&gt;一个文件或流程，用于确保功能性的分解，以及接口的形式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-5-质量参数&#34;&gt;1.5 质量参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;质量参数可分为

&lt;ul&gt;
&lt;li&gt;静态质量参数：反映了系统和组织的结构，与架构、设计和源码直接相关&lt;/li&gt;
&lt;li&gt;对终端用户不可见，但是影响了开发和维护成本&lt;/li&gt;
&lt;li&gt;比如模块化性、可测试性、可维护性&lt;/li&gt;
&lt;li&gt;动态质量参数：反映了系统执行期间的行为&lt;/li&gt;
&lt;li&gt;与系统的架构、设计、源码、配置、部署参数、环境和平台直接相关&lt;/li&gt;
&lt;li&gt;对于终端用户可见，且存在于运行时&lt;/li&gt;
&lt;li&gt;比如吞吐率、健壮性、可伸缩性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-6-质量情景&#34;&gt;1.6 质量情景&lt;/h2&gt;

&lt;p&gt;一个软件架构必须有的公共的质量参数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;设计质量

&lt;ul&gt;
&lt;li&gt;概念完整性：定义整个设计的一致性和条理性，包括组件或模块的设计方式&lt;/li&gt;
&lt;li&gt;可维护性：在一定程度上可修改&lt;/li&gt;
&lt;li&gt;可复用性：组件或紫刺探对其他应用可用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运行时质量

&lt;ul&gt;
&lt;li&gt;互用性：一个或多个系统与外部系统通过通信和交换信息正确操作，外部系统由外部组成来写或运行&lt;/li&gt;
&lt;li&gt;易管理性：系统管理员容易管理系统&lt;/li&gt;
&lt;li&gt;可靠性：系统维持操作的时间&lt;/li&gt;
&lt;li&gt;可伸缩性：可以不影响系统性能时解决负载增加的问题，或是易于扩大规模&lt;/li&gt;
&lt;li&gt;安全性：可以阻止设计之外的恶意或者偶然的使用&lt;/li&gt;
&lt;li&gt;性能：表明在给定的时间间隔，系统对于所有动作的反应&lt;/li&gt;
&lt;li&gt;可用性：定义系统正常工作的时间比例&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;系统质量

&lt;ul&gt;
&lt;li&gt;可支持性：当工作不正确时，可以提供有用的信息便于定位和解决问题&lt;/li&gt;
&lt;li&gt;可测试性：容易为系统和系统组件创建测试标准&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户质量

&lt;ul&gt;
&lt;li&gt;易用性：定义应用如何较好地满足用户和消费者的需求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;架构质量

&lt;ul&gt;
&lt;li&gt;正确性：系统满足所有需求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;非运行时质量

&lt;ul&gt;
&lt;li&gt;可移植性：使得系统可以在不同的电脑环境运行&lt;/li&gt;
&lt;li&gt;完整性：使得单独开发的系统组件一起正常工作&lt;/li&gt;
&lt;li&gt;易修改性：软件系统易修改&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;商业质量参数

&lt;ul&gt;
&lt;li&gt;花费和日程表：系统的花费，考虑市场时间、期望的工程时间、已有项目的利用&lt;/li&gt;
&lt;li&gt;市场性：系统的使用，考虑到市场竞争&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2 重要原则</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/2-key-principles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/2-key-principles/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e6%9e%b6%e6%9e%84%e9%a3%8e%e6%a0%bc&#34;&gt;2.1 架构风格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%e5%85%ac%e5%85%b1%e7%9a%84%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1&#34;&gt;2.2 公共的架构设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%e6%9e%b6%e6%9e%84%e7%b1%bb%e5%9e%8b&#34;&gt;2.3 架构类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%e6%9e%b6%e6%9e%84%e8%ae%be%e8%ae%a1%e6%b5%81%e7%a8%8b&#34;&gt;2.4 架构设计流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25-%e9%87%8d%e8%a6%81%e7%9a%84%e6%9e%b6%e6%9e%84%e5%8e%9f%e5%88%99&#34;&gt;2.5 重要的架构原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26-%e9%87%8d%e8%a6%81%e7%9a%84%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99&#34;&gt;2.6 重要的设计原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-1-架构风格&#34;&gt;2.1 架构风格&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;架构风格(architectural style)，也叫架构模式(architectural pattern)，为一组系统定义了抽象的框架&lt;/li&gt;
&lt;li&gt;架构风格内容包括

&lt;ul&gt;
&lt;li&gt;提供组件和连接者的词汇表，以及它们如何联合的规则&lt;/li&gt;
&lt;li&gt;通过给出常见问题的解决方案改善划分，允许设计重用&lt;/li&gt;
&lt;li&gt;描述一种特别的方式来配置一组组件(一个具有定义良好的接口、可重用、可替换的模块)和连接者(模块之间的通信链接)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每种风格描述了一个系统分类，包括

&lt;ul&gt;
&lt;li&gt;一组组件类型，用来执行系统要求的功能&lt;/li&gt;
&lt;li&gt;一组连接者(子例程调用，远程过程调用，数据流和套接字)使得不同的组件通信、协调、合作&lt;/li&gt;
&lt;li&gt;语义限制，定义组件如何整合成系统&lt;/li&gt;
&lt;li&gt;组件的布局拓扑图，表明它们运行时的相互关系&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-公共的架构设计&#34;&gt;2.2 公共的架构设计&lt;/h2&gt;

&lt;p&gt;架构风格根据主要的聚焦点可以分为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;通信

&lt;ul&gt;
&lt;li&gt;消息总线：规定软件系统的使用，通过一个或多个通信通道可以接受和发送消息&lt;/li&gt;
&lt;li&gt;服务导向架构：定义应用服务使用约定和消息暴露和消费功能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;部署

&lt;ul&gt;
&lt;li&gt;客户端/服务端：将系统分为客户端和服务端，客户端向服务端发送请求&lt;/li&gt;
&lt;li&gt;3/N 层式：将功能分为独立的部分，每个部分成为一层，分布在不同的物理机上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;领域

&lt;ul&gt;
&lt;li&gt;领域驱动设计：聚焦于模块化一个业务领域，基于该领域的实体定义领域目标&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;结构

&lt;ul&gt;
&lt;li&gt;基于组件：将应用设计成可复用的功能或逻辑组件，组件具有定义良好的通信接口&lt;/li&gt;
&lt;li&gt;分层：将应用的问题分成重叠的组(层)&lt;/li&gt;
&lt;li&gt;面向对象：基于应用或系统的责任分成对象，每个对象包含数据以及和该对象有关的行为&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-3-架构类型&#34;&gt;2.3 架构类型&lt;/h2&gt;

&lt;p&gt;从企业的角度来看有一下几种架构&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;业务架构：定义企业内业务、管理、组织和主要业务流程的策略，集中于业务流程的分析和设计&lt;/li&gt;
&lt;li&gt;应用(软件)架构：作为单个应用系统的蓝图,系统的相互作用和系统对组织业务流程的的关系&lt;/li&gt;
&lt;li&gt;信息架构：定义逻辑和物理的数据资源和数据管理资源&lt;/li&gt;
&lt;li&gt;信息技术(IT)架构：定义硬件和软件的基石，它们组成了组织的整个信息系统&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-4-架构设计流程&#34;&gt;2.4 架构设计流程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;架构设计流程致力于分解系统为不同的组件，以及组件直接相互作用以满足功能性和非功能性的需求&lt;/li&gt;
&lt;li&gt;架构设计的输入是

&lt;ul&gt;
&lt;li&gt;通过分析人物得到的需求&lt;/li&gt;
&lt;li&gt;硬件架构(系统架构配置硬件架构，软件架构反过来为系统架构提供需求)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;架构设计的输出是一个架构描述&lt;/li&gt;
&lt;li&gt;架构设计流程包括

&lt;ul&gt;
&lt;li&gt;理解问题：许多软件项目和产品是失败的，因为它们没有真正解决一个有效的商业问题，或者说对于投资没有一个可识别的回报&lt;/li&gt;
&lt;li&gt;确认设计元素和它们的关系&lt;/li&gt;
&lt;li&gt;为定义系统的边界上下文设定一个基线&lt;/li&gt;
&lt;li&gt;基于功能将系统分解成主要的组件。分解可以模型化，使用设计结构矩阵(DSM, Design structure matrix)，它展示了设计元素之间的依赖，不指定元素的粒度&lt;/li&gt;
&lt;li&gt;评估架构设计&lt;/li&gt;
&lt;li&gt;评估每个质量参数收集定量的数据和测量，从而评估设计&lt;/li&gt;
&lt;li&gt;如果满足每个质量参数的标准，则软件设计流程完成&lt;/li&gt;
&lt;li&gt;否则进入下个阶段，即转换架构设计&lt;/li&gt;
&lt;li&gt;转换架构设计&lt;/li&gt;
&lt;li&gt;修改架构直到满足质量参数需求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-5-重要的架构原则&#34;&gt;2.5 重要的架构原则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;为了改变而构建，而不是为了持续而构建：随着时间发展应用可能需要改变来满足新需求或挑战&lt;/li&gt;
&lt;li&gt;降低风险和模型以便于分析：使用决策工具，可视化、模型化系统来捕获需求，设计决策&lt;/li&gt;
&lt;li&gt;使用模型和可视化作为通信和协作工具：和利益共享者高效的沟通和共享设计&lt;/li&gt;
&lt;li&gt;使用增量迭代的方法：以基本架构开始，然后通过迭代测试逐步形成候选的架构，改善架构&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-6-重要的设计原则&#34;&gt;2.6 重要的设计原则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;关注点分类：确保组件功能之间没有重叠；高内聚，低耦合&lt;/li&gt;
&lt;li&gt;单一责任原则：系统的每个模块有专门的功能&lt;/li&gt;
&lt;li&gt;最少知识原则：每个组件或对象不应知道其他组件的内部细节，可以避免依赖性，提高可维护性&lt;/li&gt;
&lt;li&gt;最小化提前大型设计：当应用需求不明确时，尽量减少大型设计。如果可能需要修改需求，那么避免为整个系统添加大的设计

&lt;ul&gt;
&lt;li&gt;BDUF(Big Design Up front)，一种软件开发方法，即程序实现开始之前，程序设计时完全的、完美的、常应用域瀑布模型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不要重复功能：重复功能的代码不易修改，清晰度降低，且增加了潜在的不一致性&lt;/li&gt;
&lt;li&gt;重用功能时使用复合而不是继承：继承增加了父类和子类的依赖性，不利于单独使用子类&lt;/li&gt;
&lt;li&gt;确定组件并且整合到逻辑层：将某个关注点相关的组件组合到一个逻辑层&lt;/li&gt;
&lt;li&gt;定义层之间的通信协议&lt;/li&gt;
&lt;li&gt;定义层的数据格式：不同的组件通过数据格式交互，确保层内的数据格式是一样的&lt;/li&gt;
&lt;li&gt;系统服务组件应是抽象的：有关安全性、通信或系统服务(比如日志、分析和配置)的代码再各个组件应该是抽象的。不要将其与业务逻辑混合&lt;/li&gt;
&lt;li&gt;设计异常和异常处理机制：提前定义异常，帮助组件管理错误和不希望的情形&lt;/li&gt;
&lt;li&gt;命名规范：提前定义命名规范。以便用户理解系统，也便于团队成员检验其他人的代码，增强可维护性&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>3 架构模型</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/3-architecture-models/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/3-architecture-models/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#3-%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B&#34;&gt;3 架构模型&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80&#34;&gt;3.1 统一建模语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E6%9E%B6%E6%9E%84%E8%A7%86%E5%9B%BE%E6%A8%A1%E5%9E%8B&#34;&gt;3.2 架构视图模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%E6%9E%B6%E6%9E%84%E6%8F%8F%E8%BF%B0%E8%AF%AD%E8%A8%80&#34;&gt;3.3 架构描述语言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;定义一个软件架构的方式包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;统一建模语言(UML, unified modeling language)：面向对象的解决方案，用于软件建模和设计&lt;/li&gt;
&lt;li&gt;架构视图模型(architecture view model)，也叫 4+1 视图模型(4+1 view model)：展示软件应用的功能性和非功能性需求&lt;/li&gt;
&lt;li&gt;架构描述语言(ADL, architecture description language)：正式地从语义上定义软件架构&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-统一建模语言&#34;&gt;3.1 统一建模语言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作为软件需求分析和设计文档的标准，是开发软件的基础&lt;/li&gt;
&lt;li&gt;有两种示意图

&lt;ul&gt;
&lt;li&gt;结构图：描述系统的静态特点。静态部分可用类、接口、对象、组件和节点表示。结构图可分为&lt;/li&gt;
&lt;li&gt;类图：表示类之间的静态关系&lt;/li&gt;
&lt;li&gt;对象图：表示一组对象运行时关系，也描述了系统的静态视图&lt;/li&gt;
&lt;li&gt;组件图：描述系统所有组件，组件的相互关系、交互和接口&lt;/li&gt;
&lt;li&gt;部署图：一组节点和节点的关系。这些节点是部署组件的物理实体&lt;/li&gt;
&lt;li&gt;包图：描述包的结构和组织。包括一个包内的类和包内的包&lt;/li&gt;
&lt;li&gt;复合结构图：描述组件内部的结构，包括所有的类、组件的接口&lt;/li&gt;
&lt;li&gt;动作/行为图：捕获系统的动态特点，包括系统改变/移动的部分。动作图分为&lt;/li&gt;
&lt;li&gt;用例图：描述功能之间的关系，以及它们内部/外部的控制器/行动者&lt;/li&gt;
&lt;li&gt;序列图：可视化系统内完成专门功能的调用顺序&lt;/li&gt;
&lt;li&gt;通信图：和序列图一样，区别在于通信图关注对象角色&lt;/li&gt;
&lt;li&gt;状态图：表示系统的时间驱动状态变化。主要是类、接口的状态变化&lt;/li&gt;
&lt;li&gt;活动图：描述系统的控制流，包括活动和连接。流可以是顺序的、并发的、分支的&lt;/li&gt;
&lt;li&gt;交互图：包含活动图和序列图，提供系统和业务流程的控制流的总览&lt;/li&gt;
&lt;li&gt;时序图：描述状态、条件和事件消息的变化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-架构视图模型&#34;&gt;3.2 架构视图模型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;模型：对软件架构完整的、基础的、简化的描述，包括从一个角度或视角的多个视图&lt;/li&gt;
&lt;li&gt;视图：表示一组相关的关注点的整个系统。用于从不同的利益共享者(比如终端用户、开发者、项目管理者和测试者)描述系统&lt;/li&gt;
&lt;li&gt;4+1 视图模型：是一个强调系统不同的特点和关注点的多视图模型。标准化软件设计文档，使得设计被所有的利益共享者更好理解&lt;/li&gt;
&lt;li&gt;提供 4 个基本的视图

&lt;ul&gt;
&lt;li&gt;逻辑/概念视图：描述设计的对象模型&lt;/li&gt;
&lt;li&gt;进程视图：描述系统的活动，捕获设计的并发和同步特点&lt;/li&gt;
&lt;li&gt;物理视图：描述软件到硬件的映射，也反映了分布式特点&lt;/li&gt;
&lt;li&gt;开发视图：描述软件在开发环境下的静态组织或结构&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;1 个额外视图：场景视图/用例视图

&lt;ul&gt;
&lt;li&gt;为软件系统的终端用户和客户设计&lt;/li&gt;
&lt;li&gt;和其他 4 个视图一起展现架构&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4+1 视图的关系如下
&lt;img src=&#34;ref/four_plus_one_view_model.jpg&#34; alt=&#34;4+1视图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;3-3-架构描述语言&#34;&gt;3.3 架构描述语言&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一种正式的规范语言，描述了软件特点(比如进程、线程、数据、子程序)和硬件组件(比如处理器、设备、总线和内存)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>4 面向对象泛型</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/4-object-oriented-paradigm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/4-object-oriented-paradigm/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B&#34;&gt;4 面向对象泛型&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B3%9B%E5%9E%8B%E4%BB%8B%E7%BB%8D&#34;&gt;4.1 面向对象泛型介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90&#34;&gt;4.2 面向对象分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1&#34;&gt;4.3 面向对象设计&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-1-面向对象泛型介绍&#34;&gt;4.1 面向对象泛型介绍&lt;/h2&gt;

&lt;p&gt;面向对象系统的基础概念和术语包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对象：在面向对象环境中，对象是真实的元素，在物理(比如一个客户、一辆车)或概念(比如一个项目、一个进程)上是存在的

&lt;ul&gt;
&lt;li&gt;每个对象都有&lt;/li&gt;
&lt;li&gt;身份：与系统中其他对象区分&lt;/li&gt;
&lt;li&gt;状态：决定一个对象的特点属性，已经持有的属性的值&lt;/li&gt;
&lt;li&gt;行为：表示一个对象执行的外部可见的行为，和对象的状态变化相关&lt;/li&gt;
&lt;li&gt;对象可以根据应用的需求被模型化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类：类表示拥有相同的特点属性(表现相同的行为)的一组对象

&lt;ul&gt;
&lt;li&gt;创建一个类的一个对象作为成员称作实例化。因此，对象是类的一个实例&lt;/li&gt;
&lt;li&gt;一个类包括&lt;/li&gt;
&lt;li&gt;一组属性：对象从类实例化得到的属性

&lt;ul&gt;
&lt;li&gt;一般来说，一个类的不同对象在这些属性上有一些不同&lt;/li&gt;
&lt;li&gt;属性常表示成类的数据&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一组操作：描绘该类的对象的行为

&lt;ul&gt;
&lt;li&gt;操作常表示成类的函数或方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;封装：封装是在类中将属性和方法绑定在一起的过程

&lt;ul&gt;
&lt;li&gt;通过封装，类可以向外部隐藏内部的细节&lt;/li&gt;
&lt;li&gt;类只允许外部通过接口访问类内的元素&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多态：多态暗示操作的方式不同，取决于操作针对的实例

&lt;ul&gt;
&lt;li&gt;多态使得内部结构不同的对象可以向外部提供统一的接口&lt;/li&gt;
&lt;li&gt;多态主要通过继承实现&lt;/li&gt;
&lt;li&gt;关系：系统包括动态(行为)指标和静态(逻辑)指标&lt;/li&gt;
&lt;li&gt;动态指标描述对象之间的关系(比如消息传递)&lt;/li&gt;
&lt;li&gt;静态指标描述类之间的关系(比如聚合、关联、继承)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;消息传递：系统内的对象彼此使用消息传递通信

&lt;ul&gt;
&lt;li&gt;一个对象如果想要另一个对象执行一个方法，必须给该对象发送一个消息&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;复合或聚合：复合或聚合表示类间的关系，指一个类可以通过其他类对象的组合生成

&lt;ul&gt;
&lt;li&gt;聚合指的是 part-of 或 has-a 关系&lt;/li&gt;
&lt;li&gt;一个聚合类由一个或多个其他的对象组成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关联：关联是拥有共同的结构和行为的一组链接(link)。关联描述了一个或多个类的对象之间的关系

&lt;ul&gt;
&lt;li&gt;一个链接(link)可以定义成一个关联的一个实体&lt;/li&gt;
&lt;li&gt;关联的度表示参与到一个连接的类的数目。度可以是单元、二元或三元的&lt;/li&gt;
&lt;li&gt;一个单元关系连接同一个类内的对象&lt;/li&gt;
&lt;li&gt;一个二元关系连接两个类的对象&lt;/li&gt;
&lt;li&gt;一个三元关系连接三个或多个类的对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;继承：继承机制允许基于已有的类创建类，创建的类可以扩展或重定义能力

&lt;ul&gt;
&lt;li&gt;已有的类称作基类/父类/超类(super-class)，新类成为衍生类/子类/亚类(subclass)&lt;/li&gt;
&lt;li&gt;亚类可以继承或衍生超类提供的属性和方法&lt;/li&gt;
&lt;li&gt;亚类也可以添加自己的属性和方法，且方法可能会改变超类的方法&lt;/li&gt;
&lt;li&gt;继承定义了 is-a 的关系&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-面向对象分析&#34;&gt;4.2 面向对象分析&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;OO(object-oriented，面向对象)分析的目的是理解系统的应用领域和特定的需求&lt;/li&gt;
&lt;li&gt;OO 分析的输出是系统的需求规格文档、逻辑结构的初始分析和可行性&lt;/li&gt;
&lt;li&gt;OO 分析常用的分析技术包括

&lt;ul&gt;
&lt;li&gt;对象建模：开发软件系统对象的静态结构。对象建模的步骤&lt;/li&gt;
&lt;li&gt;标识对象，组合成类&lt;/li&gt;
&lt;li&gt;标识对象间的关系&lt;/li&gt;
&lt;li&gt;创建一个用户对象模型图&lt;/li&gt;
&lt;li&gt;定义一个用户对象的属性&lt;/li&gt;
&lt;li&gt;定义类上应该执行的操作&lt;/li&gt;
&lt;li&gt;动态建模：动态建模的目的是检验系统的时间和外部变化&lt;/li&gt;
&lt;li&gt;动态建模可以定义为“描述一个单独的对象如何响应事件的一种方式，事件可以是其他对象触发的内部事件，或者外部世界触发的外部事件”&lt;/li&gt;
&lt;li&gt;动态建模的步骤

&lt;ul&gt;
&lt;li&gt;标识每个对象的状态&lt;/li&gt;
&lt;li&gt;标识事件，分析行为的适用性&lt;/li&gt;
&lt;li&gt;构建动态模型图，包括状态转换图&lt;/li&gt;
&lt;li&gt;表示对象属性的每个状态&lt;/li&gt;
&lt;li&gt;验证画的状态转换图&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;功能建模：功能模型展示了对象内部执行的流程，以及对象在方法之间移动时数据如何变化&lt;/li&gt;
&lt;li&gt;功能建模详细说明了对象建模操作和动态建模行为的意义&lt;/li&gt;
&lt;li&gt;功能建模和传统的结构化分析的数据流图对应&lt;/li&gt;
&lt;li&gt;功能建模的步骤

&lt;ul&gt;
&lt;li&gt;标识所有的输入和输出&lt;/li&gt;
&lt;li&gt;构建数据流图，展示功能依赖性&lt;/li&gt;
&lt;li&gt;说明每个函数的目的&lt;/li&gt;
&lt;li&gt;标识约束&lt;/li&gt;
&lt;li&gt;具体说明优化标准&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-面向对象设计&#34;&gt;4.3 面向对象设计&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;面向对象设计(OOD, object-oriented design)阶段，面向对象分析中的技术独立性概念被映射到实现类，约束被标识，接口被设计，生成解决方案域的模型&lt;/li&gt;
&lt;li&gt;OOD 的主要目的是开发系统的结构化架构&lt;/li&gt;
&lt;li&gt;OOD 的步骤

&lt;ul&gt;
&lt;li&gt;定义系统的上下文&lt;/li&gt;
&lt;li&gt;设计系统架构&lt;/li&gt;
&lt;li&gt;标识系统的对象&lt;/li&gt;
&lt;li&gt;构造设计模型&lt;/li&gt;
&lt;li&gt;规范对象接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OOD 总结为两个步骤

&lt;ul&gt;
&lt;li&gt;概要设计：也叫高层设计，定义系统所需所有类，详细描述每个类的功能&lt;/li&gt;
&lt;li&gt;使用类图描述类间的关系&lt;/li&gt;
&lt;li&gt;交互图展示事件流&lt;/li&gt;
&lt;li&gt;详细设计：也叫低层设计，基于交互图给每个类赋予属性和操作&lt;/li&gt;
&lt;li&gt;状态图描述设计进一步的细节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;需要遵循下面的设计原则

&lt;ul&gt;
&lt;li&gt;解耦原理：低耦合，可以通过引入新的类或继承消除耦合&lt;/li&gt;
&lt;li&gt;确保内聚：高内聚，一个内聚的类执行一组紧密相关的功能&lt;/li&gt;
&lt;li&gt;开放封闭原则：系统应该可以扩展满足新的需求&lt;/li&gt;
&lt;li&gt;系统已有的实现和代码不应该被修改以扩展系统&lt;/li&gt;
&lt;li&gt;下面是指导方针

&lt;ul&gt;
&lt;li&gt;对于每一个具体类，应该维护独立的接口和实现&lt;/li&gt;
&lt;li&gt;在多线程环境，保持属性是私有的&lt;/li&gt;
&lt;li&gt;最小化全局变量和类变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>5 数据流结构</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/5-data-flow-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/5-data-flow-architecture/</guid>
      <description>&lt;p&gt;模型之间的执行有三种类型&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;批量顺序

&lt;ul&gt;
&lt;li&gt;数据流携带批量的数据作为一个整体，从一个子系统到另外一个子系统&lt;/li&gt;
&lt;li&gt;模块之间的通信可通过临时文件执行，并由后续的子系统删除&lt;/li&gt;
&lt;li&gt;对于数据是批量的应用可行，每个子系统读相关的输入文件，然后写相关的输出文件&lt;/li&gt;
&lt;li&gt;此架构典型的应用包括业务数据处理，比如银行和公用事业账单&lt;/li&gt;
&lt;li&gt;优点：提供子系统简单的分割，每个子系统可以是一个独立的程序，作用于输入数据，生成输出数据&lt;/li&gt;
&lt;li&gt;缺点：高延迟，低吞吐；不停并发和交互接口；需要外部控制实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;管道和过滤或非顺序的流水线模式

&lt;ul&gt;
&lt;li&gt;过滤器：一个过滤器是一个独立的数据流转换器或流传感器。在内部转换输入数据流，然后通过管道写转换的数据流传给下一个过滤器处理&lt;/li&gt;
&lt;li&gt;主动过滤器：让连接的管道拉入数据，然后推出转换的数据&lt;/li&gt;
&lt;li&gt;被动过滤器：让连接的管道推入数据，然后拉出转换的数据，必须提供读写机制&lt;/li&gt;
&lt;li&gt;优点：并行，高吞吐；可复用，简化系统维护；易修改，低耦合；灵活度，支持顺序和并行执行&lt;/li&gt;
&lt;li&gt;缺点：对动态交互不合适；过滤器直接数据转换的负载；不支持过滤器合作交互解决问题；难以动态配置&lt;/li&gt;
&lt;li&gt;管道：无状态，存在于过滤器之间，可以携带二进制或字符流&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;流程控制

&lt;ul&gt;
&lt;li&gt;处理单元：改变处理控制变量&lt;/li&gt;
&lt;li&gt;控制单元：计算改变数量。必须包含以下元素&lt;/li&gt;
&lt;li&gt;控制变量、输入变量、操纵变量、处理定义、敏感元件、设定点、控制算法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>6 以数据为中心的架构</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/6-data-centered-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/6-data-centered-architecture/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;组件包括

&lt;ul&gt;
&lt;li&gt;中心数据结构/数据存储器/数据仓库：负责提供长久的数据存储，表示当前的状态&lt;/li&gt;
&lt;li&gt;数据访问器/一系列独立的组件：操作中心数据结构存储，执行计算，存回结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>7 层次化架构</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/7-hierarchical-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/7-hierarchical-architecture/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-%e4%b8%bb%e5%ad%90%e4%be%8b%e7%a8%8b%e6%9e%b6%e6%9e%84&#34;&gt;7.1 主子例程架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-%e4%b8%bb%e4%bb%8e%e5%bc%8f%e6%9e%b6%e6%9e%84&#34;&gt;7.2 主从式架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%9e%b6%e6%9e%84&#34;&gt;7.3 虚拟机架构&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#74-%e5%88%86%e5%b1%82%e5%bc%8f%e6%9e%b6%e6%9e%84&#34;&gt;7.4 分层式架构&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将整个系统视为层次结构，即将软件系统分为不同层次的逻辑模块或子系统&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分类：主-子例程、主从式、虚拟机、分层式&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-1-主子例程架构&#34;&gt;7.1 主子例程架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;目的是复用模块，自由开发各自的模块或子例程&lt;/li&gt;
&lt;li&gt;将数据作为参数传递给子例程：值传递/引用传递&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/main_subroutine.jpg&#34; alt=&#34;主-子例程架构&#34; /&gt;&lt;/li&gt;
&lt;li&gt;优点：易基于层次改进分解系统；可用于 OOD 的子系统&lt;/li&gt;
&lt;li&gt;缺点：因包含全局共享数据而易受攻击；高耦合导致不易修改&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-2-主从式架构&#34;&gt;7.2 主从式架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;应用分治的思想，提供系统稳定系和容错性&lt;/li&gt;
&lt;li&gt;架构向主设备提供相同的服务，主设备根据选择策略从架构选取结果&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/master_slave.jpg&#34; alt=&#34;主从式架构&#34; /&gt;&lt;/li&gt;
&lt;li&gt;实现步骤：

&lt;ul&gt;
&lt;li&gt;指定计算任务如何分解成一系列等价的子任务，然后指定所需子服务处理子任务&lt;/li&gt;
&lt;li&gt;指定如何根据所得子任务的结果计算整个系统最后的结果&lt;/li&gt;
&lt;li&gt;为第一个阶段的子服务定义接口。将由从设备实现，由主设备分配子任务&lt;/li&gt;
&lt;li&gt;根据上述接口实现子服务&lt;/li&gt;
&lt;li&gt;根据前三步实现主服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用：适用于可靠性比较重要的软件，广泛应用于并行和分布式计算领域&lt;/li&gt;
&lt;li&gt;优点：快速计算，方便扩展；从设备可重复，提供了稳健性；从设备实现可不同以最小化语义错误&lt;/li&gt;
&lt;li&gt;缺点：通信负载；不是所有问题可分割；难以实现，不易跨平台&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-3-虚拟机架构&#34;&gt;7.3 虚拟机架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个虚拟机基于已有系统创建，提供一个虚拟的抽象、一系列属性和操作&lt;/li&gt;
&lt;li&gt;在虚拟机架构中，主设备使用从设备相同的子服务，执行例如划分工作、调用从设备、联合结果等工作&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/virtual_machine_architecture.jpg&#34; alt=&#34;虚拟机架构&#34; /&gt;&lt;/li&gt;
&lt;li&gt;应用：适用于以下领域

&lt;ul&gt;
&lt;li&gt;如果没有直接的解决方案，通过仿真或翻译解决问题&lt;/li&gt;
&lt;li&gt;样例程序，包括微程序解释，XML 处理，脚本命令语言执行，基于规则系统的执行，Smalltalk 和 Java 解释器类型的编程语言&lt;/li&gt;
&lt;li&gt;常见的例子包括解释器、基于规则的系统、句法 shell、命令语言处理器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;优点：可移植性，机器平台独立性；简化软件开发；灵活性；仿真灾难性的工作模型；引入运行时修改&lt;/li&gt;
&lt;li&gt;缺点：解释器执行慢；性能代价，因为执行中有多余的计算&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-4-分层式架构&#34;&gt;7.4 分层式架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每一层在系统中有自己单独的责任

&lt;ul&gt;
&lt;li&gt;每一层包含一组相关的类，被封装成一个包，一个部署组件，或者作为一组子例程&lt;/li&gt;
&lt;li&gt;每一层为上层提供服务，并作为下层的客户端，即调用下一层的服务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用：

&lt;ul&gt;
&lt;li&gt;适用于包含明显的服务类的应用，可以分成层级式&lt;/li&gt;
&lt;li&gt;应用可被分成特定应用和特定平台的部分&lt;/li&gt;
&lt;li&gt;应用可清晰地分成内核服务、关键服务、用户接口服务等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;优点：基于高层次的抽象；一层修改至多影响相邻两层；接口和实现分类；基于组件技术开发，支持即插即用；每一层可单独部署，可移植；基于任务自上而下分解；相同层的不同实现可互换&lt;/li&gt;
&lt;li&gt;缺点：许多应用或系统不易分解成层级式；多层传递会降低运行时性能；数据在每层传递的负载会降低性能；层内通信可能会死锁，到底高耦合；异常和错误不易传送到所有的调用层&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>8 面向交互的架构</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/8-interaction-oriented-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/8-interaction-oriented-architecture/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81-mvc&#34;&gt;8.1 MVC&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#82-pac&#34;&gt;8.2 PAC&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;目的：将数据层、业务数据处理和用户操作分离&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包括三个部分：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;数据模块：提供数据抽象和业务逻辑&lt;/li&gt;
&lt;li&gt;控制模块：识别控制流和系统配置行为&lt;/li&gt;
&lt;li&gt;视图展示模块：负责输出数据的视觉和听觉展示，也为用户输入提供接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包括两种：模型-视图-控制器(MVC, model-view-control)和显示-抽象-控制器(PAC, presentation-abstraction-control)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-1-mvc&#34;&gt;8.1 MVC&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;模型：封装底层数据和业务逻辑&lt;/li&gt;
&lt;li&gt;控制器：响应用户操作，指导应用流程

&lt;ul&gt;
&lt;li&gt;接收输入并转换成给模型或视图的命令&lt;/li&gt;
&lt;li&gt;作为相关命令、视图和输入设备的接口&lt;/li&gt;
&lt;li&gt;可发送命令给模型，更新模型的状态&lt;/li&gt;
&lt;li&gt;也可发送命令给相关的视图，改变视图的展示&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;视图：格式化模型的数据并展示给用户&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/mvc_component.jpg&#34; alt=&#34;MVC&#34; /&gt;&lt;/li&gt;
&lt;li&gt;可分为

&lt;ul&gt;
&lt;li&gt;MVC-I&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/mvc_1_architecture.jpg&#34; alt=&#34;MVC-I&#34; /&gt;&lt;/li&gt;
&lt;li&gt;模型模块通知控制器-视图模块数据的变化，随之改变对应的图形化数据展示&lt;/li&gt;
&lt;li&gt;模型模块提供所有的数据和域服务&lt;/li&gt;
&lt;li&gt;二者的连接可以是订阅-通知式的，即控制器视图订阅模型，模型将变化通知给控制器-视图&lt;/li&gt;
&lt;li&gt;MVC-II&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/mvc_2_architecture.jpg&#34; alt=&#34;MVC-II&#34; /&gt;&lt;/li&gt;
&lt;li&gt;视图层展示数据&lt;/li&gt;
&lt;li&gt;控制器接收输入请求，验证输入数据，初始化模型、视图以及二者的连接，分发任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用：适用于交互式应用&lt;/li&gt;
&lt;li&gt;优点

&lt;ul&gt;
&lt;li&gt;有很多 MVC 的开发框架包&lt;/li&gt;
&lt;li&gt;用同一个数据模型去同步多个视图&lt;/li&gt;
&lt;li&gt;容易添加和修改接口视图&lt;/li&gt;
&lt;li&gt;应用开发分为图像专家、编程专家、数据库开发专家&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点

&lt;ul&gt;
&lt;li&gt;不适用面向代理的应用&lt;/li&gt;
&lt;li&gt;多个控制器和视图操作统一数据模型，导致数据修改代价增大&lt;/li&gt;
&lt;li&gt;视图和控制器在某些情况下不易划分&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-2-pac&#34;&gt;8.2 PAC&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PAC 将系统划分成多个合作代理的层级。每个代理包含三个组件

&lt;ul&gt;
&lt;li&gt;展示组件：格式化数据并展示给用户&lt;/li&gt;
&lt;li&gt;抽象组件：取回并处理数据&lt;/li&gt;
&lt;li&gt;控制器组件：处理组件之间的控制流或通信等任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/pac_design.jpg&#34; alt=&#34;PAC&#34; /&gt;&lt;/li&gt;
&lt;li&gt;展示组件和抽象组件只能通过控制器组件通信&lt;/li&gt;
&lt;li&gt;多代理的 PAC

&lt;ul&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/multiple_agent_in_pac.jpg&#34; alt=&#34;多代理的 PAC&#34; /&gt;&lt;/li&gt;
&lt;li&gt;每个代理有自己特别指定的工作&lt;/li&gt;
&lt;li&gt;顶层代理提供核心数据和业务逻辑&lt;/li&gt;
&lt;li&gt;底层代理定义特定的数据和展示&lt;/li&gt;
&lt;li&gt;中间代理作为底层代理的协调者&lt;/li&gt;
&lt;li&gt;某些中间代理不需要交互展示，不需要展示组件&lt;/li&gt;
&lt;li&gt;每个代理需要控制器组件与其他代理通信&lt;/li&gt;
&lt;li&gt;应用&lt;/li&gt;
&lt;li&gt;交互系统中，系统可分成层级的合作代理时，较有效&lt;/li&gt;
&lt;li&gt;代理直接的耦合松散，因为代理修改不影响其他代理时，较有效&lt;/li&gt;
&lt;li&gt;分布式系统，每个代理有自己的数据和交互接口处理函数时，较有效&lt;/li&gt;
&lt;li&gt;有大量 GUI 组件，每个 GUI 组件保存自己当前的数据和交互接口，与其他组件进行通信时，较有效&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;优点：支持多任务，多视图；支持代理复用，延伸线好；易添加和修改已有的代理；支持并发，多个代理可在不同的线程或设备或机器上并发运行&lt;/li&gt;
&lt;li&gt;缺点：展示组件和抽象组件的控制桥的负载，代理控制器控制组件之间的通信负载；不易确定代理数目；每个代理完全划分展示和抽闲组件会增加开发复杂性&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>9 分布式架构</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/9-distributed-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/9-distributed-architecture/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#91-%e5%ae%a2%e6%88%b7%e7%ab%af%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%9e%b6%e6%9e%84&#34;&gt;9.1 客户端服务端架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#92-%e5%a4%9a%e5%b1%82%e6%9e%b6%e6%9e%84&#34;&gt;9.2 多层架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#93-%e4%bb%a3%e7%90%86broker%e6%9e%b6%e6%9e%84&#34;&gt;9.3 代理(Broker)架构&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#94-%e9%9d%a2%e5%90%91%e6%9c%8d%e5%8a%a1%e7%9a%84%e6%9e%b6%e6%9e%84&#34;&gt;9.4 面向服务的架构&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;中间件是分布式架构的基础结构。如图&lt;img src=&#34;ref/concepts_distributed_architecture.jpg&#34; alt=&#34;中间件&#34; /&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分布式架构侧重于透明性、可靠性、可用性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;关于透明性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;访问：隐藏访问资源的方式和数据平台的差异&lt;/li&gt;
&lt;li&gt;位置：隐藏资源的位置&lt;/li&gt;
&lt;li&gt;技术：对用户隐藏不同的技术，比如编程语言，操作系统&lt;/li&gt;
&lt;li&gt;迁移/重定位：隐藏使用时可能被移动到另一个位置的资源&lt;/li&gt;
&lt;li&gt;重复：隐藏可能复制在其他地方的资源&lt;/li&gt;
&lt;li&gt;并发：隐藏可能与其他用户共享的资源&lt;/li&gt;
&lt;li&gt;错误：对用户隐藏资源的错误和复原&lt;/li&gt;
&lt;li&gt;一致性：隐藏资源或软件是在内存或磁盘&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优点：资源共享、开放性、并发、易扩展、容错性&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;缺点：复杂度、安全性降低、不易管理、不可预测&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-1-客户端服务端架构&#34;&gt;9.1 客户端服务端架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/two_tier_client_server_architecture.jpg&#34; alt=&#34;客户端-服务端架构&#34; /&gt;&lt;/li&gt;
&lt;li&gt;服务端提供服务，客户端使用这些服务&lt;/li&gt;
&lt;li&gt;服务端不需要知道客户端，客户端需要知道服务端的身份&lt;/li&gt;
&lt;li&gt;优点：分离用户接口展示和业务逻辑处理；服务组件复用，可能并发；简化设计和开发；易迁移或整合已有应用到分布式环境；多客户端访问一个高性能的服务可充分利用资源&lt;/li&gt;
&lt;li&gt;缺点：缺少异构架构处理需求改变；安全问题；服务的可用性和扩展性降低&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-2-多层架构&#34;&gt;9.2 多层架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/n_tier_architecture.jpg&#34; alt=&#34;多层架构&#34; /&gt;&lt;/li&gt;
&lt;li&gt;一般分为三层：展示层、应用层(也叫业务逻辑层、逻辑层、中间层)和数据层

&lt;ul&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/data_tier.jpg&#34; alt=&#34;三层架构&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;优点：易管理、性能好；可复用，易扩展；多线程支持，降低网络负载；易维护，灵活性高&lt;/li&gt;
&lt;li&gt;缺点：不易测试，缺少测试工具；可靠性和可用性对服务要求更高&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-3-代理-broker-架构&#34;&gt;9.3 代理(Broker)架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;中间件架构，在分布式计算中使用，协调注册的服务端和客户端之间的通信&lt;/li&gt;
&lt;li&gt;对象之间通信使用中间件系统，叫做对象请求代理(系统总线)

&lt;ul&gt;
&lt;li&gt;客户端和服务端不会直接交互。它们各自直接连接自己的代理，和 mediator-broker 通信&lt;/li&gt;
&lt;li&gt;服务端通过注册和发布接口到 broker 提供服务，客户端可以通过 broker 静态或动态查找请求服务&lt;/li&gt;
&lt;li&gt;通用对象请求代理架构CORBA(CORBA, Common Object Request Broker Architecture)是一个实现的较好的例子&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;组件包括

&lt;ul&gt;
&lt;li&gt;broker：负责协调通信，比如转发和分发结果和异常&lt;/li&gt;
&lt;li&gt;协商服务请求，定位一个合适的服务端并发送请求，发送回复给客户端&lt;/li&gt;
&lt;li&gt;维护服务端的注册信息，包括它们的功能、服务和定位信息&lt;/li&gt;
&lt;li&gt;给客户端发送请求和服务端发送回复提供 API&lt;/li&gt;
&lt;li&gt;stub：静态编译阶段生成，部署在客户端，作为客户端的代理&lt;/li&gt;
&lt;li&gt;作为客户端和 broker 的协调者&lt;/li&gt;
&lt;li&gt;在协议层隐藏进程间通信(IPC, inter-process communication)&lt;/li&gt;
&lt;li&gt;整合参数值，分割服务端返回的结果&lt;/li&gt;
&lt;li&gt;skeleton：服务端接口编译生成，部署在服务端，作为服务端的代理&lt;/li&gt;
&lt;li&gt;封装了底层特定系统的网络函数，提供高级的 API 来协调服务端和 broker&lt;/li&gt;
&lt;li&gt;接收请求，解包请求，分割方法参数，调用合适的服务，发送结果，发送给客户端&lt;/li&gt;
&lt;li&gt;bridge：基于不同的通信协议连接两个不同的网络，协调不同的 broker&lt;/li&gt;
&lt;li&gt;可选组件，隐藏两个 broker 互相操作的实现细节&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/broker_model.jpg&#34; alt=&#34;代理架构&#34; /&gt;&lt;/li&gt;
&lt;li&gt;CORBA 是针对对象请求代理的国际化标准——一个管理分布式对象通信的中间件

&lt;ul&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/corba_architecture.jpg&#34; alt=&#34;CORBA&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;9-4-面向服务的架构&#34;&gt;9.4 面向服务的架构&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;如图&lt;img src=&#34;ref/soa.jpg&#34; alt=&#34;面向服务的架构&#34; /&gt;&lt;/li&gt;
&lt;li&gt;面向服务的架构(SOA, service-oriented architecture)是一个客户端/服务端设计，支持业务驱动

&lt;ul&gt;
&lt;li&gt;应用包含软件服务端和软件服务消费者&lt;/li&gt;
&lt;li&gt;服务之间的连接通过通用的基于消息的协议(比如 SOAP 网络服务协议)，可以在服务之间发送请求和回复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;特点：分布式部署；可组合性；互用性；复用性&lt;/li&gt;
&lt;li&gt;SOA 操作如图&lt;img src=&#34;ref/soa_operations.jpg&#34; alt=&#34;SOA 操作&#34; /&gt;&lt;/li&gt;
&lt;li&gt;优点：

&lt;ul&gt;
&lt;li&gt;低耦合，可以充分利用已有的服务资源，无关平台和技术限制&lt;/li&gt;
&lt;li&gt;无状态，每个服务组件和其他服务相互独立&lt;/li&gt;
&lt;li&gt;只要不改变接口，修改服务的实现不影响其他服务&lt;/li&gt;
&lt;li&gt;客户端和服务端可以访问其他服务，无关平台、技术、生产商、语言实现&lt;/li&gt;
&lt;li&gt;资产和服务的复用性，只要知道公共接口就可以使用&lt;/li&gt;
&lt;li&gt;在时间和花费上更有效&lt;/li&gt;
&lt;li&gt;提高了可扩展性，为系统提高标准连接&lt;/li&gt;
&lt;li&gt;易整合，改善了内部互操作性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>10 基于组件的架构</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/10-component-based-architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/10-component-based-architecture/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;目标：确保组件复用性&lt;/li&gt;
&lt;li&gt;致力于分解设计成单个功能或逻辑组件，表示定义良好的通信接口，包括方法、时间和属性&lt;/li&gt;
&lt;li&gt;提高更高级别的抽象，将问题分解成子问题，每个子问题一个组件&lt;/li&gt;
&lt;li&gt;特点：复用性、可替换、没有特定上下文、易扩展、封装性、独立性&lt;/li&gt;
&lt;li&gt;优点：易部署、减少花费、易开发、复用性、降低技术复杂度、可靠性、系统易维护、易升级、独立性&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>11 用户界面</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/11-user-interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/11-user-interface/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;图形化用户界面，也叫 WIMP 界面。因为使用了

&lt;ul&gt;
&lt;li&gt;window：窗口，屏幕上的一个矩形区域&lt;/li&gt;
&lt;li&gt;icon：图标，一个图片或符号用于表示软件应用或硬件设备&lt;/li&gt;
&lt;li&gt;menu：菜单，用户可选择的一系列选项&lt;/li&gt;
&lt;li&gt;pointer：指示物，一个符号(比如箭头)，当用户移动鼠标时在屏幕上移动，帮助用户选择对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;用户界面设计

&lt;ul&gt;
&lt;li&gt;分析用户界面，了解 4 个元素：用户、任务、内容、工作环境&lt;/li&gt;
&lt;li&gt;从用户而不是机器的能力和局限设计&lt;/li&gt;
&lt;li&gt;将任务分成用户和机器级别的&lt;/li&gt;
&lt;li&gt;一般分成以下几步&lt;/li&gt;
&lt;li&gt;定义用户界面对象和行为/操作&lt;/li&gt;
&lt;li&gt;定义事件(用户行为)导致用户界面改变的状态&lt;/li&gt;
&lt;li&gt;详细说明用户如何根据界面提供的信息解释系统状态&lt;/li&gt;
&lt;li&gt;描述终端中户看到每个界面状态&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;开发流程：

&lt;ul&gt;
&lt;li&gt;接口分析：分析用户、任务、内容、工作环境，定义需要做的任务&lt;/li&gt;
&lt;li&gt;接口设计：定义一系列接口对象、行为、屏幕表示&lt;/li&gt;
&lt;li&gt;接口构造：先有产品原型支持评估使用情形，然后使用开发工具完善&lt;/li&gt;
&lt;li&gt;接口验证：致力于验证以下方面&lt;/li&gt;
&lt;li&gt;接口的能力&lt;/li&gt;
&lt;li&gt;执行每个用户任务的正确性&lt;/li&gt;
&lt;li&gt;满足所有任务的改变&lt;/li&gt;
&lt;li&gt;满足所有通用的需求&lt;/li&gt;
&lt;li&gt;接口的易用性和易学性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>12 架构技术</title>
      <link>https://xueqing.github.io/translation/software_architecture_tutorial/12-architecture-techniques/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/software_architecture_tutorial/12-architecture-techniques/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;迭代增量式方法：通过一次或多次重复生成候选的解决方案。分为 5 步

&lt;ul&gt;
&lt;li&gt;确认架构目标：确认一开始的架构目标，确认架构消费者的目标，确认限制&lt;/li&gt;
&lt;li&gt;关键情节&lt;/li&gt;
&lt;li&gt;一个情节是一个扩展性的，覆盖描述用户和系统的一个交互&lt;/li&gt;
&lt;li&gt;给每个情节确定优先级，在用户、商业和系统目标之间权衡&lt;/li&gt;
&lt;li&gt;应用概述：将架构与现实世界的限制和决定关联，包括下面的活动&lt;/li&gt;
&lt;li&gt;确认应用类型：移动端、web 端、互联网应用等&lt;/li&gt;
&lt;li&gt;确认部署限制：选择合适的部署拓扑，解决应用和基础设施之间的冲突&lt;/li&gt;
&lt;li&gt;确认重要的架构设计类型：客户端/服务端、分层、消息-总线、领域驱动等&lt;/li&gt;
&lt;li&gt;确认相关的技术：根据开发的应用类型、倾向的应用部署拓扑和架构类型确认相关技术&lt;/li&gt;
&lt;li&gt;关键问题或关键热点：关键热点是经常制造错误的区域&lt;/li&gt;
&lt;li&gt;候选的解决方案：根据应用概述和关键问题创建和细化架构&lt;/li&gt;
&lt;li&gt;候选的架构包括：应用类型、部署架构、架构类型、技术选型、指令参数和横切关注点&lt;/li&gt;
&lt;li&gt;根据架构目标和关键情节验证候选的解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;架构概况：

&lt;ul&gt;
&lt;li&gt;在项目的关键阶段经常检查架构，响应其他重要架构的改变&lt;/li&gt;
&lt;li&gt;主要目的是确定基础架构和候选架构的灵活性&lt;/li&gt;
&lt;li&gt;将功能需求和之类属性与建议的技术方案关联&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;交流架构设计

&lt;ul&gt;
&lt;li&gt;完成架构设计之后，必须和其他的利益共享者交流设计，包括开发团队、系统管理员、操作员、商业所有者，及其他利益集团&lt;/li&gt;
&lt;li&gt;有下面几个方法向其他人描述架构&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;统一建模语言&#34; target=&#34;_blank&#34;&gt;统一建模语言&lt;/a&gt;：功能需求视图、静态结构视图、动态行为视图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#架构视图模型&#34;&gt;4+1 模型&lt;/a&gt;：逻辑视图、进程视图、物理视图、开发视图、场景视图/用例视图&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#架构描述语言&#34;&gt;架构描述语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;敏捷建模

&lt;ul&gt;
&lt;li&gt;模型足够简单，易于理解，足够准确、详细和已知&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;IEEE 1471：是体系结构描述的推荐规范，用于软件密集型系统，保证架构描述的内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>1 入门</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/1-primer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/1-primer/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%e6%95%8f%e6%8d%b7%e4%b8%ad%e7%9a%84%e8%a7%92%e8%89%b2&#34;&gt;1.1 敏捷中的角色&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-scrum-master-%e6%b5%81%e7%a8%8b%e7%ae%a1%e7%90%86%e5%91%98&#34;&gt;1.1.1 Scrum Master 流程管理员&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#112-product-owner-%e4%ba%a7%e5%93%81%e8%b4%9f%e8%b4%a3%e4%ba%ba&#34;&gt;1.1.2 Product Owner 产品负责人&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%e8%b7%a8%e8%81%8c%e8%83%bd%e5%9b%a2%e9%98%9f&#34;&gt;1.2 跨职能团队&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%e6%95%8f%e6%8d%b7%e5%9b%a2%e9%98%9f%e5%a6%82%e4%bd%95%e8%ae%a1%e5%88%92%e5%b7%a5%e4%bd%9c&#34;&gt;1.3 敏捷团队如何计划工作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#14-%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b-user-story&#34;&gt;1.4 用户故事 user story&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#141-%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b%e5%92%8c%e4%bb%bb%e5%8a%a1%e7%9a%84%e5%85%b3%e7%b3%bb&#34;&gt;1.4.1 用户故事和任务的关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#15-%e6%95%85%e4%ba%8b%e4%bd%95%e6%97%b6%e5%ae%8c%e6%88%90&#34;&gt;1.5 故事何时完成&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#151-%e9%aa%8c%e6%94%b6%e6%a0%87%e5%87%86acceptance-criteria&#34;&gt;1.5.1 验收标准(acceptance criteria)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#152-%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e9%9c%80%e6%b1%82&#34;&gt;1.5.2 如何定义需求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-1-敏捷中的角色&#34;&gt;1.1 敏捷中的角色&lt;/h2&gt;

&lt;h3 id=&#34;1-1-1-scrum-master-流程管理员&#34;&gt;1.1.1 Scrum Master 流程管理员&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;流程管理员是团队领导，帮助团队成员实现敏捷计划。责任包括

&lt;ul&gt;
&lt;li&gt;保证所有角色和机能之间的紧密合作&lt;/li&gt;
&lt;li&gt;移除阻碍&lt;/li&gt;
&lt;li&gt;保护团队免受打扰&lt;/li&gt;
&lt;li&gt;和组织一起跟踪公司的进度和流程&lt;/li&gt;
&lt;li&gt;保证敏捷的检查与调整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-1-2-product-owner-产品负责人&#34;&gt;1.1.2 Product Owner 产品负责人&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;从业务角度推动产品。责任包括

&lt;ul&gt;
&lt;li&gt;定义需求，评估需求的优先级&lt;/li&gt;
&lt;li&gt;确定发布的实际和内容&lt;/li&gt;
&lt;li&gt;在迭代计划和发布计划会议中承担积极的角色&lt;/li&gt;
&lt;li&gt;确保团队致力于最有价值的需求&lt;/li&gt;
&lt;li&gt;接受满足完成标准和定义好的验收标准(acceptance criteria)用户故事(user story)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-2-跨职能团队&#34;&gt;1.2 跨职能团队&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个敏捷团队应当是一个自满足的团队，成员是 5-9 人，平均经验是 6-10 年&lt;/li&gt;
&lt;li&gt;典型的敏捷团队包括 3-4 位开发者，1 位测试，1 位技术领导， 1 位产品负责人和 1 位流程管理员

&lt;ul&gt;
&lt;li&gt;产品负责人和流程管理员作为团队接口，其他成员是技术接口&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-3-敏捷团队如何计划工作&#34;&gt;1.3 敏捷团队如何计划工作&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;迭代实现用户故事，每个迭代周期是 10-15 天&lt;/li&gt;
&lt;li&gt;point 点：定义一个团队可以提交完成。一般是 8 个小时。每个故事用点评估&lt;/li&gt;
&lt;li&gt;capacity 能力：定义一个人可以提交完成。用小时评估&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-4-用户故事-user-story&#34;&gt;1.4 用户故事 user story&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个用户故事是一个需求，定义用户所需作为功能

&lt;ul&gt;
&lt;li&gt;在发布计划中，使用相对范围的点数粗略的评估一个用户故事&lt;/li&gt;
&lt;li&gt;在迭代计划中，将用户故事分解成任务(task)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-4-1-用户故事和任务的关系&#34;&gt;1.4.1 用户故事和任务的关系&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;用户故事描述要完成什么，定义了用户所需；任务描述如何完成它，定义了要实现的功能&lt;/li&gt;
&lt;li&gt;故事是通过任务实现，每个故事是任务的一个集合&lt;/li&gt;
&lt;li&gt;当把用户固执放在当前迭代计划时，用户故事被分解成任务&lt;/li&gt;
&lt;li&gt;任务用小时评估，一般是 2-12 个小时&lt;/li&gt;
&lt;li&gt;故事通过验收测试进行验证&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;1-5-故事何时完成&#34;&gt;1.5 故事何时完成&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;团队定义完成的含义。标准可能是

&lt;ul&gt;
&lt;li&gt;所有的任务(开发和测试)被完成&lt;/li&gt;
&lt;li&gt;所有的验收测试在运行并通过&lt;/li&gt;
&lt;li&gt;没有开放的缺陷(defect)&lt;/li&gt;
&lt;li&gt;产品负责人已经接受了故事&lt;/li&gt;
&lt;li&gt;可交付给终端用户&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-5-1-验收标准-acceptance-criteria&#34;&gt;1.5.1  验收标准(acceptance criteria)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;标准定义一个特性需要的功能、行为和性能，以便产品负责人可以接受&lt;/li&gt;
&lt;li&gt;它定义了要完成什么以便开发者知道一个用户故事何时完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;1-5-2-如何定义需求&#34;&gt;1.5.2 如何定义需求&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;需求可以定义为

&lt;ul&gt;
&lt;li&gt;一个用户故事&lt;/li&gt;
&lt;li&gt;包含验收标准&lt;/li&gt;
&lt;li&gt;包含完成这个故事的任务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2 宣言</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/2-manifesto/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/2-manifesto/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e4%bb%b7%e5%80%bc%e8%a7%82&#34;&gt;2.1 软件开发价值观&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%e6%95%8f%e6%8d%b7%e5%ae%a3%e8%a8%80%e7%9a%84-12-%e4%b8%aa%e5%8e%9f%e5%88%99&#34;&gt;2.2 敏捷宣言的 12 个原则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-1-软件开发价值观&#34;&gt;2.1 软件开发价值观&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;个体和互动：高于流程和工具&lt;/li&gt;
&lt;li&gt;可工作的软件：高于详尽的文档&lt;/li&gt;
&lt;li&gt;客户合作：高于合同谈判&lt;/li&gt;
&lt;li&gt;响应变化：高于遵循计划&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-敏捷宣言的-12-个原则&#34;&gt;2.2 敏捷宣言的 12 个原则&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;满足客户需求：最重要的是通过尽早和不断交付有价值的软件满足客户需求&lt;/li&gt;
&lt;li&gt;欢迎变化：软件开发过程中变化不可避免。应该欢迎需求的变化，即使在开发后期。敏捷过程应保持客户的竞争优势&lt;/li&gt;
&lt;li&gt;交付可工作软件：经常交付可以工作的软件，从几周到几个月，时间尺度越短越好&lt;/li&gt;
&lt;li&gt;合作：业务人员和开发者在整个项目过程中必须在一起工作&lt;/li&gt;
&lt;li&gt;动力：应该围绕斗志高昂的人进行软件开发。给开发者提供环境，相信他们一边使他们感觉对完成工作负责&lt;/li&gt;
&lt;li&gt;面对面对话：面对面对话是在开发小组中最有效率也最有效果的信息传达方式&lt;/li&gt;
&lt;li&gt;按照可工作的软件度量进度：可工作的软件是关键，它应当是进度的主要度量标准&lt;/li&gt;
&lt;li&gt;维持不变的节奏：敏捷过程提倡可持续开发。业务、开发人员和用户应能维持项目不变的节奏&lt;/li&gt;
&lt;li&gt;监察：定期关注技术的完美型和好的设计来提高敏捷性&lt;/li&gt;
&lt;li&gt;简单性：保持事情简单，使用简单的术语来度量未完成的工作&lt;/li&gt;
&lt;li&gt;自我组织的团队：一个敏捷团队应该是自我组织的，不应严重依赖其他团队，因为最好的架构、需求和设计源自自我组织的团队&lt;/li&gt;
&lt;li&gt;定期评审工作：每隔一段时间评审工作，以便团队可以离开如何变得更有效率，并相应地调整自己的行为&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>3 特点</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/3-characteristics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/3-characteristics/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%e8%bf%ad%e4%bb%a3%e5%a2%9e%e9%87%8f%e5%92%8c%e5%87%86%e5%a4%87%e8%bf%9b%e5%8c%96&#34;&gt;3.1 迭代/增量和准备进化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%e9%9d%a2%e5%af%b9%e9%9d%a2%e6%b2%9f%e9%80%9a&#34;&gt;3.2 面对面沟通&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-%e5%8f%8d%e9%a6%88%e5%9b%9e%e8%b7%af&#34;&gt;3.3 反馈回路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-1-迭代-增量和准备进化&#34;&gt;3.1 迭代/增量和准备进化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;大多数敏捷开发方法将一个问题分解成小任务。对于所有的需求没有直接长期的计划。通常，迭代是短时间的规划，例如一到四周。&lt;/li&gt;
&lt;li&gt;每个迭代都有一个跨职能的团队，工作内容包含软件开发的所有功能，包括规划、需求分析、设计、编码、单元测试和验收测试&lt;/li&gt;
&lt;li&gt;迭代结束的产物是一个可工作的产品，并在迭代结束后向利益相关者展示&lt;/li&gt;
&lt;li&gt;演示之后，采纳评审意见，并根据需求计划包含进可工作的软件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-面对面沟通&#34;&gt;3.2 面对面沟通&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个敏捷团队应该有一个客户代表(类似Scrum 中的产品负责人)。这个代表被授权代表利益相关者，且能够回答开发者在迭代中的问题&lt;/li&gt;
&lt;li&gt;通常会在办公室的显著位置放一个消息辐射体(实体显示器)，以便路人可以看到敏捷团队的进度。消息辐射体展示了最新的项目状态总结&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-反馈回路&#34;&gt;3.3 反馈回路&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每日站会是所有敏捷开发的一个共同文化，也称为日常 Scrum。它是一个简短的会议，每个团队成员相互报告自己已经完成的、接下来要做的以及面对的所有问题状态&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>4 每日站会</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/4-daily-standup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/4-daily-standup/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#41-%e6%af%8f%e6%97%a5%e7%ab%99%e4%bc%9a%e7%9a%84%e6%a6%82%e5%bf%b5&#34;&gt;4.1 每日站会的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#42-%e6%af%8f%e6%97%a5%e7%ab%99%e4%bc%9a%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7&#34;&gt;4.2 每日站会的重要性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%e6%af%8f%e6%97%a5%e7%ab%99%e4%bc%9a%e7%9a%84%e5%8f%82%e4%b8%8e%e4%ba%ba&#34;&gt;4.3 每日站会的参与人&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#44-%e7%89%a9%e7%90%86%e5%88%86%e6%95%a3%e7%9a%84%e5%9b%a2%e9%98%9f&#34;&gt;4.4 物理分散的团队&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每日站会，顾名思义，是敏捷团队所有成员媒体的状态会议。它不仅为定期的更新提供论坛，也将团队成员的问题作为关注点以便可以被快速处理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每日站会是一个必须的实践，不管一个敏捷团队建立的办公室位置&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-1-每日站会的概念&#34;&gt;4.1 每日站会的概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每日站会是所有成员间的一个每日状态会议，大概举行 15 分钟&lt;/li&gt;
&lt;li&gt;每个成员必须回答三个重要的问题

&lt;ul&gt;
&lt;li&gt;昨天做了什么&lt;/li&gt;
&lt;li&gt;今天要做什么&lt;/li&gt;
&lt;li&gt;正面临的问题或阻碍&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每日站会用于更新状态，而不是讨论。讨论的成员应当安排其他时间&lt;/li&gt;
&lt;li&gt;参与者应当站着而不是坐着以便快速结束&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-每日站会的重要性&#34;&gt;4.2 每日站会的重要性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每日站会在敏捷中的益处

&lt;ul&gt;
&lt;li&gt;团队可以评估每日进度，查看每个迭代计划是否可以交付&lt;/li&gt;
&lt;li&gt;每个团队成员通知自己每天的完成量&lt;/li&gt;
&lt;li&gt;为团队的所有延期和障碍提供可视化性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-每日站会的参与人&#34;&gt;4.3 每日站会的参与人&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;流程管理员、产品负责人和交付团队应当参与每日站会&lt;/li&gt;
&lt;li&gt;利益相关者和客户鼓励出席会议，并可以作为观察者，但是不应该参与站会&lt;/li&gt;
&lt;li&gt;流程管理员应该记录每个团队成员的疑问和面临的问题&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-4-物理分散的团队&#34;&gt;4.4 物理分散的团队&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;站会可以有多种方式，以便敏捷团队的成员分布在不同的时区

&lt;ul&gt;
&lt;li&gt;轮流选择一名成员，可以出席不同时区的站会&lt;/li&gt;
&lt;li&gt;每个团队有单独的站会，在一个工具(如 Rally，SharePoint，Wikis等)更新站会的状态&lt;/li&gt;
&lt;li&gt;准备多种沟通工具(如电话会议、视频会议、即时通讯工具或其他第三方认可的知识共享工具)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>5 完成标准</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/5-definition-of-done/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/5-definition-of-done/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%e7%94%a8%e6%88%b7%e6%95%85%e4%ba%8b&#34;&gt;5.1 用户故事&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-%e8%bf%ad%e4%bb%a3&#34;&gt;5.2 迭代&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-%e5%8f%91%e5%b8%83&#34;&gt;5.3 发布&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-1-用户故事&#34;&gt;5.1 用户故事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个用户故事是由用户几句日常语言表叔的需求，应该在一个迭代中完成&lt;/li&gt;
&lt;li&gt;用户故事完成时

&lt;ul&gt;
&lt;li&gt;检查了所有相关代码&lt;/li&gt;
&lt;li&gt;通过所有单元测试 case&lt;/li&gt;
&lt;li&gt;通过所有验收测试 case&lt;/li&gt;
&lt;li&gt;写了帮助文档&lt;/li&gt;
&lt;li&gt;产品负责人已经验收了这个故事&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-2-迭代&#34;&gt;5.2 迭代&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个迭代发布一个产品，来验收解决的用户故事或故障&lt;/li&gt;
&lt;li&gt;迭代在迭代计划会议中定义，通过一个迭代演示和评审会议完成&lt;/li&gt;
&lt;li&gt;一个迭代也叫一个冲刺(sprint)&lt;/li&gt;
&lt;li&gt;一个迭代完成时

&lt;ul&gt;
&lt;li&gt;产品需求列表已完成&lt;/li&gt;
&lt;li&gt;测试了性能&lt;/li&gt;
&lt;li&gt;用户故事被验收或移动到下次迭代&lt;/li&gt;
&lt;li&gt;故障被解决或推迟到下次迭代&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-3-发布&#34;&gt;5.3 发布&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个发布是一个主要的里程碑，代表内部或外部工作的交付，是产品或系统的测试版本&lt;/li&gt;
&lt;li&gt;一个发布完成时

&lt;ul&gt;
&lt;li&gt;测试了系统压力&lt;/li&gt;
&lt;li&gt;调整了性能&lt;/li&gt;
&lt;li&gt;执行了安全验证&lt;/li&gt;
&lt;li&gt;测试了灾难恢复计划&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>6 发布计划</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/6-release-planning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/6-release-planning/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#61-%e5%8f%82%e4%b8%8e%e8%80%85&#34;&gt;6.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#62-%e8%ae%a1%e5%88%92%e7%9a%84%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34;&gt;6.2 计划的先决条件-&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#63-%e9%9c%80%e8%a6%81%e7%9a%84%e6%9d%90%e6%96%99&#34;&gt;6.3 需要的材料&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#64-%e8%ae%a1%e5%88%92%e6%95%b0%e6%8d%ae&#34;&gt;6.4 计划数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#65-%e8%be%93%e5%87%ba&#34;&gt;6.5 输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#66-%e6%97%a5%e7%a8%8b&#34;&gt;6.6 日程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发布计划的目的是创建一个计划，来增量交付产品。每 2~3 个月做一次。&lt;/p&gt;

&lt;h2 id=&#34;6-1-参与者&#34;&gt;6.1 参与者&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;流程管理员：敏捷交付团队的引导者&lt;/li&gt;
&lt;li&gt;产品负责人：代表产品需求列表的一般观点&lt;/li&gt;
&lt;li&gt;敏捷团队：提出技术可行性和任何依赖的观点&lt;/li&gt;
&lt;li&gt;利益相关者：当发布会议作出决定时，利益相关者比如客户、程序管理者、主体专家提出建议&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-2-计划的先决条件&#34;&gt;6.2 计划的先决条件-&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;排好序的产品需求列表：由产品负责人管理。一般考虑 5~10 个特性，由产品负责人考虑可被纳入一个发布&lt;/li&gt;
&lt;li&gt;团队能力的输入、已知的速度或任何关于技术的挑战&lt;/li&gt;
&lt;li&gt;高等级的愿景&lt;/li&gt;
&lt;li&gt;市场和业务目标&lt;/li&gt;
&lt;li&gt;确认新产品的需求列表项是否需要&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-3-需要的材料&#34;&gt;6.3 需要的材料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;贴出的日常，目的&lt;/li&gt;
&lt;li&gt;挂图，白板，记号笔&lt;/li&gt;
&lt;li&gt;投影仪，用于共享计划会议中所需数据或工具的电脑&lt;/li&gt;
&lt;li&gt;计划数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-4-计划数据&#34;&gt;6.4 计划数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;上次迭代或发布计划的结果&lt;/li&gt;
&lt;li&gt;不同的利益相关者对于产品、市场条件和截止日期的反馈&lt;/li&gt;
&lt;li&gt;上次发布或迭代的行动计划&lt;/li&gt;
&lt;li&gt;需要考虑的特性或故障&lt;/li&gt;
&lt;li&gt;上次发布或预估的速度&lt;/li&gt;
&lt;li&gt;组织和个人的日程表&lt;/li&gt;
&lt;li&gt;其他团队和主体专家管理依赖性的输入&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-5-输出&#34;&gt;6.5 输出&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;发布计划&lt;/li&gt;
&lt;li&gt;承诺&lt;/li&gt;
&lt;li&gt;要监察的问题、关注点、依赖性和假设&lt;/li&gt;
&lt;li&gt;改进未来发布计划的建议&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;6-6-日程&#34;&gt;6.6 日程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;开场仪式：欢迎消息，评审目的和提成，组织工具，介绍业务赞助者&lt;/li&gt;
&lt;li&gt;产品愿景，蓝图：展示产品的大图&lt;/li&gt;
&lt;li&gt;评审之前的发布：太累可能影响这次计划的条目&lt;/li&gt;
&lt;li&gt;发布名字或主题：检查蓝图主题的当前状态，做出所需的调整&lt;/li&gt;
&lt;li&gt;速度：代表当前发布和之前发布的速度&lt;/li&gt;
&lt;li&gt;发布安排：评审发布中关键的里程碑和决定&lt;/li&gt;
&lt;li&gt;问题和关注点：检查并记录所有的关注点或问题&lt;/li&gt;
&lt;li&gt;评审和更新完成标准：评审完成标准，基于上次迭代或发布之后的技术、技巧或团队成员的改变做出合适的改变&lt;/li&gt;
&lt;li&gt;需要考虑的故事和条目：展示来自产品需求列表需要考虑的用户故事和特点，用于当前发布的安排&lt;/li&gt;
&lt;li&gt;确定分级值：如果速度未知，计划发布计划中药使用的分级值&lt;/li&gt;
&lt;li&gt;粗粒度划分故事：交付团队考虑之后确定故事的合适大小，且当故事比较大时，将故事划分成多个迭代。产品负责人和主体专家澄清疑问，详细制作验收标准，并做出合适的故事划分。流程管理者促进合作&lt;/li&gt;
&lt;li&gt;将故事映射到迭代：交付团队和产品负责人基于大小和速度将故事或故障移到迭代。流程管理者促进合作&lt;/li&gt;
&lt;li&gt;新的关注点或问题：基于之前的计划检查新问题，记录相同的问题&lt;/li&gt;
&lt;li&gt;依赖性和假设：价差发布计划中的任何依赖性或假设&lt;/li&gt;
&lt;li&gt;承诺：流程管理者好找计划。交付团队和产品负责人视其为最好的计划，并承诺开展下个级别的计划，即迭代计划&lt;/li&gt;
&lt;li&gt;沟通和后勤计划：为发布评审或更新沟通和后勤计划&lt;/li&gt;
&lt;li&gt;停车场：所有条目应该被解决或作为行动条目&lt;/li&gt;
&lt;li&gt;分发行动条目和行动计划：分发负责人的行动条目，处理行动计划&lt;/li&gt;
&lt;li&gt;回顾：征求参与者的反馈使会议成功&lt;/li&gt;
&lt;li&gt;结束：庆祝成功&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>7 迭代计划</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/7-iteration-planning/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/7-iteration-planning/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-%e5%8f%82%e4%b8%8e%e8%80%85&#34;&gt;7.1 参与者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-%e8%ae%a1%e5%88%92%e7%9a%84%e5%85%88%e5%86%b3%e6%9d%a1%e4%bb%b6&#34;&gt;7.2 计划的先决条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-%e8%ae%a1%e5%88%92%e6%b5%81%e7%a8%8b&#34;&gt;7.3 计划流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74-%e9%80%9f%e5%ba%a6%e8%ae%a1%e7%ae%97&#34;&gt;7.4 速度计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#75-%e4%bb%bb%e5%8a%a1%e5%ae%b9%e9%87%8f&#34;&gt;7.5 任务容量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#76-%e8%ae%a1%e5%88%92%e6%ad%a5%e9%aa%a4&#34;&gt;7.6 计划步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;迭代计划的目的是为了完成优先级高的产品需求列表项。承诺是基于迭代时间和团队速度的时间盒&lt;/p&gt;

&lt;h2 id=&#34;7-1-参与者&#34;&gt;7.1 参与者&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;流程管理者：敏捷交付团队的引导者&lt;/li&gt;
&lt;li&gt;产品负责人：处理产品需求列表及其验收标准的详细的看法&lt;/li&gt;
&lt;li&gt;敏捷团队：敏捷交付定义他们的任务，并设置完成承诺所需的努力评估&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-2-计划的先决条件&#34;&gt;7.2 计划的先决条件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;产品需求列表项有大小，且指定了相关的故事点&lt;/li&gt;
&lt;li&gt;产品负责人条目集合排好序&lt;/li&gt;
&lt;li&gt;每个条目有清晰描述的验收标准&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-3-计划流程&#34;&gt;7.3 计划流程&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;确定一个迭代包含的故事&lt;/li&gt;
&lt;li&gt;划分这些故事成任务，并分配每个任务给对应的负责人&lt;/li&gt;
&lt;li&gt;每个任务按小时评估&lt;/li&gt;
&lt;li&gt;这些评估帮助团队成员检查每个成员对于这此迭代的任务时&lt;/li&gt;
&lt;li&gt;根据团队成员的速度分配任务，以便他们不会负担过重&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-4-速度计算&#34;&gt;7.4 速度计算&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;敏捷团队基于过去的迭代计算速度&lt;/li&gt;
&lt;li&gt;速度是迭代中所需的平均数字单位以便完成用户故事

&lt;ul&gt;
&lt;li&gt;比如，一个团队在过去的三个迭代中分别用12，14，10个故事点，这个团队下次迭代的速度是 12&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;计划的速度高速团队可以在当前迭代完成多少用户故事。如果团队快速完成分配的任务，那么可以加入更多的用户故事。否则，可在下次迭代移除一些故事&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-5-任务容量&#34;&gt;7.5 任务容量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;一个团队的容量从下面三个因素考量

&lt;ul&gt;
&lt;li&gt;每天理想的工作小时&lt;/li&gt;
&lt;li&gt;这次迭代中成员可用的天数&lt;/li&gt;
&lt;li&gt;一个成员在此团队中不可用的时间百分比&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;假设一个团队 5 个成员，承诺为一个项目满时工作(每天 8 小时)，且没有人在迭代中离开，那么一个两周迭代的任务容量是 5*8*10=400 小时&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;7-6-计划步骤&#34;&gt;7.6 计划步骤&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;产品负责人描述产品需求列表排序最高的条目&lt;/li&gt;
&lt;li&gt;团队描述完成条目需要的任务&lt;/li&gt;
&lt;li&gt;团队成员负责任务&lt;/li&gt;
&lt;li&gt;团队成员估计完成每个任务的时间&lt;/li&gt;
&lt;li&gt;在迭代中重复上述步骤&lt;/li&gt;
&lt;li&gt;如果有人任务过多，将任务分给其他团队成员&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>8 产品需求列表</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/8-product-backlog/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/8-product-backlog/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81-%e4%ba%a7%e5%93%81%e9%9c%80%e6%b1%82%e5%88%97%e8%a1%a8%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7&#34;&gt;8.1 产品需求列表的重要性&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#82-%e4%ba%a7%e5%93%81%e9%9c%80%e6%b1%82%e5%88%97%e8%a1%a8%e7%9a%84%e7%89%b9%e7%82%b9&#34;&gt;8.2 产品需求列表的特点&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个产品需求列表是将要做的条目的列表。条目具有特性描述，被排好序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在理想的场景中，条目应划分成用户故事&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-1-产品需求列表的重要性&#34;&gt;8.1 产品需求列表的重要性&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;准备好产品需求列表，以便可以评估每个特性&lt;/li&gt;
&lt;li&gt;帮助计划产品蓝图&lt;/li&gt;
&lt;li&gt;帮助对特性重排序，以便产品具有更多价值&lt;/li&gt;
&lt;li&gt;帮助确定需要优先处理的事情。团队对条目排序并建立值&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;8-2-产品需求列表的特点&#34;&gt;8.2 产品需求列表的特点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;每个产品应该有一个产品需求列表，具有很多大的特性&lt;/li&gt;
&lt;li&gt;多个团队可以为一个产品需求列表工作&lt;/li&gt;
&lt;li&gt;特性排序基于业务价值、技术值、风险管理或策略调整排序&lt;/li&gt;
&lt;li&gt;在发布计划中将优先级高的条目分解成小的故事，以便可以在未来的迭代中完成它们&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>9 有用的术语</title>
      <link>https://xueqing.github.io/translation/agile/tutorial/9-useful-terms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/agile/tutorial/9-useful-terms/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;验收标准 Acceptance Criteria：由产品负责人或客户设置的条件，为了验收一个特性时有效的且和他们的需求一致&lt;/li&gt;
&lt;li&gt;列表修整 Backlog Grooming：一个持续的过程，是产品管理者或客户通过从敏捷团队获取反馈管理产品需求列表。包含条目项的排序、分解条目项成更小的条目、规划未来的迭代、创建新的故事、更小验收标准和消息描述验收标准&lt;/li&gt;
&lt;li&gt;容量 Capacity：一个迭代中团队可以完成的工作&lt;/li&gt;
&lt;li&gt;特性 Feature：对于产品的一个改进，或对利益相关者价值的兼容，在一个发布中开发&lt;/li&gt;
&lt;li&gt;迭代 Iteration：基于主题的工作项可在一个时间盒完成，并在产品的一个迭代中验收。迭代工作由迭代计划定义，结果是一个 demo 和评审会议。也叫做 Sprint&lt;/li&gt;
&lt;li&gt;增量 Increment：一个增量是逐渐开发的产品变化的状态。通常展示为里程碑或固定的迭代数&lt;/li&gt;
&lt;li&gt;产品负责人 Product Owner：敏捷交付团队的一名成员，负责收集和排序产品需求列表中的业务需求。一个产品负责人沟通一个发布或迭代中要做的工作。产品负责人设置成活，并负责保护团队在一个迭代中需求不被改变&lt;/li&gt;
&lt;li&gt;产品需求列表 Product Backlog：功能性和非功能性的产品需求的集合&lt;/li&gt;
&lt;li&gt;产品需求列表项 Product Backlog Items：可以是用户故事、故障、特性，由敏捷团队开发&lt;/li&gt;
&lt;li&gt;点 Points：一个通用单位，用以设置用户故事、特性或其他条目的相对大小&lt;/li&gt;
&lt;li&gt;发布 Release：在一个时间箱中，完成工作以支持一个软件的可测试的增量交付。在一个 Scrum 中，一个发布由多个迭代组成&lt;/li&gt;
&lt;li&gt;需求 Requirement：软件产品的规格说明，用于满足规定的合同或功能。用户故事和条目项是需求类型&lt;/li&gt;
&lt;li&gt;故事点 Story Points：敏捷团队用于评估用户故事和特性的相对大小的单位&lt;/li&gt;
&lt;li&gt;冲刺 Sprint：同迭代&lt;/li&gt;
&lt;li&gt;时间箱 Timebox：一个固定的持续时间，在这期间开发出一个可交付产品。通常，伴随固定的开始和结束时间，资源的数目也是固定的&lt;/li&gt;
&lt;li&gt;任务 Task：在迭代中，对于一个用户故事有共享的工作的单位。用户故事被分解成多个任务，且每个任务被分给团队成员作为任务负责人。团队成员可为每个任务负责，更新评估，记录已完成和要做的工作日志&lt;/li&gt;
&lt;li&gt;用户故事 User Story：一个列举的验收标准用于实现用户的一些需求。通常从一个终端用户的角度写&lt;/li&gt;
&lt;li&gt;速度 Velocity：度量迭代或时间箱的验收工作。通常是迭代中验收的故事点的总和&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Equivalent Binary Trees</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/equivalent_binary_trees/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/equivalent_binary_trees/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Equivalent Binary Trees
1. Implement the Walk function.

2. Test the Walk function.

The function tree.New(k) constructs a randomly-structured (but always sorted) binary tree holding the values k, 2k, 3k, ..., 10k.

Create a new channel ch and kick off the walker:

go Walk(tree.New(1), ch)
Then read and print 10 values from the channel. It should be the numbers 1, 2, 3, ..., 10.

3. Implement the Same function using Walk to determine whether t1 and t2 store the same values.

4. Test the Same function.

Same(tree.New(1), tree.New(1)) should return true, and Same(tree.New(1), tree.New(2)) should return false.

The documentation for Tree can be found here.
*/

package main

import (
  &amp;quot;fmt&amp;quot;

  &amp;quot;golang.org/x/tour/tree&amp;quot;
)

// Walk walks the tree t sending all values
// from the tree to the channel ch.
func Walk(t *tree.Tree, ch chan int) {
  if t.Left != nil {
    Walk(t.Left, ch)
  }
  ch &amp;lt;- t.Value
  if (t.Right) != nil {
    Walk(t.Right, ch)
  }
}

// Same determines whether the trees
// t1 and t2 contain the same values.
func Same(t1, t2 *tree.Tree) bool {
  ch1 := make(chan int)
  ch2 := make(chan int)
  go Walk(t1, ch1)
  go Walk(t2, ch2)
  for i := 1; i &amp;lt;= 10; i++ {
    v1, v2 := &amp;lt;-ch1, &amp;lt;-ch2
    fmt.Println(&amp;quot;Walk two tree: &amp;quot;, v1, v2)
    if v1 != v2 {
      return false
    }
  }
  return true
}

func main() {
  ch := make(chan int)
  go Walk(tree.New(1), ch)
  for i := 1; i &amp;lt;= 10; i++ {
    v := &amp;lt;-ch
    fmt.Println(&amp;quot;Walk tree: &amp;quot;, v)
    if i != v {
      fmt.Println(&amp;quot;Test Walk failure&amp;quot;)
      return
    }
  }
  fmt.Println(&amp;quot;Test Walk success&amp;quot;)

  if Same(tree.New(1), tree.New(1)) &amp;amp;&amp;amp; !Same(tree.New(1), tree.New(2)) {
    fmt.Println(&amp;quot;Test Same success&amp;quot;)
  } else {
    fmt.Println(&amp;quot;Test Same failure&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Errors</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/errors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/errors/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Errors
Copy your Sqrt function from the earlier exercise and modify it to return an error value.

Sqrt should return a non-nil error value when given a negative number, as it doesn&#39;t support complex numbers.

Create a new type

type ErrNegativeSqrt float64
and make it an error by giving it a

func (e ErrNegativeSqrt) Error() string
method such that ErrNegativeSqrt(-2).Error() returns &amp;quot;cannot Sqrt negative number: -2&amp;quot;.

Note: A call to fmt.Sprint(e) inside the Error method will send the program into an infinite loop. You can avoid this by converting e first: fmt.Sprint(float64(e)). Why?

Change your Sqrt function to return an ErrNegativeSqrt value when given a negative number.
*/

package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;math&amp;quot;
)

type errNegativeSqrt float64

func (e errNegativeSqrt) Error() string {
  // 因为e变量是一个通过实现Error()的接口函数成为了error类型，那么在fmt.Sprint(e)时就会调用e.Error()来输出错误的字符串信息
  return fmt.Sprint(&amp;quot;cannot Sqrt negative number: &amp;quot;, float64(e))
}

func mySqrt(x float64) (float64, error) {
  if x &amp;lt; 0 {
    return -1, errNegativeSqrt(x)
  }
  z := x / 2
  tmp := 0.0
  for math.Abs(z-tmp) &amp;gt;= 0.000000000001 {
    tmp = z
    z -= (z*z - x) / (2 * z)
  }
  return z, nil
}

func main() {
  fmt.Println(mySqrt(2))
  fmt.Println(mySqrt(-2))
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Event playlist 构造</title>
      <link>https://xueqing.github.io/translation/hls/event_playlist_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/event_playlist_construction/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/event_playlist_construction&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;示例&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#extm3u&#34;&gt;EXTM3U&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-version&#34;&gt;EXT-X-VERSION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#extinf&#34;&gt;EXTINF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%b4%e6%96%b0-playlist-%e6%96%87%e4%bb%b6&#34;&gt;更新 playlist 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;通过 EXT-X-PLAYLIST-TYPE 标记的值设为 EVENT 指定一个 event playlist。它起初没有 EXT-X-ENDLIST 标签，表示当新的媒体文件可访问时将会被加到 playlist。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的代码是一个第一个出现在会话中的 event playlist 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:EVENT
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.00,
fileSequence0.ts
#EXTINF:10.0,
fileSequence1.ts
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.0,
fileSequence4.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;event playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/h3&gt;

&lt;p&gt;提供了适用于整个 playlist 文件的易变信息。这个标记可能包含一个 EVENT 或 VOD 值。如果标记存在且值为 EVENT，服务器一定不能修改或删除 playlist 文件的任意部分(但是它可以追加行到 playlist 文件)。如果标记存在且值为 VOD，playlist 文件一定不能改变。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/h3&gt;

&lt;p&gt;指定最大的媒体文件时长。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-version&#34;&gt;EXT-X-VERSION&lt;/h3&gt;

&lt;p&gt;表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/h3&gt;

&lt;p&gt;表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。&lt;/p&gt;

&lt;h3 id=&#34;extinf&#34;&gt;EXTINF&lt;/h3&gt;

&lt;p&gt;一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。&lt;/p&gt;

&lt;h2 id=&#34;更新-playlist-文件&#34;&gt;更新 playlist 文件&lt;/h2&gt;

&lt;p&gt;当使用 EVENT 标记时，你不能从 playlist 中删除任何东西；你只可能追加新的片段到文件直到这个事件终止，那是会追加一个 EXT-X-ENDLIST 标签。下面的示例展示了使用新的媒体 URL 更新且该事件已经终止的同一 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:EVENT
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
fileSequence0.ts
#EXTINF:10.0,
fileSequence1.ts
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.0,
fileSequence4.ts

// List of files between 4 and 120 go here.

#EXTINF:10.0,
fileSequence120.ts
#EXTINF:10.0,
fileSequence121.ts
#EXT-X-ENDLIST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大概你想要支持用户跳转到事件内的任何一点时，比如一个音乐会或者运动事件，通常使用 event playlist。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Fibonacci closure</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/fibonacci_closure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/fibonacci_closure/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Fibonacci closure
Let&#39;s have some fun with functions.

Implement a fibonacci function that returns a function (a closure) that returns successive fibonacci numbers (0, 1, 1, 2, 3, 5, ...).
*/

package main

import &amp;quot;fmt&amp;quot;

func fibonacci() func() int {
  before, val := 0, 1
  return func() int {
    ret := before
    before, val = val, before + val
    return ret
  }
}

func main() {
  f := fibonacci()
  for i := 0; i &amp;lt; 10; i++ {
    fmt.Println(f())
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>fmt 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/fmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/fmt/</guid>
      <description>

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/fmt/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;fmt&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;fmt 包用类似于 C 的 printf 和 scanf 的函数实现了格式化的 I/O。格式 “verbs” 衍生自 C 但是更简单。&lt;/p&gt;

&lt;h3 id=&#34;打印&#34;&gt;打印&lt;/h3&gt;

&lt;p&gt;verbs 包括：&lt;/p&gt;

&lt;p&gt;通用的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;%v  默认格式的值
    当打印结构体时，增加标识 (%+v) 会增加域名。
%#v 值的一个 Go 语法显示
%T  值类型的一个 Go 语法显示
%%  一个字面百分比符号；不消费任何值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;布尔型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;%t  单词是 true 还是 false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;%b  base 2
%c  the character represented by the corresponding Unicode code point
%d  base 10
%o  base 8
%O  base 8 with 0o prefix
%q  a single-quoted character literal safely escaped with Go syntax.
%x  base 16, with lower-case letters for a-f
%X  base 16, with upper-case letters for A-F
%U  Unicode format: U+1234; same as &amp;quot;U+%04X&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/fmt/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/fmt/#pkg-examples&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go bug</title>
      <link>https://xueqing.github.io/translation/go-doc/command/bug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/bug/</guid>
      <description>&lt;p&gt;用法：&lt;code&gt;go bug&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;命令打开默认浏览器，并开启一个新的缺陷报告。报告包含有用的系统信息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go build</title>
      <link>https://xueqing.github.io/translation/go-doc/command/build/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/build/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%ba%90%e7%a0%81%e6%96%87%e4%bb%b6&#34;&gt;源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e8%af%91%e5%a4%9a%e4%b8%aa-go-%e6%ba%90%e7%a0%81%e6%96%87%e4%bb%b6&#34;&gt;编译多个 Go 源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-build-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go build 的参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%9d%e8%b5%96%e5%8c%85&#34;&gt;依赖包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%84%e5%bb%ba%e6%a0%87%e7%ad%be&#34;&gt;构建标签&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build [-o output] [-i] [build flags] [packages]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令用于编译我们指定的源码文件或代码包以及它们的依赖包&lt;/li&gt;
&lt;li&gt;如果在执行 &lt;code&gt;go build&lt;/code&gt; 命令时不后跟任何代码包，那么命令将试图编译当前目录所对应的代码包&lt;/li&gt;
&lt;li&gt;编译码包 &lt;code&gt;cnet/ctcp&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH/src/cnet/ctcp&lt;/code&gt; 执行 &lt;code&gt;go build&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;GOPATH/src/cnet/&lt;/code&gt; 执行 &lt;code&gt;go build ctcp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在任意目录下执行 &lt;code&gt;go build cnet/ctcp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 会忽略目录下以 “_” 或 “.” 开头的 go 文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt; 强制将生成的可执行文件或目标文件写到指定的输出文件或文件夹。如果指定的输出是存在的文件夹，生成的可执行文件会写到文件夹&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; 安装依赖包&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;源码文件&#34;&gt;源码文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go 语言的源码文件有三大类，即：命令源码文件、库源码文件和测试源码文件

&lt;ul&gt;
&lt;li&gt;命令源码文件：总是作为可执行的程序的入口&lt;/li&gt;
&lt;li&gt;库源码文件：一般用于集中放置各种待被使用的程序实体（全局常量、全局变量、接口、结构体、函数等等）&lt;/li&gt;
&lt;li&gt;测试源码文件：主要用于对前两种源码文件中的程序实体的功能和性能进行测试。另外也可以用于展现命令源码文件和库源码文件中程序的使用方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果是库源码文件，执行 &lt;code&gt;go build&lt;/code&gt; 之后，不会产生任何文件。如果需要在 &lt;code&gt;$GOPATH/pkg&lt;/code&gt; 下生成相应的文件，那就得执行 &lt;code&gt;go install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是命令源码文件(main 包)，执行 &lt;code&gt;go build&lt;/code&gt; 之后，它就会调用链接器在当前目录下生成一个可执行文件，可执行程序的名字取自包的导入路径的最后一段。如果需要在 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 下生成相应的文件，需要执行 &lt;code&gt;go install&lt;/code&gt;，或者使用 &lt;code&gt;go build -o 可执行文件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;编译多个-go-源码文件&#34;&gt;编译多个 Go 源码文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 默认会编译当前目录下的所有 go 文件

&lt;ul&gt;
&lt;li&gt;构建所有需要的包及其依赖，然后丢弃除了可执行程序之外的所有编译的代码&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以同时编译多个 Go 源码文件，在 &lt;code&gt;go build&lt;/code&gt; 后跟要编译的文件名，用空格分隔

&lt;ul&gt;
&lt;li&gt;限制：作为参数的多个 Go 源码文件必须在同一个目录中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令在编译只包含库源码文件的代码包（或者同时编译多个代码包）时，只会做检查性的编译，而不会输出任何结果文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令既不能编译包含多个命令源码文件的代码包，也不能同时编译多个命令源码文件。因为，如果把多个命令源码文件作为一个整体看待，那么每个文件中的 main 函数就属于重名函数，在编译时会抛出重复定义错误&lt;/li&gt;
&lt;li&gt;如果编译的多个属于 main 包的源码文件中没有 main 函数的声明，那么就会使编译器立即报出“未定义 main 函数声明”的错误并中止编译&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结：&lt;/strong&gt;同时编译多个 main 包的源码文件时，要保证其中有且仅有一个 main 函数声明，否则编译是无法成功的&lt;/li&gt;
&lt;li&gt;如果有多个声明为属于 main 包的源码文件，且其中只有一个文件声明了 main 函数的话，那么是可以使用 &lt;code&gt;go build&lt;/code&gt; 命令同时编译它们的。在这种情况下，不包含 main 函数声明的那几个源码文件会被视为库源码文件。如此编译之后的可执行文件的名称来自指定的编译目标中最左边的那个源码文件的主文件名相同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-build-的参数&#34;&gt;go build 的参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;下面的编译标志被 &lt;code&gt;build/clean/get/install/list/run/test&lt;/code&gt; 共享&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;强行重新构建包，即使它们已经是最新的了，但是对标准包不适用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;打印将要执行的命令，但是不执行&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-p n&lt;/td&gt;
&lt;td&gt;指定执行命令的并行程序数量。默认等于可用的 CPU 逻辑数。在 darwin/arm (iPhone 和 iPad) 平台，默认是1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-race&lt;/td&gt;
&lt;td&gt;开启竞态条件检测。仅在 linux/amd64、freebsd/amd64、darwin/amd64和windows/amd64 平台支持&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;打印被编译的包名&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-work&lt;/td&gt;
&lt;td&gt;打印临时工作目录名称，且如果存在不会在执行命令后删除。默认结束命令时会删除该目录&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;打印命令。注意它与 &lt;code&gt;-n&lt;/code&gt; 标记的区别&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;其他参数

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-mod&lt;/code&gt; 控制对 &lt;code&gt;go.mod&lt;/code&gt; 的更新和使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mod=readonly&lt;/code&gt; 不能隐式自动更新 &lt;code&gt;go.mod&lt;/code&gt;。当需要修改 &lt;code&gt;go.mod&lt;/code&gt; 时会失败。用于检查 &lt;code&gt;go.mod&lt;/code&gt; 不需要任何更新，比如在持续集成和测试系统

&lt;ul&gt;
&lt;li&gt;这个参数对 &lt;code&gt;go get&lt;/code&gt; 不生效，即命令仍然可以更新 &lt;code&gt;go.mod&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-mod=vendor&lt;/code&gt;: 使用模块的顶层的 &lt;code&gt;vendor&lt;/code&gt; 目录来编译以满足依赖(不使用通常的网络源码和本地缓存)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;依赖包&#34;&gt;依赖包&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令在执行时，编译程序会先查找目标代码包的所有依赖包，以及这些依赖包的依赖包，直至找到最深层的依赖包为止。在此过程中，如果发现有循环依赖的情况，编译程序就会输出错误信息并立即退出。此过程完成之后，所有的依赖关系也就形成了一棵含有重复元素的依赖树。对于依赖树中的一个节点（代码包）来说，它的直接分支节点（前者的依赖包），是按照代码包导入路径的字典序从左到右排列的。最左边的分支节点会最先被编译。编译程序会依此设定每个代码包的编译优先级&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go build&lt;/code&gt; 命令的计算机如果拥有多个逻辑 CPU 核心，那么编译代码包的顺序可能会存在一些不确定性。但是，它一定会满足这样的约束条件：&lt;code&gt;依赖代码包 -&amp;gt; 当前代码包 -&amp;gt; 触发代码包&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在执行 &lt;code&gt;go build&lt;/code&gt; 命令时加入标记 &lt;code&gt;-p 1&lt;/code&gt;，那么就可以保证代码包编译顺序严格按照预先设定好的优先级进行&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;构建标签&#34;&gt;构建标签&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;构建标签：&lt;code&gt;go build&lt;/code&gt; 只会在构建指定规格的目标文件的时候才进行编译，叫做构建标签的特殊注释，提供更细力度的控制。&lt;/li&gt;
&lt;li&gt;注释需要加在包的声明之前，这是文档注释。如 &lt;code&gt;// +build linux darwin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;// +build ignore&lt;/code&gt; 指出任何时候都不要编译这个文件&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go clean</title>
      <link>https://xueqing.github.io/translation/go-doc/command/clean/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/clean/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-clean-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go clean 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go clean&lt;/code&gt; 命令会删除掉执行其它命令时产生的一些文件和目录，包括

&lt;ul&gt;
&lt;li&gt;有一些目录和文件是在编译 Go 或 C 源码文件时留在相应目录中的&lt;/li&gt;
&lt;li&gt;目录 &lt;code&gt;_obj/&lt;/code&gt;：旧的 object 目录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;目录 &lt;code&gt;_test/&lt;/code&gt;：旧的 test 目录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;_testmain.go&lt;/code&gt;：旧的 gotest 文件，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;test.out&lt;/code&gt;：旧的 test 记录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;build.out&lt;/code&gt;：旧的 test 记录，由 Makefiles 遗留&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;a.out&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;DIR(.exe)&lt;/code&gt;： 由 &lt;code&gt;go build&lt;/code&gt; 在当前代码包下生成的与包名同名或者与 Go 源码文件同名的可执行文件(Windows 带有 &lt;code&gt;.exe&lt;/code&gt; 后缀)&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;DIR.test(.exe)&lt;/code&gt;： 由 &lt;code&gt;go test -c&lt;/code&gt; 在当前代码包下生成(Windows 带有 &lt;code&gt;.test.exe&lt;/code&gt; 后缀)&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;MAINFILE(.exe)&lt;/code&gt;： 由 &lt;code&gt;go build MAINFILE.go&lt;/code&gt; 产生&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;*.so&lt;/code&gt;：由 SWIG 遗留&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go clean&lt;/code&gt; 命令时带有标记 &lt;code&gt;-i&lt;/code&gt;，则会同时删除安装当前代码包时所产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区的 pkg 目录的相应目录下的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区的 bin 目录下的可执行文件。这些目录和文件是在执行 &lt;code&gt;go build&lt;/code&gt; 命令时生成在临时目录中的。临时目录的名称以 go-build 为前缀&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;go clean&lt;/code&gt; 命令时带有标记 &lt;code&gt;-r&lt;/code&gt;，则还包括当前代码包的所有依赖包的上述目录和文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-clean-的参数&#34;&gt;go clean 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-i&lt;/td&gt;
&lt;td&gt;清除关联的安装的包和可运行文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;打印执行命令期间所用到的其它命令，但是并不真正执行它们&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;循环的清除在 import 中引入的包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-x&lt;/td&gt;
&lt;td&gt;打印执行命令期间所用到的其它命令。注意它与 &lt;code&gt;-n&lt;/code&gt; 标记的区别&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go doc</title>
      <link>https://xueqing.github.io/translation/go-doc/command/doc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/doc/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-%e8%af%ad%e8%a8%80%e7%a8%8b%e5%ba%8f%e5%ae%9e%e4%bd%93&#34;&gt;Go 语言程序实体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-doc-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go doc 的参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#godoc&#34;&gt;godoc&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4%e8%a1%8c%e6%a8%a1%e5%bc%8f&#34;&gt;命令行模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#web-%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%a8%a1%e5%bc%8f&#34;&gt;Web 服务器模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 命令可以打印附于 Go 语言程序实体上的文档。可以通过把程序实体的标识符作为该命令的参数来达到查看其文档的目的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 可以接受一个参数，指定包/包成员/方法：&lt;code&gt;go doc http.Request&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 命令根据参数查找代码包或程序实体的顺序：Go 语言根目录（GOROOT 环境变量指定的目录）-&amp;gt; 工作区目录（GOPATH 环境变量包含的目录）。在内部遵循字典序&lt;/li&gt;
&lt;li&gt;如果某个工作区目录中的代码包与标准库中的包重名了，那么它是无法被打印出来的。&lt;code&gt;go doc&lt;/code&gt; 命令只会打印出第一个匹配的代码包或程序实体的文档&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go doc&lt;/code&gt; 也可以接受两个参数：&lt;code&gt;go doc net/http Request&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;这是一种更加精细的指定代码包或程序实体的方式&lt;/li&gt;
&lt;li&gt;第一个参数的代码包名称必须是完整的导入路径&lt;/li&gt;
&lt;li&gt;在给定两个参数时，&lt;code&gt;go doc&lt;/code&gt; 会打印出所有匹配的文档，而不是像给定一个参数时那样只打印出第一个匹配的文档。这对于查找只有大小写不同的多个方法（如 New、new）的文档来说非常有用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-语言程序实体&#34;&gt;Go 语言程序实体&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Go 语言的程序实体，是指变量、常量、函数、结构体以及接口&lt;/li&gt;
&lt;li&gt;程序实体的标识符即是代表它们的名称。标识符又分非限定标识符和限定标识符

&lt;ul&gt;
&lt;li&gt;限定标识符一般用于表示某个代码包中的程序实体或者某个结构体类型中的方法或字段&lt;/li&gt;
&lt;li&gt;如：标准库代码包 io 中的名为 EOF 的变量用限定标识符表示即 io.EOF&lt;/li&gt;
&lt;li&gt;如：如果有一个 sync.WaitGroup 类型的变量 wg 并且想调用它的 Add 方法，那么可以这样写 wg.Add()。其中，wg.Add 就是一个限定标识符，而后面的 () 则代表了调用操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-doc-的参数&#34;&gt;go doc 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-c&lt;/td&gt;
&lt;td&gt;区分参数中字母的大小写。默认情况下，命令是大小写不敏感的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-cmd&lt;/td&gt;
&lt;td&gt;打印出 main 包中的可导出的程序实体（其名称的首字母大写）的文档。默认情况下，这部分文档是不会被打印出来的&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;打印出不可导出的程序实体（其名称的首字母小写）的文档。默认情况下，这部分文档是不会被打印出来的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;godoc&#34;&gt;godoc&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在 Go1.2 版本之前还支持 &lt;code&gt;go doc&lt;/code&gt; 命令，但是之后全部移到了 &lt;code&gt;godoc&lt;/code&gt; 这个命令下，需要这样安装 &lt;code&gt;go get golang.org/x/tools/cmd/godoc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 Go1.5 版本中，&lt;code&gt;go doc&lt;/code&gt; 是一个内置的标准命令&lt;/li&gt;
&lt;li&gt;命令有两种模式可供选择&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;命令行模式&#34;&gt;命令行模式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;不加入 &lt;code&gt;-http&lt;/code&gt; 标记：以命令行模式运行。在打印纯文本格式的文档到标准输出后，命令执行就结束了。如 &lt;code&gt;godoc fmt Printf&lt;/code&gt;，&lt;code&gt;godoc fmt Printf Println&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;加 &lt;code&gt;-src&lt;/code&gt; 标记：不但可以在文档中查看可导出的程序实体的声明，还可以看到源码。如 &lt;code&gt;godoc -src fmt Printf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;godoc&lt;/code&gt; 命令只能把代码包和程序实体的标识符拆成两个参数。也就是说，&lt;code&gt;godoc&lt;/code&gt; 命令不支持前文所述的 &lt;code&gt;go doc&lt;/code&gt; 命令的单参数用法&lt;/li&gt;
&lt;li&gt;在实际的环境中，可能会遇到一个命令源码文件所产生的可执行文件与代码包重名的情况。比如，标准命令 go 和官方代码包 go。们要明确的告诉 &lt;code&gt;godoc&lt;/code&gt; 命令要查看可执行文件 go 的文档，需要在名称前加入 &lt;code&gt;cmd/&lt;/code&gt; 前缀 &lt;code&gt;godoc cmd/go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看 HTML 格式的文档，就需要加入标记 &lt;code&gt;-html&lt;/code&gt;，可以在其中找到一些相应源码的链接地址&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;web-服务器模式&#34;&gt;Web 服务器模式&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;加上 &lt;code&gt;-http&lt;/code&gt; 标记：以 Web 服务器模式运行。以 Web 页面的形式提供 Go 语言文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;godoc -http=:6060&lt;/code&gt; 标记 &lt;code&gt;-http&lt;/code&gt; 的值 &lt;code&gt;:6060&lt;/code&gt; 表示启动的 Web 服务器使用本机的 6060 端口。之后，可通过在浏览器中输入 &lt;code&gt;http://localhost:6060&lt;/code&gt; 查看以网页方式展现的 Go 文档&lt;/li&gt;
&lt;li&gt;这使得在不方便访问 Go 语言官方站点的情况下也可以查看 Go 语言文档。并且通过本机的 Go 文档 Web 服务，还可以查看所有本机工作区下的代码的文档&lt;/li&gt;
&lt;li&gt;&lt;code&gt;godoc -http=:9090 -index&lt;/code&gt; 使用 &lt;code&gt;-index&lt;/code&gt; 标记开启搜索索引。这个索引会在服务器启动时创建并维护。如果不加入此标记，那么无论在 Web 页面还是命令行终端中都无法进行查询操作&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go env</title>
      <link>https://xueqing.github.io/translation/go-doc/command/env/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/env/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-env-%e5%91%bd%e4%bb%a4%e5%8f%af%e6%89%93%e5%8d%b0%e5%87%ba%e7%9a%84-go-%e8%af%ad%e8%a8%80%e9%80%9a%e7%94%a8%e7%8e%af%e5%a2%83%e4%bf%a1%e6%81%af&#34;&gt;go env 命令可打印出的 Go 语言通用环境信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-env-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go env 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go env&lt;/code&gt; 用于打印 Go 语言的环境信息：&lt;code&gt;go env GOARCH&lt;/code&gt; 或 &lt;code&gt;go env GOARCH GOCHAR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go env -w&lt;/code&gt; 重写 Go 语言的环境信息：&lt;code&gt;go env -w GOPRIVATE=&amp;quot;*.bmi&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-env-命令可打印出的-go-语言通用环境信息&#34;&gt;go env 命令可打印出的 Go 语言通用环境信息&lt;/h2&gt;

&lt;p&gt;| 名称 | 描述 |
| CGO_ENABLED | 指明 cgo 工具是否可用的标识 |
| GOARCH | 程序构建环境的目标计算架构 |
| GOBIN | 存放可执行文件的目录的绝对路径 |
| GOCHAR | 程序构建环境的目标计算架构的单字符标识 |
| GOEXE | 可执行文件的后缀 |
| GOHOSTARCH | 程序运行环境的目标计算架构 |
| GOOS | 程序构建环境的目标操作系统 |
| GOHOSTOS | 程序运行环境的目标操作系统 |
| GOPATH | 工作区目录的绝对路径 |
| GORACE | 用于数据竞争检测的相关选项 |
| GOROOT | Go 语言的安装目录的绝对路径 |
| GOTOOLDIR | Go 工具目录的绝对路径 |&lt;/p&gt;

&lt;h2 id=&#34;go-env-的参数&#34;&gt;go env 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go fmt</title>
      <link>https://xueqing.github.io/translation/go-doc/command/fmt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/fmt/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gofmt-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;gofmt 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;go 代码有标准的风格。&lt;code&gt;go fmt file_name.go&lt;/code&gt; 命令可以格式化写好的代码文件&lt;/li&gt;
&lt;li&gt;开发工具里面一般都带了保存时候自动格式化功能，这个功能其实在底层就是调用了 &lt;code&gt;go fmt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;go fmt&lt;/code&gt; 命令，其实是调用了 &lt;code&gt;gofmt&lt;/code&gt;，而且需要参数 &lt;code&gt;-w&lt;/code&gt;，否则格式化结果不会写入文件。&lt;code&gt;gofmt -w -l src&lt;/code&gt; 可以格式化整个项目&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;gofmt-的参数&#34;&gt;gofmt 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-l&lt;/td&gt;
&lt;td&gt;显示需要格式化的文件&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-w&lt;/td&gt;
&lt;td&gt;把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-r&lt;/td&gt;
&lt;td&gt;添加形如 “a[b:len(a)] -&amp;gt; a[b:]” 的重写规则，方便做批量替换&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-s&lt;/td&gt;
&lt;td&gt;简化文件中的代码&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;显示格式化前后的 diff 而不是写入文件，默认是 false&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;打印所有的语法错误到标准输出。如果不使用此标记，则只会打印不同行的前10个错误&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-cpuprofile&lt;/td&gt;
&lt;td&gt;支持调试模式，写入相应的 cpufile 到指定的文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go generate</title>
      <link>https://xueqing.github.io/translation/go-doc/command/generate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/generate/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go generate&lt;/code&gt; 用于在编译前自动化生成某类代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go generate&lt;/code&gt; 通过分析源码中特殊的注释，然后执行相应的命令。注意

&lt;ul&gt;
&lt;li&gt;此特殊注释必须在 &lt;code&gt;.go&lt;/code&gt; 源码文件&lt;/li&gt;
&lt;li&gt;每个源码文件可包含多个 generate 注释&lt;/li&gt;
&lt;li&gt;显示运行 &lt;code&gt;go generate&lt;/code&gt; 命令时，才会执行特殊注释后面的命令&lt;/li&gt;
&lt;li&gt;命令串执行时，如果出错则终止后面的执行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//go:generate go tool yacc -o gopher.go -p parser gopher.y&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//go:generate&lt;/code&gt; 没有空格，这是一个固定的格式，在扫描源码文件的时候是根据这个来判断的&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;yacc&lt;/code&gt; 来生成代码：&lt;code&gt;-o&lt;/code&gt; 指定输出文件名，&lt;code&gt;-p&lt;/code&gt; 指定 package 名称&lt;/li&gt;
&lt;li&gt;这是一个单独的命令。如果想让 &lt;code&gt;go generate&lt;/code&gt; 来触发这个命令，那么就可以在当然目录的任意一个 xxx.go 文件里面的任意位置增加此注释&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go get</title>
      <link>https://xueqing.github.io/translation/go-doc/command/get/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/get/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-get-%e5%91%bd%e4%bb%a4%e6%94%af%e6%8c%81%e7%9a%84-vcs&#34;&gt;go get 命令支持的 VCS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-get-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go get 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 命令用来动态获取远程代码包，从代码版本控制系统的远程仓库中检出/更新代码包并对其进行编译和安装&lt;/li&gt;
&lt;li&gt;在内部实际上分成了两步操作：第一步是下载源码包第一个工作区的 src 目录下，第二步是执行 &lt;code&gt;go install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下

&lt;ul&gt;
&lt;li&gt;BitBucket (Mercurial Git)&lt;/li&gt;
&lt;li&gt;GitHub (Git)&lt;/li&gt;
&lt;li&gt;Google Code Project Hosting (Git, Mercurial, Subversion)&lt;/li&gt;
&lt;li&gt;Launchpad (Bazaar)&lt;/li&gt;
&lt;li&gt;这些网站的项目包路径有一个共同标准：远程包路径格式是 &lt;code&gt;网站域名/作者或机构/项目名&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如 &lt;code&gt;go get github.com/hyper-carrot/go_lib/logging&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 支持自定义域名的功能，具体参见 &lt;code&gt;go help remote&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;除非要求强行更新代码包，否则 &lt;code&gt;go get&lt;/code&gt; 命令不会进行重复下载&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-get-命令支持的-vcs&#34;&gt;go get 命令支持的 VCS&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;代码版本控制系统（Version Control System，VCS）&lt;/li&gt;
&lt;li&gt;这几个版本控制系统都有一个共同点，那就是会在检出的项目目录中存放一个元数据目录，名称为 “.” 前缀加其主命令名&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;主命令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Mercurial&lt;/td&gt;
&lt;td&gt;hg&lt;/td&gt;
&lt;td&gt;Mercurial 是一种轻量级分布式版本控制系统，采用 Python 语言实现，易于学习和使用，扩展性强&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Git&lt;/td&gt;
&lt;td&gt;git&lt;/td&gt;
&lt;td&gt;Git 最开始是 Linux Torvalds 为了帮助管理 Linux 内核开发而开发的一个开源的分布式版本控制软件。但现在已被广泛使用。它是被用来进行有效、高速的各种规模项目的版本管理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Subversion&lt;/td&gt;
&lt;td&gt;svn&lt;/td&gt;
&lt;td&gt;Subversion 是一个版本控制系统，也是第一个将分支概念和功能纳入到版本控制模型的系统。但相对于 Git 和 Mercurial 而言，它只算是传统版本控制系统的一员&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Bazaar&lt;/td&gt;
&lt;td&gt;bzr&lt;/td&gt;
&lt;td&gt;Bazaar 是一个开源的分布式版本控制系统。但相比而言，用它来作为 VCS 的项目并不多&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对于不知名的网站，需要指出导入路径使用哪种版本控制协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;位置由诸如 googlesource.com 或 github.com 之类通用服务托管，包可以在其导入路径中使用自定义域名。其 HTML 网页下包含元数据重定向 go 工具到实际托管地址的服务仓库&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;go-get-的参数&#34;&gt;go get 的参数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 命令可以接受所有可用于 &lt;code&gt;go build&lt;/code&gt; 命令和 &lt;code&gt;go install&lt;/code&gt; 命令的参数。这是因为 &lt;code&gt;go get&lt;/code&gt; 命令的内部步骤中完全包含了编译和安装这两个动作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go get&lt;/code&gt; 命令还有一些特有的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;只下载不安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;只有在包含 -u 参数时才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-fix&lt;/td&gt;
&lt;td&gt;在获取源码之后先运行 fix，而后再进行编译和安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-insecure&lt;/td&gt;
&lt;td&gt;允许使用非安全的 scheme（如HTTP）去下载指定的代码包。如果代码仓库（如公司内部的Gitlab）没有 HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;下载并安装指定的代码包中的测试源码文件中依赖的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;强制使用网络更新已有代码包及其依赖包。默认情况该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;显示执行的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go install</title>
      <link>https://xueqing.github.io/translation/go-doc/command/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/install/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e4%bb%a4&#34;&gt;命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85%e4%bb%a3%e7%a0%81%e5%8c%85&#34;&gt;安装代码包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%89%e8%a3%85%e5%91%bd%e4%bb%a4%e6%ba%90%e7%a0%81%e6%96%87%e4%bb%b6&#34;&gt;安装命令源码文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#go-install-%e7%9a%84%e5%8f%82%e6%95%b0&#34;&gt;go install 的参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;命令&#34;&gt;命令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 用于编译并安装指定的代码包及它们的依赖包&lt;/li&gt;
&lt;li&gt;这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或 &lt;code&gt;.a&lt;/code&gt; 包)，第二步会把编译好的结果移到指定目录(&lt;code&gt;$GOPATH/bin&lt;/code&gt; 或 &lt;code&gt;$GOPATH/pkg&lt;/code&gt;)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令只比 &lt;code&gt;go build&lt;/code&gt; 命令多做了一件事，即安装编译后的结果文件到指定目录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令可以接受所有可用于 &lt;code&gt;go build&lt;/code&gt; 命令的参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装代码包&#34;&gt;安装代码包&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令会把编译后的可执行文件保存在源码文件所在工作区的 bin 目录下，包保存在 pkg 目录&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;go install&lt;/code&gt; 命令后跟的代码包中仅包含库源码文件，那么 &lt;code&gt;go install&lt;/code&gt; 命令会把编译后的结果文件保存在源码文件所在工作区的 pkg 目录下。结果文件是对应的代码包归档文件（也叫静态链接库文件，名称以 .a 结尾）

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go build&lt;/code&gt; 命令对仅包含库源码文件的代码包进行编译时，不会在当前工作区的 src 以及 pkg 目录下产生任何结果文件。结果文件会出于编译目的被生成在临时目录，但并不会使当前工作区目录产生任何变化。只会留下可执行文件。&lt;code&gt;go build -i&lt;/code&gt; 可将包安装在独立于构建目标的地方&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go install&lt;/code&gt; 命令时不后跟任何代码包参数，那么命令将试图编译当前目录所对应的代码包&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;安装命令源码文件&#34;&gt;安装命令源码文件&lt;/h2&gt;

&lt;h2 id=&#34;go-install-的参数&#34;&gt;go install 的参数&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-d&lt;/td&gt;
&lt;td&gt;只下载不安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-f&lt;/td&gt;
&lt;td&gt;只有在包含 -u 参数时才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-fix&lt;/td&gt;
&lt;td&gt;在获取源码之后先运行 fix，而后再进行编译和安装&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-insecure&lt;/td&gt;
&lt;td&gt;允许使用非安全的 scheme（如HTTP）去下载指定的代码包。如果代码仓库（如公司内部的Gitlab）没有 HTTPS 支持，可以添加此标记。请在确定安全的情况下使用它&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-t&lt;/td&gt;
&lt;td&gt;下载并安装指定的代码包中的测试源码文件中依赖的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-u&lt;/td&gt;
&lt;td&gt;强制使用网络更新已有代码包及其依赖包。默认情况该命令只会从网络上下载本地不存在的代码包，而不会更新已有的代码包&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-v&lt;/td&gt;
&lt;td&gt;显示执行的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>go list</title>
      <link>https://xueqing.github.io/translation/go-doc/command/list/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/list/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8%e6%b3%95&#34;&gt;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#f&#34;&gt;-f&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#m&#34;&gt;-m&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;列举命名包，每行一个。不带参数时判断一个包是否存在工作空间，存在则输出包的导入路径&lt;/li&gt;
&lt;li&gt;命令 &lt;code&gt;go list [-f format] [-json] [-m] [list flags] [build flags] [packages]&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;常用的参数是 &lt;code&gt;-f&lt;/code&gt; 和 &lt;code&gt;-json&lt;/code&gt;，用于控制输出格式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list cnet hash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;...&lt;/code&gt; 通配符用于匹配包的导入路径中的任意子串

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go list ...&lt;/code&gt; 枚举工作空间的所有包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list ch3/...&lt;/code&gt; 指定子树中的所有包&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list ...xml..&lt;/code&gt; 指定具体主题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list&lt;/code&gt; 获取每个包的完整元数据，提供各种用于对用户或其他工具可访问的格式&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-e&lt;/td&gt;
&lt;td&gt;以容错模式加载和分析指定的代码包，这样讲不会打印错误信息&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-json&lt;/td&gt;
&lt;td&gt;把代码包的结构实体用 JSON 样式打印，所有值为对应类型的空值的字段会被忽略&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-compiled&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-deps&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-export&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-find&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-test&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;-m&lt;/td&gt;
&lt;td&gt;列举模块而不是包。使用 -f 指定的是模块模板&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;f&#34;&gt;-f&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;使用包模板语法指定可选格式。默认输出等价于 &lt;code&gt;-f &#39;{{ImportPath}}&#39;&lt;/code&gt;。&lt;code&gt;-f&lt;/code&gt; 的值需要满足 &lt;code&gt;text/template&lt;/code&gt; 中定义的语法

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{{.S}}&lt;/code&gt; 代表根结构体的 &lt;code&gt;S&lt;/code&gt; 字段的值。&lt;code&gt;go list&lt;/code&gt; 对应的跟结构体就是指定的代码包所对应的的结构体&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -f {{.GoFiles}} cnet/ctcp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -e -f {{.Error.Err}} cnet&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -e -f &#39;The package {{.ImportPath}} is {{if .Incomplete}}incomplete!{{else}}complete.{{end}}&#39; cnet&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板结构如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Package struct {
  Dir           string   // directory containing package sources
  ImportPath    string   // import path of package in dir
  ImportComment string   // path in import comment on package statement
  Name          string   // package name
  Doc           string   // package documentation string
  Target        string   // install path
  Shlib         string   // the shared library that contains this package (only set when -linkshared)
  Goroot        bool     // is this package in the Go root?
  Standard      bool     // is this package part of the standard Go library?
  Stale         bool     // would &#39;go install&#39; do anything for this package?
  StaleReason   string   // explanation for Stale==true
  Root          string   // Go root or Go path dir containing this package
  ConflictDir   string   // this directory shadows Dir in $GOPATH
  BinaryOnly    bool     // binary-only package (no longer supported)
  ForTest       string   // package is only for use in named test
  Export        string   // file containing export data (when using -export)
  Module        *Module  // info about package&#39;s containing module, if any (can be nil)
  Match         []string // command-line patterns matching this package
  DepOnly       bool     // package is only a dependency, not explicitly listed

  // Source files
  GoFiles         []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
  CgoFiles        []string // .go source files that import &amp;quot;C&amp;quot;
  CompiledGoFiles []string // .go files presented to compiler (when using -compiled)
  IgnoredGoFiles  []string // .go source files ignored due to build constraints
  CFiles          []string // .c source files
  CXXFiles        []string // .cc, .cxx and .cpp source files
  MFiles          []string // .m source files
  HFiles          []string // .h, .hh, .hpp and .hxx source files
  FFiles          []string // .f, .F, .for and .f90 Fortran source files
  SFiles          []string // .s source files
  SwigFiles       []string // .swig files
  SwigCXXFiles    []string // .swigcxx files
  SysoFiles       []string // .syso object files to add to archive
  TestGoFiles     []string // _test.go files in package
  XTestGoFiles    []string // _test.go files outside package

  // Cgo directives
  CgoCFLAGS    []string // cgo: flags for C compiler
  CgoCPPFLAGS  []string // cgo: flags for C preprocessor
  CgoCXXFLAGS  []string // cgo: flags for C++ compiler
  CgoFFLAGS    []string // cgo: flags for Fortran compiler
  CgoLDFLAGS   []string // cgo: flags for linker
  CgoPkgConfig []string // cgo: pkg-config names

  // Dependency information
  Imports      []string          // import paths used by this package
  ImportMap    map[string]string // map from source import to ImportPath (identity entries omitted)
  Deps         []string          // all (recursively) imported dependencies
  TestImports  []string          // imports from TestGoFiles
  XTestImports []string          // imports from XTestGoFiles

  // Error information
  Incomplete bool            // this package or a dependency has an error
  Error      *PackageError   // error loading package
  DepsErrors []*PackageError // errors loading dependencies
}

type PackageError struct {
  ImportStack   []string // shortest path from package named on command line to this one
  Pos           string   // position of error (if present, file:line:col)
  Err           string   // the error itself
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板函数 &lt;code&gt;join&lt;/code&gt; 调用 &lt;code&gt;strings.Join&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;go list -f &#39;{{join .Deps &amp;quot; &amp;quot;}}&#39; strconv&lt;/code&gt; 输出 strconv 包的依赖过渡关系记录，空格分隔&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go list -f &#39;{{.ImportPath}} -&amp;gt; {{join .Imports &amp;quot; &amp;quot;}}&#39; compress/...&lt;/code&gt; 输出标准库的 compress 子树中每个包的直接导入记录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板函数 &lt;code&gt;context&lt;/code&gt; 返回构建上下文，定义如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Context struct {
  GOARCH        string   // target architecture
  GOOS          string   // target operating system
  GOROOT        string   // Go root
  GOPATH        string   // Go path
  CgoEnabled    bool     // whether cgo can be used
  UseAllFiles   bool     // use files regardless of +build lines, file names
  Compiler      string   // compiler to assume when computing target paths
  BuildTags     []string // build constraints to match in +build lines
  ReleaseTags   []string // releases the current release is compatible with
  InstallSuffix string   // suffix to use in the name of the install dir
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;m&#34;&gt;-m&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;默认输出模块路径、版本信息，如果有替换，输出替换信息

&lt;ul&gt;
&lt;li&gt;如果有替换，即 &lt;code&gt;Replace&lt;/code&gt; 不为 nil 时，下面的 &lt;code&gt;Dir&lt;/code&gt; 设置的是 &lt;code&gt;Replace.Dir&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;主模块是包含当前目录的模块。活动模块是主模块及其依赖模块。默认显示主模块

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt; 指定所有活动模块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;和 &lt;code&gt;-f&lt;/code&gt; 一起使用，指定模块模板&lt;/li&gt;

&lt;li&gt;&lt;p&gt;结构体 Module 有一个 String 方法，用于格式化输出行，因此默认输出等价于 &lt;code&gt;-f {{.String}}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Module struct {
  Path      string       // module path
  Version   string       // module version
  Versions  []string     // available module versions (with -versions)
  Replace   *Module      // replaced by this module
  Time      *time.Time   // time version was created
  Update    *Module      // available update, if any (with -u)
  Main      bool         // is this the main module?
  Indirect  bool         // is this module only an indirect dependency of main module?
  Dir       string       // directory holding files for this module, if any
  GoMod     string       // path to go.mod file for this module, if any
  GoVersion string       // go version used in module
  Error     *ModuleError // error loading module
}

type ModuleError struct {
  Err string // the error itself
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-u&lt;/code&gt; 增加了关于可以升级的信息：&lt;code&gt;go list -m -u -json all&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;-version&lt;/code&gt; 设置 &lt;code&gt;Module.Version&lt;/code&gt; 域为模块已知的版本&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;模板函数 &lt;code&gt;module&lt;/code&gt; 接收一个字符串参数(必须是一个模块路径或查询)，返回指定的模块对应的 Module 结构体&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go mod</title>
      <link>https://xueqing.github.io/translation/go-doc/command/mod/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/mod/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8%e6%b3%95&#34;&gt;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#download&#34;&gt;download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#edit&#34;&gt;edit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#graph&#34;&gt;graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#init&#34;&gt;init&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tidy&#34;&gt;tidy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vendor&#34;&gt;vendor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#verify&#34;&gt;verify&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why&#34;&gt;why&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用于操作模块。&lt;strong&gt;注意：所有的 go 命令支持模块&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用法：&lt;code&gt;go mod &amp;lt;command&amp;gt; [arguments]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;download&lt;/td&gt;
&lt;td&gt;下载模块到本地缓存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;edit&lt;/td&gt;
&lt;td&gt;使用工具或脚本更新 go.mod&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;graph&lt;/td&gt;
&lt;td&gt;打印模块需求图&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;init&lt;/td&gt;
&lt;td&gt;在当前目录初始化一个新模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;tidy&lt;/td&gt;
&lt;td&gt;添加缺失模块，删除无用模块&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;vendor&lt;/td&gt;
&lt;td&gt;创建依赖的 vendor 拷贝&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;verify&lt;/td&gt;
&lt;td&gt;验证依赖拥有预期的内容&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;why&lt;/td&gt;
&lt;td&gt;解释为什么需要一个包或者模块&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;download&#34;&gt;download&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法： &lt;code&gt;go mod download [-json] [modules]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不带模块参数时，默认下载主模块的所有依赖&lt;/li&gt;
&lt;li&gt;其他 go 命令会自动下载所需模块，&lt;code&gt;go mod download&lt;/code&gt; 主要用于预先填充本地缓存或用户计算 Go 模块代理&lt;/li&gt;

&lt;li&gt;&lt;p&gt;默认将错误发生给标准错误。&lt;code&gt;-json&lt;/code&gt; 会打印 JSON 对象到标准输出，描述每个下载的模块(或失败)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Module struct {
  Path     string // module path
  Version  string // module version
  Error    string // error loading module
  Info     string // absolute path to cached .info file
  GoMod    string // absolute path to cached .mod file
  Zip      string // absolute path to cached .zip file
  Dir      string // absolute path to cached source root directory
  Sum      string // checksum for path, version (as in go.sum)
  GoModSum string // checksum for go.mod (as in go.sum)
  Latest   bool   // would @latest resolve to this version?
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;edit&#34;&gt;edit&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod edit [edit flags] [go.mod]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;命令只会读写主模块 &lt;code&gt;go.mod&lt;/code&gt; 文件，可在编辑参数指定另外需要编辑的文件&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑标识包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-fmt&lt;/code&gt;: 只格式化文件。其他参数默认会格式化。只有在没有其他编辑参数时需要指定 &lt;code&gt;-fmt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-module&lt;/code&gt;: 修改模块路径(&lt;code&gt;module&lt;/code&gt; 行)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-require=path@version&lt;/code&gt;/&lt;code&gt;-droprequire=path&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-exclude=path@version&lt;/code&gt;/&lt;code&gt;-dropexclude=path@version&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-replace=old[@v]=new[@v]&lt;/code&gt;/&lt;code&gt;-dropreplace=old[@v]&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-go=version&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-print&lt;/code&gt;:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-json&lt;/code&gt;: 以 JSON 格式打印最终的 &lt;code&gt;go.mod&lt;/code&gt; 而不是写到 &lt;code&gt;go.mod&lt;/code&gt;。JSON 输出符合下面的 Go 类型&lt;/li&gt;

&lt;li&gt;&lt;p&gt;命令只会描述 &lt;code&gt;go.mod&lt;/code&gt; 文件，间接引用的模块不会包含。需要查看编译所需的所有模块使用 &lt;code&gt;go list -m -json all&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type Module struct {
Path string
Version string
}

type GoMod struct {
Module  Module
Go      string
Require []Require
Exclude []Module
Replace []Replace
}

type Require struct {
Path string
Version string
Indirect bool
}

type Replace struct {
Old Module
New Module
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工具可以通过解析 &lt;code&gt;go mod edit -json&lt;/code&gt; 的输出获取 &lt;code&gt;go.mod&lt;/code&gt; 数据结构，然后通过 &lt;code&gt;go mod edit&lt;/code&gt; 修改&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;graph&#34;&gt;graph&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod graph&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：以文本格式打印模块需求图(使用 replaced 模块)。每一行输出包含模块及其一个依赖&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;init&#34;&gt;init&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod init [module]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：在当前目录初始化并写一个新的 &lt;code&gt;go.mod&lt;/code&gt;，实际上是以当前目录为根创建一个新模块。&lt;code&gt;go.mod&lt;/code&gt; 一定不能已经存在。可能的话，命令会从导入注释或版本控制配置(git 等)猜测模块路径。要 覆盖猜测，可以提供模块路径参数&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tidy&#34;&gt;tidy&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod tidy [-v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：确保 &lt;code&gt;go.mod&lt;/code&gt; 和模块的源码匹配。拉取需要的缺失模块，删除无用模块。同时修改 &lt;code&gt;go.sum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 会输出删除模块信息到标准错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;vendor&#34;&gt;vendor&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod vendor [-v]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：重置主模块的 &lt;code&gt;vendor&lt;/code&gt; 目录一包含编译和测试主模块所有包所需的包。目录不包含 vendored 包的测试代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 打印 vendored 模块和包的名称到标准错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;verify&#34;&gt;verify&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod verify&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：检查当前模块的依赖在下载之后不曾被修改，该依赖存储在一个本地下载的源码缓存。如果所有模块未被修改，输出 &lt;code&gt;all modules verified.&lt;/code&gt;。否则打印被修改的模块，并导致 &lt;code&gt;go mod&lt;/code&gt; 以非 0 状态码返回&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;why&#34;&gt;why&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;用法：&lt;code&gt;go mod why [-m] [-vendor] packages...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能：显示主模块到每个列举包的最短导入路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt; 将参数视为一系列模块，并为模块的每个包找到一个路径&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go run</title>
      <link>https://xueqing.github.io/translation/go-doc/command/run/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/run/</guid>
      <description>

&lt;h2 id=&#34;构建并运行程序&#34;&gt;构建并运行程序&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;对于简单的程序，可以使用 &lt;code&gt;go run program.go&lt;/code&gt; 直接构建并允许程序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go run&lt;/code&gt; 不会再运行目录生成任何文件，可执行文件被放在临时文件中执行，工作目录被设置为当前目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;go run&lt;/code&gt; 可以跟参数，第一个不是以 &lt;code&gt;.go&lt;/code&gt; 结尾的参数会作为可执行程序的参数列表的开始&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>go test</title>
      <link>https://xueqing.github.io/translation/go-doc/command/test_package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/test_package/</guid>
      <description>&lt;p&gt;用法：&lt;code&gt;go test [build/test flags] [packages] [build/test flags &amp;amp; test binary flags]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 自动测试通过导入路径命名的包。命令按下面的格式打印测试结果的概要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;ok   archive/tar   0.011s
FAIL archive/zip   0.022s
ok   compress/gzip 0.033s
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后是每个失败的包的详细输出。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 重新编译每个包以及所有名字匹配 “*_test.go” 的文件。这些额外的文件可以包含测试函数，基准测试函数和示例函数。查看 &lt;code&gt;go help testfunc&lt;/code&gt; 获取更多信息。每个列举的包执行一个单独的二进制测试。忽视以 “_” (包括 “_test.go”) 或 “.” 开始的文件。&lt;/p&gt;

&lt;p&gt;声明了后缀为 “_test” 的包的测试文件会作为一个单独的包被编译，然后被主二进制测试链接和运行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go tool&lt;/code&gt; 会忽视 “testdata” 命名的目录，使得可以包含测试所需的辅助数据。&lt;/p&gt;

&lt;p&gt;作为编译一个二进制测试的一部分，&lt;code&gt;go test&lt;/code&gt; 在包及其测试源文件上运行 &lt;code&gt;go vet&lt;/code&gt; 以识别显著的问题。如果 &lt;code&gt;go vet&lt;/code&gt; 发现任何问题，&lt;code&gt;go test&lt;/code&gt; 报告这些问题并且不再运行二进制测试。只使用了默认 &lt;code&gt;go vet&lt;/code&gt; 检查的高可信度的子集。这些子集包括：atomic、bool、buildtags、nilfunc 和 printf。你可以通过 &lt;code&gt;go doc cmd/vet&lt;/code&gt; 查看他们的文档以及其他的 vet 测试。使用 -vet=off 标识禁用 &lt;code&gt;go vet&lt;/code&gt; 的运行。&lt;/p&gt;

&lt;p&gt;即使测试打印输出到它自己的标准错误，所有的测试输出和总结行会被打印到 go 命令的标准输出。(保留 go 命令的标准错误用于打印编译这些测试的错误。)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 运行包括两种模式：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;叫做本地目录模式。当调用 &lt;code&gt;go test&lt;/code&gt; 不带包参数时发生(如 &lt;code&gt;go test&lt;/code&gt; 或 &lt;code&gt;go test -v&lt;/code&gt;)。在这种模式，&lt;code&gt;go test&lt;/code&gt; 在当前目录找到的包源文件和测试文件，然后运行生成的二进制测试。在这种模式，禁用缓存(后面会讨论)。包测试结束之后，&lt;code&gt;go test&lt;/code&gt; 打印一个总结行显示测试状态(“ok” 或 “FAIL”)、包名和用时。&lt;/li&gt;
&lt;li&gt;叫做包列表模式。当调用 &lt;code&gt;go test&lt;/code&gt; 携带显式的包参数时发送(如 &lt;code&gt;go test math&lt;/code&gt;、&lt;code&gt;go test ./...&lt;/code&gt; 甚至 &lt;code&gt;go test ..&lt;/code&gt;)。在这种模式，&lt;code&gt;go test&lt;/code&gt; 编译和测试命令行列举的每个包。如果一个包测试通过，&lt;code&gt;go test&lt;/code&gt; 只打印最后的 “ok” 总结行。如果一个包测试失败，&lt;code&gt;go test&lt;/code&gt; 打印完整的测试输出。如果调用时携带 -bench 或 -v 标识，&lt;code&gt;go test&lt;/code&gt; 也会为通过测试包打印完整的输出，以显示请求的基准测试结果或错误日志。当所有列举的包测试结束且打印了他们的输出之后，如果任何一个包测试失败，&lt;code&gt;go test&lt;/code&gt; 打印一个最终的 “FAIL” 状态。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;只有在包列表模式，&lt;code&gt;go test&lt;/code&gt; 会缓存成功的包测试结果以避免不必要的重复运行测试。当一个测试的结果可从缓存中恢复时，&lt;code&gt;go test&lt;/code&gt; 会再次显示之前的输出而不是再次运行二进制测试。这时，&lt;code&gt;go test&lt;/code&gt; 打印 “(cached)” 取代总结行中的用时。&lt;/p&gt;

&lt;p&gt;缓存匹配的规则是 go 命令调用相同的二进制测试，且命令行标识完全来自受限的可缓存的测试标识集合，被定义为 -cpu、-list、-parallel、-run、-short 和 -v。如果允许一次 &lt;code&gt;go test&lt;/code&gt; 包含任何这个集合之外的测试标识或非测试标识，结果都是不可缓存的。要禁用测试缓存，使用除了可缓存的标识以外的任意的测试标识或参数。惯用的显式禁用测试缓存的方法是使用 -count=1。打开在包的源根(通常是 $GOPATH)或者查询环境变量的测试只有在这些文件和环境变量不改变时才会与之后的运行匹配。一个缓存的测试结果被视为立刻执行，因此无论如何设置 -timeout，一个成功的包测试结果会被缓存且重用。&lt;/p&gt;

&lt;p&gt;除了编译标志，&lt;code&gt;go test&lt;/code&gt; 专属的标识包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;args：传递命令行的剩余部分(-args 之后的所有)给二进制测试，不解释且不修改。因为这个标识使用了命令行的剩余部分，包列表(如果有)必须出现在这个标识之前。&lt;/li&gt;
&lt;li&gt;-c：编译二进制测试为 pkg.test 但不要运行(pkg 是包导入路径的最后一个元素)。文件名可以使用 -o 标识修改。&lt;/li&gt;
&lt;li&gt;-exec xprog：使用 xprog 运行二进制测试。这个行为和 &lt;code&gt;go run&lt;/code&gt; 相同。查看 &lt;code&gt;go run&lt;/code&gt; 获取更多信息。&lt;/li&gt;
&lt;li&gt;-i：安装测试的依赖包。不要运行测试。&lt;/li&gt;
&lt;li&gt;-json：将测试输出转化为 JSON 用于自动处理。查看 &lt;code&gt;go doc test2json&lt;/code&gt; 获取编码信息。&lt;/li&gt;
&lt;li&gt;-o file：编译二进制测试到指定名称的文件。测试仍然运行(除非指定 -c 或 -i)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;二进制测试也接收控制测试执行的标识；这些标识也可被 &lt;code&gt;go test&lt;/code&gt; 访问。查看 &lt;code&gt;go help testflag&lt;/code&gt; 获取更多信息。&lt;/p&gt;

&lt;p&gt;需要更多关于编译标识，查看 &lt;code&gt;go help build&lt;/code&gt;。需要更多关于指定包的，查看 &lt;code&gt;go help package&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;查看其他：&lt;code&gt;go build&lt;/code&gt;、&lt;code&gt;go vet&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GOPATH 和模块</title>
      <link>https://xueqing.github.io/translation/go-doc/command/gopath_and_module/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/gopath_and_module/</guid>
      <description>&lt;p&gt;当使用模块时，不再使用 GOPATH 来解决导入。但是，它仍被用于存储下载的源码(在 GOPATH/pkg/mod)和编译好的命令(在 GOPATH/bin)。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GOPATH 环境变量</title>
      <link>https://xueqing.github.io/translation/go-doc/command/gopath_env_var/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/gopath_env_var/</guid>
      <description>&lt;p&gt;Go 路径用于解决导入语句，它通过 go/build 包实现，并记录在 go/build 包。&lt;/p&gt;

&lt;p&gt;GOPATH 环境变量列举了寻找 Go 代码的位置。在 Unix 上，其值是一个冒号分隔的字符串。在 Windows 上，其值是一个分号分隔的字符串。在 Plan 9 上，其值是一个列表。&lt;/p&gt;

&lt;p&gt;如果环境变量未被设置，GOPATH 默认是用户主目录下的一个 “go” 子目录(Unix 下是 &lt;code&gt;$HOME/go&lt;/code&gt;，Windows 下是 &lt;code&gt;%USERPROFILE%\go&lt;/code&gt;)，除非那个目录存在一个 Go 发行版本。运行 &lt;code&gt;go env GOPATH&lt;/code&gt; 查看当前的 GOPATH。&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;../wiki/set_gopath.md&#34;&gt;SettingGOPATH&lt;/a&gt; 设置一个自定义的 GOPATH。&lt;/p&gt;

&lt;p&gt;GOPATH 下的每个目录必须有一个规定的结构：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;src 目录持有源码。src 下的目录确定了导入路径或可执行文件名字。&lt;/li&gt;
&lt;li&gt;pkg 目录持有安装的包对象。在 Go 树中，每个目标操作系统和架构对有其自己的包的子目录(pkg/GOOS_ARCH).&lt;/li&gt;
&lt;li&gt;如果 DIR 是GOPATH 下的一个目录，包的源码在 DIR/src/foo/bar，那么包可以导出为 “foo/bar”，且将其编译文件安装到 “DIR/pkg/GOOS_GOARCH/foo/bar.a”。&lt;/li&gt;
&lt;li&gt;bin 目录持有编译的命令。每个命令命名为它的源码目录，但是只有最后一个元素，而不是整个路径。也就是说，一个命令的源码在 DIR/src/foo/quux，那么它被安装到 DIR/bin/quux。这个 “foo/” 前缀被除去以便你可以增加 DIR/bin 到你的 PATH 来获取安装的命令。如果设置了 GOBIN 环境变量，命令被安装到 GOBIN 命名的目录而不是 DIR/bin。GOBIN 必须是一个绝对路径。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里是一个目录格式示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;GOPATH=/home/user/go

/home/user/go/
    src/
        foo/
            bar/               (包 bar 中的 go 代码)
                x.go
            quux/              (包 main 中的 go 代码)
                y.go
    bin/
        quux                   (安装的命令)
    pkg/
        linux_amd64/
            foo/
                bar.a          (安装的包对象)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 搜索 GOPATH 列举的每个目录来查找源码，但是新包总是下载到列表中的第一个目录。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&#34;../golangdoc/code.md&#34;&gt;如何编写 Go 代码&lt;/a&gt;的例子。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Images</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/images/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/images/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Images
Remember the picture generator you wrote earlier? Let&#39;s write another one, but this time it will return an implementation of image.Image instead of a slice of data.

Define your own Image type, implement the necessary methods, and call pic.ShowImage.

Bounds should return a image.Rectangle, like image.Rect(0, 0, w, h).

ColorModel should return color.RGBAModel.

At should return a color; the value v in the last picture generator corresponds to color.RGBA{v, v, 255, 255} in this one.
*/

package main

import (
  &amp;quot;image&amp;quot;
  &amp;quot;image/color&amp;quot;
  &amp;quot;math&amp;quot;

  &amp;quot;golang.org/x/tour/pic&amp;quot;
)

/*
type Image interface {
  // ColorModel returns the Image&#39;s color model.
  ColorModel() color.Model
  // Bounds returns the domain for which At can return non-zero color.
  // The bounds do not necessarily contain the point (0, 0).
  Bounds() Rectangle
  // At returns the color of the pixel at (x, y).
  // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.
  // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.
  At(x, y int) color.Color
}
*/

type myImage struct{}

func (img myImage) ColorModel() color.Model {
  return color.NRGBAModel
}

func (img myImage) Bounds() image.Rectangle {
  return image.Rect(0, 0, 100, 100)
}

func (img myImage) At(x, y int) color.Color {
  val := float64(x ^ y)
  v := uint8(math.Abs(val))
  return color.RGBA{v, v, 255, 255}
}

func main() {
  m := myImage{}
  pic.ShowImage(m)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>iotest 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/iotest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/iotest/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95&#34;&gt;索引&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/testing/iotest/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;testing/iotest&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;iotest 包实现了主要用于 testing 的 Reader 和 Writer。&lt;/p&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/iotest/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>live playlist (滑动窗口)构造</title>
      <link>https://xueqing.github.io/translation/hls/live_playlist_sliding_window_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/live_playlist_sliding_window_construction/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/live_playlist_sliding_window_construction&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;示例&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#extm3u&#34;&gt;EXTM3U&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-version&#34;&gt;EXT-X-VERSION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#extinf&#34;&gt;EXTINF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9b%b4%e6%96%b0-playlist-%e6%96%87%e4%bb%b6&#34;&gt;更新 playlist 文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;在直播会话中，当生成新的媒体文件且可访问时，通过从文件中移除媒体 URL 来更新索引文件。EXT-X-ENDLIST 标记不会在 live playlist 中出现，表示当新的媒体文件可访问时会被追加到索引文件。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的代码是一个第一个出现在直播会话中的 live playlist 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:1
#EXTINF:10.0,
fileSequence1.ts
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.0,
fileSequence4.ts
#EXTINF:10.0,
fileSequence5.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;live playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-playlist-type&#34;&gt;EXT-X-PLAYLIST-TYPE&lt;/h3&gt;

&lt;p&gt;提供了适用于整个 playlist 文件的易变信息。这个标记可能包含一个 EVENT 或 VOD 值。如果标记存在且值为 EVENT，服务器一定不能修改或删除 playlist 文件的任意部分(但是它可以追加行到 playlist 文件)。如果标记存在且值为 VOD，playlist 文件一定不能改变。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/h3&gt;

&lt;p&gt;指定最大的媒体文件时长。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-version&#34;&gt;EXT-X-VERSION&lt;/h3&gt;

&lt;p&gt;表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/h3&gt;

&lt;p&gt;表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：对于每个从 playlist 文件移除的 URL，EXT-X-MEDIA-SEQUENCE 标记值必须加 1。媒体 URL 必须按照出现在 playlist 中的顺序移除。更新的索引文件展示了移动窗口为一个持续流。这种会话类型适用于持续的广播。&lt;/p&gt;

&lt;h3 id=&#34;extinf&#34;&gt;EXTINF&lt;/h3&gt;

&lt;p&gt;一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。&lt;/p&gt;

&lt;h2 id=&#34;更新-playlist-文件&#34;&gt;更新 playlist 文件&lt;/h2&gt;

&lt;p&gt;下面的示例展示了使用新的媒体 URL 更新的同一 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:2
#EXTINF:10.0,
fileSequence2.ts
#EXTINF:10.0,
fileSequence3.ts
#EXTINF:10.00,
fileSequence4.ts
#EXTINF:10.00,
fileSequence5.ts
#EXTINF:10.0,
fileSequence6.ts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当增加新的媒体 URL 时继续更新 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:4
#EXTINF:10.00,
fileSequence4.ts
#EXTINF:10.00,
fileSequence5.ts
#EXTINF:10.0,
fileSequence6.ts,
#EXTINF:10.0,
fileSequence7.ts,
#EXTINF:10.0,
fileSequence8.ts,
#EXTINF:10.0,
fileSequence9.ts
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Loops and Functions</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/loops_and_functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/loops_and_functions/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: Loops and Functions
As a way to play with functions and loops, let&amp;rsquo;s implement a square root function: given a number x, we want to find the number z for which z² is most nearly x.&lt;/p&gt;

&lt;p&gt;Computers typically compute the square root of x using a loop. Starting with some guess z, we can adjust z based on how close z² is to x, producing a better guess:&lt;/p&gt;

&lt;p&gt;z -= (z*z - x) / (2*z)
Repeating this adjustment makes the guess better and better until we reach an answer that is as close to the actual square root as can be.&lt;/p&gt;

&lt;p&gt;Implement this in the func Sqrt provided. A decent starting guess for z is 1, no matter what the input. To begin with, repeat the calculation 10 times and print each z along the way. See how close you get to the answer for various values of x (1, 2, 3, &amp;hellip;) and how quickly the guess improves.&lt;/p&gt;

&lt;p&gt;Hint: To declare and initialize a floating point value, give it floating point syntax or use a conversion:&lt;/p&gt;

&lt;p&gt;z := 1.0
z := float64(1)
Next, change the loop condition to stop once the value has stopped changing (or only changes by a very small amount). See if that&amp;rsquo;s more or fewer than 10 iterations. Try other initial guesses for z, like x, or x/2. How close are your function&amp;rsquo;s results to the math.Sqrt in the standard library?&lt;/p&gt;

&lt;p&gt;(Note: If you are interested in the details of the algorithm, the z² − x above is how far away z² is from where it needs to be (x), and the division by 2z is the derivative of z², to scale how much we adjust z by how quickly z² is changing. This general approach is called Newton&amp;rsquo;s method. It works well for many functions but especially well for square root.)
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;fmt&amp;rdquo;
    &amp;ldquo;math&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;func mySqrt(x float64) float64 {
    // z := x / 2
    z := x
    tmp := 0.0
    for math.Abs(z-tmp) &amp;gt;= 0.000000000001 {
        tmp = z
        z -= (z*z - x) / (2 * z)
        fmt.Println(z)
    }
    return z
}&lt;/p&gt;

&lt;p&gt;func main() {
    fmt.Println(mySqrt(2))
    fmt.Println(math.Sqrt(2))
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Maps</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/maps/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/maps/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: Maps
Implement WordCount. It should return a map of the counts of each “word” in the string s. The wc.Test function runs a test suite against the provided function and prints success or failure.&lt;/p&gt;

&lt;p&gt;You might find strings.Fields helpful.
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;strings&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;quot;golang.org/x/tour/wc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;)&lt;/p&gt;

&lt;p&gt;func wordCount(s string) map[string]int {
    m := make(map[string]int)
    var ss []string
    ss = strings.Fields(s)
    for i := 0; i &amp;lt; len(ss); i++ {
        m[ss[i]]++
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;func main() {
    wc.Test(wordCount)
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>quick 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/quick/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/quick/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95&#34;&gt;索引&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/testing/quick/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;testing/quick&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;quick 包实现了帮辅助黑盒测试的工具函数。&lt;/p&gt;

&lt;p&gt;testing/quick 包被冻结，且不再接受新特性。&lt;/p&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/quick/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Readers</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/reader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/reader/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: Readers
Implement a Reader type that emits an infinite stream of the ASCII character &amp;lsquo;A&amp;rsquo;.
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;golang.org/x/tour/reader&amp;rdquo;&lt;/p&gt;

&lt;p&gt;type myReader struct{}&lt;/p&gt;

&lt;p&gt;func (r myReader) Read(c []byte) (int, error) {
    i := 0
    for ; i &amp;lt; len&amp;copy;; i++ {
        c[i] = &amp;lsquo;A&amp;rsquo;
    }
    for ; i &amp;lt; cap&amp;copy;; i++ {
        c = append(c, &amp;lsquo;A&amp;rsquo;)
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return cap(c), nil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;func main() {
    reader.Validate(myReader{})
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rot13Reader</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/rot_reader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/rot_reader/</guid>
      <description>&lt;p&gt;```go
/*
Exercise: rot13Reader
A common pattern is an io.Reader that wraps another io.Reader, modifying the stream in some way.&lt;/p&gt;

&lt;p&gt;For example, the gzip.NewReader function takes an io.Reader (a stream of compressed data) and returns a *gzip.Reader that also implements io.Reader (a stream of the decompressed data).&lt;/p&gt;

&lt;p&gt;Implement a rot13Reader that implements io.Reader and reads from an io.Reader, modifying the stream by applying the rot13 substitution cipher to all alphabetical characters.&lt;/p&gt;

&lt;p&gt;The rot13Reader type is provided for you. Make it an io.Reader by implementing its Read method.
*/&lt;/p&gt;

&lt;p&gt;package main&lt;/p&gt;

&lt;p&gt;import (
    &amp;ldquo;io&amp;rdquo;
    &amp;ldquo;os&amp;rdquo;
    &amp;ldquo;strings&amp;rdquo;
)&lt;/p&gt;

&lt;p&gt;type rot13Reader struct {
    r io.Reader
}&lt;/p&gt;

&lt;p&gt;func rot13(b byte) byte {
    if b &amp;gt;= &amp;lsquo;a&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;rsquo;m&amp;rsquo; {
        return b + 13
    }
    if b &amp;gt;= &amp;lsquo;n&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;lsquo;z&amp;rsquo; {
        return b - &amp;lsquo;n&amp;rsquo; + &amp;lsquo;a&amp;rsquo;
    }
    if b &amp;gt;= &amp;lsquo;A&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;rsquo;M&amp;rsquo; {
        return b + 13
    }
    if b &amp;gt;= &amp;lsquo;N&amp;rsquo; &amp;amp;&amp;amp; b &amp;lt;= &amp;lsquo;Z&amp;rsquo; {
        return b - &amp;lsquo;N&amp;rsquo; + &amp;lsquo;A&amp;rsquo;
    }
    return b
}&lt;/p&gt;

&lt;p&gt;var rot13Map = make(map[byte]byte)&lt;/p&gt;

&lt;p&gt;func initializeRot13Map() {
    s1 := &amp;ldquo;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&amp;rdquo;
    s2 := &amp;ldquo;NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm&amp;rdquo;
    for i := 0; i &amp;lt; len(s1); i++ {
        rot13Map[s1[i]] = s2[i]
    }
}&lt;/p&gt;

&lt;p&gt;func rot13ByMap(b byte) byte {
    val, ok := rot13Map[b]
    if ok {
        return val
    }
    return b
}&lt;/p&gt;

&lt;p&gt;func (rot rot13Reader) Read(c []byte) (int, error) {
    b := make([]byte, 8)
    n, err := rot.r.Read(b)
    initializeRot13Map()
    for i := 0; i &amp;lt; n; i++ {
        // b[i] = rot13(b[i])
        b[i] = rot13ByMap(b[i])
    }
    if err == io.EOF {
        return n, err
    }
    copy(c, b)
    return n, nil
}&lt;/p&gt;

&lt;p&gt;func main() {
    s := strings.NewReader(&amp;ldquo;Lbh penpxrq gur pbqr!&amp;rdquo;)
    r := rot13Reader{s}
    io.Copy(os.Stdout, &amp;amp;r)
}&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Slices</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/slices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/slices/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Slices
Implement Pic. It should return a slice of length dy, each element of which is a slice of dx 8-bit unsigned integers. When you run the program, it will display your picture, interpreting the integers as grayscale (well, bluescale) values.

The choice of image is up to you. Interesting functions include (x+y)/2, x*y, and x^y.

(You need to use a loop to allocate each []uint8 inside the [][]uint8.)

(Use uint8(intValue) to convert between types.)
*/

package main

import &amp;quot;golang.org/x/tour/pic&amp;quot;

func myPic(dx, dy int) [][]uint8 {
  pic := make([][]uint8, dx)
  for i := 0; i &amp;lt; dx; i++ {
    pic[i] = make([]uint8, dy)
  }
  for i := 0; i &amp;lt; dx; i++ {
    for j := 0; j &amp;lt; dy; j++ {
      pic[i][j] = uint8((i ^ j))
    }
  }
  return pic
}

func main() {
  pic.Show(myPic)
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Stringers</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/stringer/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/stringer/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Stringers
Make the IPAddr type implement fmt.Stringer to print the address as a dotted quad.

For instance, IPAddr{1, 2, 3, 4} should print as &amp;quot;1.2.3.4&amp;quot;.
*/

package main

import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;strconv&amp;quot;
  &amp;quot;strings&amp;quot;
)

type iPAddr [4]byte

func (ip iPAddr) String() string {
  arr := []string{&amp;quot;0&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;0&amp;quot;, &amp;quot;.&amp;quot;, &amp;quot;0&amp;quot;}
  for i := 0; i &amp;lt; 4; i++ {
    arr[i&amp;lt;&amp;lt;1] = strconv.Itoa(int(ip[i]))
  }
  sip := strings.Join(arr, &amp;quot;&amp;quot;)
  return sip
}

func main() {
  hosts := map[string]iPAddr{
    &amp;quot;loopback&amp;quot;:  {127, 0, 0, 1},
    &amp;quot;googleDNS&amp;quot;: {8, 8, 8, 8},
  }
  for name, ip := range hosts {
    fmt.Printf(&amp;quot;%v: %v\n&amp;quot;, name, ip)
  }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>testing 包</title>
      <link>https://xueqing.github.io/translation/go-doc/golangpkg/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangpkg/testing/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b%e5%87%bd%e6%95%b0&#34;&gt;示例函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b7%b3%e8%bf%87%e6%b5%8b%e8%af%95&#34;&gt;跳过测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%90%e6%b5%8b%e8%af%95%e9%a1%b9%e7%9b%ae%e5%92%8c%e5%ad%90%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;子测试项目和子基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#main&#34;&gt;Main&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b4%a2%e5%bc%95&#34;&gt;索引&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%8b%e5%ad%90&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ad%90%e7%9b%ae%e5%bd%95&#34;&gt;子目录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/pkg/testing/&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;p&gt;导入语句：&lt;code&gt;import &amp;quot;testing&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;testing 包提供对 Go 包的自动测试。它适用于和 &lt;code&gt;go test&lt;/code&gt; 命令协作，自动执行下面格式的函数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestXxx(*testing.T)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，Xxx 不是小写字母开头。这个函数名用于识别测试代码。&lt;/p&gt;

&lt;p&gt;在这些函数中，使用 Error、Fail 或相关的方法来标记失败。&lt;/p&gt;

&lt;p&gt;要写一个新的测试集，新建一个文件以 _test.go 结尾，其中包含上述的 TestXxx 函数。将此文件放在将要测试的同一包中。正常的包编译不会包含此文件，但是运行 &lt;code&gt;go test&lt;/code&gt; 命令时会包含。查看更多细节，运行 &lt;code&gt;go help test&lt;/code&gt; 和 &lt;code&gt;go help testflag&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一个简单的功能测试函数看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestAbs(t testing.T) {
  got := Abs(-1)
  if got != 1 {
    t.Errorf(&amp;quot;Abs(-1) = %d; want 1&amp;quot;, got)
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;基准测试&#34;&gt;基准测试&lt;/h3&gt;

&lt;p&gt;下面格式的函数被当做基准测试，并且当 &lt;code&gt;go test&lt;/code&gt; 命令提供 -bench 标记时会执行此函数。基准测试是顺序执行的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkXxxx(*testing.B)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对 testing 标记的描述，查看 &lt;a href=&#34;../command/test_flag.md&#34;&gt;Testing flags&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个简单的基准测试函数看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkHello(b *testing.B) {
    for i := 0; i &amp;lt; b.N; i++ {
        fmt.Sprintf(&amp;quot;hello&amp;quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;基准测试函数必须运行目标代码 b.N 次。在执行基准测试期间，会调整 b.N 直到基准测试函数持续时间足够长，认为是时间可靠的。输出 &lt;code&gt;BenchmarkHello    10000000    282 ns/op&lt;/code&gt; 意味着这个循环以每次循环 282 纳秒的速度运行了 10000000 次。&lt;/p&gt;

&lt;p&gt;如果一个基准测试在运行之前需要一些耗时的设置，可重置定时器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkBigLen(b *testing.B) {
    big := NewBig()
    b.ResetTimer()
    for i := 0; i &amp;lt; b.N; i++ {
        big.Len()
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一个基准测试需要并行测试性能，可以使用 RunParallel 辅助函数；这样的基准测试适用于和 go test -cpu 标识一起使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkTemplateParallel(b *testing.B) {
    templ := template.Must(template.New(&amp;quot;test&amp;quot;).Parse(&amp;quot;Hello, {{.}}!&amp;quot;))
    b.RunParallel(func(pb *testing.PB) {
        var buf bytes.Buffer
        for pb.Next() {
            buf.Reset()
            templ.Execute(&amp;amp;buf, &amp;quot;World&amp;quot;)
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;示例函数&#34;&gt;示例函数&lt;/h3&gt;

&lt;p&gt;testing 包也会运行和验证示例代码。示例函数可以包含一个总结性的行注释，以 “Output:” 开头，并且运行测试的是和这个函数的标准输出比较。(这个比较忽视开始和末尾的空格)。下面是一个示例代码的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExampleHello() {
    fmt.Println(&amp;quot;hello&amp;quot;)
    // Output: hello
}

func ExampleSalutations() {
    fmt.Println(&amp;quot;hello, and&amp;quot;)
    fmt.Println(&amp;quot;goodbye&amp;quot;)
    // Output:
    // hello, and
    // goodbye
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释前缀 “Unordered output:” 类似于 “Output:”，但是匹配任意的行顺序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExamplePerm() {
    for _, value := range Perm(4) {
        fmt.Println(value)
    }
    // Unordered output: 4
    // 2
    // 1
    // 3
    // 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有输出注释的示例函数被编译但是不会被执行。&lt;/p&gt;

&lt;p&gt;声明包、函数 F、类型 T 和作用于类型 T 的方法 M 的示例函数的命名如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Example() { ... }
func ExampleF() { ... }
func ExampleT() { ... }
func ExampleT_M() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可通过增加一个不同的后缀到函数名字后面以支持对于一个包/类型/函数/方法的多个示例函数。后缀必须以小写字母开始。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Example_suffix() { ... }
func ExampleF_suffix() { ... }
func ExampleT_suffix() { ... }
func ExampleT_M_suffix() { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当文件包含一个单独的示例函数，及至少一个其他的函数、类型、变量或常数声明，且没有功能测试函数或者基准测试函数时，整个测试文件作为例子显示。&lt;/p&gt;

&lt;h3 id=&#34;跳过测试&#34;&gt;跳过测试&lt;/h3&gt;

&lt;p&gt;可在运行时调用 *T 或 *B 的 Skip 方法跳过功能测试或基准测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTimeConsuming(t *testing.T) {
    if testing.Short() {
        t.Skip(&amp;quot;skipping test in short mode.&amp;quot;)
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;子测试项目和子基准测试&#34;&gt;子测试项目和子基准测试&lt;/h3&gt;

&lt;p&gt;T 和 B 的 Run 方法允许定义子测试项目和子基准测试，而不需要为每个子测试项目和子基准测试定义另外的函数。这使能使用类似表驱动的基准测试和创建分级测试。它也提供了一种方式来共享共用的设置和终止代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestFoo(t *testing.T) {
    // &amp;lt;setup code&amp;gt;
    t.Run(&amp;quot;A=1&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;A=2&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;B=1&amp;quot;, func(t *testing.T) { ... })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个子测试项目和子基准测试有一个唯一的名字：结合顶层测试的名字以及传递给 Run 的名字的顺序，由斜线分隔，以及一个可选的尾随的序号以消除歧义。&lt;/p&gt;

&lt;p&gt;传递给 -run 和 -bench 命令行标识符的参数是一个不固定的正则表达式，匹配了测试的名字。参数是多个斜线分隔的元素时，比如子测试，参数是自身(斜线分隔)；表达式匹配每个名字元素。因为是不固定的，一个空的表达式匹配任意字符串。比如，使用 “matching” 表达 “谁的名字包含”：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go test -run &#39;&#39;      # Run all tests.
go test -run Foo     # Run top-level tests matching &amp;quot;Foo&amp;quot;, such as &amp;quot;TestFooBar&amp;quot;.
go test -run Foo/A=  # For top-level tests matching &amp;quot;Foo&amp;quot;, run subtests matching &amp;quot;A=&amp;quot;.
go test -run /A=1    # For all top-level tests, run subtests matching &amp;quot;A=1&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子测试也可用于控制并行度。一个父测试只有在其子测试完成时才会完成。在这个例子中，所有测试去其他测试并行运行，且只与其他测试并行，而与可能定义的其他顶层测试无关。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestGroupedParallel(t *testing.T) {
    for _, tc := range tests {
        tc := tc // capture range variable
        t.Run(tc.Name, func(t *testing.T) {
            t.Parallel()
            // ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当程序超过 8192 个并行 goroutine 时，竞争检测器会杀掉程序，因此当运行并行测试且设置了 -race 标识时需要注意。&lt;/p&gt;

&lt;p&gt;Run 只有在并行子测试结束才会返回，为一组并行测试之后的资源清理提供了一种方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTeardownParallel(t *testing.T) {
    // This Run will not return until the parallel tests finish.
    t.Run(&amp;quot;group&amp;quot;, func(t *testing.T) {
        t.Run(&amp;quot;Test1&amp;quot;, parallelTest1)
        t.Run(&amp;quot;Test2&amp;quot;, parallelTest2)
        t.Run(&amp;quot;Test3&amp;quot;, parallelTest3)
    })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;main&#34;&gt;Main&lt;/h3&gt;

&lt;p&gt;测试程序有时需要在测试之前或之后做一些额外的设置和清理。并且，测试程序有时需要控制哪些代码运行在主线程。为了满足这些需求和其他的场景，一个测试文件可以包含一个函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestMain(m *testing.M)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，生成的测试会调用 TestMain(m) 而不是直接运行测试。TestMain 在主的 goroutine 运行，且可以做调用 m.Run 前后所需的所有设置和清理。然后，它应该使用 m.Run 的结果调用 OS.Exit。当调用 TestMain 时，flag.Parse 还没有运行。如果 TestMain(包括这些测试包) 依赖命令行标识，应该显式调用 flag.Parse。&lt;/p&gt;

&lt;p&gt;一个简单的 TestMain 的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestMain(m *testing.M) {
    // call flag.Parse() here if TestMain uses flags
    os.Exit(m.Run())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/#pkg-index&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;例子&#34;&gt;例子&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/pkg/testing/#pkg-examples&#34; target=&#34;_blank&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;子目录&#34;&gt;子目录&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;概述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;iotest.md&#34; target=&#34;_blank&#34;&gt;iotest&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了主要用于 testing 的 Reader 和 Writer&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;quick.md&#34; target=&#34;_blank&#34;&gt;quick&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;实现了帮助黑盒测试的工具函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>VOD playlist 构造</title>
      <link>https://xueqing.github.io/translation/hls/vod_playlist_construction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/vod_playlist_construction/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/video_on_demand_playlist_construction&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%bf%b0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%a4%ba%e4%be%8b&#34;&gt;示例&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#extm3u&#34;&gt;EXTM3U&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-version&#34;&gt;EXT-X-VERSION&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#extinf&#34;&gt;EXTINF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ext-x-endlist&#34;&gt;EXT-X-ENDLIST&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%b8%e5%af%b9%e8%b7%af%e5%be%84&#34;&gt;相对路径&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;对于 VOD(video on demand, 点播) 会话，可以访问的媒体文件表示显示的整个时间段。索引文件是静态的，且包含相关 URL 的一个完整列表，可以访问从显示开始创建的所有媒体文件。这种会话支持用户对整个程序的完整控制。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的代码是一个 VOD playlist 的示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:VOD
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
http://example.com/movie1/fileSequenceA.ts
#EXTINF:10.0,
http://example.com/movie1/fileSequenceB.ts
#EXTINF:10.0,
http://example.com/movie1/fileSequenceC.ts
#EXTINF:9.0,
http://example.com/movie1/fileSequenceD.ts
#EXT-X-ENDLIST
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直播 playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-targetduration&#34;&gt;EXT-X-TARGETDURATION&lt;/h3&gt;

&lt;p&gt;指定最大的媒体文件时长。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-version&#34;&gt;EXT-X-VERSION&lt;/h3&gt;

&lt;p&gt;表明该 playlist 文件的兼容性版本。playlist 媒体及其服务器必须遵守 HLS 规范的 IETF 互联网草案最新版本的所有规定，此规范定义了协议版本。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-media-sequence&#34;&gt;EXT-X-MEDIA-SEQUENCE&lt;/h3&gt;

&lt;p&gt;表明出现在 playlist 文件的第一个 URL 的序列号。playlist 中的每个媒体文件 URL 有一个唯一的整数序列号。一个 URL 的序列号比前一个 URL 加 1。这个媒体序列号和文件名字无关。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：EXT-X-MEDIA-SEQUENCE 标记的值&lt;/p&gt;

&lt;h3 id=&#34;extinf&#34;&gt;EXTINF&lt;/h3&gt;

&lt;p&gt;一个记录标识，描述了媒体文件，通过其后的 URL 标记该媒体文件。每个媒体文件 URL 前面必须有一个 EXTINF 标记。这个标记包含一个时长属性，是一个十进制的整数或浮点数，指定了这个媒体片段的时长(单位是秒)。这个时长属性的值必须不大于 EXT-X-TARGETDURATION 的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：总使用浮点的 EXTINF 时长(在协议版本 3 支持)。这支持客户端再流内部跳转(seek)时最小化四舍五入的差错。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-endlist&#34;&gt;EXT-X-ENDLIST&lt;/h3&gt;

&lt;p&gt;表明不会再向 playlist 文件增加媒体文件了。&lt;/p&gt;

&lt;h2 id=&#34;相对路径&#34;&gt;相对路径&lt;/h2&gt;

&lt;p&gt;上述的 VOD playlist 示例对于媒体文件 playlist 条目使用完整的路径名。虽然支持这么做，更鼓励使用相对路径。相对路径比绝对路径更易移植且相对于 playlist 文件的 URL。对于单个 playlist 条目使用完整路径名比使用相对路径经常导致文本更长。下面是使用相对路径的相同的 playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-PLAYLIST-TYPE:VOD
#EXT-X-TARGETDURATION:10
#EXT-X-VERSION:4
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
fileSequenceA.ts
#EXTINF:10.0,
fileSequenceB.ts
#EXTINF:10.0,
fileSequenceC.ts
#EXTINF:9.0,
fileSequenceD.ts
#EXT-X-ENDLIST
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Web Crawler</title>
      <link>https://xueqing.github.io/translation/go-doc/gotour/web_crawler/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/gotour/web_crawler/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
Exercise: Web Crawler
In this exercise you&#39;ll use Go&#39;s concurrency features to parallelize a web crawler.

Modify the Crawl function to fetch URLs in parallel without fetching the same URL twice.

Hint: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not safe for concurrent use!
*/

package main

import (
  &amp;quot;fmt&amp;quot;
)

type Fetcher interface {
  // Fetch returns the body of URL and
  // a slice of URLs found on that page.
  Fetch(url string) (body string, urls []string, err error)
}

// Crawl uses fetcher to recursively crawl
// pages starting with url, to a maximum of depth.
func Crawl(url string, depth int, fetcher Fetcher) {
  // TODO: Fetch URLs in parallel.
  // TODO: Don&#39;t fetch the same URL twice.
  // This implementation doesn&#39;t do either:
  if depth &amp;lt;= 0 {
    return
  }
  body, urls, err := fetcher.Fetch(url)
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Printf(&amp;quot;found: %s %q\n&amp;quot;, url, body)
  for _, u := range urls {
    Crawl(u, depth-1, fetcher)
  }
  return
}

func main() {
  Crawl(&amp;quot;https://golang.org/&amp;quot;, 4, fetcher)
}

// fakeFetcher is Fetcher that returns canned results.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
  body string
  urls []string
}

func (f fakeFetcher) Fetch(url string) (string, []string, error) {
  if res, ok := f[url]; ok {
    return res.body, res.urls, nil
  }
  return &amp;quot;&amp;quot;, nil, fmt.Errorf(&amp;quot;not found: %s&amp;quot;, url)
}

// fetcher is a populated fakeFetcher.
var fetcher = fakeFetcher{
  &amp;quot;https://golang.org/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;The Go Programming Language&amp;quot;,
    []string{
      &amp;quot;https://golang.org/pkg/&amp;quot;,
      &amp;quot;https://golang.org/cmd/&amp;quot;,
    },
  },
  &amp;quot;https://golang.org/pkg/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;Packages&amp;quot;,
    []string{
      &amp;quot;https://golang.org/&amp;quot;,
      &amp;quot;https://golang.org/cmd/&amp;quot;,
      &amp;quot;https://golang.org/pkg/fmt/&amp;quot;,
      &amp;quot;https://golang.org/pkg/os/&amp;quot;,
    },
  },
  &amp;quot;https://golang.org/pkg/fmt/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;Package fmt&amp;quot;,
    []string{
      &amp;quot;https://golang.org/&amp;quot;,
      &amp;quot;https://golang.org/pkg/&amp;quot;,
    },
  },
  &amp;quot;https://golang.org/pkg/os/&amp;quot;: &amp;amp;fakeResult{
    &amp;quot;Package os&amp;quot;,
    []string{
      &amp;quot;https://golang.org/&amp;quot;,
      &amp;quot;https://golang.org/pkg/&amp;quot;,
    },
  },
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>二进制兼容的 C&#43;&#43; 接口</title>
      <link>https://xueqing.github.io/translation/cplusplus/binary_compatible_cpp_interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/cplusplus/binary_compatible_cpp_interface/</guid>
      <description>

&lt;p&gt;原文参考 &lt;a href=&#34;https://chadaustin.me/cppinterface.html&#34; target=&#34;_blank&#34;&gt;Binary-compatible C++ Interfaces&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;作者：Chad Austin, 2002.02.15&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%85%BC%E5%AE%B9%E7%9A%84-C-%E6%8E%A5%E5%8F%A3&#34;&gt;二进制兼容的 C++ 接口&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%BF%B0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%83%8C%E6%99%AF&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E5%BF%B5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95&#34;&gt;初次尝试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%B0%9D%E8%AF%95&#34;&gt;第二次尝试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BF%AE%E6%AD%A3&#34;&gt;第三次修正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BF%AE%E6%AD%A3&#34;&gt;第四次修正&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%8C%E6%88%90%E6%B6%A6%E8%89%B2&#34;&gt;完成润色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E7%BB%88%E5%AE%9E%E7%8E%B0&#34;&gt;最终实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;本文解释如何生成跨编译器和配置(发布/调试等)的 C++ DLL API。&lt;/p&gt;

&lt;h2 id=&#34;背景&#34;&gt;背景&lt;/h2&gt;

&lt;p&gt;许多平台对他们偏好的编程语言有自己的 ABI。比如，BeOS 的主要语言是 C++，所以 C++ 编译器一定可以生成保持操作系统 C++ 系统调用二(还有类等)进制兼容的代码。&lt;/p&gt;

&lt;p&gt;Windows 为 C 语言定义 API 和 ABI，因此 C++ 编译器的开发者可以自由控制 C++ ABI 的实现。但是，MS 最后为 Windows 创建面向对象的 ABI，称为 COM。为了简化 COM 的使用，他们使 C++ ABI 的虚表(vtables)映射到 COM 接口所需的虚表。由于不能使用 COM 的 Windows 编译器非常受限，其他的编译器强制执行 COM 虚表和 C++ 虚表之前的映射。&lt;/p&gt;

&lt;p&gt;ABI 包含多个方面。这篇文章只讨论在 Windows 下使用 C++ 的问题。其他平台要求不一样。(幸运的是，因为大部分其他平台不如 Windows 流行，这些平台只有一或两个编译器，因此不是很大的问题。)&lt;/p&gt;

&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ABI&lt;/strong&gt;(Application Binary Interface，应用程序二进制接口)：系统之间的二进制接口。如果一个二进制接口改变，接口两端(使用者和实现)必须被重新编译。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;API&lt;/strong&gt;(Application Program Interface，应用程序编程接口)：系统之间的源接口。如果一个源接口改变，使用这个接口的代码必须修改。API 改变通常暗示 ABI 改变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Interface&lt;/strong&gt;(接口)：一个所有方法都是纯虚的类，因此没有内在实现。一个接口只是对象之间通讯的协议。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Factory&lt;/strong&gt;(工厂)：用于创建对象。在这篇文章中，我们使用一个全局的函数作为我们的工厂。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLL Boundary&lt;/strong&gt;(DLL 界限)：DLL 中被实例化的代码和调用进程的代码之间的线被称为 DLL 界限。在一些情况下，代码可以在界限两侧：一个头文件中的一个内联函数在 DLL 和可执行文件中被使用。这个函数实际上在界限两侧被实例化。因此，如果内联函数有一个静态变量，会创建两个变量，分别在可执行文件和 DLL 中，&lt;strong&gt;哪个变量被使用取决于 DLL 还是可执行文件中的代码调用了这个函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;初次尝试&#34;&gt;初次尝试&lt;/h2&gt;

&lt;p&gt;假设想要创建一个可移植的 windowing API，而且想要把实现放在 DLL 中。我会创建一个名为 Window 的类，这个类可以表示不同的 windowing 系统的一个窗口，Win32，MFC，wxWindows，Qt，Gtk，Aqua，X11，Swing(gasp)等。我们会多次尝试创建一个接口直到它可以在不同的实现、编译器和编译器设置上工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

#include &amp;lt;string&amp;gt;

#ifdef WIN32
  #ifdef EXPORTING
    #define DLLIMPORT _declspec(dllexport)
  #endif
  #else
    #define DLLIMPORT _declspec(dllimport)
  #endif
  #define CALL __stdcall
#else
  #define DLLIMPORT
  #define CALL
#endif

class DLLIMPORT Window {
public:
  Window(std::string title);
  ~Window();

  void setTitle(std::string title);
  std::string getTitle();

  //...

private:
  HWND m_window;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我不会展示实现，因为我假定你已经知道如何实现。关于这个接口有一个明显的问题：它假定你使用基础的 Win32 API。即它持有一个 HWND 作为私有成员，因此引入了 Window 类和 WIn32 SDK 的依赖。一个可能的解决方案是使用 pImpl 语法从类的定义中移除这个私有成员。参考文档&lt;a href=&#34;http://www.gotw.ca/publications/mill04.htm&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;、&lt;a href=&#34;http://www.gotw.ca/publications/mill05.htm&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;、&lt;a href=&#34;http://www.gotw.ca/gotw/028.htm&#34; target=&#34;_blank&#34;&gt;3&lt;/a&gt;和&lt;a href=&#34;http://wiki.c2.com/?PimplIdiom&#34; target=&#34;_blank&#34;&gt;4&lt;/a&gt;。同时，你不能在不破坏二进制兼容的条件下向这个类增加新成员，因为这个类的大小会改变。&lt;/p&gt;

&lt;p&gt;可能这个方法最重要的问题是成员方法不是纯虚的。因此，这些成员方法被实现为专门命名的函数，且函数使用 &lt;code&gt;this&lt;/code&gt; 指针作为第一个参数。不幸的是，我不知道有哪两种编译器对方法的名称重整(name mangling)是一样的。因此不要认为你用一个编译器生成的的 DLL 可被另一个编译器编译的可执行文件使用。&lt;/p&gt;

&lt;h2 id=&#34;第二次尝试&#34;&gt;第二次尝试&lt;/h2&gt;

&lt;p&gt;对于面向对象编程，你知道每个类可以分为两个概念：接口和工厂。工厂是创建对象的一种机制，接口支持对象之间通讯。下个版本的 Window.h 会分离这些概念。注意你不再需要导出类(你需要导出工厂函数)，因为这个是抽象类：所有的方法调用经过对象的虚表(vtables)，而不是通过一个直接的链接到 DLL。只有调用这个工厂函数会直接调用 DLL。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

#include &amp;lt;string&amp;gt;

class Window {
public:
  virtual ~Window() {}
  virtual void setTitle(std::string title) = 0;
  virtual std::string getTitle() = 0;
};

Window* DLLIMPORT CreateWindow(std::string title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码更好。使用 Window 对象的代码不关心 Window 对象实际的类型，只要实现 Window 接口的类型都可以。但是，还有一个问题：不同的编译器重整符号名称不同，因此不同编译器生成的 DLL 中的 &lt;code&gt;CreateWindow&lt;/code&gt; 函数名称不同。这意味着如果你使用 Visual C++ 6 编译 windowing DLL，不能再 Bor兰 C++ 中使用，反之亦然。幸运的是，C++ 标准通过 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 使得禁用符号重整成特殊的名称。&lt;/p&gt;

&lt;p&gt;一些人可能注意到代码的另一个问题。不同的编译器对 C++ 库的实现不同。在一些不明显的情况下，一些人会用其他的(如 &lt;a href=&#34;http://stlport.org/&#34; target=&#34;_blank&#34;&gt;STLPort&lt;/a&gt;)替代编译器的库实现……由此你不能依赖跨编译器的 STL 对象是二进制兼容的，你不能在 DLL 接口中安全使用它们。&lt;/p&gt;

&lt;p&gt;如果一个 C++ ABI 曾为 Windows 创建，需要明确指定如何与标准库中的每个类交互，但是我马上就不会再看到这个事情发生了。&lt;/p&gt;

&lt;p&gt;最后一个问题比较小。出于惯例，COM 方法和 DLL 函数使用 &lt;code&gt;__stdcall&lt;/code&gt; 调用惯例。我们可以使用前面定义的 &lt;code&gt;CALL&lt;/code&gt; 宏解决这个问题。(可以在工程中重命名)&lt;/p&gt;

&lt;h2 id=&#34;第三次修正&#34;&gt;第三次修正&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;// Window.h

class Window {
public:
  virtual ~Window() {}
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;马上就完成了！这个特殊的接口可能在大多数情况下会有效。但是，虚析构函数使得事情有趣了……因为 COM 不使用虚析构函数，你不能依赖不同的编译器使用是一样的。然而，你可以使用一个虚方法取代虚析构函数。即在实现类中通过 &lt;code&gt;delete this&lt;/code&gt; 实现；这个方式会在 DLL 界限同一侧实现构造和析构函数。比如，如果尝试使用 VC++6 的发布版可执行程序调试 DLL，程序会崩溃或遇到类似“Value of ESP not saved across function call”的警告。发生这个错误是因为 VC++ 运行时库的调试版本和发布版的分配器(allocator)不同。因为两个分配器不兼容，我们不能在 DLL 界限一侧申请内存然后再另一侧释放这个内存。&lt;/p&gt;

&lt;p&gt;但是一个虚析构函数和一个虚方法是什么不同呢？虚析构函数不负责释放这个对象使用的内存：它们只是在释放对象之前简单地被调用执行必要的清理。使用 DLL 的可执行程序不会尝试释放对象本身的内存。另一方面， &lt;code&gt;destroy()&lt;/code&gt; 函数负责释放内存，因此所有的 new 和 delete 调用在 DLL 界限的同一侧。&lt;/p&gt;

&lt;p&gt;可以将接口的析构函数设为受保护的，以便使用接口的地方在析构函数中不小心删除它。&lt;/p&gt;

&lt;h2 id=&#34;第四次修正&#34;&gt;第四次修正&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.h

class Window {
protected:
  virtual ~Window() {} //use destroy()

public:
  virtual void CALL destroy() = 0;
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为这段代码不使用 COM 定义的语义，它可以跨编译器和配置工作。不幸的是，它不是完美的。你必须记住使用 &lt;code&gt;object-&amp;gt;destroy()&lt;/code&gt; 删除对象，这个不如 &lt;code&gt;delete object&lt;/code&gt; 直观。可能更重要的是，你不能在这个对象类型上使用 &lt;code&gt;std::auto_ptr&lt;/code&gt;，&lt;code&gt;autho_ptr&lt;/code&gt; 会使用 &lt;code&gt;delete object&lt;/code&gt; 删除它拥有的对象。有一种方式实现 &lt;code&gt;delete object&lt;/code&gt; 语法吗，实际上调用 &lt;code&gt;object-&amp;gt;destroy()&lt;/code&gt;？有的。这正使得事情有点奇怪……你可以为这个接口重载 &lt;code&gt;operator delete&lt;/code&gt;，在内部调用 &lt;code&gt;destroy()&lt;/code&gt;。因为运算符 delete 持有一个 void 指针，你需要记得你永远不会对任何非 Window 调用 &lt;code&gt;Window::operator delete&lt;/code&gt;。这是一个相当安全的假设。下面是运算符的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//...
void operator delete(void *p) {
  if(p) {
    Window* w = static_cast&amp;lt;Window*&amp;gt;(p);
    w-&amp;gt;destroy();
  }
}
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来相当好……你现在可以再使用 &lt;code&gt;autho_ptr&lt;/code&gt;，而且你仍然有一个稳定的二进制接口。当你重新编译和测试你的新代码，你会注意到在 &lt;code&gt;WindowImpl::destroy&lt;/code&gt; 有一个栈溢出！发生了什么？如果你记得 destroy 方法如何被实现，你会发现它只是简单的执行 &lt;code&gt;delete this&lt;/code&gt;。由于这个接口重载了 &lt;code&gt;operator delete&lt;/code&gt;，&lt;code&gt;WindowImpl::destroy&lt;/code&gt; 调用 &lt;code&gt;Window::operator delete&lt;/code&gt; 会调用 &lt;code&gt;WindowImpl::destroy&lt;/code&gt;……无限循环。这个特别问题的解决方法是在实现类中重载运算符 delete 来调用全局的运算符 delete&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//...
void operator delete(void *p) {
  ::operator delete(p);
}
//...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完成润色&#34;&gt;完成润色&lt;/h2&gt;

&lt;p&gt;如果你的系统有很多接口和实现，你会发现你想要一些方式自动化取消定义运算符 delete。幸运的是，这个也是可能的。简单地创建一个模板类叫做 DefaultDelete，然后不要从接口类 I 衍生，而是从 &lt;code&gt;class DefaultDelete&amp;lt;I&amp;gt;&lt;/code&gt; 衍生实现类。下面是 DefaultDelete 的实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;template&amp;lt;typename T&amp;gt;
class DefaultDelete : public T {
public:
  void operator delete(void *p) {
    ::operator delete(p);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;最终实现&#34;&gt;最终实现&lt;/h2&gt;

&lt;p&gt;下面是最终版本的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.h

#ifdef WIN32
  #define CALL __stdcall
#else
  #define CALL
#endif

class Window {
public:
  virtual void CALL destroy() = 0;
  virtual void CALL setTitle(const char* title) = 0;
  virtual const char* CALL getTitle() = 0;

  void operator delete(void* p) {
    if(p) {
      Window* p = static_cast&amp;lt;Window*&amp;gt;(p);
      w-&amp;gt;destroy();
    }
  }
};

extern &amp;quot;C&amp;quot; Window* CALL CreateWindow(const char* title);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//DefaultDelete.h

template&amp;lt;typename T&amp;gt;
class DefaultDelete : public T {
public:
  void operator delete(void* p) {
    ::operator delete(p);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//Window.cpp

#include &amp;quot;Window.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;windows.h&amp;gt;
#include &amp;quot;DefaultDelete.h&amp;quot;

class WindowImpl : public DefaultDelete&amp;lt;Window&amp;gt; {
public:
  WindowImpl(HWND window) {
    m_window = window;
  }

  ~WindowImpl() {
    DestroyWindow(m_window);
  }

  void CALL destroy() {
    delete this;
  }

  void CALL setTitle(const char* title) {
    SetWindowtext(m_window, title);
  }

  const char* CALL getTitle() {
    char title[512];
    GetWindowText(m_window, title, 512);
    m_title = title; //save the title past the call
    return m_title.c_str();
  }

private:
  HWND m_window;
  std::string m_title;
}

Window* CALL CreateWindow(const char* title) {
  // create Win32 window object
  HWND window = ::CreateWindow(..., title, ...);
  return (window ? new WindowImple(window) : 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;我会枚举一些指导方针，在创建 C++ 接口的时候需要记得。你可以回顾作为一个参考或者使用它帮助巩固你的知识。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;所有的接口类应该是完全抽象的。每个方法应该是纯虚的(或者内联的……你可以安全地编写内联方法调用其他方法)。&lt;/li&gt;
&lt;li&gt;所有的全局函数应该是 &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; 以避免不兼容的名称重整。并且，导出的函数和方法应该使用。&lt;code&gt;__stdcall&lt;/code&gt; 调用惯例，因为 DLL 函数和 COM 习惯上使用这种调用惯例。这种方式，如果这个库的使用者使用默认的 &lt;code&gt;__cdecl&lt;/code&gt; 编译，对 DLL 的调用仍然使用正确的惯例。&lt;/li&gt;
&lt;li&gt;不要使用标准 C++ 库。&lt;/li&gt;
&lt;li&gt;不要使用异常处理。&lt;/li&gt;
&lt;li&gt;不要使用虚析构函数。相反地，创建一个 &lt;code&gt;destroy()&lt;/code&gt; 方法和一个重载的 &lt;code&gt;operator delete&lt;/code&gt; 调用 &lt;code&gt;destroy()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;不要在 DLL 界限的一侧申请内存，在另一侧释放它。不同的 DLL 和 可执行文件可以使用不同的堆编译，并且使用不同的堆申请和释放内存块肯定会导致崩溃。比如，不要内联内存申请函数以便函数不会编译到不同的可执行文件和 DLL。&lt;/li&gt;
&lt;li&gt;不要在接口使用重载的方法。不同的编译器在虚表中排序不同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://stlport.org/&#34; target=&#34;_blank&#34;&gt;STLPort&lt;/a&gt; 是 STL 的替代&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.sgi.com/tech/stl/&#34; target=&#34;_blank&#34;&gt;SGI&lt;/a&gt; 有另外一个标准的 C++ 库实现&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://corona.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;Corona&lt;/a&gt; 图片 I/O 库使用了本文引入的技术&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>使用子测试和子基准测试</title>
      <link>https://xueqing.github.io/translation/go-doc/blog/subtest/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/blog/subtest/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95%e5%9f%ba%e7%a1%80&#34;&gt;表驱动测试基础&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e7%9a%84%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;表驱动的基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8%e5%ad%90%e6%b5%8b%e8%af%95%e7%9a%84%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95&#34;&gt;使用子测试的表驱动测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%90%e8%a1%8c%e6%8c%87%e5%ae%9a%e7%9a%84%e6%b5%8b%e8%af%95%e6%88%96%e5%9f%ba%e5%87%86%e6%b5%8b%e8%af%95&#34;&gt;运行指定的测试或基准测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%ae%be%e7%bd%ae%e5%92%8c%e6%b8%85%e7%90%86&#34;&gt;设置和清理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b6%e8%a1%8c%e6%8e%a7%e5%88%b6&#34;&gt;并行控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b6%e8%a1%8c%e8%bf%90%e8%a1%8c%e4%b8%80%e7%bb%84%e6%b5%8b%e8%af%95&#34;&gt;并行运行一组测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%80%e7%bb%84%e5%b9%b6%e8%a1%8c%e6%b5%8b%e8%af%95%e4%b9%8b%e5%90%8e%e7%9a%84%e6%b8%85%e7%90%86&#34;&gt;一组并行测试之后的清理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bb%93%e8%ae%ba&#34;&gt;结论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%9b%b8%e5%85%b3%e6%96%87%e7%ab%a0&#34;&gt;相关文章&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://blog.golang.org/subtests&#34; target=&#34;_blank&#34;&gt;Go 博客——使用子测试和子基准测试&lt;/a&gt;学习。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;  作者：Marcel van Lohuizen
  日期：2016/10/3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;在 Go1.7，testing 包引入了一个 Run 方法，作用于 &lt;a href=&#34;https://golang.org/pkg/testing/#T.Run&#34; target=&#34;_blank&#34;&gt;T&lt;/a&gt; 和 &lt;a href=&#34;https://golang.org/pkg/testing/#B.Run&#34; target=&#34;_blank&#34;&gt;B&lt;/a&gt; 类型，允许创建子测试和子基准测试。子测试和子基准测试的引入使得支持更好的失败处理，从命令行对运行哪个测试的细粒度控制，并行控制，并且经常生成更简单和可维护的代码。&lt;/p&gt;

&lt;h2 id=&#34;表驱动测试基础&#34;&gt;表驱动测试基础&lt;/h2&gt;

&lt;p&gt;在深入细节之前，让我们先讨论用 Go 编写测试的常用方式。可以通过对一个测试用例切片的循环实现一系列相关的检查：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTime(t *testing.T) {
    testCases := []struct {
        gmt  string
        loc  string
        want string
    }{
        {&amp;quot;12:31&amp;quot;, &amp;quot;Europe/Zuri&amp;quot;, &amp;quot;13:31&amp;quot;},     // incorrect location name
        {&amp;quot;12:31&amp;quot;, &amp;quot;America/New_York&amp;quot;, &amp;quot;7:31&amp;quot;}, // should be 07:31
        {&amp;quot;08:08&amp;quot;, &amp;quot;Australia/Sydney&amp;quot;, &amp;quot;18:08&amp;quot;},
    }
    for _, tc := range testCases {
        loc, err := time.LoadLocation(tc.loc)
        if err != nil {
            t.Fatalf(&amp;quot;could not load location %q&amp;quot;, tc.loc)
        }
        gmt, _ := time.Parse(&amp;quot;15:04&amp;quot;, tc.gmt)
        if got := gmt.In(loc).Format(&amp;quot;15:04&amp;quot;); got != tc.want {
            t.Errorf(&amp;quot;In(%s, %s) = %s; want %s&amp;quot;, tc.gmt, tc.loc, got, tc.want)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法常备表驱动测试提及。且相比为每个测试重复相同的代码，此方法减少了大量的重复代码，且使得增加测试用例更加直接。&lt;/p&gt;

&lt;h2 id=&#34;表驱动的基准测试&#34;&gt;表驱动的基准测试&lt;/h2&gt;

&lt;p&gt;在 Go1.7 之前，不能为基准测试使用相同的表驱动方法。一个基准测试测试整个函数的性能，因此遍历基准测试只是将它们作为一个整体测试。&lt;/p&gt;

&lt;p&gt;一个常用的变通方案是定义单独的顶层基准测试，每个基准测试使用不同参数调用一个公共的函数。比如，在 1.7 之前，strconv 包地狱塔 AppendFloat 的基准测试看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func benchmarkAppendFloat(b *testing.B, f float64, fmt byte, prec, bitSize int) {
    dst := make([]byte, 30)
    b.ResetTimer() // Overkill here, but for illustrative purposes.
    for i := 0; i &amp;lt; b.N; i++ {
        AppendFloat(dst[:0], f, fmt, prec, bitSize)
    }
}

func BenchmarkAppendFloatDecimal(b *testing.B) { benchmarkAppendFloat(b, 33909, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloat(b *testing.B)        { benchmarkAppendFloat(b, 339.7784, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloatExp(b *testing.B)     { benchmarkAppendFloat(b, -5.09e75, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloatNegExp(b *testing.B)  { benchmarkAppendFloat(b, -5.11e-95, &#39;g&#39;, -1, 64) }
func BenchmarkAppendFloatBig(b *testing.B)     { benchmarkAppendFloat(b, 123456789123456789123456789, &#39;g&#39;, -1, 64) }
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go1.7 可使用 Run 方法，相同的基准测试现在可以表示为一个顶层的基准测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkAppendFloat(b *testing.B) {
    benchmarks := []struct{
        name    string
        float   float64
        fmt     byte
        prec    int
        bitSize int
    }{
        {&amp;quot;Decimal&amp;quot;, 33909, &#39;g&#39;, -1, 64},
        {&amp;quot;Float&amp;quot;, 339.7784, &#39;g&#39;, -1, 64},
        {&amp;quot;Exp&amp;quot;, -5.09e75, &#39;g&#39;, -1, 64},
        {&amp;quot;NegExp&amp;quot;, -5.11e-95, &#39;g&#39;, -1, 64},
        {&amp;quot;Big&amp;quot;, 123456789123456789123456789, &#39;g&#39;, -1, 64},
        ...
    }
    dst := make([]byte, 30)
    for _, bm := range benchmarks {
        b.Run(bm.name, func(b *testing.B) {
            for i := 0; i &amp;lt; b.N; i++ {
                AppendFloat(dst[:0], bm.float, bm.fmt, bm.prec, bm.bitSize)
            }
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每次调用 Run 方法创建一个单独的基准测试。调用 Run 方法的闭包的基准测试函数只允许一次且不被测量。&lt;/p&gt;

&lt;p&gt;新代码行数更多，但是更易维护，更易读，且与测试常用的表驱动方法是一致的。此外，现在可以在运行时共享设置代码，同时不再需要重置计时器。&lt;/p&gt;

&lt;h2 id=&#34;使用子测试的表驱动测试&#34;&gt;使用子测试的表驱动测试&lt;/h2&gt;

&lt;p&gt;Go1.7 也引入了用于创建子测试的 Run 方法。这个测试是使用子测试对之前的例子重新的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTime(t *testing.T) {
    testCases := []struct {
        gmt  string
        loc  string
        want string
    }{
        {&amp;quot;12:31&amp;quot;, &amp;quot;Europe/Zuri&amp;quot;, &amp;quot;13:31&amp;quot;},
        {&amp;quot;12:31&amp;quot;, &amp;quot;America/New_York&amp;quot;, &amp;quot;7:31&amp;quot;},
        {&amp;quot;08:08&amp;quot;, &amp;quot;Australia/Sydney&amp;quot;, &amp;quot;18:08&amp;quot;},
    }
    for _, tc := range testCases {
        t.Run(fmt.Sprintf(&amp;quot;%s in %s&amp;quot;, tc.gmt, tc.loc), func(t *testing.T) {
            loc, err := time.LoadLocation(tc.loc)
            if err != nil {
                t.Fatal(&amp;quot;could not load location&amp;quot;)
            }
            gmt, _ := time.Parse(&amp;quot;15:04&amp;quot;, tc.gmt)
            if got := gmt.In(loc).Format(&amp;quot;15:04&amp;quot;); got != tc.want {
                t.Errorf(&amp;quot;got %s; want %s&amp;quot;, got, tc.want)
            }
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一件要注意的事情是两个实现的输出不同。原本的实现打印：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;--- FAIL: TestTime (0.00s)
    time_test.go:62: could not load location &amp;quot;Europe/Zuri&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即使有两个错误，测试执行终止在对 Fatalf 的调用，且第二个测试永远不会运行。&lt;/p&gt;

&lt;p&gt;使用 Run 的实现打印两个错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)
        time_test.go:84: could not load location
    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)
        time_test.go:88: got 07:31; want 7:31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fatal 及其同属函数导致子测试被跳过，但是不会跳过父测试或后续的子测试。&lt;/p&gt;

&lt;p&gt;另外一件要注意的事情是新版本中的错误信息更短。因为子测试的名字唯一标识了一个子测试，因此不再需要在错误信息内部识别该测试。&lt;/p&gt;

&lt;p&gt;使用子测试或子基准测试还有其他的益处，下面的部分会阐明。&lt;/p&gt;

&lt;h2 id=&#34;运行指定的测试或基准测试&#34;&gt;运行指定的测试或基准测试&lt;/h2&gt;

&lt;p&gt;子测试和子基准测试可以在命令行使用 &lt;a href=&#34;../command/test_flag.md&#34;&gt;&lt;code&gt;-run 或 -bench 标识&lt;/code&gt;&lt;/a&gt;选择。两个标识都接收一个斜线分隔的正则表达式列表，匹配了子测试或子基准测试的完整名字的对应部分。&lt;/p&gt;

&lt;p&gt;子测试或子基准测试的完整名字是一个斜线分隔的列表，包括自身的名字以及所有父测试的名字，从顶层测试开始。名字是顶层测试和基准测试对应的名字，且第一个参数必须是 Run。为了避免显示和解析问题，名字使用下划线替换空格，且忽视不可打印字符。相同的处理适用于传递给 -run 或 -bench 表示的正则表达式。&lt;/p&gt;

&lt;p&gt;一些例子：&lt;/p&gt;

&lt;p&gt;使用欧洲时区运行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go test -run=TestTime/&amp;quot;in Europe&amp;quot;
--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)
        time_test.go:85: could not load location
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只运行时间在午后的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -run=Time/12:[0-9] -v
=== RUN   TestTime
=== RUN   TestTime/12:31_in_Europe/Zuri
=== RUN   TestTime/12:31_in_America/New_York
--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)
        time_test.go:85: could not load location
    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)
        time_test.go:89: got 07:31; want 7:31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能有点奇怪，使用 -run=TestTime/NewYork 没有匹配任何测试。这是因为出现在位置名字的斜线被当做一个分割符。反之使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go test -run=TestTime//New_York
--- FAIL: TestTime (0.00s)
    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)
        time_test.go:88: got 07:31; want 7:31
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意传递给 -run 的字符串中的 //。时区名字 America/New_York 中的 / 被当做是来自子测试的一个分隔符处理。第一个正则表达式模式 (TestTime) 匹配顶层测试。第二个正则表达式(空字符串)匹配所有，这种情况匹配时间和位置的大洲部。第三部分正则表达式(New_york)匹配位置的城市部分。&lt;/p&gt;

&lt;p&gt;把名字中的斜线当做分隔符允许用户重构测试的层次结构，而不用修改名字。它也简化了避免规则。如果这暴露一个问题的话，用户应该避免名字中的斜线，比如使用下划线替代。&lt;/p&gt;

&lt;p&gt;一个唯一的序列号被增加到不唯一的测试名字末尾。因此如果子测试没有明显的名字结构，可以只传递一个空字符串给 Run，且子测试可以简单地通过序列号识别。&lt;/p&gt;

&lt;h2 id=&#34;设置和清理&#34;&gt;设置和清理&lt;/h2&gt;

&lt;p&gt;子测试和自己准测试可用于管理公共的设置和清理代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestFoo(t *testing.T) {
    // &amp;lt;setup code&amp;gt;
    t.Run(&amp;quot;A=1&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;A=2&amp;quot;, func(t *testing.T) { ... })
    t.Run(&amp;quot;B=1&amp;quot;, func(t *testing.T) {
        if !test(foo{B:1}) {
            t.Fail()
        }
    })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果任一闭包的子测试运行，设置和清理代码会被允许且最多只运行一次。即使任何子测试调用 Skip、FAIL 或 Fatal 也适用。&lt;/p&gt;

&lt;h2 id=&#34;并行控制&#34;&gt;并行控制&lt;/h2&gt;

&lt;p&gt;子测试支持细粒度控制并行，为了理解如何用这种方式使用子测试，理解并行测试的语法是重要的。&lt;/p&gt;

&lt;p&gt;每个子测试和一个测试函数相关。如果一个测试的测试函数在其 testing.T 实例中调用 Parallel 方法，那么这个测试被称为并行测试。一个并行测试不会和一个顺序测试并发运行，且并行测试的执行被中止直到调用它的测试方法，即父测试返回。-parallel 标识定义了可以并行运行的并行测试的最大数目。&lt;/p&gt;

&lt;p&gt;一个测试会阻塞直到它的测试函数返回且它所有的子测试结束。这意味着顺序测试运行的并行测试会在任何其他一连串的顺序测试运行之前完成。&lt;/p&gt;

&lt;p&gt;这种行为对使用 Run 创建的测试和顶层测试是一样的。事实上，在底层，顶层测试被实现为一个隐藏的主测试的子测试。&lt;/p&gt;

&lt;h2 id=&#34;并行运行一组测试&#34;&gt;并行运行一组测试&lt;/h2&gt;

&lt;p&gt;上述语义支持并行运行一组测试，这组测试内部是并行的，但不与其他并行测试并行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestGroupedParallel(t *testing.T) {
    for _, tc := range testCases {
        tc := tc // capture range variable
        t.Run(tc.Name, func(t *testing.T) {
            t.Parallel()
            if got := foo(tc.in); got != tc.out {
                t.Errorf(&amp;quot;got %v; want %v&amp;quot;, got, tc.out)
            }
            ...
        })
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;外部测试一直到所有通过 Run 启动的并行测试完成之后才会结束。因此，不会有其他并行测试可以和这些并行测试并行运行。&lt;/p&gt;

&lt;p&gt;注意我们需要捕获 range 变量以确保 tc 与正确的实例绑定。&lt;/p&gt;

&lt;h2 id=&#34;一组并行测试之后的清理&#34;&gt;一组并行测试之后的清理&lt;/h2&gt;

&lt;p&gt;在上述例子中，我们在开始其他测试之前使用语义等待一组并行测试结束。相同的技术可用于在一组共享公共资源的并行测试之后清理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestTeardownParallel(t *testing.T) {
    // &amp;lt;setup code&amp;gt;
    // This Run will not return until its parallel subtests complete.
    t.Run(&amp;quot;group&amp;quot;, func(t *testing.T) {
        t.Run(&amp;quot;Test1&amp;quot;, parallelTest1)
        t.Run(&amp;quot;Test2&amp;quot;, parallelTest2)
        t.Run(&amp;quot;Test3&amp;quot;, parallelTest3)
    })
    // &amp;lt;tear-down code&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等待一组并行测试的行为和之前的例子是相同的。&lt;/p&gt;

&lt;h2 id=&#34;结论&#34;&gt;结论&lt;/h2&gt;

&lt;p&gt;Go1.7 对子测试和子基准测试的增加允许你用正常的方式编写结构化的测试和基准测试，可以优雅的融入现有的工具。一种思考方式是 testing 包之前的版本有 1 层结构：包级别的测试被组织为一个单独的测试和基准测试的集合。现在这种组织可以递归扩展到这些单独的测试和基准测试。事实上，在实现中，顶层测试和基准测试被作为一个隐藏的主测试和基准测试的子测试和基准测试：这种处理在每一层都是相同的。&lt;/p&gt;

&lt;p&gt;对于测试来说，定义这种结构的能力使能细粒度执行指定的测试用例、共享设置和清理，以及更好地控制测试并行。我们很高兴看到人们发现其他用途。享受它！&lt;/p&gt;

&lt;h2 id=&#34;相关文章&#34;&gt;相关文章&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;examples.md&#34; target=&#34;_blank&#34;&gt;Go 可测试的示例函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;cover.md&#34; target=&#34;_blank&#34;&gt;关于覆盖的故事&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>创建一个 master playlist</title>
      <link>https://xueqing.github.io/translation/hls/creating_a_master_playlist/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/hls/creating_a_master_playlist/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://developer.apple.com/documentation/http_live_streaming/example_playlists_for_http_live_streaming/creating_a_master_playlist&#34; target=&#34;_blank&#34;&gt;原文&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;

&lt;p&gt;master playlist 描述了对于你的内容所有可访问的 variant(变体)。每个 variant 是一个特定比特率的流版本且被包含在一个单独的 playlist。客户端基于测量的网络比特率切换到最合适的 variant。调节客户端的播放器最小化回放的停顿，以便给用户进坑好的流体验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://xueqing.github.io/translation/hls/images/hls_master_playlist.png&#34; alt=&#34;hls master playlist&#34; /&gt;&lt;/p&gt;

&lt;p&gt;master playlist 不能重复读。一旦客户端读到 master playlist，它假定 variant 集合不会改变。当客户端在其中一个单一的 variant playlist 中看到 EXT-X-ENDLIST 标记时流结束。&lt;/p&gt;

&lt;h2 id=&#34;示例&#34;&gt;示例&lt;/h2&gt;

&lt;p&gt;下面的示例展示了定义不同 variant 的一个 master playlist：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-m3u8&#34;&gt;#EXTM3U
#EXT-X-STREAM-INF:BANDWIDTH=150000,RESOLUTION=416x234,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/low/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=240000,RESOLUTION=416x234,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/lo_mid/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=440000,RESOLUTION=416x234,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/hi_mid/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=640000,RESOLUTION=640x360,CODECS=&amp;quot;avc1.42e00a,mp4a.40.2&amp;quot;
http://example.com/high/index.m3u8
#EXT-X-STREAM-INF:BANDWIDTH=64000,CODECS=&amp;quot;mp4a.40.5&amp;quot;
http://example.com/audio/index.m3u8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;master playlist 示例中使用的标记有：&lt;/p&gt;

&lt;h3 id=&#34;extm3u&#34;&gt;EXTM3U&lt;/h3&gt;

&lt;p&gt;表明这个 playlist 是 一个扩展的 M3U 文件。这种文件类型通过修改第一行标记为 EXTM3U 以区别于基本的 M3U 文件。所有的 HLS playlist 必须以这个标记开始。&lt;/p&gt;

&lt;h3 id=&#34;ext-x-stream-inf&#34;&gt;EXT-X-STREAM-INF&lt;/h3&gt;

&lt;p&gt;表示 playlist 文件的下一个 URL 标识了另一个 playlist 文件。EXT-X-STREAM-INF 标记包含下面的参数：&lt;/p&gt;

&lt;h4 id=&#34;average-bandwidth&#34;&gt;AVERAGE-BANDWIDTH&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)一个整数，表示这个 variant 流的平均比特率。&lt;/p&gt;

&lt;h4 id=&#34;bandwidth&#34;&gt;BANDWIDTH&lt;/h4&gt;

&lt;p&gt;(必选)一个证书，表示对于每个媒体文件所有比特率的上限，单位是 比特/秒。上限值的计算包含了所有出现或将会出现在 playlist 中的容器负载。&lt;/p&gt;

&lt;h4 id=&#34;frame-rate&#34;&gt;FRAME-RATE&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)一个浮点值，描述了一个 variant 流的最大帧率。&lt;/p&gt;

&lt;h4 id=&#34;hdcp-level&#34;&gt;HDCP-LEVEL&lt;/h4&gt;

&lt;p&gt;(可选)表明使用的加密类型。有效值是 TYPE-0 和 NONE。如果只有使用 HDCP 保护输出才能播放这个流，使用 TYPE-0。&lt;/p&gt;

&lt;h4 id=&#34;resolution&#34;&gt;RESOLUTION&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)这个选项展示了播放 playlist 所有视频的大小，单位是像素。所有包含视频的流都应该包含这个参数。&lt;/p&gt;

&lt;h4 id=&#34;video-range&#34;&gt;VIDEO-RANGE&lt;/h4&gt;

&lt;p&gt;(视编码而定)一个字符串，有效值是 SDR 或 PQ。如果没有指定传输特征编码 1, 16 或 18，那么必须忽视这个参数。&lt;/p&gt;

&lt;h4 id=&#34;codecs&#34;&gt;CODECS&lt;/h4&gt;

&lt;p&gt;(可选，但是建议使用)一个引用字符串，包含了一个逗号分隔的格式列表，其中每个格式指定了出现在 playlist 中的一个媒体片段的媒体采样类型。有效的格式标识是根据 RFC 6381 定义的 ISO 文件格式命名空间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：虽然 CODECS 参数可选，每个 EXT-X-STREAM-INF 标记应该包含这个属性。这个属性提供了解码一个特定流所需的完整编码。它支持客户端区分只包含音频的 variant 和包含音频及视频的 variant。然后，客户端可以利用这个信息在切换流的时候提供更好的用户体验。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>如何编写 Go 代码</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/code/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%a3%e7%a0%81%e7%bb%84%e7%bb%87&#34;&gt;代码组织&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a6%82%e8%a7%88&#34;&gt;概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b7%a5%e4%bd%9c%e5%8c%ba&#34;&gt;工作区&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gopath-%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f&#34;&gt;GOPATH 环境变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84&#34;&gt;导入路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ac%ac%e4%b8%80%e4%b8%aa%e7%a8%8b%e5%ba%8f&#34;&gt;第一个程序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%ba%93&#34;&gt;第一个库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e5%90%8d&#34;&gt;包名&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b5%8b%e8%af%95&#34;&gt;测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%9c%e7%a8%8b%e5%8c%85&#34;&gt;远程包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%8b%e4%b8%80%e6%ad%a5&#34;&gt;下一步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%8e%b7%e5%8f%96%e5%b8%ae%e5%8a%a9&#34;&gt;获取帮助&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/code.html&#34; target=&#34;_blank&#34;&gt;Golang 官网文档&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;此文档演示一个简单的 Go 包的发展，并介绍 &lt;a href=&#34;../command/README.md&#34;&gt;&lt;code&gt;go 工具&lt;/code&gt;&lt;/a&gt;。go 工具是拉取、编译和安装 Go 包和目录的标准方式。&lt;/p&gt;

&lt;p&gt;go 工具要求你按照指定方式组织你的代码。请仔细阅读此文档。它解释了使用 Go 安装组织和运行的最简单的方式。&lt;/p&gt;

&lt;p&gt;一个类似的解释可参考&lt;a href=&#34;https://www.youtube.com/watch?v=XCsL89YtqCs&#34; target=&#34;_blank&#34;&gt;编写、编译、安装和测试 Go 代码&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;代码组织&#34;&gt;代码组织&lt;/h2&gt;

&lt;h3 id=&#34;概览&#34;&gt;概览&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Go 开发人员通常保存他们所有的 Go 代码在一个单一的工作区。&lt;/li&gt;
&lt;li&gt;一个工作区包含很多版本控制仓库(比如使用 Git 管理)。&lt;/li&gt;
&lt;li&gt;每个仓库包含一个或多个包。&lt;/li&gt;
&lt;li&gt;每个包由同一目录的一个或多个 Go 源文件组成。&lt;/li&gt;
&lt;li&gt;包目录的路径确定了导入路径。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注意这个其他编程环境不同。其他编程环境的每个工程有一个单独的工作区，且工作区和版本控制仓库紧密相关。&lt;/p&gt;

&lt;h3 id=&#34;工作区&#34;&gt;工作区&lt;/h3&gt;

&lt;p&gt;一个工作区是一个目录层次架构，在其根有两个目录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;src 包含 Go 源文件，且&lt;/li&gt;
&lt;li&gt;bin 包含可执行命令。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;go 工具编译和安装二进制到 bin 目录。&lt;/p&gt;

&lt;p&gt;src 子目录通常包含多个版本控制仓库(比如 Git 或 Mercurial)，跟踪了一个或多个源包的发展。&lt;/p&gt;

&lt;p&gt;为了让你理解一个工作区实际上的组织，这里有一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;bin/
  hello                      # command executable
  outyet                     # command executable
src/
  github.com/golang/example/
    .git/                    # Git repository metadata
    hello/
      hello.go               # command source
    outyet/
      main.go                # command source
      main_test.go           # test source
    stringutil/
      reverse.go             # package source
      reverse_test.go        # test source
  golang.org/x/image/
    .git/                    # Git repository metadata
    bmp/
      reader.go              # package source
      writer.go              # package source
  ... (many more repositories and packages omitted) ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述树显示一个工作区有两个仓库(example 和 image)。example 仓库包含两个命令(hello 和 outyet)和一个库(stringutil)。image 仓库包含 bmp 包和&lt;a href=&#34;https://godoc.org/golang.org/x/image&#34; target=&#34;_blank&#34;&gt;其他的包&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个普通的工作区包含许多源仓库，这些仓库包含一些包和命令。大多数 Go 开发人员保存他们所有的 Go 源代码和依赖在一个单一的工作区。&lt;/p&gt;

&lt;p&gt;注意不应使用符号链接链接文件或目录到你的工作区。&lt;/p&gt;

&lt;p&gt;命令和库由不同的源包编译。我们之后会讨论&lt;a href=&#34;#包名&#34;&gt;区别&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;gopath-环境变量&#34;&gt;GOPATH 环境变量&lt;/h3&gt;

&lt;p&gt;GOPATH 环境变量指定你的工作区位置。默认是你的主目录下名字为 go 的目录，因此在 Unix 上是 $HOME/go，Plan9 上是 $home/go，Windows 上是 %USERPROFILE%\go (通常是 C:\Users\YourName\go)。&lt;/p&gt;

&lt;p&gt;如果你想要在不同的位置工作，你需要&lt;a href=&#34;../wiki/set_gopath.md&#34;&gt;设置 GOPATH&lt;/a&gt; 到那个目录。(另外一个常用的设置是设置 GOPATH=$HOME)。注意 GOPATH 一定不能和你的 Go 安装路径相同。&lt;/p&gt;

&lt;p&gt;命令 &lt;code&gt;go env GOPATH&lt;/code&gt; 打印当前实际的 GOPATH；如果该环境变量没有设置，它会打印默认的位置。&lt;/p&gt;

&lt;p&gt;方便起见，增加工作区的 bin 子目录到你的 PATH：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export PATH=$PATH:$(go env GOPATH)/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简洁起见，这个脚本在文档的其他部分使用 $GOPATH 而不是 $(go env GOPATH)。如果你还未设置 GOPATH，为了使得所写的脚本可运行，可以使用 $HOME/go 替换这些命令或者运行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GOPATH=$(go env GOPATH)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要了解更多关于 GOPATH 环境变量，参考 &lt;a href=&#34;../command/gopath_env_var.md&#34;&gt;&lt;code&gt;go help gopath&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要使用自定义的工作区位置，&lt;a href=&#34;../wiki/set_gopath.md&#34;&gt;设置 GOPATH 环境变量&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;导入路径&#34;&gt;导入路径&lt;/h3&gt;

&lt;p&gt;导入路径是一个唯一的标识一个包的字符串。一个包的导入路径对应它在工作区或远程仓库内的位置(下面会解释)。&lt;/p&gt;

&lt;p&gt;标准库的包使用短的导入路径类似 “fmt” 和 “net/http”。对于你自己的包，你必须选择一个基础路径，该路径不太可能与将来增加的标准库或其他外部库冲突。&lt;/p&gt;

&lt;p&gt;如果你将代码保存在其他地方的源仓库，那么你应该使用该源码库的根作为你的基础路径。比如，如果你有一个 Github 账户位于 github.com/user，那么 github.com/user 应该是你的基础路径。&lt;/p&gt;

&lt;p&gt;注意在你可以编译代码之前，你不需要发布你的代码到一个远程仓库。这只是一个组织代码的好习惯以便某天你会发布它。实际上你可以选择任意的路径名字，只要它对于标准库和更大的 Go 生态系统是唯一的。&lt;/p&gt;

&lt;p&gt;我们将会使用 github.com/user 作为我们的基础路径。在你的工作区内新建一个目录来保存源码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir -p $GOPATH/src/github.com/user
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;第一个程序&#34;&gt;第一个程序&lt;/h3&gt;

&lt;p&gt;为了编译和运行一个简单的程序，首先选择一个包路径(我们将会使用 github.com/user/hello)，并且在你的工作区内创建一个对应的包目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir $GOPATH/src/github.com/user/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，在目录内部创建一个名为 hello.go 的文件，包含下面的 Go 代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
  fmt.Println(&amp;quot;Hello, world.&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你可以使用 go 工具编译和安装这个程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go install github.com/user/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意你可以在你的系统任何地方运行这个命令。go 工具通过在 GOPATH 指定的工作区内查找 github.com/user/hello 包找到源码。&lt;/p&gt;

&lt;p&gt;如果你从包目录运行 &lt;code&gt;go install&lt;/code&gt;，你也可以忽视包路径：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd $GOPATH/src/github.com/user/hello
go install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个命令编译 hello 命令，生成可执行的二进制文件。它接着安装该二进制文件到工作区的 bin 目录，安装的文件名字是 hello(或者在 Windows 上是 hello.exe)。在我们的例子中，该文件将会是 $GOPATH/bin/hello，也就是 $HOME/go/bin/hello。&lt;/p&gt;

&lt;p&gt;发生错误时，go 工具只会打印输出。因此如果这些命令没有生成输出，那么这些命令已经被正确执行。&lt;/p&gt;

&lt;p&gt;你现在可以通过在命令行输入程序的完整路径来运行它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ $GOPATH/bin/hello
Hello, world.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者，因为你已经添加 $GOPATH/bin 到你的 PATH，只需要输入二进制文件的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hello
Hello, world.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你在使用一个源码控制系统，现在将是一个好的时机来初始化一个仓库，增加这些文件，并提交你的第一次修改。重申一次，这一步是可选的：你不必使用源码控制来写 Go 代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd $GOPATH/src/github.com/user/hello
git init
git add hello.go
git commit -m &amp;quot;initial commit&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推送代码到远程仓库留作读者的一个练习。&lt;/p&gt;

&lt;h3 id=&#34;第一个库&#34;&gt;第一个库&lt;/h3&gt;

&lt;p&gt;让我们编写一个库，并在 hello 程序使用它。&lt;/p&gt;

&lt;p&gt;重申一次，第一步是选择一个包路径(我们将会使用 github.com/user/stringutil)并创建一个包目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mkdir $GOPATH/src/github.com/user/stringutil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来，在该目录创建一个名为 reverse.go 的文件，包含下面的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Package stringutil contains utility functions for working with strings.
package stringutil

// Reverse returns its argument string reversed rune-wise left to right.
func Reverse(s string) string {
  r := []rune(s)
  for i, j := 0, len(r)-1; i &amp;lt; len(r)/2; i, j = i+1, j-1 {
    r[i], r[j] = r[j], r[i]
  }
  return string(r)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，使用 &lt;code&gt;go build&lt;/code&gt; 编译测试这个包：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build github.com/user/stringutil
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者，如果你正在包的源目录，只需要：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这不会生成一个输出文件。反之，它将编译的包保存在本地的编译缓存。&lt;/p&gt;

&lt;p&gt;在确认编译 stringutil 包之后，修改你原始的 hello.go(在 $GOPATH/src/github.com/user/hello)，使用下面的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
  &amp;quot;fmt&amp;quot;

  &amp;quot;github.com/user/stringutil&amp;quot;
)

func main() {
  fmt.Println(stringutil.Reverse(&amp;quot;!oG ,olleH&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装 hello 程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go install github.com/user/hello
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行这个程序的新版本，你应该看到一个新的、翻转的消息：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ hello
Hello, Go!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述步骤之后，你的工作区应该看起来是下面的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;bin/
  hello                 # command executable
src/
  github.com/user/
    hello/
      hello.go      # command source
    stringutil/
      reverse.go    # package source
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;包名&#34;&gt;包名&lt;/h3&gt;

&lt;p&gt;Go 源文件的第一个语句必须是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，name 是用于导入包的默认名字。(包内的所有文件必须使用这个名字。)&lt;/p&gt;

&lt;p&gt;Go 的管理是包名是导入路径的最后一个元素：按照 “crypto/rot13” 导入的包名应该命名为 rot13。&lt;/p&gt;

&lt;p&gt;可执行的命令必须总使用 &lt;code&gt;package main&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;不需要包名在链接所有包成一个单一的二进制文件时是唯一的，只要它的导入路径(完整的文件名)是唯一的。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&#34;effective_go.md#名字&#34; target=&#34;_blank&#34;&gt;实效 Go 编程&lt;/a&gt;了解更多关于 Go 的命名惯例。&lt;/p&gt;

&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;

&lt;p&gt;Go 有一个轻量级的测试框架，由 &lt;code&gt;go test&lt;/code&gt; 命令和 testing 包组成。&lt;/p&gt;

&lt;p&gt;你可以通过新建一个以 _test.go 结尾的文件编写测试，文件包含名字为 TestXXX，签名为 &lt;code&gt;func (t *testing.T)&lt;/code&gt; 的函数。测试框架运行每个像这样的函数；如果函数调用一个失败函数，如 t.Error 或 t.Fail，认为该测试失败。&lt;/p&gt;

&lt;p&gt;向 stringutil 包增加一个测试，新建文件 $GOPATH/src/github.com/user/stringutil/reverse_test.go，包含下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package stringutil

import &amp;quot;testing&amp;quot;

func TestReverse(t *testing.T) {
  cases := []struct {
    in, want string
  }{
    {&amp;quot;Hello, world&amp;quot;, &amp;quot;dlrow ,olleH&amp;quot;},
    {&amp;quot;Hello, 世界&amp;quot;, &amp;quot;界世 ,olleH&amp;quot;},
    {&amp;quot;&amp;quot;, &amp;quot;&amp;quot;},
  }
  for _, c := range cases {
    got := Reverse(c.in)
    if got != c.want {
      t.Errorf(&amp;quot;Reverse(%q) == %q, want %q&amp;quot;, c.in, got, c.want)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后使用 &lt;code&gt;go test&lt;/code&gt; 运行测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go test github.com/user/stringutil
ok    github.com/user/stringutil 0.165s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和平时一样，如果你在包目录运行 go 工具，可以忽视包路径&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ go test
ok    github.com/user/stringutil 0.165s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行 &lt;a href=&#34;../command/test_package.md&#34;&gt;&lt;code&gt;go help test&lt;/code&gt;&lt;/a&gt; 并查看 &lt;a href=&#34;../golangpkg/testing.md&#34;&gt;testing 包文档&lt;/a&gt; 获取更多信息。&lt;/p&gt;

&lt;h2 id=&#34;远程包&#34;&gt;远程包&lt;/h2&gt;

&lt;p&gt;导入路径可以描述如何使用版本控制系统(如 Git 或 Mercurial)获取包源码。go 工具使用这个属性从远程仓库自动拉取代码。比如，文档中描述的例子也保存在 &lt;a href=&#34;https://github.com/golang/example&#34; target=&#34;_blank&#34;&gt;Github&lt;/a&gt; 托管的 Git 仓库。如果你在包的导入路径包含这个仓库的 URL，&lt;code&gt;go get&lt;/code&gt; 会自动拉取、编译和运行它：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go get github.com/golang/example/hello
$GOPATH/bin/hello
# 输出 Hello, Go examples!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果指定的包没有出现在工作区，&lt;code&gt;go get&lt;/code&gt; 会放置在 GOPATH 指定的第一个工作区。(如果包以及存在，&lt;code&gt;go get&lt;/code&gt; 会跳过远程拉取，行为类似于 &lt;code&gt;go install&lt;/code&gt;。)&lt;/p&gt;

&lt;p&gt;在执行上述 &lt;code&gt;go get&lt;/code&gt; 命令只会，工作区目录树应该看起来是下面的结构：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;bin/
    hello                     # command executable
src/
  github.com/golang/example/
    .git/                     # Git repository metadata
    hello/
      hello.go                # command source
    stringutil/
      reverse.go              # package source
      reverse_test.go         # test source
  github.com/user/
    hello/
      hello.go                # command source
    stringutil/
      reverse.go              # package source
      reverse_test.go         # test source
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Github 托管的 hello 命令依赖相同仓库的 stringutil 包。hello.go 文件中的导入使用相同的导入路径惯例，因此 &lt;code&gt;go get&lt;/code&gt; 命令也可以定位和安装依赖依赖包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import &amp;quot;github.com/golang/example/stringutil&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此惯例是使得你的 Go 包被其他人可用的最简单的方式。&lt;a href=&#34;https://github.com/golang/go/wiki/Projects&#34; target=&#34;_blank&#34;&gt;Go 维基&lt;/a&gt; 和 &lt;a href=&#34;https://godoc.org/&#34; target=&#34;_blank&#34;&gt;go 官方文档&lt;/a&gt; 提供了外部 Go 过程的列表。&lt;/p&gt;

&lt;p&gt;要获取更多关于借助 go 工具使用远程仓库的信息，查看&lt;a href=&#34;../command/remote_import_path.md&#34;&gt;远程导入路径&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;下一步&#34;&gt;下一步&lt;/h2&gt;

&lt;p&gt;订阅 &lt;a href=&#34;https://groups.google.com/group/golang-announce&#34; target=&#34;_blank&#34;&gt;golang 宣传&lt;/a&gt; 邮件列表，接受发行新的稳定版本 Go 的通知。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&#34;effective_go.md&#34; target=&#34;_blank&#34;&gt;实效 Go 编程&lt;/a&gt;了解更多关于编写清楚、惯用的 Go 代码的建议。&lt;/p&gt;

&lt;p&gt;访问 &lt;a href=&#34;https://tour.golang.org/&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt; 学习语言规则。&lt;/p&gt;

&lt;p&gt;访问&lt;a href=&#34;README.md#文章&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt;查看关于 Go 语言及其库和工具的全面深入的文章。&lt;/p&gt;

&lt;h2 id=&#34;获取帮助&#34;&gt;获取帮助&lt;/h2&gt;

&lt;p&gt;需要实时帮助，询问有帮助的 gopher ，它位于 &lt;a href=&#34;https://freenode.net/&#34; target=&#34;_blank&#34;&gt;FreeNode&lt;/a&gt; IRC 服务的 #go-nuts。&lt;/p&gt;

&lt;p&gt;关于 Go 语言讨论的官方邮件列表在 &lt;a href=&#34;https://groups.google.com/group/golang-nuts&#34; target=&#34;_blank&#34;&gt;Go Nuts&lt;/a&gt; 群组。&lt;/p&gt;

&lt;p&gt;使用 &lt;a href=&#34;https://github.com/golang/go/issues&#34; target=&#34;_blank&#34;&gt;Go issue 跟踪&lt;/a&gt;报告错误。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>学习测试</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/learn_testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/learn_testing/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%86%85%e5%ae%b9&#34;&gt;内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki/LearnTesting&#34; target=&#34;_blank&#34;&gt;Go 维基官网——学习测试&lt;/a&gt;学习。&lt;/p&gt;

&lt;p&gt;原网页由 Evgeny Vereshchagin 在 2019/1/29 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/LearnTesting/_history&#34; target=&#34;_blank&#34;&gt;第 4 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;内容&#34;&gt;内容&lt;/h2&gt;

&lt;p&gt;这个页面链接到关于 Go 测试的资源。&lt;/p&gt;

&lt;ul class=&#34;task-list&#34;&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../golangdoc/code.md&#34;&gt;如何编写 Go 代码&lt;/a&gt;，尤其是&lt;a href=&#34;../golangdoc/code.md#测试&#34;&gt;测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 学习&lt;a href=&#34;../golangpkg/testing.md&#34;&gt;测试包&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../golangdoc/faq.md#为什么-Go-没有断言&#34;&gt;为什么 Go 没有断言&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../golangdoc/faq.md#我最喜欢的测试辅助函数在哪里&#34;&gt;我最喜欢的测试辅助函数在哪里&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 观看&lt;a href=&#34;https://talks.golang.org/2014/testing.slide#1&#34; target=&#34;_blank&#34;&gt;测试技巧&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;table_driven_tests.md&#34; target=&#34;_blank&#34;&gt;表驱动测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;li&gt;&lt;label&gt;&lt;input type=&#34;checkbox&#34; checked disabled class=&#34;task-list-item&#34;&gt; 阅读&lt;a href=&#34;../blog/subtest.md&#34;&gt;使用子测试项目和子基准测试&lt;/a&gt;&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>实效 Go 编程</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/effective_go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/effective_go/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%be%8b%e5%ad%90&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%a0%bc%e5%bc%8f%e5%8c%96&#34;&gt;格式化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%b3%a8%e9%87%8a&#34;&gt;注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%90%8d%e5%ad%97&#34;&gt;名字&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e5%90%8d&#34;&gt;包名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#getter&#34;&gt;getter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a5%e5%8f%a3%e5%90%8d&#34;&gt;接口名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%a9%bc%e5%b3%b0&#34;&gt;驼峰&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%86%e5%8f%b7&#34;&gt;分号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a7%e5%88%b6%e7%bb%93%e6%9e%84&#34;&gt;控制结构&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#if&#34;&gt;if&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e9%87%8d%e6%96%b0%e5%a3%b0%e6%98%8e%e5%92%8c%e9%87%8d%e6%96%b0%e8%b5%8b%e5%80%bc&#34;&gt;重新声明和重新赋值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0&#34;&gt;函数&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%a4%9a%e8%bf%94%e5%9b%9e%e5%80%bc&#34;&gt;多返回值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%91%bd%e5%90%8d%e7%bb%93%e6%9e%9c%e5%8f%82%e6%95%b0&#34;&gt;命名结果参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#defer&#34;&gt;defer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e6%8d%ae&#34;&gt;数据&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-new-%e5%88%86%e9%85%8d&#34;&gt;使用 new 分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e5%a4%8d%e5%90%88%e5%ad%97%e9%9d%a2%e9%87%8f&#34;&gt;构造函数和复合字面量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bd%bf%e7%94%a8-make-%e5%88%86%e9%85%8d&#34;&gt;使用 make 分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%95%b0%e7%bb%84&#34;&gt;数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%87%e7%89%87&#34;&gt;切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%ba%8c%e7%bb%b4%e5%88%87%e7%89%87&#34;&gt;二维切片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%98%a0%e5%b0%84&#34;&gt;映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%89%93%e5%8d%b0&#34;&gt;打印&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%bf%bd%e5%8a%a0&#34;&gt;追加&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96&#34;&gt;初始化&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b8%b8%e6%95%b0&#34;&gt;常数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/effective_go.html&#34; target=&#34;_blank&#34;&gt;Golang 官网文档——Effective Go&lt;/a&gt; 学习。&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;Go 是一门新语言。虽然它从现有语言借鉴了想法，但是它有独特的属性使得实效的 Go 程序和使用其他语言编写的程序特点不同。直接将一个 C++ 或 Java 程序翻译成 Go 不太可能生成令人满意的结果——Java 程序是用 Java 写的，而不是 Go。另一方面，从 Go 的角度思考一个问题可能产生一个成功的但是完全不同的程序。换句话说，要写好 Go，理解它的特性和惯用语是很重要的。而且，了解用 Go 编程已有的惯例，比如命名、格式化、程序结构等等也很重要，以便你编写的程序容易被其他 Go 开发人员理解。&lt;/p&gt;

&lt;p&gt;此文档给出关于编写清晰、惯用的 Go 代码的建议。它增补了&lt;a href=&#34;https://golang.org/ref/spec&#34; target=&#34;_blank&#34;&gt;语言规范&lt;/a&gt;、&lt;a href=&#34;https://tour.golang.org/&#34; target=&#34;_blank&#34;&gt;Go 语言之旅&lt;/a&gt;以及&lt;a href=&#34;code.md&#34; target=&#34;_blank&#34;&gt;如何编写 Go 代码&lt;/a&gt;，所有这些你应该先阅读。&lt;/p&gt;

&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://golang.org/src/&#34; target=&#34;_blank&#34;&gt;Go 包源码&lt;/a&gt;用于作为和核心库，也作为如何使用语言的例子。此外，很多包包含可工作的、自包含的可执行例子，你可以直接从 &lt;a href=&#34;https://golang.org/&#34; target=&#34;_blank&#34;&gt;golang.org&lt;/a&gt; 网站运行，比如&lt;a href=&#34;https://golang.org/pkg/strings/#example_Map&#34; target=&#34;_blank&#34;&gt;这个网站&lt;/a&gt;(如果需要，点击单词 “Example” 打开它)。如果你对于如何处理一个问题或一些东西是如何实现的有疑问，这个库中的文档、代码和例子可以给出答案、思想和背景。&lt;/p&gt;

&lt;h2 id=&#34;格式化&#34;&gt;格式化&lt;/h2&gt;

&lt;p&gt;格式化问题是最有争议却最不重要的。人们可以选择不同的格式风格，但是如果每个人遵循相同的风格，那么人们不需要且可以花费更少的时间在这个问题上是更好的。问题是如何在没有一个长长的风格规范指南的情况下实现这个想法。&lt;/p&gt;

&lt;p&gt;对于 Go，我们使用了一种特别的方法且交由机器注意大多数格式化问题。gofmt 程序(也可以通过 &lt;code&gt;go fmt&lt;/code&gt; 使用，它作用于包级别而不是源文件级别)读入一个 Go 程序并且以标准的风格缩进、垂直对齐、保持或者需要的话重新格式化注释，然后发出源文件。如果你想要知道如何处理一些新的格式场景，运行 gofmt；如果答案看起来不正确，重新组织你的程序(或提出一个 gofmt 的错误)，不要绕过这个问题。&lt;/p&gt;

&lt;p&gt;作为一个例子，不必花时间对结构体的域做注释对齐。gofmt 将会为你做这些。给出一个声明&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    name string // 对象的名字
    value int // 对象的值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;gofmt 会列对齐：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type T struct {
    name    string // 对象的名字
    value   int    // 对象的值
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;标准库中所有的 Go 代码都已经使用 gofmt 格式化过。&lt;/p&gt;

&lt;p&gt;还有一些格式化细节。非常简洁：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;缩进
  我们使用 tab 键缩进，且 gofmt 默认使用 tab 键。只在必要的时候使用空格。
行长度
  Go 没有行长度限制。不要担心溢出穿孔卡片。如果感觉一行太长，包裹它并使用额外的 tab 键缩进
括号
  Go 比 C 和 Java 需要更少的括号：控制结构 (if/for/switch) 的语法没有括号。同时，操作符优先级层次更短更清晰。
  因此不像其他语言， `x&amp;lt;&amp;lt;8 + y&amp;lt;&amp;lt;16` 就是空格暗示的含义。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;注释&#34;&gt;注释&lt;/h2&gt;

&lt;p&gt;Go 提供 C-风格的块注释 /**/ 和 C++-风格的行注释 //。行注释是常态；块注释大多出现在包注释，但是在一个表达式内部或禁用大段代码是有用的。&lt;/p&gt;

&lt;p&gt;godoc 程序，也是 web 服务器，处理 Go 源文件以提取关于包内容的文档。在顶层声明之前出现的注释，中间没有新行，和声明一起提取作为该元素的解释文本。这些注释的本性和风格决定了 godoc 生成的文档的质量。&lt;/p&gt;

&lt;p&gt;每个包应该有一个包注释，即 package 语句之前的一个块注释。对于多文件的包，包注释只需要出现在一个文件，且每个文件都可以看到。包注释应该介绍包并提供和包有关的信息作为一个整体。它会先出现在 godoc 页面，并且应该设置后面的详细文档。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/*
包 regexp 实现了正则表达式的一个简单库。

接收正则表达式的语法是:

    正则表达式:
        连接 { &#39;|&#39; 连接 }
    连接:
        { 闭包 }
    闭包:
        项 [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]
    项:
        &#39;^&#39;
        &#39;$&#39;
        &#39;.&#39;
        字符
        &#39;[&#39; [ &#39;^&#39; ] 字符范围 &#39;]&#39;
        &#39;(&#39; 正则表达式 &#39;)&#39;
*/
package regexp
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是一个简单包，包注释可以是简洁的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 包 path 实现了功能代码，用于操作斜线分隔的文件名路径。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释不需要额外的格式比如一行星号。生成的输出可能不能显式为固定宽度的字体，因此不要依赖空格对齐——godoc 像 gofmt 一样，会注意对齐问题。注释是无解释的普通文本，因此 HTML 和其他的注解，比如 _this_，会逐字重复，不应该使用。godoc 会做的一个调整是按固定宽度的字体显示缩进文本，适用于代码片段。&lt;a href=&#34;../golangpkg/fmt.md&#34;&gt;fmt 包&lt;/a&gt;对包注释的使用恰到好处。&lt;/p&gt;

&lt;p&gt;视上下文而定，godoc 甚至可能不会重新格式化注释，因此确保他们直接看起来是格式好的：使用正确的拼写、标点符号和句子结构，折叠长行等等。&lt;/p&gt;

&lt;p&gt;在包内部，任何紧紧出现在顶层声明之前的注释作为该声明的一个文档注释。程序中每个导出的(大写开头的)名字应该有一个文档注释。&lt;/p&gt;

&lt;p&gt;文档注释最好是完整的句子，允许不同的自动化显示。第一个句子应该是一个总结句，以声明的名字开头。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Compile 解析一个正则表达式，且成功时返回一个可用于匹配文本的 Regexp 对象。
func Compile(str string) (*Regexp, error) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果每个文档注释以描述的元素名字开头，你可以使用 &lt;a href=&#34;../command/README.md&#34;&gt;go&lt;/a&gt; 工具的 &lt;a href=&#34;../command/show_doc.md&#34;&gt;doc&lt;/a&gt; 子命令并通过 grep 运行输出。设想你不能急的 “Compile” 名字但是正在查找正则表达式的解析函数，因此你运行命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go doc -all regexp | grep -i parse
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果包内所有的文档注释以“这个函数……”开头，grep 不会帮助你记得那个名字。但是因为包的每个文档注释以名字开始，你会看到类似下面的内容，这会回忆起你正在寻找的单词。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;$ go doc -all regexp | grep -i parse
    Compile parses a regular expression and returns, if successful, a Regexp
    MustCompile is like Compile but panics if the expression cannot be parsed.
    parsed. It simplifies safe initialization of global variables holding
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go 的声明语法允许分组声明。一个单一的文档注释可以介绍一组相关的常量或变量。因为显示了整个声明，这样的注释通常是敷衍了事的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 解析表达式失败时返回的错误代码。
var (
    ErrInternal      = errors.New(&amp;quot;regexp: internal error&amp;quot;)
    ErrUnmatchedLpar = errors.New(&amp;quot;regexp: unmatched &#39;(&#39;&amp;quot;)
    ErrUnmatchedRpar = errors.New(&amp;quot;regexp: unmatched &#39;)&#39;&amp;quot;)
    ...
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分组也可以指示元素之间的关系，比如被一个所保护的变量集合的事实。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;名字&#34;&gt;名字&lt;/h2&gt;

&lt;p&gt;Go 中的名字和其他语言中的一样重要。它们甚至有语义影响：一个名字在包外的可见性取决于它的第一个字母是否是大写。因此值得花费一些时间讨论 Go 编程中的命名惯例。&lt;/p&gt;

&lt;h3 id=&#34;包名&#34;&gt;包名&lt;/h3&gt;

&lt;p&gt;当导入一个包时，包名成为这些内容的一个访问器。在 &lt;code&gt;import &amp;quot;bytes&amp;quot;&lt;/code&gt; 之后，导入包可以讨论 &lt;code&gt;bytes.buffer&lt;/code&gt;。每个使用该包的人可以使用相同的名字来引用包内容是有帮助的，这意味着包名应该是好的：短、简明、引起共鸣的。按照惯例，包使用小写的、单一单词的名字；不应该需要使用下划线或驼峰。Err 就是简洁的，因为每个人使用你的包都会输入那个名字。并且不予担心与先前的冲突。包名只是导入的默认名字；它不需要在所有源码范围内唯一，并且在极少冲突的情况下，导入包可选择一个不同的名字在局部使用。无论如何，混淆是稀少的，因为这个导入的文件名只决定正在使用的包。&lt;/p&gt;

&lt;p&gt;另外一个惯例是包名是源路径的基础名；在 src/encoding/base64 中的包作为 “encoding/base64” 导入，但名字是 base64，而不是 encoding_base64 或者 encodingBase64。&lt;/p&gt;

&lt;p&gt;包的导入者将会使用包名来引用它的内容，因此包中导出的名字可使用这个事实来避免停顿。(不要使用 &lt;code&gt;import .&lt;/code&gt; 符号，这可以简化必须在被测试包之外的测试，但应该被避免。)比如， bufio 包中的带缓冲的 reader 类型叫做 Reader，而不是 BufReader，因为使用者看到的是 bufio.Reader，这是一个更加清晰简洁的名字。此外，因为导入的实体总是用包名处理，bufio.Reader 和 io.Reader 不会冲突。类似的，生成 ring.Ring 实例的函数——这是 Go 中构造函数的定义——通常会使用 NewRing 调用，但是因为 Ring 是这个包导出的唯一类型，且这个包叫做 ring，这个函数只用 New 调用，这个包的使用者看到的是 ring.New。使用包结构来帮助你选择好名字。&lt;/p&gt;

&lt;p&gt;另外一个简单的例子是 once.Do；once.Do(setup) 读着不错，并且不会被写做 once.DoOrWaitUntilDone(setup) 而有改善。长名字不会自动使得东西更易读。一个有用的文档注释通常比一个特别长的名字更有价值。&lt;/p&gt;

&lt;h3 id=&#34;getter&#34;&gt;getter&lt;/h3&gt;

&lt;p&gt;Go 不提供对 getter 和 setter 的自动支持。自己提供 getter 和 setter 是没有问题的，且通常这样做事合适的。但是将 Get 放在 getter 名字中既不是惯例也非必要的。如果你有一个域叫 owner(小写的，不导出)，它的 getter 方法应叫做 Owner(大写，导出的)，而不是 GetOwner。使用大写名字导出可以区分域名和方法名。如果有必要，一个 setter 方法可能叫做 SetOwner。两个名字实际上也是易读的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;owner := obj.Owner()
if owner != user {
  obj.SetOwner(user)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;接口名&#34;&gt;接口名&lt;/h3&gt;

&lt;p&gt;按照惯例，一个方法的接口用方法名和一个 -er 后缀或类似的修改器命名，用以构造一个代理名词：Reader，Writer，Formatter，CloseNotifier 等。&lt;/p&gt;

&lt;p&gt;有许多类似的名字，且尊重这些名字及其捕获的函数名是富有成效的，Read，Write，Close，Flush，String 等等有规范的签名和含义。为了避免混淆，除非方法具有相同的签名和含义，不要使用上述这些名字给方法命名。相反地，如果你的类型实现的方法与一个熟悉的类型的方法有相同的含义，使用这个相同的名字和签名；将你的字符串转换方法命名为 String 而不是 ToString。&lt;/p&gt;

&lt;h3 id=&#34;驼峰&#34;&gt;驼峰&lt;/h3&gt;

&lt;p&gt;最后，Go 的惯例是使用 MixedCaps 或 mixedCaps 而不是下划线来写多单词的名字。&lt;/p&gt;

&lt;h2 id=&#34;分号&#34;&gt;分号&lt;/h2&gt;

&lt;p&gt;类似 C，Go 规范的语法使用分号来终止一个语句，但是和 C 不同的是，这些分号不会出现在源文件。反之，词法分析器使用一个简单的规则在扫描时自动插入分号，因此输入文本可免除大部分分号。&lt;/p&gt;

&lt;p&gt;规则如下。如果新行之前的最后一个符号是一个标识符(包括像 int 和 float64 的单词)，一个基本字面量，比如一个数字、字符串常量，或者下面的一个符号&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;break continue fallthrough return ++ -- ) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;词法分析器总是在这个符号之后插入一个分号。这可以概括为，“如果在一个可以结束一句话的符号之后有一个新行，插入一个分号”。&lt;/p&gt;

&lt;p&gt;紧挨着在一个右大括号之前出现的分号也可以忽略，因此一个类似下面的语句不需要分号：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go func() {for { dts &amp;lt;- &amp;lt;- src }} ()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;习惯上，Go 程序只在类似于 for 循环子句中有分号，用于分隔初始化、条件和连续元素。如果你在一行中写多个语句，也需要分号来分隔语句。&lt;/p&gt;

&lt;p&gt;插入分号规则的一个结果是你不能将一个控制结构(if/for/switch/select)的左大括号放在下一行。如果你这样做，会在一个大括号之前插入分号，这会导致不想出现的影响。像这样编写代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if i &amp;lt; f() {
    g()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不要像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if i &amp;lt; f()  // 错误!
{           // 错误!
    g()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;控制结构&#34;&gt;控制结构&lt;/h2&gt;

&lt;p&gt;Go 的控制结构和 C 的控制结构相关，但是很不相同。Go 没有 do 或 while 循环，只有一个稍微普遍的 for；switch 更加灵活；if 和 switch 接受一个可选的类似 for 中的初始化语句；break 和 continue 语句使用一个可选的标签来识别从哪里跳出或继续循环；Go 也有新的控制结构，包括 type switch 和多向通讯复用器 select。语法也有一点不同：Go 没有小括号，且控制结构体必须使用大括号分隔。&lt;/p&gt;

&lt;h3 id=&#34;if&#34;&gt;if&lt;/h3&gt;

&lt;p&gt;在 Go 中，一个简单的 if 看起来像这样：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if x &amp;gt; 0 {
    return y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;强制的大括号鼓励将一个简单的 if 语句分为多行。无论如何，这样编写是一个好的风格，尤其是当代码体包含一个控制语句，比如 return 或 break。&lt;/p&gt;

&lt;p&gt;因为 if 和 switch 接受一个初始化语句，常见的是用于设置一个局部变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Go 的库中，你会发现当一个 if 没有流入下一句——即代码体以 break、continue、goto 或 return 结束——会忽略不需要的 else。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个常见情形的例子，即代码必须防止一系列错误条件。如果成功的控制流沿着页面向下，而错误出现的时候消除它们时，代码阅读体验更好。因为错误情况倾向于以 return 语句结束，生成的diamante不需要 else 语句。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;重新声明和重新赋值&#34;&gt;重新声明和重新赋值&lt;/h3&gt;

&lt;h2 id=&#34;函数&#34;&gt;函数&lt;/h2&gt;

&lt;h3 id=&#34;多返回值&#34;&gt;多返回值&lt;/h3&gt;

&lt;p&gt;Go 其中一个非凡的特性时函数和方法可以返回多个值。这个性质可用于改善 C 程序中的一些笨拙的写法：in-band 错误返回类似 -1 的值表示错误码并修改通过地址传递的参数。&lt;/p&gt;

&lt;p&gt;在 C 语言，使用一个负的计数器标记一个写入错误，且错误码隐藏在一个不固定位置。在 Go 语言，&lt;code&gt;Write&lt;/code&gt; 可以返回一个计数器和一个错误：“是的，你写了一部分但非全部的字节，因为你已经填满了设备”。&lt;code&gt;os&lt;/code&gt; 包中作用于文件的 &lt;code&gt;Write&lt;/code&gt; 方法签名：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func (file *File) Write(b []byte) (n int, err error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;且如文档所说，当 n 不等于 b 时这个方法返回写入的字节数和一个非空的错误。这是常见的风格；查看错误处理部分获得更多例子。&lt;/p&gt;

&lt;p&gt;一个类似的方法不需要传递一个指针给返回值来模拟一个引用参数。下面是一个简单的函数，从一个字节切片的某个位置起捕获一个数字，返回该数字和下一个位置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func nextInt(b []byte, i int) (int, int) {
    for ; i &amp;lt; len(b) &amp;amp;&amp;amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &amp;lt; len(b) &amp;amp;&amp;amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - &#39;0&#39;
    }
    return x, i
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可以使用这个方法像下面这样来扫描一个输入切片 &lt;code&gt;b&lt;/code&gt; 的数字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; len(b); {
    x, i = nextInt(b, i)
    fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;命名结果参数&#34;&gt;命名结果参数&lt;/h3&gt;

&lt;p&gt;Go 函数的返回或结果“参数”可以指定名字并作为普通变量使用，就像使用传入参数。当函数开始时，命名的参数被初始化对应类型的零值；如果函数执行一个不带参数的 &lt;code&gt;return&lt;/code&gt; 语句，返回参数的当前值被作为返回值。&lt;/p&gt;

&lt;p&gt;名字不是必须的，但是名字可以使得代码更加简短清晰：名字即是文档。如果我们将 &lt;code&gt;nextInt&lt;/code&gt; 的结果命名，很显然返回的 &lt;code&gt;int&lt;/code&gt; 含义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func nextInt(b []byte, pos int) (value, nextPos int) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为命名的结果会被初始化且绑定在一个简单的 &lt;code&gt;return&lt;/code&gt;，它们可以既简单又清晰。下面是 &lt;code&gt;oi.ReadFull&lt;/code&gt; 使用命名结果良好的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &amp;gt; 0 &amp;amp;&amp;amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;defer&#34;&gt;defer&lt;/h3&gt;

&lt;p&gt;Go 的 &lt;code&gt;defer&lt;/code&gt; 语句安排执行 &lt;code&gt;defer&lt;/code&gt; 的函数返回之前立即运行一个函数调用(即推迟的函数)。这是一个处理一些场景特别而高效的方式，比如无论函数使用哪条路径返回都必须释放的资源。经典的例子是解锁一个互斥锁或关闭一个文件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Contents 将文件内容作为字符串返回。
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return &amp;quot;&amp;quot;, err
    }
    defer f.Close()  // 函数结束时会运行 f.Close。

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // 后面会讨论 append。
        if err != nil {
            if err == io.EOF {
                break
            }
            return &amp;quot;&amp;quot;, err  // 如果在这里返回，会关闭 f。
        }
    }
    return string(result), nil // 如果在这里返回，会关闭 f。
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推迟一个类似于 &lt;code&gt;Close&lt;/code&gt; 的函数调用有两个优点。其一，它保证你永远不会忘记关闭一个文件，如果你之后编辑这个函数增加一个新的返回路径，这是很容易犯的一个错误。其二，它意味着关闭挨着打开操作，这比放在函数末尾更加清晰。&lt;/p&gt;

&lt;p&gt;推迟的函数参数(当函数是一个方法时还包括接收者)在执行 &lt;code&gt;defer&lt;/code&gt; 时计算值，而不是执行调用时计算。除了避免担心在函数执行时修改变量值，这还意味着一个单一的推迟调用可以推迟多个函数执行。这里有一个丑陋的示例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; 5; i++ {
    defer fmt.Printf(&amp;quot;%d &amp;quot;, i)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;推迟的函数按照 LIFO (后进先出)的顺序执行，因此上述代码函数返回时，会打印“ 4 3 2 1 0”。一个更加合乎情理的例子是使用一个简单的方式来跟踪程序的函数执行。我们可以写一些像这样的简单的跟踪代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func trace(s string)   { fmt.Println(&amp;quot;entering:&amp;quot;, s) }
func untrace(s string) { fmt.Println(&amp;quot;leaving:&amp;quot;, s) }

// 像这样使用它们:
func a() {
    trace(&amp;quot;a&amp;quot;)
    defer untrace(&amp;quot;a&amp;quot;)
    // 做一些事情....
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以利用延迟函数的参数在执行 &lt;code&gt;defer&lt;/code&gt; 时计算这一事实做的更好。跟踪代码可以设置不跟踪代码的参数。下面的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func trace(s string) string {
    fmt.Println(&amp;quot;entering:&amp;quot;, s)
    return s
}

func un(s string) {
    fmt.Println(&amp;quot;leaving:&amp;quot;, s)
}

func a() {
    defer un(trace(&amp;quot;a&amp;quot;))
    fmt.Println(&amp;quot;in a&amp;quot;)
}

func b() {
    defer un(trace(&amp;quot;b&amp;quot;))
    fmt.Println(&amp;quot;in b&amp;quot;)
    a()
}

func main() {
    b()
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;entering: b
in b
entering: a
in a
leaving: a
leaving: b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于习惯块级别资源管理的其他语言的编程人员，&lt;code&gt;defer&lt;/code&gt; 可能看起来怪异的，但是它最有趣且强大的应用正来自它不是块级别而是函数级别的事实。在 &lt;code&gt;panic&lt;/code&gt; 和 &lt;code&gt;recover&lt;/code&gt; 部分，我们会看到另一个可能使用 &lt;code&gt;defer&lt;/code&gt; 的例子。&lt;/p&gt;

&lt;h2 id=&#34;数据&#34;&gt;数据&lt;/h2&gt;

&lt;h3 id=&#34;使用-new-分配&#34;&gt;使用 new 分配&lt;/h3&gt;

&lt;p&gt;Go 有两种分配原语，即内置函数 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;make&lt;/code&gt;。它们做了不同的事情且适用于不同类型，这可能有点难以理解，但是规则很简单。我们首先讨论 &lt;code&gt;new&lt;/code&gt;。它是一个分配内存的内置函数，但是和一些其他语言的同名函数不同，它不会初始化内存，它只是将内存置零。也就是说，&lt;code&gt;new(T)&lt;/code&gt; 为类型 T 的新条目分配置零的存储，并返回存储地址(值为类型 T*)。在 Go 的术语中， 它返回一个指针指向一个新分配的类型 T 的零值。&lt;/p&gt;

&lt;p&gt;因为 &lt;code&gt;new&lt;/code&gt; 返回的内存是置零的，当将你的数据结构设计为每个类型的零值都可以直接使用不需要进一步初始化，在安排的时候是很有用的。这意味着数据结构的使用者可以使用 &lt;code&gt;new&lt;/code&gt; 创建一个对象并正常工作。比如，&lt;code&gt;bytes.Buffer&lt;/code&gt; 的文档声明“ Buffer 的零值是一个就绪的空缓冲”。类似的，&lt;code&gt;sync.Mutex&lt;/code&gt; 没有一个显式的构造函数或 &lt;code&gt;Init&lt;/code&gt; 方法。反之，&lt;code&gt;sync.Mutex&lt;/code&gt; 的零值被定义为一个未上锁的互斥锁。&lt;/p&gt;

&lt;p&gt;“零值是有用的”这一属性可以传递。考虑这个类型声明：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;SyncedBuffer&lt;/code&gt; 类型的值也是分配或声明时就绪的。在下一个片段中，&lt;code&gt;p&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt; 都可以正确工作而不用进一步安排。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;p := new(SyncedBuffer)  // *SyncedBuffer 类型
var v SyncedBuffer      // SyncedBuffer 类型
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;构造函数和复合字面量&#34;&gt;构造函数和复合字面量&lt;/h3&gt;

&lt;p&gt;有时候零值不够好，且需要一个初始化构造函数，正如下面从 &lt;code&gt;os&lt;/code&gt; 包衍生的一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewFile(fd int, name string) *File {
    if fd &amp;lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有很多模板式代码。我们可以使用一个“复合字面量”来简化代码。“复合字面量”是一个表达式，它在每次求值时创建一个新的实例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func NewFile(fd int, name string) *File {
    if fd &amp;lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;amp;f
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意，和 C 不同，返回一个局部变量的地址是完全可以的；和变量相关的存储在函数返回时仍存在。事实上，使用复合字面量的地址在每次求值时分配一个新的实例，因此我们可以合并后面两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;return &amp;amp;File{fd, name, nil, 0}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;复合字面量的域按顺序放置且必须都要出现。然而，通过显式给域打像 &lt;code&gt;field:value&lt;/code&gt; 的标签，初始化列表可以按任何顺序出现，且缺失的域会分别使用对应的零值。因此我们可以写&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;return &amp;amp;File{fd: fd, name: name}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;作为一个限制性场景，如果一个复合字面量不包含任何域，它会为类型创建零值。表达式 &lt;code&gt;new(File)&lt;/code&gt; 和 &lt;code&gt;&amp;amp;File{}&lt;/code&gt; 是等价的。&lt;/p&gt;

&lt;p&gt;复合字面量也可用于创建数组、切片和映射，使用索引或合适的键给域打标签，在这些例子中，无论 &lt;code&gt;Enone&lt;/code&gt;、&lt;code&gt;Eio&lt;/code&gt; 和 &lt;code&gt;Einval&lt;/code&gt; 的值是什么，只要它们是唯一的，初始化器都可以工作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a := [...]string   {Enone: &amp;quot;no error&amp;quot;, Eio: &amp;quot;Eio&amp;quot;, Einval: &amp;quot;invalid argument&amp;quot;}
s := []string      {Enone: &amp;quot;no error&amp;quot;, Eio: &amp;quot;Eio&amp;quot;, Einval: &amp;quot;invalid argument&amp;quot;}
m := map[int]string{Enone: &amp;quot;no error&amp;quot;, Eio: &amp;quot;Eio&amp;quot;, Einval: &amp;quot;invalid argument&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用-make-分配&#34;&gt;使用 make 分配&lt;/h3&gt;

&lt;h3 id=&#34;数组&#34;&gt;数组&lt;/h3&gt;

&lt;h3 id=&#34;切片&#34;&gt;切片&lt;/h3&gt;

&lt;h3 id=&#34;二维切片&#34;&gt;二维切片&lt;/h3&gt;

&lt;h3 id=&#34;映射&#34;&gt;映射&lt;/h3&gt;

&lt;h3 id=&#34;打印&#34;&gt;打印&lt;/h3&gt;

&lt;h3 id=&#34;追加&#34;&gt;追加&lt;/h3&gt;

&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;

&lt;h3 id=&#34;常数&#34;&gt;常数&lt;/h3&gt;
</description>
    </item>
    
    <item>
      <title>常见问题解答</title>
      <link>https://xueqing.github.io/translation/go-doc/golangdoc/faq/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/golangdoc/faq/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%b5%b7%e6%ba%90&#34;&gt;起源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%94%a8%e6%b3%95&#34;&gt;用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%ae%be%e8%ae%a1&#34;&gt;设计&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%b8%ba%e4%bb%80%e4%b9%88-go-%e6%b2%a1%e6%9c%89%e6%96%ad%e8%a8%80&#34;&gt;为什么 Go 没有断言&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%b1%bb%e5%9e%8b&#34;&gt;类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%80%bc&#34;&gt;值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e7%bc%96%e5%86%99%e4%bb%a3%e7%a0%81&#34;&gt;编写代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8c%87%e9%92%88%e5%92%8c%e5%88%86%e9%85%8d&#34;&gt;指针和分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%b9%b6%e5%8f%91&#34;&gt;并发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%87%bd%e6%95%b0%e5%92%8c%e6%96%b9%e6%b3%95&#34;&gt;函数和方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%8e%a7%e5%88%b6%e6%b5%81&#34;&gt;控制流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8c%85%e5%92%8c%e6%b5%8b%e8%af%95&#34;&gt;包和测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%ae%9e%e7%8e%b0&#34;&gt;实现&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%88%91%e6%9c%80%e5%96%9c%e6%ac%a2%e7%9a%84%e6%b5%8b%e8%af%95%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0%e5%9c%a8%e5%93%aa%e9%87%8c&#34;&gt;我最喜欢的测试辅助函数在哪里&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e6%80%a7%e8%83%bd&#34;&gt;性能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8e-c-%e7%9a%84%e6%94%b9%e5%8f%98&#34;&gt;从 C 的改变&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://golang.org/doc/faq#assertions&#34; target=&#34;_blank&#34;&gt;Go 官方文档——常见问题解答&lt;/a&gt;学习。&lt;/p&gt;

&lt;h2 id=&#34;起源&#34;&gt;起源&lt;/h2&gt;

&lt;h2 id=&#34;用法&#34;&gt;用法&lt;/h2&gt;

&lt;h2 id=&#34;设计&#34;&gt;设计&lt;/h2&gt;

&lt;h3 id=&#34;为什么-go-没有断言&#34;&gt;为什么 Go 没有断言&lt;/h3&gt;

&lt;p&gt;Go 不提供断言。他们无疑是方便的，但是我们已有的经验是开发人员依赖断言避免思考合适的错误处理和报告。合适的错误处理意味着服务在一个非严重的错误之后继续操作而不是崩溃。合适的错误处理意味着错误是直接的、扼要的，使开发人员免于解释大量的崩溃跟踪。当看到错误的开发人员不熟悉代码，错误的准确尤为重要。&lt;/p&gt;

&lt;p&gt;我们明白这是一个争论点。Go 语言和库有很多不同于现代实践的地方，只是因为我们感觉有时候值得尝试一个不同的方法。&lt;/p&gt;

&lt;h2 id=&#34;类型&#34;&gt;类型&lt;/h2&gt;

&lt;h2 id=&#34;值&#34;&gt;值&lt;/h2&gt;

&lt;h2 id=&#34;编写代码&#34;&gt;编写代码&lt;/h2&gt;

&lt;h2 id=&#34;指针和分配&#34;&gt;指针和分配&lt;/h2&gt;

&lt;h2 id=&#34;并发&#34;&gt;并发&lt;/h2&gt;

&lt;h2 id=&#34;函数和方法&#34;&gt;函数和方法&lt;/h2&gt;

&lt;h2 id=&#34;控制流&#34;&gt;控制流&lt;/h2&gt;

&lt;h2 id=&#34;包和测试&#34;&gt;包和测试&lt;/h2&gt;

&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;

&lt;h3 id=&#34;我最喜欢的测试辅助函数在哪里&#34;&gt;我最喜欢的测试辅助函数在哪里&lt;/h3&gt;

&lt;p&gt;Go 的标准 &lt;a href=&#34;../golangpkg/testing.md&#34;&gt;testing&lt;/a&gt; 包使得易于编写单元测试，但是它缺少其他语言测试框架提供的一些特性，比如断言函数。此文档&lt;a href=&#34;#为什么-Go-没有断言&#34;&gt;前面的部分&lt;/a&gt;解释了为什么 Go 没有断言，以及在测试中使用断言的相同论点。合适的错误处理意味着使得其他测试在一个测试失败时继续运行，以便调试错误的人员可以得到一个错误的完整信息。对于一个测试来说，比起报告 isPrime 对于 2 的答案是错误的并因此不再运行更多测试，报告 isPrime 对 2、3、5、7 (或 2、4、8、16) 给出错误的答案是更加有用的。触发测试错误的开发人员可能不熟悉失败的代码。在测试失败时，花费时间编写一个好的错误消息是值得的。&lt;/p&gt;

&lt;p&gt;相关的一点是测试框架趋向于发展成为他们自己的微语言，包括条件、控制和打印机制，但是 Go 已经有所有这些功能了；为什么要创建他们？我们更愿意用 Go 编写测试；它是一门学习更少的语言，而且这个方法保持测试是直截了当易于理解的。&lt;/p&gt;

&lt;p&gt;如果编写好的错误所需的额外代码数量看起来是重复的、巨大的，那么表驱动测试可能效果更好。表驱动是迭代遍历定义在一个数据结构(Go 对于数据结构字面量有极好的支持)的输入和输出列表。编写一个好的测试和错误信息的工作在测试拥挤很多时将会被分摊。标准的 Go 库有许多说明示例，比如 &lt;a href=&#34;https://golang.org/src/fmt/fmt_test.go&#34; target=&#34;_blank&#34;&gt;fmt 包的格式化测试&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;性能&#34;&gt;性能&lt;/h2&gt;

&lt;h2 id=&#34;从-c-的改变&#34;&gt;从 C 的改变&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>文章</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/articles/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/articles/</guid>
      <description>&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki/Articles&#34; target=&#34;_blank&#34;&gt;Go 维基官网——文章&lt;/a&gt; 学习。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试函数</title>
      <link>https://xueqing.github.io/translation/go-doc/command/test_func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/test_func/</guid>
      <description>&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 命令预期查找对应测试包的 “*_test.go” 文件中的测试函数、基准测试函数和示例函数。&lt;/p&gt;

&lt;p&gt;测试函数命名为 TestXxx(Xxx 不以小写字母开始)，且应当有签名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func TestXxx(t *testing.T) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个基准测试函数命名为 BenchmarkXxx，且应该有签名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func BenchmarkXxx(b *testing.B) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个示例函数，类似于测试函数，但不使用 *testing.T 报告成功或失败，而是打印输出到 os.Stdout。如果函数内最后的注释以 “Output:” 开头，那么输出与注释精确比较(看下面的例子)。如果最后的注释以 “Unordered output:” 开始，那么输出和注释做比较，但是忽视行的顺序。一个不带这样的注释的示例被编译但是不执行。一个在 “Output:” 之后没有文本的示例会被编译、执行并预期不会生成输出。&lt;/p&gt;

&lt;p&gt;Godoc 显示 ExampleXxx 的消息体来演示函数、常量或变量 Xxx 的使用。一个接收类型是 T 或 *T 的方法 M 的示例函数命名为 ExampleT_M。对于一个给定的函数、常数或变量可能有多个示例，通过后缀 _xxx 区分，xxx 是一个不以大写字母开始的后缀。&lt;/p&gt;

&lt;p&gt;有一个示例函数的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExamplePrintln() {
  Println(&amp;quot;The output of\nthis example.&amp;quot;)
  // Output: The output of
  // this example.
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外一个忽视输出顺序的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ExamplePerm() {
  for _, value := range Perm(4) {
    fmt.Println(value)
  }

  // Unordered output: 4
  // 2
  // 1
  // 3
  // 0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当文件包含一个单独的示例函数，及至少一个其他的函数、类型、变量或常数声明，且没有测试函数或者基准测试函数时，整个测试文件作为例子显示。&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;../wiki/golangpkg/testing.md&#34;&gt;testing 包的文档&lt;/a&gt;查看更多信息。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>测试标识</title>
      <link>https://xueqing.github.io/translation/go-doc/command/test_flag/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/test_flag/</guid>
      <description>&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 命令使用只适用于 &lt;code&gt;go test&lt;/code&gt; 的标识以及适用于生成二进制测试的标识。&lt;/p&gt;

&lt;p&gt;一些标识控制概要并且写适用于 &lt;code&gt;go tool pprof&lt;/code&gt; 的执行概要；运行 &lt;code&gt;go tool pprof -h&lt;/code&gt; 查看更多信息。pprof 的 &amp;ndash;alloc_space、&amp;ndash;alloc_objects 和 &amp;ndash;show_bytes 选项控制如何显示这些信息。&lt;/p&gt;

&lt;p&gt;下面的标识被 &lt;code&gt;go test&lt;/code&gt; 命令识别，并且控制测试的执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;-bench regexp
    Run only those benchmarks matching a regular expression.
    By default, no benchmarks are run.
    To run all benchmarks, use &#39;-bench .&#39; or &#39;-bench=.&#39;.
    The regular expression is split by unbracketed slash (/)
    characters into a sequence of regular expressions, and each
    part of a benchmark&#39;s identifier must match the corresponding
    element in the sequence, if any. Possible parents of matches
    are run with b.N=1 to identify sub-benchmarks. For example,
    given -bench=X/Y, top-level benchmarks matching X are run
    with b.N=1 to find any sub-benchmarks matching Y, which are
    then run in full.

-benchtime t
    Run enough iterations of each benchmark to take t, specified
    as a time.Duration (for example, -benchtime 1h30s).
    The default is 1 second (1s).
    The special syntax Nx means to run the benchmark N times
    (for example, -benchtime 100x).

-count n
    Run each test and benchmark n times (default 1).
    If -cpu is set, run n times for each GOMAXPROCS value.
    Examples are always run once.

-cover
    Enable coverage analysis.
    Note that because coverage works by annotating the source
    code before compilation, compilation and test failures with
    coverage enabled may report line numbers that don&#39;t correspond
    to the original sources.

-covermode set,count,atomic
    Set the mode for coverage analysis for the package[s]
    being tested. The default is &amp;quot;set&amp;quot; unless -race is enabled,
    in which case it is &amp;quot;atomic&amp;quot;.
    The values:
  set: bool: does this statement run?
  count: int: how many times does this statement run?
  atomic: int: count, but correct in multithreaded tests;
    significantly more expensive.
    Sets -cover.

-coverpkg pattern1,pattern2,pattern3
    Apply coverage analysis in each test to packages matching the patterns.
    The default is for each test to analyze only the package being tested.
    See &#39;go help packages&#39; for a description of package patterns.
    Sets -cover.

-cpu 1,2,4
    Specify a list of GOMAXPROCS values for which the tests or
    benchmarks should be executed. The default is the current value
    of GOMAXPROCS.

-failfast
    Do not start new tests after the first test failure.

-list regexp
    List tests, benchmarks, or examples matching the regular expression.
    No tests, benchmarks or examples will be run. This will only
    list top-level tests. No subtest or subbenchmarks will be shown.

-parallel n
    Allow parallel execution of test functions that call t.Parallel.
    The value of this flag is the maximum number of tests to run
    simultaneously; by default, it is set to the value of GOMAXPROCS.
    Note that -parallel only applies within a single test binary.
    The &#39;go test&#39; command may run tests for different packages
    in parallel as well, according to the setting of the -p flag
    (see &#39;go help build&#39;).

-run regexp
    Run only those tests and examples matching the regular expression.
    For tests, the regular expression is split by unbracketed slash (/)
    characters into a sequence of regular expressions, and each part
    of a test&#39;s identifier must match the corresponding element in
    the sequence, if any. Note that possible parents of matches are
    run too, so that -run=X/Y matches and runs and reports the result
    of all tests matching X, even those without sub-tests matching Y,
    because it must run them to look for those sub-tests.

-short
    Tell long-running tests to shorten their run time.
    It is off by default but set during all.bash so that installing
    the Go tree can run a sanity check but not spend time running
    exhaustive tests.

-timeout d
    If a test binary runs longer than duration d, panic.
    If d is 0, the timeout is disabled.
    The default is 10 minutes (10m).

-v
    Verbose output: log all tests as they are run. Also print all
    text from Log and Logf calls even if the test succeeds.

-vet list
    Configure the invocation of &amp;quot;go vet&amp;quot; during &amp;quot;go test&amp;quot;
    to use the comma-separated list of vet checks.
    If list is empty, &amp;quot;go test&amp;quot; runs &amp;quot;go vet&amp;quot; with a curated list of
    checks believed to be always worth addressing.
    If list is &amp;quot;off&amp;quot;, &amp;quot;go test&amp;quot; does not run &amp;quot;go vet&amp;quot; at all.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的标识被 &lt;code&gt;go test&lt;/code&gt; 命令识别，且可用于概述执行期间的测试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;-benchmem
    Print memory allocation statistics for benchmarks.

-blockprofile block.out
    Write a goroutine blocking profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.

-blockprofilerate n
    Control the detail provided in goroutine blocking profiles by
    calling runtime.SetBlockProfileRate with n.
    See &#39;go doc runtime.SetBlockProfileRate&#39;.
    The profiler aims to sample, on average, one blocking event every
    n nanoseconds the program spends blocked. By default,
    if -test.blockprofile is set without this flag, all blocking events
    are recorded, equivalent to -test.blockprofilerate=1.

-coverprofile cover.out
    Write a coverage profile to the file after all tests have passed.
    Sets -cover.

-cpuprofile cpu.out
    Write a CPU profile to the specified file before exiting.
    Writes test binary as -c would.

-memprofile mem.out
    Write an allocation profile to the file after all tests have passed.
    Writes test binary as -c would.

-memprofilerate n
    Enable more precise (and expensive) memory allocation profiles by
    setting runtime.MemProfileRate. See &#39;go doc runtime.MemProfileRate&#39;.
    To profile all memory allocations, use -test.memprofilerate=1.

-mutexprofile mutex.out
    Write a mutex contention profile to the specified file
    when all tests are complete.
    Writes test binary as -c would.

-mutexprofilefraction n
    Sample 1 in n stack traces of goroutines holding a
    contended mutex.

-outputdir directory
    Place output files from profiling in the specified directory,
    by default the directory in which &amp;quot;go test&amp;quot; is running.

-trace trace.out
    Write an execution trace to the specified file before exiting.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有这些标识也有一个可选的 “test.” 前缀被识别(如 -test.v)。但是当直接调用生成的二进制测试时(&lt;code&gt;go test -c&lt;/code&gt; 生成)，这个前缀是强制的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;go test&lt;/code&gt; 命令在调用二进制测试之前，适当地重写或移除在可选的包列表之前或之后识别的标识。&lt;/p&gt;

&lt;p&gt;比如，命令 &lt;code&gt;go test -v -myflag testdata -cpuprofile=prof.out -x&lt;/code&gt; 将会编译二进制测试然后运行 &lt;code&gt;pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out&lt;/code&gt;。(-x 标识被移除，因为它只适用于go 命令的执行，而不是&lt;code&gt;go test&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;生成概述(除了用于覆盖)的测试标识也会将二进制测试留在 pkg.test 以便用于分析概述。&lt;/p&gt;

&lt;p&gt;当 &lt;code&gt;go test&lt;/code&gt; 运行一个二进制测试时，它从对应包源码目录内部运行。视测试而定，可能需要在直接调用一个生成的二进制测试时也这样做。&lt;/p&gt;

&lt;p&gt;命令行的包列表，如果有的话，必须出现在所有 &lt;code&gt;go test&lt;/code&gt; 命令不知道的标识之前。继续上面的例子，包列表需要出现在 -myflag 之前，但是可以出现在 -v 两侧。&lt;/p&gt;

&lt;p&gt;当 &lt;code&gt;go test&lt;/code&gt; 在列表模式运行时，&lt;code&gt;go test&lt;/code&gt; 缓存成功的包测试结果以避免不必要的重复运行测试。要禁用测试缓存，使用除了可缓存的标识以外的任意的测试标识或参数。惯用的显式禁用测试缓存的方法是使用 -count=1。&lt;/p&gt;

&lt;p&gt;要保持二进制测试的一个参数不被翻译成一个已知的标识或者包名，使用 -args (查看 &lt;code&gt;got help test&lt;/code&gt;) 换地命令行的剩余部分给二进制测试，该部分不会被解释或修改。&lt;/p&gt;

&lt;p&gt;例如，命令 &lt;code&gt;go test -v -args -x -v&lt;/code&gt; 会编译二进制测试然后运行 &lt;code&gt;pkg.test -test.v -x -v&lt;/code&gt;。类似的，&lt;code&gt;go test -args math&lt;/code&gt; 会编译二进制测试然后运行 &lt;code&gt;pkg.test math&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在第一个例子中，-x 和第二个 -v 被传递给二进制测试且未被修改，且对 go 命令本身没有影响。在第二个例子中，参数 math 被传递给二进制测试，而不是解释成包列表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>表驱动测试</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/table_driven_tests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/table_driven_tests/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%e4%bb%8b%e7%bb%8d&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95%e7%9a%84%e4%be%8b%e5%ad%90&#34;&gt;表驱动测试的例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%e5%8f%82%e8%80%83&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests&#34; target=&#34;_blank&#34;&gt;Go 维基官网——表驱动测试&lt;/a&gt;学习。&lt;/p&gt;

&lt;p&gt;原网页由 Martin Tournoij 在 2018/4/11 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/TableDrivenTests/_history&#34; target=&#34;_blank&#34;&gt;第 3 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;

&lt;p&gt;编写好的测试不是烦琐的，在很多情况下大量领域可以使用表驱动测试覆盖：每个表条目是一个包含输入和预期结果的测试用例，而且有时候包含一些额外的信息，比如测试名称，使得测试输出易于阅读。如果你曾经发现自己在编写测试时使用拷贝和粘贴，考虑是否重构为表驱动测试，或者把拷贝的代码放在一个辅助函数可能是一个更好的选择。&lt;/p&gt;

&lt;p&gt;给定一个测试用例表，真正的测试简单地迭代遍历所有表条目，且未每个条目执行必要的测试。测试代码只编写一次且被分摊到所有的表条目，因此精心编写一个带有好的错误消息的测试是有意义的。&lt;/p&gt;

&lt;h2 id=&#34;表驱动测试的例子&#34;&gt;表驱动测试的例子&lt;/h2&gt;

&lt;p&gt;这里是一个来自 &lt;a href=&#34;http://golang.org/pkg/fmt/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;fmt&lt;/code&gt; 包&lt;/a&gt;测试代码的好例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var flagtests = []struct {
  in  string
  out string
}{
  {&amp;quot;%a&amp;quot;, &amp;quot;[%a]&amp;quot;},
  {&amp;quot;%-a&amp;quot;, &amp;quot;[%-a]&amp;quot;},
  {&amp;quot;%+a&amp;quot;, &amp;quot;[%+a]&amp;quot;},
  {&amp;quot;%#a&amp;quot;, &amp;quot;[%#a]&amp;quot;},
  {&amp;quot;% a&amp;quot;, &amp;quot;[% a]&amp;quot;},
  {&amp;quot;%0a&amp;quot;, &amp;quot;[%0a]&amp;quot;},
  {&amp;quot;%1.2a&amp;quot;, &amp;quot;[%1.2a]&amp;quot;},
  {&amp;quot;%-1.2a&amp;quot;, &amp;quot;[%-1.2a]&amp;quot;},
  {&amp;quot;%+1.2a&amp;quot;, &amp;quot;[%+1.2a]&amp;quot;},
  {&amp;quot;%-+1.2a&amp;quot;, &amp;quot;[%+-1.2a]&amp;quot;},
  {&amp;quot;%-+1.2abc&amp;quot;, &amp;quot;[%+-1.2a]bc&amp;quot;},
  {&amp;quot;%-1.2abc&amp;quot;, &amp;quot;[%-1.2a]bc&amp;quot;},
}
func TestFlagParser(t *testing.T) {
  var flagprinter flagPrinter
  for _, tt := range flagtests {
    t.Run(tt.in, func(t *testing.T) {
      s := Sprintf(tt.in, &amp;amp;flagprinter)
      if s != tt.out {
        t.Errorf(&amp;quot;got %q, want %q&amp;quot;, s, tt.out)
      }
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意使用 &lt;code&gt;t.Errorf&lt;/code&gt; 提供的详细的错误消息：提供了函数结果和预期结果；输入是子测试的名字。当测试失败时，哪个错误失败以及为什么失败是显然的，甚至不用阅读测试代码。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;t.Errorf&lt;/code&gt; 调用不是一个断言。即使打印一个错误日志，测试仍会继续。比如，当使用整数输入测试一些代码时，知道函数对所有输入失败，还是只对奇数失败，或者是对 2 的幂失败是有意义的。&lt;/p&gt;

&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;golangdoc/code.md#测试&#34; target=&#34;_blank&#34;&gt;如何编写 Go 代码——测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;golangdoc/faq.md#为什么-Go-没有断言&#34; target=&#34;_blank&#34;&gt;常见问题解答——断言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;golangdoc/faq.md#我最喜欢的测试辅助函数在哪里&#34; target=&#34;_blank&#34;&gt;常见问题解答——测试框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;golangpkg/testing.md&#34; target=&#34;_blank&#34;&gt;testing 包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>设置 GOPATH</title>
      <link>https://xueqing.github.io/translation/go-doc/wiki/set_gopath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/wiki/set_gopath/</guid>
      <description>

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#unix-%e7%b3%bb%e7%bb%9f&#34;&gt;Unix 系统&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-113&#34;&gt;Go 1.13&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bash&#34;&gt;Bash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#zsh&#34;&gt;Zsh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fish&#34;&gt;fish&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#windows&#34;&gt;Windows&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#go-113-%e5%91%bd%e4%bb%a4%e8%a1%8c&#34;&gt;Go 1.13 (命令行)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#windows-10-%e5%9b%be%e5%bd%a2%e7%94%a8%e6%88%b7%e7%95%8c%e9%9d%a2&#34;&gt;Windows 10 (图形用户界面)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#windows-10-%e5%91%bd%e4%bb%a4%e8%a1%8c&#34;&gt;Windows 10 (命令行)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考&lt;a href=&#34;https://github.com/golang/go/wiki/SettingGOPATH&#34; target=&#34;_blank&#34;&gt;设置 GOPATH 维基&lt;/a&gt;学习。&lt;/p&gt;

&lt;p&gt;原网页由 Bryan C. Mills 在 2019/9/27 编辑。&lt;a href=&#34;https://github.com/golang/go/wiki/SettingGOPATH/_history&#34; target=&#34;_blank&#34;&gt;第 55 次修订&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GOPATH&lt;/code&gt; 环境变量指定你的工作区的位置。如果没有设置 &lt;code&gt;GOPATH&lt;/code&gt;，则认为 Unix 系统上是 &lt;code&gt;$HOME/go&lt;/code&gt; 且 Windows 上是 &lt;code&gt;%USERPROFILE%\go&lt;/code&gt;。如果你想要使用自定义位置作为你的工作区，你可以设置 &lt;code&gt;GOPATH&lt;/code&gt; 环境变量。此页解释如何在不同的平台上设置这个变量。&lt;/p&gt;

&lt;h2 id=&#34;unix-系统&#34;&gt;Unix 系统&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;GOPATH&lt;/code&gt; 可以是你系统上的任一目录。在 Unix 系统上，我们将设置其为 &lt;code&gt;$HOME/go&lt;/code&gt; (从 Go 1.8 其的默认值)。注意 &lt;code&gt;GOPATH&lt;/code&gt; 一定不能和 Go 安装路径相同。另外一个常见的设置是设置 &lt;code&gt;GOPATH=$HOME&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;go-1-13&#34;&gt;Go 1.13&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;go env -w GOPATH=$HOME/go&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;bash&#34;&gt;Bash&lt;/h3&gt;

&lt;p&gt;编辑 &lt;code&gt;~/.bash_profile&lt;/code&gt;，添加下面的行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GOPATH=$HOME/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并退出编辑器。然后使 &lt;code&gt;~/.bash_profile&lt;/code&gt; 修改生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;source ~/.bash_profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;zsh&#34;&gt;Zsh&lt;/h3&gt;

&lt;p&gt;编辑 &lt;code&gt;~/.zshrc&lt;/code&gt;，添加下面的行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;export GOPATH=$HOME/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存并退出编辑器。然后使 &lt;code&gt;~/.zshrc&lt;/code&gt; 修改生效：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;source ~/.zshrc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fish&#34;&gt;fish&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;set -x -U GOPATH $HOME/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-x&lt;/code&gt; 用于指定这个变量应被导出，且 &lt;code&gt;-U&lt;/code&gt; 使其成为一个全局变量，对所有会话可用且是持久的。&lt;/p&gt;

&lt;h2 id=&#34;windows&#34;&gt;Windows&lt;/h2&gt;

&lt;p&gt;你的工作区可位于任何你喜欢的地方，但是我们在这个例子中使用 &lt;code&gt;C:\go-work&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;GOPATH&lt;/code&gt; 一定不能和 Go 安装路径相同。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;C:\go-work&lt;/code&gt; 新建文件夹。&lt;/li&gt;
&lt;li&gt;右击“开始”，并点击“控制面板”。选择“系统和安全”，然后点击“系统”。&lt;/li&gt;
&lt;li&gt;从左边的菜单栏，选中“高级系统设置”。&lt;/li&gt;
&lt;li&gt;点击底部的“环境变量”按钮。&lt;/li&gt;
&lt;li&gt;从“用户变量”区域点击“新建”。&lt;/li&gt;
&lt;li&gt;在“变量名”输入 &lt;code&gt;GOPATH&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在“变量值”输入 &lt;code&gt;C:\go-work&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;点击“确定”。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;go-1-13-命令行&#34;&gt;Go 1.13 (命令行)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;打开一个命令提示符(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;r&lt;/code&gt; 然后输入 &lt;code&gt;cmd&lt;/code&gt;) 或者 powershell 窗口(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;i&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;go env -w GOPATH=c:\go-work&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;windows-10-图形用户界面&#34;&gt;Windows 10 (图形用户界面)&lt;/h3&gt;

&lt;p&gt;有一个通过搜索编辑 &lt;code&gt;环境变量&lt;/code&gt; 的快速方式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;左击“搜索”并输入 &lt;code&gt;env&lt;/code&gt; 或 &lt;code&gt;environment&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择&lt;code&gt;编辑账户的环境变量&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;和上述步骤相同。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;windows-10-命令行&#34;&gt;Windows 10 (命令行)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;打开一个命令提示符(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;r&lt;/code&gt; 然后输入 &lt;code&gt;cmd&lt;/code&gt;) 或者 powershell 窗口(&lt;code&gt;Win&lt;/code&gt;+&lt;code&gt;i&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;setx GOPATH %USERPROFILE%\go&lt;/code&gt;。(这将会设置 &lt;code&gt;GOPATH&lt;/code&gt; 为你的 &lt;code&gt;[home folder]\go&lt;/code&gt;，比如 &lt;code&gt;C:\Users\yourusername\go&lt;/code&gt;。)&lt;/li&gt;
&lt;li&gt;关闭命令提示符或 powershell 窗口。(环境变量只对新的命令提示符或 powershell 窗口生效，当前窗口不生效。)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>远程导入路径</title>
      <link>https://xueqing.github.io/translation/go-doc/command/remote_import_path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://xueqing.github.io/translation/go-doc/command/remote_import_path/</guid>
      <description>&lt;p&gt;一些导入路径也描述了如何使用版本控制系统获取包的源码。&lt;/p&gt;

&lt;p&gt;一些常见的代码托管网站有一些特殊的语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Bitbucket (Git, Mercurial)

  import &amp;quot;bitbucket.org/user/project&amp;quot;
  import &amp;quot;bitbucket.org/user/project/sub/directory&amp;quot;

GitHub (Git)

  import &amp;quot;github.com/user/project&amp;quot;
  import &amp;quot;github.com/user/project/sub/directory&amp;quot;

Launchpad (Bazaar)

  import &amp;quot;launchpad.net/project&amp;quot;
  import &amp;quot;launchpad.net/project/series&amp;quot;
  import &amp;quot;launchpad.net/project/series/sub/directory&amp;quot;

  import &amp;quot;launchpad.net/~user/project/branch&amp;quot;
  import &amp;quot;launchpad.net/~user/project/branch/sub/directory&amp;quot;

IBM DevOps Services (Git)

  import &amp;quot;hub.jazz.net/git/user/project&amp;quot;
  import &amp;quot;hub.jazz.net/git/user/project/sub/directory&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于托管在其他服务商的代码，导入路径或者具备版本控制类型，或者 go 工具可以通过 https/http 动态拉取导入路径，然后从 HTML 的 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 标签代码位置。&lt;/p&gt;

&lt;p&gt;为了声明代码位置，具有形式 &lt;code&gt;repository.vcs/path&lt;/code&gt; 的导入路径指定了给定的仓库(使用或不使用 .vcs 后缀，使用命名的版本控制系统)和该仓库内的路径。支持的版本控制系统是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;Bazaar      .bzr
Fossil      .fossil
Git         .git
Mercurial   .hg
Subversion  .svn
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如，&lt;code&gt;import &amp;quot;example.org/user/foo.hg&amp;quot;&lt;/code&gt; 表示根目录在 Mercurial 仓库的 example.org/user/foo 或 foo.hg，且 &lt;code&gt;import &amp;quot;example.org/repo.git/foo/bar&amp;quot;&lt;/code&gt; 表示 Git 仓库的 foo/bar 目录在 example.org/repo 或 repo.git。&lt;/p&gt;

&lt;p&gt;当一个版本控制系统支持多个协议时，下载时轮流尝试每个协议。比如，一个 Git 下载尝试 &lt;code&gt;https://&lt;/code&gt;，然后是 &lt;code&gt;git+ssh://&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;默认的，下载受限于已知的安全协议(比如，https 和 ssh)。要覆盖 Git 下载的这个设置，可以设置 GIT_ALLOW_PROTOCOL 环境变量(查看 &lt;code&gt;go help environment&lt;/code&gt; 获取更多信息)。&lt;/p&gt;

&lt;p&gt;如果导入路径不是已知的代码托管网站，且缺少版本控制限定符，go 工具尝试通过 https/http 查找 HTML  &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 标签来拉取导入。&lt;/p&gt;

&lt;p&gt;meta 标签有这样的形式 &lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;import-prefix vcs repo-root&amp;quot;&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;import-prefix 是对应 repo-root 的导入路径。它必须是一个前缀，或者是借助 &lt;code&gt;go get&lt;/code&gt; 拉取包的一个精确匹配。如果不是一个精确匹配，生成另外一个 http 请求来验证 meta 标签。&lt;/p&gt;

&lt;p&gt;meta 标签应该尽早出现在文件中。特别地，它应该出现在任何原始的 JavaScript 或 CSS 之前，避免使 go 命令受限的解释器不能理解。&lt;/p&gt;

&lt;p&gt;vcs 是 bzr/fossil/git/hg/svn 中的一个。&lt;/p&gt;

&lt;p&gt;repo-root 是版本控制系统的根，包含了一个体系，但是不包含 .vcs 限定符。&lt;/p&gt;

&lt;p&gt;比如，&lt;code&gt;import &amp;quot;example.org/pkg/foo&amp;quot;&lt;/code&gt; 会导致下面的请求&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;https://example.org/pkg/foo?go-get=1 (preferred)
http://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果页面包含 meta 标签 &lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;example.org git https://code.org/r/p/exproj&amp;quot;&amp;gt;&lt;/code&gt;，那么 go 工具会验证 &lt;code&gt;https://example.org/pkg/foo?go-get=1&lt;/code&gt; 包含相同的 meta 标签，然后使用 &lt;code&gt;git clone https://code.org/r/p/exproj&lt;/code&gt; 克隆源码到 &lt;code&gt;GOPATH/src/example.org&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当使用 GOPATH 时，下载的包被写到 GOPATH 环境变量列举的第一个目录。(查看 &lt;code&gt;go help gopath-get&lt;/code&gt; 和 &lt;code&gt;go help gopath&lt;/code&gt;。)&lt;/p&gt;

&lt;p&gt;当使用模块时，下载的包存储在模块缓存。(查看 &lt;code&gt;go help module-get&lt;/code&gt; 和 &lt;code&gt;go help goproxy&lt;/code&gt;。)&lt;/p&gt;

&lt;p&gt;当使用模块时，go-import meta 标签的额外的变量被识别且更倾向于通过这些列举的版本控制系统。比如，在 &lt;code&gt;&amp;lt;meta name=&amp;quot;go-import&amp;quot; content=&amp;quot;example.org mod https://code.org/moduleproxy&amp;quot;&amp;gt;&lt;/code&gt; 中，该变量使用 “mod” 作为 vcs 内容的值。&lt;/p&gt;

&lt;p&gt;这个标签意味着使用以 example.org 开始的路径从 &lt;code&gt;https://code.org/moduleproxy&lt;/code&gt; 可用的模块代理拉取模块。查看 &lt;code&gt;go help goproxy&lt;/code&gt; 获取更多关于代理的信息。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
